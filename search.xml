<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>github+hexo+next 快速搭建漂亮的个人博客</title>
    <url>/2016/11/18/github-hexo-next-%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E5%81%8F%E4%BA%AE%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<blockquote>
<p>本教程针对windows用户，苦逼实习生用不起mac</p>
</blockquote>
<h1 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h1><h3 id="安装git-for-windows"><a href="#安装git-for-windows" class="headerlink" title="安装git for windows"></a>安装git for windows</h3><p><a href="https://git-for-windows.github.io/">《下载安装入口》</a><br>关于github与本地git客户端的关联这里不做阐述，百度一大把。</p>
<h3 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h3><p><a href="https://nodejs.org/en/download/">《node.js下载安装入口》</a><br>官网下载速度可能会很慢，安装完毕之后可以再cmd窗口测试一下是否安装成功。<br>键入以下命令，你会看到对应的版本号。</p>
<pre><code>$ node -v
</code></pre>
<p>除此之外还要检测一下npm是否安装成功，npm作为node.js的子项目也被安装进去了，后面安装hexo需要依赖于npm，用下面命令测试，成功依然会返回版本号。</p>
<pre><code>$ npm -v
</code></pre>
<h4 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h4><p>在你想要安装hexo的目录里面右键Git Bash Here，然后键入以下命令。</p>
<pre><code>$ npm install -g hexo-cli
</code></pre>
<p>详情可以参照<a href="https://hexo.io/zh-cn/docs/index.html">《hexo 中文文档入口》</a></p>
<h4 id="下载next主题"><a href="#下载next主题" class="headerlink" title="下载next主题"></a>下载next主题</h4><p>首先在你git bash窗口定位到安装hexo的根目录。</p>
<pre><code>$ cd your-hexo-site    
$ git clone https://github.com/iissnan/hexo-theme-next themes/next
</code></pre>
<p>详情请参照<a href="http://theme-next.iissnan.com/getting-started.html">《hexo next主题中文配置教程入口》</a></p>
<h4 id="hexo-next配置"><a href="#hexo-next配置" class="headerlink" title="hexo next配置"></a>hexo next配置</h4><p>打开git bash，定位到你的hexo安装目录，执行</p>
<pre><code>$ hexo init
</code></pre>
<p>关于hexo的命令参照<a href="https://hexo.io/zh-cn/docs/commands.html">《hexo 命令文档》</a><br>关于next第三方服务配置参照<a href="http://theme-next.iissnan.com/third-party-services.html">《next第三方服务配置》</a></p>
<h1 id="编写博文"><a href="#编写博文" class="headerlink" title="编写博文"></a>编写博文</h1><p>hexo 支持使用常用的markdown语法，关于markdown的语法可以参照<a href="http://www.jianshu.com/p/075d7cac8fef">《markdown新手教程》</a></p>
<blockquote>
<p>特别要注意的地方是，关于代码块网上很多都说得模棱两可，要实现上面代码高亮的代码块只要在代码上面空一行，前面键入大空格Tab开头就可以了，详细的markdown语法这里就不一一列出。</p>
</blockquote>
<p>博文的md文件写完之后保存，切回git bash窗口，重新生成静态文件</p>
<pre><code>$ hexo g
INFO  Start processing
INFO  Files loaded in 1.93 s
INFO  Generated: search.xml
INFO  Generated: 2016/11/18/github-hexo-next-快速搭建偏亮的个人博客/index.html
INFO  2 files generated in 874 ms
</code></pre>
<p>静态文件生成之后可以先部署到本地预览一下</p>
<pre><code>$ hexo s
INFO  Start processing
INFO  Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.
</code></pre>
<p>效果满意的话就可以执行一下命令发布到github远程仓库，然后访问your_username.github.io。<br>ok，博客搭建完毕！</p>
<h2 id="全部md文件重新生成静态网页"><a href="#全部md文件重新生成静态网页" class="headerlink" title="全部md文件重新生成静态网页"></a>全部md文件重新生成静态网页</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hexo g -f</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>blog build</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>github</tag>
      </tags>
  </entry>
  <entry>
    <title>windows环境下mysql提示ERROR 1045 (28000): Access denied for user &#39;root&#39;@&#39;localhost&#39; (using passwor: YES)的解决办法</title>
    <url>/2016/11/23/windows%E7%8E%AF%E5%A2%83%E4%B8%8Bmysql%E6%8F%90%E7%A4%BAERROR-1045-28000-Access-denied-for-user-root-localhost-using-passwor-YES-%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>好久没用mysql，早上试了一下发现报了下面这个经典的错误，表示有点恶心。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files\MySQL\MySQL Server 5.7\bin&gt;mysql -u root -p 12345678</span><br><span class="line">Enter password: ********</span><br><span class="line">ERROR 1045 (28000): Access denied for user &#x27;root&#x27;@&#x27;localhost&#x27; (using password: YES)</span><br></pre></td></tr></table></figure>
<p>解决方法很简单，首先进入mysql的安装目录找到my.ini</p>
<p>打开后，搜索mysqld关键字</p>
<p>找到后，在mysqld下面添加skip-grant-tables，保存退出。</p>
<p>如果提醒没有权限右键文件my.ini-&gt;安全-&gt;编辑-&gt;添加-&gt;高级-&gt;立即查找，把你当前账号添加进去，权限改成完全控制。</p>
<p>然后运行cmd，cd进入你mysql安装目录的bin目录下，</p>
<p>输入mysql -u root -p就可以不用密码登录了，出现password：的时候直接回车可以进入。</p>
<p>如果没有输入密码还是报错的话可以再Enter password的时候输入你上一次的密码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">C:\Program Files\MySQL\MySQL Server 5.7\bin&gt;mysql -u root -p</span><br><span class="line">Enter password: **********</span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection id is 11</span><br><span class="line">Server version: 5.7.9-log</span><br></pre></td></tr></table></figure>
<p>之后执行修改密码命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql&gt; alter user &#x27;root&#x27;@&#x27;localhost&#x27; identified by &#x27;123456789&#x27;;</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br></pre></td></tr></table></figure>
<p>大告功成！！</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系列之自定义注解入门</title>
    <url>/2016/11/23/Java%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<blockquote>
<p>下个月3号要去考个java的证书，java很多基础的东西已经忘了，最近工作上几乎没有任务，索性就总结一下java的基础。</p>
</blockquote>
<h2 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h2><p>元注解的作用就是负责注解其他注解。Java5.0定义了4个标准的meta-annotation类型，它们被用来提供对其它 annotation类型作说明。Java5.0定义的元注解：</p>
<ul>
<li>@Target,</li>
<li>@Retention,</li>
<li>@Documented,</li>
<li>@Inherited</li>
</ul>
<p>这些类型和它们所支持的类在java.lang.annotation包中可以找到。下面我们看一下每个元注解的作用和相应分参数的使用说明。</p>
<p>@Inherited的官方说明是这样子的。</p>
<pre><code>/**
 * Indicates that an annotation type is automatically inherited.  If
 * an Inherited meta-annotation is present on an annotation type
 * declaration, and the user queries the annotation type on a class
 * declaration, and the class declaration has no annotation for this type,
 * then the class&#39;s superclass will automatically be queried for the
 * annotation type.  This process will be repeated until an annotation for this
 * type is found, or the top of the class hierarchy (Object)
 * is reached.  If no superclass has an annotation for this type, then
 * the query will indicate that the class in question has no such annotation.
 *
 * &lt;p&gt;Note that this meta-annotation type has no effect if the annotated
 * type is used to annotate anything other than a class.  Note also
 * that this meta-annotation only causes annotations to be inherited
 * from superclasses; annotations on implemented interfaces have no
 * effect.
 *
 * @author  Joshua Bloch
 * @since 1.5
 */
</code></pre>
<p>好吧，看起来真的是吃力，后悔以前没有学好英文。</p>
<h4 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h4><p>@Target说明了Annotation所修饰的对象范围：Annotation可被用于 packages、types（类、接口、枚举、Annotation类型）、类型成员（方法、构造方法、成员变量、枚举值）、方法参数和本地变量（如循环变量、catch参数）。在Annotation类型的声明中使用了target可更加明晰其修饰的目标</p>
<blockquote>
<p>作用：用于描述注解的使用范围（即：被描述的注解可以用在什么地方）</p>
</blockquote>
<p>取值(ElementType)有：</p>
<ul>
<li>CONSTRUCTOR:用于描述构造器</li>
<li>FIELD:用于描述域</li>
<li>LOCAL_VARIABLE:用于描述局部变量</li>
<li>METHOD:用于描述方法</li>
<li>PACKAGE:用于描述包</li>
<li>PARAMETER:用于描述参数</li>
<li>TYPE:用于描述类、接口(包括注解类型) 或enum声明</li>
</ul>
<h4 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h4><p>@Retention定义了该Annotation被保留的时间长短：某些Annotation仅出现在源代码中，而被编译器丢弃；而另一些却被编译在class文件中；编译在class文件中的Annotation可能会被虚拟机忽略，而另一些在class被装载时将被读取（请注意并不影响class的执行，因为Annotation与class在使用上是被分离的）。使用这个meta-Annotation可以对 Annotation的“生命周期”限制。</p>
<p>取值（RetentionPoicy）有：</p>
<ul>
<li>SOURCE:在源文件中有效（即源文件保留）</li>
<li>CLASS:在class文件中有效（即class保留）</li>
<li>RUNTIME:在运行时有效（即运行时保留）</li>
</ul>
<h4 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h4><p>@Documented用于描述其它类型的annotation应该被作为被标注的程序成员的公共API，因此可以被例如javadoc此类的工具文档化。Documented是一个标记注解，没有成员。</p>
<h4 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h4><p>@Inherited 元注解是一个标记注解，@Inherited阐述了某个被标注的类型是被继承的。如果一个使用了@Inherited修饰的annotation类型被用于一个class，则这个annotation将被用于该class的子类。</p>
<p>注意：@Inherited annotation类型是被标注过的class的子类所继承。类并不从它所实现的接口继承annotation，方法并不从它所重载的方法继承annotation。</p>
<p>当@Inherited annotation类型标注的annotation的Retention是RetentionPolicy.RUNTIME，则反射API增强了这种继承性。如果我们使用java.lang.reflect去查询一个@Inherited annotation类型的annotation时，反射代码检查将展开工作：检查class和其父类，直到发现指定的annotation类型被发现，或者到达类继承结构的顶层。</p>
<h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>使用@interface自定义注解时，自动继承了java.lang.annotation.Annotation接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。@interface用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型（返回值类型只能是基本类型、Class、String、enum）。可以通过default来声明参数的默认值。<br>定义注解格式：</p>
<p>　　public @interface 注解名 {定义体}</p>
<p>注解参数的可支持数据类型：</p>
<ul>
<li>所有基本数据类型（int,float,boolean,byte,double,char,long,short)</li>
<li>String类型</li>
<li>Class类型</li>
<li>enum类型</li>
<li>Annotation类型</li>
<li>以上所有类型的数组</li>
</ul>
<h4 id="注解元素的默认值"><a href="#注解元素的默认值" class="headerlink" title="注解元素的默认值"></a>注解元素的默认值</h4><p>注解元素必须有确定的值，要么在定义注解的默认值中指定，要么在使用注解时指定，非基本类型的注解元素的值不可为null。因此, 使用空字符串或0作为默认值是一种常用的做法。这个约束使得处理器很难表现一个元素的存在或缺失的状态，因为每个注解的声明中，所有元素都存在，并且都具有相应的值，为了绕开这个约束，我们只能定义一些特殊的值，例如空字符串或者负数，一次表示某个元素不存在，在定义注解时，这已经成为一个习惯用法。</p>
<h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><pre><code>package cn.fengblog.java.review.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitColor &#123;

    public enum Color &#123;
        RED, YELLOW, BLUE
    &#125;

    Color value() default Color.RED;

&#125;
</code></pre>
<hr>
<pre><code>package cn.fengblog.java.review.annotation;

import java.lang.annotation.Documented;
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

@Target(ElementType.FIELD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface FruitName &#123;
    String value() default &quot;&quot;;
&#125;
</code></pre>
<hr>
<pre><code>package cn.fengblog.java.review.annotation;

import cn.fengblog.java.review.annotation.FruitColor.Color;

public class Apple &#123;

    @FruitName(&quot;红富士&quot;)
    private String appleName;

    @FruitColor(Color.RED)
    private String appleColor;

    public String getAppleName() &#123;
        return appleName;
    &#125;

    public void setAppleName(String appleName) &#123;
        this.appleName = appleName;
    &#125;

    public String getAppleColor() &#123;
        return appleColor;
    &#125;

    public void setAppleColor(String appleColor) &#123;
        this.appleColor = appleColor;
    &#125;

&#125;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>超详细Maven总结</title>
    <url>/2016/11/21/%E8%B6%85%E8%AF%A6%E7%BB%86Maven%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<blockquote>
<p>一直以来对于maven只是基本会用，配置文件只认得几个常用到的标签，今晚月黑风高，甚是寂寥，不凡总结一下maven。</p>
</blockquote>
<h2 id="什么是maven，为什么需要maven。"><a href="#什么是maven，为什么需要maven。" class="headerlink" title="什么是maven，为什么需要maven。"></a>什么是maven，为什么需要maven。</h2><p>在没有maven的时代，程序员往往需要花较多的精力在引用Jar包搭建项目环境上，而这一项工作尤为艰难，少一个Jar包、多一个Jar包往往会报一些让人摸不着头脑的异常，于是maven应运而生。<br>而Maven就是一款帮助程序员构建项目的工具，我们只需要告诉Maven需要哪些Jar 包，它会帮助我们下载所有的Jar，极大提升开发效率。</p>
<h2 id="maven的安装"><a href="#maven的安装" class="headerlink" title="maven的安装"></a>maven的安装</h2><p><a href="http://dead-knight.iteye.com/blog/1841658">《eclipse Maven插件安装》</a><br>myeclipse有自带maven插件。</p>
<h2 id="maven的基本命令"><a href="#maven的基本命令" class="headerlink" title="maven的基本命令"></a>maven的基本命令</h2><p>常用命令可以参考这篇博客<a href="http://www.cnblogs.com/xdp-gacl/p/4051690.html">http://www.cnblogs.com/xdp-gacl/p/4051690.html</a><br>使用IDE和maven的话基本用不到命令，有兴趣自行百度。</p>
<h2 id="maven的一些基本概念"><a href="#maven的一些基本概念" class="headerlink" title="maven的一些基本概念"></a>maven的一些基本概念</h2><h4 id="仓库"><a href="#仓库" class="headerlink" title="仓库"></a>仓库</h4><p>maven的仓库分为本地仓库和远程仓库，都可以通过setting.xml配置。当项目编译时，Maven首先从本地仓库中寻找项目所需的Jar包，若本地仓库没有，再到Maven的中央仓库下载所需Jar包。<br>Maven默认的远程仓库，URL地址：<a href="http://search.maven.org/">http://search.maven.org/</a><br>我个人习惯使用<a href="http://mvnrepository.com/">http://mvnrepository.com/</a></p>
<h6 id="私服"><a href="#私服" class="headerlink" title="私服"></a>私服</h6><p>私服：是一种特殊的远程仓库，它是架设在局域网内的仓库<br><img src="/images/post/img7.png"></p>
<h4 id="坐标"><a href="#坐标" class="headerlink" title="坐标"></a>坐标</h4><p>在Maven中，坐标是Jar包的唯一标识，Maven通过坐标在仓库中找到项目所需的Jar包。<br>如下代码中，groupId和artifactId构成了一个Jar包的坐标。</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;cn.fengblog.maven&lt;/groupId&gt;
    &lt;artifactId&gt;maven-test&lt;/artifactId&gt;
    &lt;version&gt;1.1.1&lt;/version&gt;
&lt;/dependency&gt;
</code></pre>
<ul>
<li>groupId:所需Jar包的项目名</li>
<li>artifactId:所需Jar包的模块名</li>
<li>version:所需Jar包的版本号</li>
</ul>
<h4 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h4><h6 id="传递依赖"><a href="#传递依赖" class="headerlink" title="传递依赖"></a>传递依赖</h6><p>如果我们的项目引用了一个Jar包，而该Jar包又引用了其他Jar包，那么在默认情况下项目编译时，Maven会把直接引用和间接引用的Jar包都下载到本地。</p>
<h6 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h6><p>如果我们只想下载直接引用的Jar包，那么需要在pom.xml中做如下配置：(将需要排除的Jar包的坐标写在中)</p>
<pre><code>&lt;exclusions&gt;
    &lt;exclusion&gt;
        &lt;groupId&gt;cn.fengblog.maven&lt;/groupId&gt;
        &lt;artifactId&gt;maven-exclusion&lt;/artifactId&gt;
    &lt;/exclusion&gt;
&lt;/exclusions&gt;
</code></pre>
<p>关于排除依赖如果不理解可以参照下面的博客&gt;&gt;&gt;<br><a href="http://www.cnblogs.com/victorma/p/mavenconflict.html">http://www.cnblogs.com/victorma/p/mavenconflict.html</a></p>
<h6 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h6><p>依赖配置主要包含如下元素：</p>
<pre><code>&lt;!--添加依赖配置--&gt;
&lt;dependencies&gt;
    &lt;!--项目要使用到junit的jar包，所以在这里添加junit的jar包的依赖--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;junit&lt;/groupId&gt;
        &lt;artifactId&gt;junit&lt;/artifactId&gt;
        &lt;version&gt;4.9&lt;/version&gt;
        &lt;scope&gt;test&lt;/scope&gt;
    &lt;/dependency&gt;
    &lt;!--项目要使用到Hello的jar包，所以在这里添加Hello的jar包的依赖--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;cn.fengblog&lt;/groupId&gt;
        &lt;artifactId&gt;Hello-Maven&lt;/artifactId&gt;
        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
        &lt;scope&gt;compile&lt;/scope&gt;
    &lt;/dependency&gt;    
&lt;/dependencies&gt;
</code></pre>
<p>依赖范围scope用来控制依赖和编译，测试，运行的classpath的关系. 主要的是三种依赖关系如下：</p>
<ul>
<li>compile： 默认编译依赖范围。对于编译，测试，运行三种classpath都有效</li>
<li>test：测试依赖范围。只对于测试classpath有效</li>
<li>provided：已提供依赖范围。对于编译，测试的classpath都有效，但对于运行无效。因为由容器已经提供，例如servlet-api</li>
<li>runtime:运行时提供。例如:jdbc驱动</li>
</ul>
<h4 id="短路优先"><a href="#短路优先" class="headerlink" title="短路优先"></a>短路优先</h4><p>若存在下面这种依赖情况，优先选择”短路“的依赖关系。</p>
<blockquote>
<p>本项目——&gt;A.jar——&gt;B.jar——&gt;X.jar<br>本项目——&gt;C.jar——&gt;X.jar</p>
</blockquote>
<h4 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h4><p>关于maven的聚合，推荐以下博文。<br><a href="https://my.oschina.net/xuqiang/blog/99854">一个多maven项目聚合的实例</a><br><a href="http://blog.csdn.net/qq_32588349/article/details/51934100">Maven工程聚合,多个Java工程、web工程聚合</a><br><a href="http://www.cnblogs.com/xdp-gacl/p/4058008.html">Maven学习总结(五)——聚合与继承</a></p>
<h4 id="继承-amp-amp-如何实现继承"><a href="#继承-amp-amp-如何实现继承" class="headerlink" title="继承 &amp;&amp; 如何实现继承"></a>继承 &amp;&amp; 如何实现继承</h4><p>在聚合多个项目时，如果这些被聚合的项目中需要引入相同的Jar，那么可以将这些Jar写入父pom中，各个子项目继承该pom即可。</p>
<h6 id="父pom配置：将需要继承的Jar包的坐标放入标签即可。"><a href="#父pom配置：将需要继承的Jar包的坐标放入标签即可。" class="headerlink" title="父pom配置：将需要继承的Jar包的坐标放入标签即可。"></a>父pom配置：将需要继承的Jar包的坐标放入标签即可。</h6><pre><code>&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;cn.fengblog.maven&lt;/groupId&gt;
            &lt;artifactId&gt;maven-provide&lt;/artifactId&gt;
            &lt;version&gt;1.0.0&lt;/version&gt;
        &lt;/dependency&gt; 
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;
</code></pre>
<h6 id="子pom配置："><a href="#子pom配置：" class="headerlink" title="子pom配置："></a>子pom配置：</h6><pre><code>&lt;parent&gt;
    &lt;groupId&gt;父pom所在项目的groupId&lt;/groupId&gt;
    &lt;artifactId&gt;父pom所在项目的artifactId&lt;/artifactId&gt;
    &lt;version&gt;父pom所在项目的版本号&lt;/version&gt;
&lt;/parent&gt;
</code></pre>
<h2 id="pom配置详解"><a href="#pom配置详解" class="headerlink" title="pom配置详解"></a>pom配置详解</h2><pre><code>&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
  xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0http://maven.apache.org/maven-v4_0_0.xsd&quot;&gt;
  &lt;!--父项目的坐标。如果项目中没有规定某个元素的值，那么父项目中的对应值即为项目的默认值。 坐标包括group ID，artifact ID和 
    version。 --&gt;
  &lt;parent&gt;
    &lt;!--被继承的父项目的构件标识符 --&gt;
    &lt;artifactId /&gt;
    &lt;!--被继承的父项目的全球唯一标识符 --&gt;
    &lt;groupId /&gt;
    &lt;!--被继承的父项目的版本 --&gt;
    &lt;version /&gt;
    &lt;!-- 父项目的pom.xml文件的相对路径。相对路径允许你选择一个不同的路径。默认值是../pom.xml。Maven首先在构建当前项目的地方寻找父项 
      目的pom，其次在文件系统的这个位置（relativePath位置），然后在本地仓库，最后在远程仓库寻找父项目的pom。 --&gt;
    &lt;relativePath /&gt;
  &lt;/parent&gt;
  &lt;!--声明项目描述符遵循哪一个POM模型版本。模型本身的版本很少改变，虽然如此，但它仍然是必不可少的，这是为了当Maven引入了新的特性或者其他模型变更的时候，确保稳定性。 --&gt;
  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
  &lt;!--项目的全球唯一标识符，通常使用全限定的包名区分该项目和其他项目。并且构建时生成的路径也是由此生成， 如com.mycompany.app生成的相对路径为：/com/mycompany/app --&gt;
  &lt;groupId&gt;cn.erhuowang&lt;/groupId&gt;
  &lt;!-- 构件的标识符，它和group ID一起唯一标识一个构件。换句话说，你不能有两个不同的项目拥有同样的artifact ID和groupID；在某个 
    特定的group ID下，artifact ID也必须是唯一的。构件是项目产生的或使用的一个东西，Maven为项目产生的构件包括：JARs，源 码，二进制发布和WARs等。 --&gt;
  &lt;artifactId&gt;erhuowang-maven2&lt;/artifactId&gt;
  &lt;!--项目产生的构件类型，例如jar、war、ear、pom。插件可以创建他们自己的构件类型，所以前面列的不是全部构件类型 --&gt;
  &lt;packaging&gt;war&lt;/packaging&gt;
  &lt;!--项目当前版本，格式为:主版本.次版本.增量版本-限定版本号 --&gt;
  &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
  &lt;!--项目的名称, Maven产生的文档用 --&gt;
  &lt;name&gt;erhuo-maven&lt;/name&gt;
  &lt;!--项目主页的URL, Maven产生的文档用 --&gt;
  &lt;url&gt;http://erhuowang.cn&lt;/url&gt;
  &lt;!-- 项目的详细描述, Maven 产生的文档用。 当这个元素能够用HTML格式描述时（例如，CDATA中的文本会被解析器忽略，就可以包含HTML标 
    签）， 不鼓励使用纯文本描述。如果你需要修改产生的web站点的索引页面，你应该修改你自己的索引页文件，而不是调整这里的文档。 --&gt;
  &lt;description&gt;A maven project to study maven.&lt;/description&gt;
  &lt;!--描述了这个项目构建环境中的前提条件。 --&gt;
  &lt;prerequisites&gt;
    &lt;!--构建该项目或使用该插件所需要的Maven的最低版本 --&gt;
    &lt;maven /&gt;
  &lt;/prerequisites&gt;
  &lt;!--项目名称和URL --&gt;
  &lt;issueManagement&gt;
    &lt;!--项目名字， --&gt;
    &lt;system&gt;erhuowang&lt;/system&gt;
    &lt;!--该项目使用的URL --&gt;
    &lt;url&gt;http://erhuowang.cn&lt;/url&gt;
  &lt;/issueManagement&gt;
  &lt;!--项目持续集成信息 --&gt;
  &lt;ciManagement&gt;
    &lt;!--持续集成系统的名字，例如continuum --&gt;
    &lt;system /&gt;
    &lt;!--该项目使用的持续集成系统的URL（如果持续集成系统有web接口的话）。 --&gt;
    &lt;url /&gt;
    &lt;!--构建完成时，需要通知的开发者/用户的配置项。包括被通知者信息和通知条件（错误，失败，成功，警告） --&gt;
    &lt;notifiers&gt;
      &lt;!--配置一种方式，当构建中断时，以该方式通知用户/开发者 --&gt;
      &lt;notifier&gt;
        &lt;!--传送通知的途径 --&gt;
        &lt;type /&gt;
        &lt;!--发生错误时是否通知 --&gt;
        &lt;sendOnError /&gt;
        &lt;!--构建失败时是否通知 --&gt;
        &lt;sendOnFailure /&gt;
        &lt;!--构建成功时是否通知 --&gt;
        &lt;sendOnSuccess /&gt;
        &lt;!--发生警告时是否通知 --&gt;
        &lt;sendOnWarning /&gt;
        &lt;!--不赞成使用。通知发送到哪里 --&gt;
        &lt;address /&gt;
        &lt;!--扩展配置项 --&gt;
        &lt;configuration /&gt;
      &lt;/notifier&gt;
    &lt;/notifiers&gt;
  &lt;/ciManagement&gt;
  &lt;!--项目创建年份，4位数字。当产生版权信息时需要使用这个值。 --&gt;
  &lt;inceptionYear /&gt;
  &lt;!--项目相关邮件列表信息 --&gt;
  &lt;mailingLists&gt;
    &lt;!--该元素描述了项目相关的所有邮件列表。自动产生的网站引用这些信息。 --&gt;
    &lt;mailingList&gt;
      &lt;!--邮件的名称 --&gt;
      &lt;name&gt;Demo&lt;/name&gt;
      &lt;!--发送邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;
      &lt;post&gt;chaibozhou@163.com&lt;/post&gt;
      &lt;!--订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;
      &lt;subscribe&gt;chaibozhou@163.com&lt;/subscribe&gt;
      &lt;!--取消订阅邮件的地址或链接，如果是邮件地址，创建文档时，mailto: 链接会被自动创建 --&gt;
      &lt;unsubscribe&gt;chaibozhou@163.com&lt;/unsubscribe&gt;
      &lt;!--你可以浏览邮件信息的URL --&gt;
      &lt;archive&gt;chaibozhou@163.com&lt;/archive&gt;
    &lt;/mailingList&gt;
  &lt;/mailingLists&gt;
  &lt;!--项目开发者列表 --&gt;
  &lt;developers&gt;
    &lt;!--某个项目开发者的信息 --&gt;
    &lt;developer&gt;
      &lt;!--SCM里项目开发者的唯一标识符 --&gt;
      &lt;id&gt;HELLO WORLD&lt;/id&gt;
      &lt;!--项目开发者的全名 --&gt;
      &lt;name&gt;chaimm&lt;/name&gt;
      &lt;!--项目开发者的email --&gt;
      &lt;email&gt;chaibozhou@163.com&lt;/email&gt;
      &lt;!--项目开发者的主页的URL --&gt;
      &lt;url /&gt;
      &lt;!--项目开发者在项目中扮演的角色，角色元素描述了各种角色 --&gt;
      &lt;roles&gt;
        &lt;role&gt;Project Manager&lt;/role&gt;
        &lt;role&gt;Architect&lt;/role&gt;
      &lt;/roles&gt;
      &lt;!--项目开发者所属组织 --&gt;
      &lt;organization&gt;demo&lt;/organization&gt;
      &lt;!--项目开发者所属组织的URL --&gt;
      &lt;organizationUrl&gt;http://erhuowang.cn&lt;/organizationUrl&gt;
      &lt;!--项目开发者属性，如即时消息如何处理等 --&gt;
      &lt;properties&gt;
        &lt;dept&gt;No&lt;/dept&gt;
      &lt;/properties&gt;
      &lt;!--项目开发者所在时区， -11到12范围内的整数。 --&gt;
      &lt;timezone&gt;-5&lt;/timezone&gt;
    &lt;/developer&gt;
  &lt;/developers&gt;
  &lt;!--项目的其他贡献者列表 --&gt;
  &lt;contributors&gt;
    &lt;!--项目的其他贡献者。参见developers/developer元素 --&gt;
    &lt;contributor&gt;
      &lt;name /&gt;
      &lt;email /&gt;
      &lt;url /&gt;
      &lt;organization /&gt;
      &lt;organizationUrl /&gt;
      &lt;roles /&gt;
      &lt;timezone /&gt;
      &lt;properties /&gt;
    &lt;/contributor&gt;
  &lt;/contributors&gt;
  &lt;!--该元素描述了项目所有License列表。 应该只列出该项目的license列表，不要列出依赖项目的 license列表。如果列出多个license，用户可以选择它们中的一个而不是接受所有license。 --&gt;
  &lt;licenses&gt;
    &lt;!--描述了项目的license，用于生成项目的web站点的license页面，其他一些报表和validation也会用到该元素。 --&gt;
    &lt;license&gt;
      &lt;!--license用于法律上的名称 --&gt;
      &lt;name&gt;Apache 2&lt;/name&gt;
      &lt;!--官方的license正文页面的URL --&gt;
      &lt;url&gt;http://www.baidu.com/erhuwoang/LICENSE-2.0.txt&lt;/url&gt;
      &lt;!--项目分发的主要方式： repo，可以从Maven库下载 manual， 用户必须手动下载和安装依赖 --&gt;
      &lt;distribution&gt;repo&lt;/distribution&gt;
      &lt;!--关于license的补充信息 --&gt;
      &lt;comments&gt;A business-friendly OSS license&lt;/comments&gt;
    &lt;/license&gt;
  &lt;/licenses&gt;
  &lt;!--SCM(Source Control Management)标签允许你配置你的代码库，供Maven web站点和其它插件使用。 --&gt;
  &lt;scm&gt;
    &lt;!--SCM的URL,该URL描述了版本库和如何连接到版本库。欲知详情，请看SCMs提供的URL格式和列表。该连接只读。 --&gt;
    &lt;connection&gt;
    scm:svn:http://svn.baidu.com/banseon/maven/banseon/banseon-maven2-trunk(dao-trunk)
  &lt;/connection&gt;
    &lt;!--给开发者使用的，类似connection元素。即该连接不仅仅只读 --&gt;
    &lt;developerConnection&gt;
    scm:svn:http://svn.baidu.com/banseon/maven/banseon/dao-trunk
  &lt;/developerConnection&gt;
    &lt;!--当前代码的标签，在开发阶段默认为HEAD --&gt;
    &lt;tag /&gt;
    &lt;!--指向项目的可浏览SCM库（例如ViewVC或者Fisheye）的URL。 --&gt;
    &lt;url&gt;http://svn.baidu.com/banseon&lt;/url&gt;
  &lt;/scm&gt;
  &lt;!--描述项目所属组织的各种属性。Maven产生的文档用 --&gt;
  &lt;organization&gt;
    &lt;!--组织的全名 --&gt;
    &lt;name&gt;demo&lt;/name&gt;
    &lt;!--组织主页的URL --&gt;
    &lt;url&gt;http://www.erhuowang.cn&lt;/url&gt;
  &lt;/organization&gt;
  &lt;!--构建项目需要的信息 --&gt;
  &lt;build&gt;
    &lt;!--该元素设置了项目源码目录，当构建项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;
    &lt;sourceDirectory /&gt;
    &lt;!--该元素设置了项目脚本源码目录，该目录和源码目录不同：绝大多数情况下，该目录下的内容 会被拷贝到输出目录(因为脚本是被解释的，而不是被编译的)。 --&gt;
    &lt;scriptSourceDirectory /&gt;
    &lt;!--该元素设置了项目单元测试使用的源码目录，当测试项目的时候，构建系统会编译目录里的源码。该路径是相对于pom.xml的相对路径。 --&gt;
    &lt;testSourceDirectory /&gt;
    &lt;!--被编译过的应用程序class文件存放的目录。 --&gt;
    &lt;outputDirectory /&gt;
    &lt;!--被编译过的测试class文件存放的目录。 --&gt;
    &lt;testOutputDirectory /&gt;
    &lt;!--使用来自该项目的一系列构建扩展 --&gt;
    &lt;extensions&gt;
      &lt;!--描述使用到的构建扩展。 --&gt;
      &lt;extension&gt;
        &lt;!--构建扩展的groupId --&gt;
        &lt;groupId /&gt;
        &lt;!--构建扩展的artifactId --&gt;
        &lt;artifactId /&gt;
        &lt;!--构建扩展的版本 --&gt;
        &lt;version /&gt;
      &lt;/extension&gt;
    &lt;/extensions&gt;
    &lt;!--当项目没有规定目标（Maven2 叫做阶段）时的默认值 --&gt;
    &lt;defaultGoal /&gt;
    &lt;!--这个元素描述了项目相关的所有资源路径列表，例如和项目相关的属性文件，这些资源被包含在最终的打包文件里。 --&gt;
    &lt;resources&gt;
      &lt;!--这个元素描述了项目相关或测试相关的所有资源路径 --&gt;
      &lt;resource&gt;
        &lt;!-- 描述了资源的目标路径。该路径相对target/classes目录（例如$&#123;project.build.outputDirectory&#125;）。举个例 
          子，如果你想资源在特定的包里(org.apache.maven.messages)，你就必须该元素设置为org/apache/maven /messages。然而，如果你只是想把资源放到源码目录结构里，就不需要该配置。 --&gt;
        &lt;targetPath /&gt;
        &lt;!--是否使用参数值代替参数名。参数值取自properties元素或者文件里配置的属性，文件在filters元素里列出。 --&gt;
        &lt;filtering /&gt;
        &lt;!--描述存放资源的目录，该路径相对POM路径 --&gt;
        &lt;directory /&gt;
        &lt;!--包含的模式列表，例如**/*.xml. --&gt;
        &lt;includes /&gt;
        &lt;!--排除的模式列表，例如**/*.xml --&gt;
        &lt;excludes /&gt;
      &lt;/resource&gt;
    &lt;/resources&gt;
    &lt;!--这个元素描述了单元测试相关的所有资源路径，例如和单元测试相关的属性文件。 --&gt;
    &lt;testResources&gt;
      &lt;!--这个元素描述了测试相关的所有资源路径，参见build/resources/resource元素的说明 --&gt;
      &lt;testResource&gt;
        &lt;targetPath /&gt;
        &lt;filtering /&gt;
        &lt;directory /&gt;
        &lt;includes /&gt;
        &lt;excludes /&gt;
      &lt;/testResource&gt;
    &lt;/testResources&gt;
    &lt;!--构建产生的所有文件存放的目录 --&gt;
    &lt;directory /&gt;
    &lt;!--产生的构件的文件名，默认值是$&#123;artifactId&#125;-$&#123;version&#125;。 --&gt;
    &lt;finalName /&gt;
    &lt;!--当filtering开关打开时，使用到的过滤器属性文件列表 --&gt;
    &lt;filters /&gt;
    &lt;!--子项目可以引用的默认插件信息。该插件配置项直到被引用时才会被解析或绑定到生命周期。给定插件的任何本地配置都会覆盖这里的配置 --&gt;
    &lt;pluginManagement&gt;
      &lt;!--使用的插件列表 。 --&gt;
      &lt;plugins&gt;
        &lt;!--plugin元素包含描述插件所需要的信息。 --&gt;
        &lt;plugin&gt;
          &lt;!--插件在仓库里的group ID --&gt;
          &lt;groupId /&gt;
          &lt;!--插件在仓库里的artifact ID --&gt;
          &lt;artifactId /&gt;
          &lt;!--被使用的插件的版本（或版本范围） --&gt;
          &lt;version /&gt;
          &lt;!--是否从该插件下载Maven扩展（例如打包和类型处理器），由于性能原因，只有在真需要下载时，该元素才被设置成enabled。 --&gt;
          &lt;extensions /&gt;
          &lt;!--在构建生命周期中执行一组目标的配置。每个目标可能有不同的配置。 --&gt;
          &lt;executions&gt;
            &lt;!--execution元素包含了插件执行需要的信息 --&gt;
            &lt;execution&gt;
              &lt;!--执行目标的标识符，用于标识构建过程中的目标，或者匹配继承过程中需要合并的执行目标 --&gt;
              &lt;id /&gt;
              &lt;!--绑定了目标的构建生命周期阶段，如果省略，目标会被绑定到源数据里配置的默认阶段 --&gt;
              &lt;phase /&gt;
              &lt;!--配置的执行目标 --&gt;
              &lt;goals /&gt;
              &lt;!--配置是否被传播到子POM --&gt;
              &lt;inherited /&gt;
              &lt;!--作为DOM对象的配置 --&gt;
              &lt;configuration /&gt;
            &lt;/execution&gt;
          &lt;/executions&gt;
          &lt;!--项目引入插件所需要的额外依赖 --&gt;
          &lt;dependencies&gt;
            &lt;!--参见dependencies/dependency元素 --&gt;
            &lt;dependency&gt;
              ......
            &lt;/dependency&gt;
          &lt;/dependencies&gt;
          &lt;!--任何配置是否被传播到子项目 --&gt;
          &lt;inherited /&gt;
          &lt;!--作为DOM对象的配置 --&gt;
          &lt;configuration /&gt;
        &lt;/plugin&gt;
      &lt;/plugins&gt;
    &lt;/pluginManagement&gt;
    &lt;!--使用的插件列表 --&gt;
    &lt;plugins&gt;
      &lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;
      &lt;plugin&gt;
        &lt;groupId /&gt;
        &lt;artifactId /&gt;
        &lt;version /&gt;
        &lt;extensions /&gt;
        &lt;executions&gt;
          &lt;execution&gt;
            &lt;id /&gt;
            &lt;phase /&gt;
            &lt;goals /&gt;
            &lt;inherited /&gt;
            &lt;configuration /&gt;
          &lt;/execution&gt;
        &lt;/executions&gt;
        &lt;dependencies&gt;
          &lt;!--参见dependencies/dependency元素 --&gt;
          &lt;dependency&gt;
            ......
          &lt;/dependency&gt;
        &lt;/dependencies&gt;
        &lt;goals /&gt;
        &lt;inherited /&gt;
        &lt;configuration /&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/build&gt;
  &lt;!--在列的项目构建profile，如果被激活，会修改构建处理 --&gt;
  &lt;profiles&gt;
    &lt;!--根据环境参数或命令行参数激活某个构建处理 --&gt;
    &lt;profile&gt;
      &lt;!--构建配置的唯一标识符。即用于命令行激活，也用于在继承时合并具有相同标识符的profile。 --&gt;
      &lt;id /&gt;
      &lt;!--自动触发profile的条件逻辑。Activation是profile的开启钥匙。profile的力量来自于它 能够在某些特定的环境中自动使用某些特定的值；这些环境通过activation元素指定。activation元素并不是激活profile的唯一方式。 --&gt;
      &lt;activation&gt;
        &lt;!--profile默认是否激活的标志 --&gt;
        &lt;activeByDefault /&gt;
        &lt;!--当匹配的jdk被检测到，profile被激活。例如，1.4激活JDK1.4，1.4.0_2，而!1.4激活所有版本不是以1.4开头的JDK。 --&gt;
        &lt;jdk /&gt;
        &lt;!--当匹配的操作系统属性被检测到，profile被激活。os元素可以定义一些操作系统相关的属性。 --&gt;
        &lt;os&gt;
          &lt;!--激活profile的操作系统的名字 --&gt;
          &lt;name&gt;Windows XP&lt;/name&gt;
          &lt;!--激活profile的操作系统所属家族(如 &#39;windows&#39;) --&gt;
          &lt;family&gt;Windows&lt;/family&gt;
          &lt;!--激活profile的操作系统体系结构 --&gt;
          &lt;arch&gt;x86&lt;/arch&gt;
          &lt;!--激活profile的操作系统版本 --&gt;
          &lt;version&gt;5.1.2600&lt;/version&gt;
        &lt;/os&gt;
        &lt;!--如果Maven检测到某一个属性（其值可以在POM中通过$&#123;名称&#125;引用），其拥有对应的名称和值，Profile就会被激活。如果值 字段是空的，那么存在属性名称字段就会激活profile，否则按区分大小写方式匹配属性值字段 --&gt;
        &lt;property&gt;
          &lt;!--激活profile的属性的名称 --&gt;
          &lt;name&gt;mavenVersion&lt;/name&gt;
          &lt;!--激活profile的属性的值 --&gt;
          &lt;value&gt;2.0.3&lt;/value&gt;
        &lt;/property&gt;
        &lt;!--提供一个文件名，通过检测该文件的存在或不存在来激活profile。missing检查文件是否存在，如果不存在则激活 profile。另一方面，exists则会检查文件是否存在，如果存在则激活profile。 --&gt;
        &lt;file&gt;
          &lt;!--如果指定的文件存在，则激活profile。 --&gt;
          &lt;exists&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/exists&gt;
          &lt;!--如果指定的文件不存在，则激活profile。 --&gt;
          &lt;missing&gt;/usr/local/hudson/hudson-home/jobs/maven-guide-zh-to-production/workspace/&lt;/missing&gt;
        &lt;/file&gt;
      &lt;/activation&gt;
      &lt;!--构建项目所需要的信息。参见build元素 --&gt;
      &lt;build&gt;
        &lt;defaultGoal /&gt;
        &lt;resources&gt;
          &lt;resource&gt;
            &lt;targetPath /&gt;
            &lt;filtering /&gt;
            &lt;directory /&gt;
            &lt;includes /&gt;
            &lt;excludes /&gt;
          &lt;/resource&gt;
        &lt;/resources&gt;
        &lt;testResources&gt;
          &lt;testResource&gt;
            &lt;targetPath /&gt;
            &lt;filtering /&gt;
            &lt;directory /&gt;
            &lt;includes /&gt;
            &lt;excludes /&gt;
          &lt;/testResource&gt;
        &lt;/testResources&gt;
        &lt;directory /&gt;
        &lt;finalName /&gt;
        &lt;filters /&gt;
        &lt;pluginManagement&gt;
          &lt;plugins&gt;
            &lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;
            &lt;plugin&gt;
              &lt;groupId /&gt;
              &lt;artifactId /&gt;
              &lt;version /&gt;
              &lt;extensions /&gt;
              &lt;executions&gt;
                &lt;execution&gt;
                  &lt;id /&gt;
                  &lt;phase /&gt;
                  &lt;goals /&gt;
                  &lt;inherited /&gt;
                  &lt;configuration /&gt;
                &lt;/execution&gt;
              &lt;/executions&gt;
              &lt;dependencies&gt;
                &lt;!--参见dependencies/dependency元素 --&gt;
                &lt;dependency&gt;
                  ......
                &lt;/dependency&gt;
              &lt;/dependencies&gt;
              &lt;goals /&gt;
              &lt;inherited /&gt;
              &lt;configuration /&gt;
            &lt;/plugin&gt;
          &lt;/plugins&gt;
        &lt;/pluginManagement&gt;
        &lt;plugins&gt;
          &lt;!--参见build/pluginManagement/plugins/plugin元素 --&gt;
          &lt;plugin&gt;
            &lt;groupId /&gt;
            &lt;artifactId /&gt;
            &lt;version /&gt;
            &lt;extensions /&gt;
            &lt;executions&gt;
              &lt;execution&gt;
                &lt;id /&gt;
                &lt;phase /&gt;
                &lt;goals /&gt;
                &lt;inherited /&gt;
                &lt;configuration /&gt;
              &lt;/execution&gt;
            &lt;/executions&gt;
            &lt;dependencies&gt;
              &lt;!--参见dependencies/dependency元素 --&gt;
              &lt;dependency&gt;
                ......
              &lt;/dependency&gt;
            &lt;/dependencies&gt;
            &lt;goals /&gt;
            &lt;inherited /&gt;
            &lt;configuration /&gt;
          &lt;/plugin&gt;
        &lt;/plugins&gt;
      &lt;/build&gt;
      &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;
      &lt;modules /&gt;
      &lt;!--发现依赖和扩展的远程仓库列表。 --&gt;
      &lt;repositories&gt;
        &lt;!--参见repositories/repository元素 --&gt;
        &lt;repository&gt;
          &lt;releases&gt;
            &lt;enabled /&gt;
            &lt;updatePolicy /&gt;
            &lt;checksumPolicy /&gt;
          &lt;/releases&gt;
          &lt;snapshots&gt;
            &lt;enabled /&gt;
            &lt;updatePolicy /&gt;
            &lt;checksumPolicy /&gt;
          &lt;/snapshots&gt;
          &lt;id /&gt;
          &lt;name /&gt;
          &lt;url /&gt;
          &lt;layout /&gt;
        &lt;/repository&gt;
      &lt;/repositories&gt;
      &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;
      &lt;pluginRepositories&gt;
        &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;
        &lt;pluginRepository&gt;
          &lt;releases&gt;
            &lt;enabled /&gt;
            &lt;updatePolicy /&gt;
            &lt;checksumPolicy /&gt;
          &lt;/releases&gt;
          &lt;snapshots&gt;
            &lt;enabled /&gt;
            &lt;updatePolicy /&gt;
            &lt;checksumPolicy /&gt;
          &lt;/snapshots&gt;
          &lt;id /&gt;
          &lt;name /&gt;
          &lt;url /&gt;
          &lt;layout /&gt;
        &lt;/pluginRepository&gt;
      &lt;/pluginRepositories&gt;
      &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;
      &lt;dependencies&gt;
        &lt;!--参见dependencies/dependency元素 --&gt;
        &lt;dependency&gt;
          ......
        &lt;/dependency&gt;
      &lt;/dependencies&gt;
      &lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;
      &lt;reports /&gt;
      &lt;!--该元素包括使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。参见reporting元素 --&gt;
      &lt;reporting&gt;
        ......
      &lt;/reporting&gt;
      &lt;!--参见dependencyManagement元素 --&gt;
      &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
          &lt;!--参见dependencies/dependency元素 --&gt;
          &lt;dependency&gt;
            ......
          &lt;/dependency&gt;
        &lt;/dependencies&gt;
      &lt;/dependencyManagement&gt;
      &lt;!--参见distributionManagement元素 --&gt;
      &lt;distributionManagement&gt;
        ......
      &lt;/distributionManagement&gt;
      &lt;!--参见properties元素 --&gt;
      &lt;properties /&gt;
    &lt;/profile&gt;
  &lt;/profiles&gt;
  &lt;!--模块（有时称作子项目） 被构建成项目的一部分。列出的每个模块元素是指向该模块的目录的相对路径 --&gt;
  &lt;modules /&gt;
  &lt;!--发现依赖和扩展的远程仓库列表。 --&gt;
  &lt;repositories&gt;
    &lt;!--包含需要连接到远程仓库的信息 --&gt;
    &lt;repository&gt;
      &lt;!--如何处理远程仓库里发布版本的下载 --&gt;
      &lt;releases&gt;
        &lt;!--true或者false表示该仓库是否为下载某种类型构件（发布版，快照版）开启。 --&gt;
        &lt;enabled /&gt;
        &lt;!--该元素指定更新发生的频率。Maven会比较本地POM和远程POM的时间戳。这里的选项是：always（一直），daily（默认，每日），interval：X（这里X是以分钟为单位的时间间隔），或者never（从不）。 --&gt;
        &lt;updatePolicy /&gt;
        &lt;!--当Maven验证构件校验文件失败时该怎么做：ignore（忽略），fail（失败），或者warn（警告）。 --&gt;
        &lt;checksumPolicy /&gt;
      &lt;/releases&gt;
      &lt;!-- 如何处理远程仓库里快照版本的下载。有了releases和snapshots这两组配置，POM就可以在每个单独的仓库中，为每种类型的构件采取不同的 
        策略。例如，可能有人会决定只为开发目的开启对快照版本下载的支持。参见repositories/repository/releases元素 --&gt;
      &lt;snapshots&gt;
        &lt;enabled /&gt;
        &lt;updatePolicy /&gt;
        &lt;checksumPolicy /&gt;
      &lt;/snapshots&gt;
      &lt;!--远程仓库唯一标识符。可以用来匹配在settings.xml文件里配置的远程仓库 --&gt;
      &lt;id&gt;banseon-repository-proxy&lt;/id&gt;
      &lt;!--远程仓库名称 --&gt;
      &lt;name&gt;banseon-repository-proxy&lt;/name&gt;
      &lt;!--远程仓库URL，按protocol://hostname/path形式 --&gt;
      &lt;url&gt;http://192.168.1.169:9999/repository/&lt;/url&gt;
      &lt;!-- 用于定位和排序构件的仓库布局类型-可以是default（默认）或者legacy（遗留）。Maven 2为其仓库提供了一个默认的布局；然 
        而，Maven 1.x有一种不同的布局。我们可以使用该元素指定布局是default（默认）还是legacy（遗留）。 --&gt;
      &lt;layout&gt;default&lt;/layout&gt;
    &lt;/repository&gt;
  &lt;/repositories&gt;
  &lt;!--发现插件的远程仓库列表，这些插件用于构建和报表 --&gt;
  &lt;pluginRepositories&gt;
    &lt;!--包含需要连接到远程插件仓库的信息.参见repositories/repository元素 --&gt;
    &lt;pluginRepository&gt;
      ......
    &lt;/pluginRepository&gt;
  &lt;/pluginRepositories&gt;

  &lt;!--该元素描述了项目相关的所有依赖。 这些依赖组成了项目构建过程中的一个个环节。它们自动从项目定义的仓库中下载。要获取更多信息，请看项目依赖机制。 --&gt;
  &lt;dependencies&gt;
    &lt;dependency&gt;
      &lt;!--依赖的group ID --&gt;
      &lt;groupId&gt;org.apache.maven&lt;/groupId&gt;
      &lt;!--依赖的artifact ID --&gt;
      &lt;artifactId&gt;maven-artifact&lt;/artifactId&gt;
      &lt;!--依赖的版本号。 在Maven 2里, 也可以配置成版本号的范围。 --&gt;
      &lt;version&gt;3.8.1&lt;/version&gt;
      &lt;!-- 依赖类型，默认类型是jar。它通常表示依赖的文件的扩展名，但也有例外。一个类型可以被映射成另外一个扩展名或分类器。类型经常和使用的打包方式对应， 
        尽管这也有例外。一些类型的例子：jar，war，ejb-client和test-jar。如果设置extensions为 true，就可以在 plugin里定义新的类型。所以前面的类型的例子不完整。 --&gt;
      &lt;type&gt;jar&lt;/type&gt;
      &lt;!-- 依赖的分类器。分类器可以区分属于同一个POM，但不同构建方式的构件。分类器名被附加到文件名的版本号后面。例如，如果你想要构建两个单独的构件成 
        JAR，一个使用Java 1.4编译器，另一个使用Java 6编译器，你就可以使用分类器来生成两个单独的JAR构件。 --&gt;
      &lt;classifier&gt;&lt;/classifier&gt;
      &lt;!--依赖范围。在项目发布过程中，帮助决定哪些构件被包括进来。欲知详情请参考依赖机制。 - compile ：默认范围，用于编译 - provided：类似于编译，但支持你期待jdk或者容器提供，类似于classpath 
        - runtime: 在执行时需要使用 - test: 用于test任务时使用 - system: 需要外在提供相应的元素。通过systemPath来取得 
        - systemPath: 仅用于范围为system。提供相应的路径 - optional: 当项目自身被依赖时，标注依赖是否传递。用于连续依赖时使用 --&gt;
      &lt;scope&gt;test&lt;/scope&gt;
      &lt;!--仅供system范围使用。注意，不鼓励使用这个元素，并且在新的版本中该元素可能被覆盖掉。该元素为依赖规定了文件系统上的路径。需要绝对路径而不是相对路径。推荐使用属性匹配绝对路径，例如$&#123;java.home&#125;。 --&gt;
      &lt;systemPath&gt;&lt;/systemPath&gt;
      &lt;!--当计算传递依赖时， 从依赖构件列表里，列出被排除的依赖构件集。即告诉maven你只依赖指定的项目，不依赖项目的依赖。此元素主要用于解决版本冲突问题 --&gt;
      &lt;exclusions&gt;
        &lt;exclusion&gt;
          &lt;artifactId&gt;spring-core&lt;/artifactId&gt;
          &lt;groupId&gt;org.springframework&lt;/groupId&gt;
        &lt;/exclusion&gt;
      &lt;/exclusions&gt;
      &lt;!--可选依赖，如果你在项目B中把C依赖声明为可选，你就需要在依赖于B的项目（例如项目A）中显式的引用对C的依赖。可选依赖阻断依赖的传递性。 --&gt;
      &lt;optional&gt;true&lt;/optional&gt;
    &lt;/dependency&gt;
  &lt;/dependencies&gt;
  &lt;!--不赞成使用. 现在Maven忽略该元素. --&gt;
  &lt;reports&gt;&lt;/reports&gt;
  &lt;!--该元素描述使用报表插件产生报表的规范。当用户执行“mvn site”，这些报表就会运行。 在页面导航栏能看到所有报表的链接。 --&gt;
  &lt;reporting&gt;
    &lt;!--true，则，网站不包括默认的报表。这包括“项目信息”菜单中的报表。 --&gt;
    &lt;excludeDefaults /&gt;
    &lt;!--所有产生的报表存放到哪里。默认值是$&#123;project.build.directory&#125;/site。 --&gt;
    &lt;outputDirectory /&gt;
    &lt;!--使用的报表插件和他们的配置。 --&gt;
    &lt;plugins&gt;
      &lt;!--plugin元素包含描述报表插件需要的信息 --&gt;
      &lt;plugin&gt;
        &lt;!--报表插件在仓库里的group ID --&gt;
        &lt;groupId /&gt;
        &lt;!--报表插件在仓库里的artifact ID --&gt;
        &lt;artifactId /&gt;
        &lt;!--被使用的报表插件的版本（或版本范围） --&gt;
        &lt;version /&gt;
        &lt;!--任何配置是否被传播到子项目 --&gt;
        &lt;inherited /&gt;
        &lt;!--报表插件的配置 --&gt;
        &lt;configuration /&gt;
        &lt;!--一组报表的多重规范，每个规范可能有不同的配置。一个规范（报表集）对应一个执行目标 。例如，有1，2，3，4，5，6，7，8，9个报表。1，2，5构成A报表集，对应一个执行目标。2，5，8构成B报表集，对应另一个执行目标 --&gt;
        &lt;reportSets&gt;
          &lt;!--表示报表的一个集合，以及产生该集合的配置 --&gt;
          &lt;reportSet&gt;
            &lt;!--报表集合的唯一标识符，POM继承时用到 --&gt;
            &lt;id /&gt;
            &lt;!--产生报表集合时，被使用的报表的配置 --&gt;
            &lt;configuration /&gt;
            &lt;!--配置是否被继承到子POMs --&gt;
            &lt;inherited /&gt;
            &lt;!--这个集合里使用到哪些报表 --&gt;
            &lt;reports /&gt;
          &lt;/reportSet&gt;
        &lt;/reportSets&gt;
      &lt;/plugin&gt;
    &lt;/plugins&gt;
  &lt;/reporting&gt;
  &lt;!-- 继承自该项目的所有子项目的默认依赖信息。这部分的依赖信息不会被立即解析,而是当子项目声明一个依赖（必须描述group ID和 artifact 
    ID信息），如果group ID和artifact ID以外的一些信息没有描述，则通过group ID和artifact ID 匹配到这里的依赖，并使用这里的依赖信息。 --&gt;
  &lt;dependencyManagement&gt;
    &lt;dependencies&gt;
      &lt;!--参见dependencies/dependency元素 --&gt;
      &lt;dependency&gt;
        ......
      &lt;/dependency&gt;
    &lt;/dependencies&gt;
  &lt;/dependencyManagement&gt;
  &lt;!--项目分发信息，在执行mvn deploy后表示要发布的位置。有了这些信息就可以把网站部署到远程服务器或者把构件部署到远程仓库。 --&gt;
  &lt;distributionManagement&gt;
    &lt;!--部署项目产生的构件到远程仓库需要的信息 --&gt;
    &lt;repository&gt;
      &lt;!--是分配给快照一个唯一的版本号（由时间戳和构建流水号）？还是每次都使用相同的版本号？参见repositories/repository元素 --&gt;
      &lt;uniqueVersion /&gt;
      &lt;id&gt;banseon-maven2&lt;/id&gt;
      &lt;name&gt;banseon maven2&lt;/name&gt;
      &lt;url&gt;file://$&#123;basedir&#125;/target/deploy&lt;/url&gt;
      &lt;layout /&gt;
    &lt;/repository&gt;
    &lt;!--构件的快照部署到哪里？如果没有配置该元素，默认部署到repository元素配置的仓库，参见distributionManagement/repository元素 --&gt;
    &lt;snapshotRepository&gt;
      &lt;uniqueVersion /&gt;
      &lt;id&gt;banseon-maven2&lt;/id&gt;
      &lt;name&gt;Banseon-maven2 Snapshot Repository&lt;/name&gt;
      &lt;url&gt;scp://svn.baidu.com/banseon:/usr/local/maven-snapshot&lt;/url&gt;
      &lt;layout /&gt;
    &lt;/snapshotRepository&gt;
    &lt;!--部署项目的网站需要的信息 --&gt;
    &lt;site&gt;
      &lt;!--部署位置的唯一标识符，用来匹配站点和settings.xml文件里的配置 --&gt;
      &lt;id&gt;banseon-site&lt;/id&gt;
      &lt;!--部署位置的名称 --&gt;
      &lt;name&gt;business api website&lt;/name&gt;
      &lt;!--部署位置的URL，按protocol://hostname/path形式 --&gt;
      &lt;url&gt;
      scp://svn.baidu.com/banseon:/var/www/localhost/banseon-web
    &lt;/url&gt;
    &lt;/site&gt;
    &lt;!--项目下载页面的URL。如果没有该元素，用户应该参考主页。使用该元素的原因是：帮助定位那些不在仓库里的构件（由于license限制）。 --&gt;
    &lt;downloadUrl /&gt;
    &lt;!--如果构件有了新的group ID和artifact ID（构件移到了新的位置），这里列出构件的重定位信息。 --&gt;
    &lt;relocation&gt;
      &lt;!--构件新的group ID --&gt;
      &lt;groupId /&gt;
      &lt;!--构件新的artifact ID --&gt;
      &lt;artifactId /&gt;
      &lt;!--构件新的版本号 --&gt;
      &lt;version /&gt;
      &lt;!--显示给用户的，关于移动的额外信息，例如原因。 --&gt;
      &lt;message /&gt;
    &lt;/relocation&gt;
    &lt;!-- 给出该构件在远程仓库的状态。不得在本地项目中设置该元素，因为这是工具自动更新的。有效的值有：none（默认），converted（仓库管理员从 
      Maven 1 POM转换过来），partner（直接从伙伴Maven 2仓库同步过来），deployed（从Maven 2实例部 署），verified（被核实时正确的和最终的）。 --&gt;
    &lt;status /&gt;
  &lt;/distributionManagement&gt;
  &lt;!--以值替代名称，Properties可以在整个POM中使用，也可以作为触发条件（见settings.xml配置文件里activation元素的说明）。格式是&lt;name&gt;value&lt;/name&gt;。 --&gt;
  &lt;properties /&gt;
&lt;/project&gt;
</code></pre>
<p>关于pom.xml配置，推荐博客<br><a href="http://blog.csdn.net/zhuxinhua/article/details/5788546">maven核心，pom.xml详解</a><br><a href="http://blog.csdn.net/taiyangdao/article/details/52374125">Maven的pom.xml文件结构之Build配置build</a></p>
<h2 id="使用Maven运行Web项目"><a href="#使用Maven运行Web项目" class="headerlink" title="使用Maven运行Web项目"></a>使用Maven运行Web项目</h2><h2 id="scope详解"><a href="#scope详解" class="headerlink" title="scope详解"></a>scope详解</h2><p><a href="https://www.cnblogs.com/hzzll/p/6738955.html">https://www.cnblogs.com/hzzll/p/6738955.html</a></p>
<h2 id="参照博客"><a href="#参照博客" class="headerlink" title="参照博客"></a>参照博客</h2><p><a href="http://www.cnblogs.com/xdp-gacl/p/3498271.html">《Maven学习总结(一)——Maven入门》</a>(整个系列)</p>
]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>ear war jar 区别</title>
    <url>/2016/11/25/ear-war-jar-%E5%8C%BA%E5%88%AB/</url>
    <content><![CDATA[<h2 id="Jar文件"><a href="#Jar文件" class="headerlink" title="Jar文件"></a>Jar文件</h2><p>（扩展名为. Jar，Java Application Archive）包含Java类的普通库、资源（resources）、辅助文件（auxiliary files）等</p>
<h2 id="War文件"><a href="#War文件" class="headerlink" title="War文件"></a>War文件</h2><p>（扩展名为.War,Web Application Archive）包含全部Web应用程序。在这种情形下，一个Web应用程序被定义为单独的一组文件、类和资源，用户可以对jar文件进行封装，并把它作为小型服务程序（servlet）来访问。</p>
<h2 id="Ear文件"><a href="#Ear文件" class="headerlink" title="Ear文件"></a>Ear文件</h2><p>（扩展名为.Ear,Enterprise Application Archive）包含全部企业应用程序。在这种情形下，一个企业应用程序被定义为多个jar文件、资源、类和Web应用程序的集合。</p>
<blockquote>
<p>EAR文件包括整个项目，内含多个ejb module（jar文件）和web module（war文件）</p>
</blockquote>
<p>EAR文件的生成可以使用winrar zip压缩方式或者jar命令。<br>先打包成war和jar,并写好application.xml，放到META-INF目录下，然后</p>
<pre><code>jar cf your_application.ear your_war.war your_jar.jar META-INF/application.xml
</code></pre>
<p>打包，我这假设war和jar都在当前目录下。解压用</p>
<pre><code>jar xf your_application.ear 
</code></pre>
<p>application.xml demo：</p>
<pre><code>&lt;!DOCTYPE application PUBLIC  
    &quot;-//Sun Microsystems, Inc.//DTD J2EE Application 1.3//EN&quot;  
    &quot;http://java.sun.com/dtd/application_1_3.dtd&quot;&gt;  
&lt;application&gt;  
  &lt;display-name&gt;fengblog.ear&lt;/display-name&gt;  
  &lt;module&gt;  
    &lt;java&gt;fengblog_api-0.0.1-SNAPSHOT.jar&lt;/java&gt;  
  &lt;/module&gt;  
  &lt;module&gt;  
    &lt;java&gt;fengblog_core-0.0.1-SNAPSHOT.jar&lt;/java&gt;  
  &lt;/module&gt;  
  &lt;module&gt;  
    &lt;web&gt;  
      &lt;web-uri&gt;fengblog_war-0.0.1-SNAPSHOT.war&lt;/web-uri&gt;  
      &lt;context-root&gt;/fengblog_war&lt;/context-root&gt;  
    &lt;/web&gt;  
  &lt;/module&gt;  
&lt;/application&gt;
</code></pre>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>JavaEE</tag>
      </tags>
  </entry>
  <entry>
    <title>从Eclipse转到IDEA的过程</title>
    <url>/2019/02/24/%E4%BB%8EEclipse%E8%BD%AC%E5%88%B0IDEA%E7%9A%84%E8%BF%87%E7%A8%8B/</url>
    <content><![CDATA[<blockquote>
<p>这篇文章会比较乱，因为我不想做太多系列细分，就是单纯地把我从eclipse转到idea的经过写出来而已，公司的项目一直采用的&gt;是eclipse+maven+jboss的环境开发的，版本控制通过svn控制，这年代还用svn做控制确实有点更不上时代了，转的过程有点麻烦，但是最终我还是顺利用上idea，只是目前还不太习惯。想入坑idea很早之前就有这个想法了，eclipse我们公司一直都在用很古老的一个版本，隐藏的bug且不说，时不时的卡顿就够影响效率的了。</p>
</blockquote>
<h2 id="idea的subversion巨坑"><a href="#idea的subversion巨坑" class="headerlink" title="idea的subversion巨坑"></a>idea的subversion巨坑</h2><p>转idea遇到第一个大难题就是svn版本控制的转换，我司采用svn+ssh协议，还是秘钥文件+密码验证的。以前使用的一直是入职就分给我的一个ssh的秘钥文件eclipse专用的，还附带了一个ppk后缀的秘钥文件，但是ppk那个一直没有派上用途。idea的svn用户认证可能存在bug，我和在elipse上做了类似的svn地址和用户+秘钥文件的配置之后一直无法脸上代码仓库，一直无限弹出让我输入密码。搞得我一度想放弃。<br>后来在查了下，ssh+svn协议原则上是先通过ssh登录svn服务端的机器，等于先打通一条数据流通的渠道，然后svn的交互依赖于这条ssh的通道上面。一直依赖我都是直接在eclipse做svn的操作，没有考虑太多，于是我好奇用我的svn账号密码+ppk秘钥文件去登录svn指向ip的服务器，果然成功了，既然能登上去，说明idea只是没有正确通过ssh登录到svn服务器上而已，<em><strong>通过搜索我才知道，原来的ppk文件是putty的专用格式秘钥文件，而openssh一般采用pem，于是刻不容缓，我又查了下ppk转pem的方法，然后顺利转换到pem文件，在idea的preferences-&gt;Version Control-&gt;Subversion-&gt;SSH上面的Private key指向到新的pem秘钥文件，then connect svn server success，注意其他关于svn的设置先还原，保持默认即可。</strong></em></p>
<h2 id="ssh-svn可以通过SSH-tunnel的方式连接"><a href="#ssh-svn可以通过SSH-tunnel的方式连接" class="headerlink" title="ssh+svn可以通过SSH tunnel的方式连接"></a>ssh+svn可以通过SSH tunnel的方式连接</h2><p>之前一定用pem秘钥的方式，有次突然抽风不能用了，于是改用SSH tunnel的方式。Subversion-&gt;SSH，勾选Subversion config，SSH tunnel用默认的：</p>
<p>但是要先记住ssh的pem秘钥通过命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh-add -k /Users/zhanshifeng/Documents/ccssoftDocument/eclipse/zhanshifeng.pem</span><br></pre></td></tr></table></figure>
<p>输入密码然后即可永久记住，测试是否可以登录成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ssh zhanshifeng@199.3.0.10</span><br></pre></td></tr></table></figure>

<h2 id="不复存在的workspace"><a href="#不复存在的workspace" class="headerlink" title="不复存在的workspace"></a>不复存在的workspace</h2><p>使用eclipse的开发者转到idea最不习惯的地方之一就是idea没有eclipse对应的workspace，我们公司是采用maven来控制jar依赖的,<br>通过maven实现多个子工程（project-anything）继承一个父工程(project-parent)，父工程的依赖jar可以被子工程共用。我直接粗暴得将所有模块的根目录直接check out到新的目录（idea-all-project），然后选择idea的import project，因为eclipse不存在workspace的概念，所以我直接import idea-all-project这个跟目录，因为根目录也有一个pom.xml指向了project-parent，project-parent会因为子模块继承了它，它回去自动匹配到所哟偶子模块，只要在引入的时候勾选了项目是由maven做jar管控。<br>其实，很多时候如果存在子模块，或者其他模块不在所引入的目录之下可以通过project structure里面的modules去增减想要的模块。从这种角度上来讲，其实任何一个目录都是一个workspace，也可以说任何一个module都是workspace。</p>
<h2 id="maven管控的企业级j2ee应用架构"><a href="#maven管控的企业级j2ee应用架构" class="headerlink" title="maven管控的企业级j2ee应用架构"></a>maven管控的企业级j2ee应用架构</h2><p>我们的整个应用架构可以这样分级。架构类似采用金字塔三角形管控。工程application-all的pom.xml中引入apache的maven-ear-plugin插件，这个EAR插件主要用于生成Java EE Enterprise Archive (EAR)文件，即将各种组件打包到一起生成一个ear文件。此外，EAR插件也用于生成EAR的部署描述符文件application.xml。<br>application-all通过maven-ear-plugin指向了子模块console-web-all，console-web-all采用了maven-war-plugin插件,maven-war-plugin顾名思义，是将底下所有依赖的资源打包成一个war包，war被ear包含。</p>
<h2 id="在idea中将ear部署到jboss中"><a href="#在idea中将ear部署到jboss中" class="headerlink" title="在idea中将ear部署到jboss中"></a>在idea中将ear部署到jboss中</h2><p>一直依赖我都以为，jboss是启动的时候自动加载他对应的部署目录下面的应用，使用了idea之后，才发现，idea中maven项目是默认将资源部署到maven目录架构对应的target中的。。idea会去先启动jboss，jboss只有启动成功之后，才通过它的EARDeployer，传给部署器一个资源目录，然后jboss加载部署资源还是部署。<br><em><strong>部署ear到jboss的时候有一点要特别注意的。由于我们项目采用ear管控war，所以需要一些额外的配置操作，开发过程中建议部署Artifacts中的exploded，exploded是被分解的意思，翻译成中文我也不知道叫什么合适，总之开发模式采用这个比较好。我还在Project Structure的Artifacts对ear exploded的资源输出目录手动加了个ear后缀，不加应该也没关系，还是我又强迫症，然后在war exploded的资源输出目录手动加了war后缀，还有对资源输出做了一些配置调整，最后成功部署到jboss。</strong></em></p>
<h2 id="不习惯的subservion操作模式"><a href="#不习惯的subservion操作模式" class="headerlink" title="不习惯的subservion操作模式"></a>不习惯的subservion操作模式</h2><p>用惯eclipse的svn插件就知道，eclipse的资源同步功能非常实用，然后idea乍眼一看貌似是没有这个类似的功能的，这让我很抓狂，后来通过摸索找到了可以基本代替之的办法。<br><em><strong>idea底部有个Version Control栏，其tool bar上有个Local Changes，打开这个刷新，可以看到本地改了那些代码，Local Changes旁边的Incoming可以看到别人新提交我没有更新下来的代码，Repository可以看到所有人的操作记录，还可以在Local Changes左边的tool bar对一些文件做一些辅助性的操作，比如搁置，忽略版本控制，还原等操作，实用性可以说五五开吧，虽然还是很不习惯。其他的基本操作基本会无师自通的。</strong></em></p>
<h2 id="强大无比的各种快捷键"><a href="#强大无比的各种快捷键" class="headerlink" title="强大无比的各种快捷键"></a>强大无比的各种快捷键</h2><p>几个自动生成代码的快剪辑区别：</p>
<h2 id="Bookmarks的排序功能"><a href="#Bookmarks的排序功能" class="headerlink" title="Bookmarks的排序功能"></a>Bookmarks的排序功能</h2><p>shift+F11，可以对书签进行上下移动排序，大赞！</p>
<h2 id="输出控制台乱码解决"><a href="#输出控制台乱码解决" class="headerlink" title="输出控制台乱码解决"></a>输出控制台乱码解决</h2><p>在Server的VM options参数中加入以下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Dfile.encoding=UTF-8</span><br></pre></td></tr></table></figure>

<h2 id="代码审计，代码分析，FindBugs-Plugin"><a href="#代码审计，代码分析，FindBugs-Plugin" class="headerlink" title="代码审计，代码分析，FindBugs Plugin"></a>代码审计，代码分析，FindBugs Plugin</h2><h2 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h2><blockquote>
<p>shift+方向怎么改成选中？<br>在vim命令行模式下按v+方向，用这种方式更好。</p>
</blockquote>
]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>沾ibator的光，sql忘得不能再多了</title>
    <url>/2017/04/18/%E6%B2%BEibator%E7%9A%84%E5%85%89%EF%BC%8Csql%E5%BF%98%E5%BE%97%E4%B8%8D%E8%83%BD%E5%86%8D%E5%A4%9A%E4%BA%86/</url>
    <content><![CDATA[<h2 id="单行子查询"><a href="#单行子查询" class="headerlink" title="单行子查询"></a>单行子查询</h2><pre><code>select * from t_mon_task tmt where tmt.bill_id=(select tpt.bill_id from t_pub_task tpt where tpt.task_sn=&#39;anything&#39;);
</code></pre>
<h2 id="多行子查询"><a href="#多行子查询" class="headerlink" title="多行子查询"></a>多行子查询</h2><pre><code>select * from t_mon_task tmt where tmt.bill_id in (select tpt.bill_id from t_pub_task tpt where tpt.task_sn=&#39;anything&#39;);
</code></pre>
<h2 id="多列子查询"><a href="#多列子查询" class="headerlink" title="多列子查询"></a>多列子查询</h2><pre><code>select tmt.deal_desc from t_mon_task tmt where (tmt.bill_id, tmt.task_id) in (select tpt.bill_id,tpt.task_id from t_pub_task tpt where tpt.task_sn=&#39;anything&#39;);
</code></pre>
<h2 id="sql函数"><a href="#sql函数" class="headerlink" title="sql函数"></a>sql函数</h2><pre><code>http://blog.csdn.net/jojo52013145/article/details/6998984
</code></pre>
<h2 id="group-by"><a href="#group-by" class="headerlink" title="group by"></a>group by</h2><blockquote>
<p>个人最为憎恨的地方就是，网上有很多所谓深入讲解sql语法的各种博文，其引用的example中，表用A表、B表或者table1、table2来表示，没有和实际应用场景配合说明，那这样子你还说个**毛啊。</p>
</blockquote>
<p>group by 将结果集进行分组，一般与多配合聚合函数，sum，count，min，max等一起使用。<br>举个简单的例子，数据表记录学生id，课程名称，课程成绩，一个学生多门课程，多条记录。<br>现在想要计算学生的总成绩，需要通过id进行分组，然后里面sum（成绩）就可以计算出总成绩了</p>
<pre><code>select sum(t.成绩) 成绩 from 表 t group by t.成绩
</code></pre>
<p>有时候我们再分组的同时需要查询其他字段，这时候可以采用多字段分组。<br>举个简单的例子，基于上面的例子，现在数据表还有一个字段学期（上学期和下学期）。<br>现在要统计分别每个同学上下成绩的总成绩。</p>
<pre><code>select sum(t.成绩) 成绩, t.学期 学期 from 表 t group by t.成绩, t.学期
</code></pre>
<h2 id="sql-select语句完整的执行顺序"><a href="#sql-select语句完整的执行顺序" class="headerlink" title="sql select语句完整的执行顺序"></a>sql select语句完整的执行顺序</h2><p>1、from子句组装来自不同数据源的数据；<br>2、where子句基于指定的条件对记录行进行筛选；<br>3、group by子句将数据划分为多个分组；<br>4、使用聚集函数进行计算；<br>5、使用having子句筛选分组；<br>6、计算所有的表达式；<br>7、select 的字段；<br>8、使用order by对结果集进行排序。SQL语言不同于其他编程语言的最明显特征是处理代码的顺序。在大多数据库语言中，代码按编码顺序被处理。但在SQL语句中，第一个被处理的子句式FROM，而不是第一出现的SELECT。</p>
<h2 id="内连接-amp-amp-外链接"><a href="#内连接-amp-amp-外链接" class="headerlink" title="内连接 &amp;&amp; 外链接"></a>内连接 &amp;&amp; 外链接</h2><h5 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h5><p>所谓内连接，可以这么理解，还是引用上面学生的例子，现在两个表tb_student(学生表)，tb_exam(成绩表)，两个表用id主键关联，想要一一列出各个学生的成绩sql如下：</p>
<pre><code>select s.id, s.name, e.course_name, e.score from tb_student s inner join tb_exam e on s.id=e.id;
</code></pre>
<blockquote>
<p>未完待续</p>
</blockquote>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>sql</tag>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>linux常用命令与知识点</title>
    <url>/2019/02/26/linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E4%B8%8E%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h2 id="查看所有可执行path"><a href="#查看所有可执行path" class="headerlink" title="查看所有可执行path"></a>查看所有可执行path</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;$PATH&quot;</span><br></pre></td></tr></table></figure>

<h2 id="返回上次所在目录"><a href="#返回上次所在目录" class="headerlink" title="返回上次所在目录"></a>返回上次所在目录</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd -</span><br><span class="line">cd $OLDPWD</span><br></pre></td></tr></table></figure>

<h2 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd - 返回进入此目录之前所在的目录</span><br><span class="line">cd .. 返回上级目录</span><br></pre></td></tr></table></figure>

<h2 id="修改权限"><a href="#修改权限" class="headerlink" title="修改权限"></a>修改权限</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 修改文件夹以及其子文件夹</span><br><span class="line">chmod -R 777 fileName</span><br></pre></td></tr></table></figure>

<h2 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h2><h3 id="cp-omitting-directory"><a href="#cp-omitting-directory" class="headerlink" title="cp: omitting directory"></a>cp: omitting directory</h3><p>增加-r</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp -r ...</span><br></pre></td></tr></table></figure>

<h2 id="find和grep"><a href="#find和grep" class="headerlink" title="find和grep"></a>find和grep</h2><p>find是在系统中搜索符合条件的文件名，grep是在文件中搜索符合条件的字符串。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">find ~/dir -name filename.txt</span><br><span class="line">grep &quot;someStr&quot; filename.txt</span><br><span class="line"># 查询某个文件夹下面大小大于某个值文件</span><br><span class="line">find ~/dir -type f -size +1G</span><br></pre></td></tr></table></figure>
<h2 id="ls-查询目录具体file"><a href="#ls-查询目录具体file" class="headerlink" title="ls 查询目录具体file"></a>ls 查询目录具体file</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 按照时间升序</span><br><span class="line">ls -lrt</span><br><span class="line"># 按照时间降序</span><br><span class="line">ls -lt</span><br></pre></td></tr></table></figure>

<h2 id="ll按时间排序"><a href="#ll按时间排序" class="headerlink" title="ll按时间排序"></a>ll按时间排序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 升序</span><br><span class="line">ll -rt</span><br><span class="line"># 降序</span><br><span class="line">ll -t</span><br></pre></td></tr></table></figure>

<h2 id="ll按大小排序"><a href="#ll按大小排序" class="headerlink" title="ll按大小排序"></a>ll按大小排序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 大小单位按照human-readable</span><br><span class="line">ll -Sh</span><br></pre></td></tr></table></figure>
<h2 id="ln链接命令"><a href="#ln链接命令" class="headerlink" title="ln链接命令"></a>ln链接命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ln -s [源文件] [目标文件]</span><br><span class="line"># -s软链接，不带-s是硬链接，硬链接等于是copy了一份文件，软链接相当于window的快捷方式。</span><br><span class="line"># 硬链接不能对目录使用，删除源文件，硬链接可以正常使用，软连接不可以。</span><br></pre></td></tr></table></figure>
<h2 id="wget命令"><a href="#wget命令" class="headerlink" title="wget命令"></a>wget命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 拉取文件</span><br></pre></td></tr></table></figure>
<h2 id="tar"><a href="#tar" class="headerlink" title="tar"></a>tar</h2><p>tar -zxvf 用于解压  .tar.gz 后缀结尾的</p>
<p>tar -xvf 用于解压   .tar后缀结尾的</p>
<h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建空白文件</span><br><span class="line">touch filename</span><br></pre></td></tr></table></figure>

<h2 id="nohup"><a href="#nohup" class="headerlink" title="nohup"></a>nohup</h2><p>后台不挂断执行，执行某个脚本，并将脚本的执行打印日志追加写入到某个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nohup xxx.sh &gt;&gt; /usr/local/node/output.log 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<p>jboss:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 启动指定部署目录：</span><br><span class="line">nohup ./run.sh -c web38b -b 0.0.0.0  &gt;/dev/null 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>

<blockquote>
<blockquote>
<p>&#x2F;dev&#x2F;null redirects standard output (stdout) to &#x2F;dev&#x2F;null, which discards it.<br>(The &gt;&gt; seems sort of superfluous, since &gt;&gt; means append while &gt; means truncate and write, and either appending to or writing to &#x2F;dev&#x2F;null has the same net effect. I usually just use &gt; for that reason.)<br>2&gt;&amp;1 redirects standard error (2) to standard output (1), which then discards it as well since standard output has already been redirected.</p>
</blockquote>
</blockquote>
<h2 id="更改所有子文件和子目录所有者权限"><a href="#更改所有子文件和子目录所有者权限" class="headerlink" title="更改所有子文件和子目录所有者权限"></a>更改所有子文件和子目录所有者权限</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod -R 777 fileDir</span><br></pre></td></tr></table></figure>

<h2 id="curl"><a href="#curl" class="headerlink" title="curl"></a>curl</h2><p>curl -H “Content-Type:application&#x2F;json” -X POST -d ‘json data’ URL</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -H &quot;Content-Type:application/json&quot; -X POST -d &#x27;&#123;&quot;user&quot;: &quot;admin&quot;, &quot;passwd&quot;:&quot;12345678&quot;&#125;&#x27; http://127.0.0.1:8000/login</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -d &quot;user=admin&amp;passwd=12345678&quot; http://127.0.0.1:8080/login</span><br></pre></td></tr></table></figure>
<p>监控某个网站的网页响应下载时间：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -o /dev/null -s -w ‘%&#123;time_total&#125;’ https://www.fengorz.me</span><br></pre></td></tr></table></figure>
<p>更多用法参考：<a href="https://www.cnblogs.com/taosim/articles/4092572.html">https://www.cnblogs.com/taosim/articles/4092572.html</a></p>
<h3 id="结果格式化"><a href="#结果格式化" class="headerlink" title="结果格式化"></a>结果格式化</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g json</span><br><span class="line">curl -X GET &quot;http://127.0.0.1:9200/kiwi_vocabulary/_search&quot; -s | json</span><br></pre></td></tr></table></figure>

<h2 id="df命令详解（清理磁盘空间）"><a href="#df命令详解（清理磁盘空间）" class="headerlink" title="df命令详解（清理磁盘空间）"></a>df命令详解（清理磁盘空间）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 先列出大文件</span><br><span class="line">du -sh *</span><br></pre></td></tr></table></figure>

<p>whereis<br>which<br>xargs<br><a href="https://blog.csdn.net/wzzfeitian/article/details/40985549">https://blog.csdn.net/wzzfeitian/article/details/40985549</a></p>
<hr>
<p>标准输出重定向<br>标准输出重定向到空，相当于忽略输出</p>
<hr>
<h2 id="查看防火墙，放开端口"><a href="#查看防火墙，放开端口" class="headerlink" title="查看防火墙，放开端口"></a>查看防火墙，放开端口</h2><h2 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h2><h2 id="killall"><a href="#killall" class="headerlink" title="killall"></a>killall</h2><p>结束所有进程</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">killall -9 picName  </span><br></pre></td></tr></table></figure>

<p>##线上日志文件查看</p>
<h3 id="查看文件内容more命令"><a href="#查看文件内容more命令" class="headerlink" title="查看文件内容more命令"></a>查看文件内容more命令</h3><p><a href="https://www.runoob.com/linux/linux-comm-more.html">https://www.runoob.com/linux/linux-comm-more.html</a></p>
<h3 id="less命令"><a href="#less命令" class="headerlink" title="less命令"></a>less命令</h3><p><a href="https://www.runoob.com/linux/linux-comm-less.html">https://www.runoob.com/linux/linux-comm-less.html</a></p>
<h4 id="less搜索"><a href="#less搜索" class="headerlink" title="less搜索"></a>less搜索</h4><p>&#x2F;字符串：向下搜索”字符串”的功能<br>?字符串：向上搜索”字符串”的功能</p>
<p>ps查看进程信息并通过less分页显示:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef | less</span><br></pre></td></tr></table></figure>
<p>历史命令信息分页：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">history|grep cd |less</span><br></pre></td></tr></table></figure>
<p>参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-N 显示每行的行号</span><br><span class="line">/字符串：向下搜索&quot;字符串&quot;的功能</span><br><span class="line">?字符串：向上搜索&quot;字符串&quot;的功能</span><br><span class="line">n：重复前一个搜索（与 / 或 ? 有关）</span><br><span class="line">N：反向重复前一个搜索（与 / 或 ? 有关）</span><br><span class="line">b 向后翻一页</span><br></pre></td></tr></table></figure>

<h2 id="解压war包"><a href="#解压war包" class="headerlink" title="解压war包"></a>解压war包</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 解压到当前目录</span><br><span class="line">jar -xvf</span><br><span class="line"># 解压到指定目录</span><br><span class="line">unzip pay.war -d /home/zookeeper1/test/pay</span><br></pre></td></tr></table></figure>

<h2 id="du"><a href="#du" class="headerlink" title="du"></a>du</h2><p><a href="https://blog.csdn.net/zzldm/article/details/82804557">https://blog.csdn.net/zzldm/article/details/82804557</a></p>
<p>查看对应目录大小</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">du -sh 路径</span><br><span class="line">du -sh 　　　　显示当前目录所占空间大小</span><br><span class="line">df 显示磁盘占用信息</span><br><span class="line">直接df默认一k为单位</span><br><span class="line">df -lh 显示本地系统的占用信息，以K，M，G为单位</span><br></pre></td></tr></table></figure>

<h2 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h2><p>Linux sed 命令是利用脚本来处理文本文件。</p>
<p>sed 可依照脚本的指令来处理、编辑文本文件。</p>
<p>Sed 主要用来自动编辑一个或多个文件、简化对文件的反复操作、编写转换程序等。</p>
<p><a href="https://www.runoob.com/linux/linux-comm-sed.html">https://www.runoob.com/linux/linux-comm-sed.html</a></p>
<h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2><p>从本地复制到远程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">scp local_file remote_username@remote_ip:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_username@remote_ip:remote_file </span><br><span class="line">或者 scp local_file remote_ip:remote_folder </span><br><span class="line">或者 </span><br><span class="line">scp local_file remote_ip:remote_file </span><br></pre></td></tr></table></figure>
<p><a href="https://www.runoob.com/linux/linux-comm-scp.html">https://www.runoob.com/linux/linux-comm-scp.html</a></p>
<h2 id="远程调用shell命令"><a href="#远程调用shell命令" class="headerlink" title="远程调用shell命令"></a>远程调用shell命令</h2><p><a href="https://www.cnblogs.com/ilfmonday/p/ShellRemote.html">https://www.cnblogs.com/ilfmonday/p/ShellRemote.html</a></p>
<h2 id="Linux下如何查看版本信息"><a href="#Linux下如何查看版本信息" class="headerlink" title="Linux下如何查看版本信息"></a>Linux下如何查看版本信息</h2><p>[<a href="https://www.cnblogs.com/williamjie/p/10271945.html]">https://www.cnblogs.com/williamjie/p/10271945.html]</a>(<a href="https://www.cnsnap/">https://www.cnsnap</a> install coreblogs.com&#x2F;williamjie&#x2F;p&#x2F;10271945.html “”)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /etc/os-release</span><br><span class="line">hostnamectl</span><br><span class="line">uname -r</span><br></pre></td></tr></table></figure>

<h2 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h2><p>睡眠一段时间（5秒）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sleep 5s</span><br></pre></td></tr></table></figure>

<h2 id="利用管道kill掉监听端口的进程"><a href="#利用管道kill掉监听端口的进程" class="headerlink" title="利用管道kill掉监听端口的进程"></a>利用管道kill掉监听端口的进程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kill -9 `lsof -i -n -P | grep ? | awk &#x27;&#123;print $2&#125;&#x27;`</span><br></pre></td></tr></table></figure>
<p>将问号换成对应的端口号</p>
<h2 id="tldr"><a href="#tldr" class="headerlink" title="tldr"></a>tldr</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="top-查看内存状态"><a href="#top-查看内存状态" class="headerlink" title="top(查看内存状态)"></a>top(查看内存状态)</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">top -i（不显示任何闲置(Idle)或无用(Zombie)的行程）</span><br><span class="line">cat /proc/meminfo</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/255b54b5445f">https://www.jianshu.com/p/255b54b5445f</a></p>
<h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p>查看日志使用tail是不会显示行号的，如果要具体比对某些行，可以使用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat -n xxx</span><br></pre></td></tr></table></figure>
<p>创建空文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat &gt; filename</span><br></pre></td></tr></table></figure>
<p>将几个文件合并为一个文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat file1 file2 &gt; file</span><br></pre></td></tr></table></figure>
<p>清空文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /dev/null &gt; textfile2</span><br></pre></td></tr></table></figure>

<h2 id="man"><a href="#man" class="headerlink" title="man"></a>man</h2><p>你可以使用<code>man</code>命令来查看各个命令的使用文档，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">man cp</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/HNv4GG.png"></p>
<h2 id="netstat"><a href="#netstat" class="headerlink" title="netstat"></a>netstat</h2><p>查看网络监听状态</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -natp</span><br></pre></td></tr></table></figure>

<h2 id="gt-gt"><a href="#gt-gt" class="headerlink" title="&gt;&gt;"></a>&gt;&gt;</h2><h2 id="公钥ssh登录"><a href="#公钥ssh登录" class="headerlink" title="公钥ssh登录"></a>公钥ssh登录</h2><h2 id="history"><a href="#history" class="headerlink" title="history"></a>history</h2><p>查看某个命令</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">history|grep xxx</span><br></pre></td></tr></table></figure>

<h2 id="tail"><a href="#tail" class="headerlink" title="tail"></a>tail</h2><p>通过行号查看的一些方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 显示行数可以不用n</span><br><span class="line">tail -10 xxx.log</span><br><span class="line"># 查询日志尾部最后10行的日志</span><br><span class="line">tail  -n  10   test.log</span><br><span class="line"># 查询10行之后的所有日志</span><br><span class="line">tail  -n +10   test.log</span><br><span class="line"># 循环实时查看最后1000行记录(最常用的)</span><br><span class="line">tail  -fn 10   test.log</span><br></pre></td></tr></table></figure>
<p>可以只抓取刚刚刷新的指定行数，而不滚动去刷新：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail -q -n 100 /opt/app/nginx-1.19.2/logs/access.log</span><br></pre></td></tr></table></figure>
<p>可以结合grep只实时抓取想要的日志：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail -n 1000 /opt/app/nginx-1.19.2/logs/access.log |grep &#x27;XXX&#x27;</span><br><span class="line">tail -f /opt/app/nginx-1.19.2/logs/access.log |grep &#x27;XXX&#x27;</span><br><span class="line">tail -fn 1000 test.log | grep &#x27;XXX&#x27;</span><br></pre></td></tr></table></figure>
<p>可以结合less一起查看日志：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tail -5000 /opt/app/nginx-1.19.2/logs/access.log |less</span><br></pre></td></tr></table></figure>

<h2 id="crontab"><a href="#crontab" class="headerlink" title="crontab"></a>crontab</h2><h2 id="清空日志"><a href="#清空日志" class="headerlink" title="清空日志"></a>清空日志</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">第一种：cat /dev/null &gt; filename</span><br><span class="line">第二种：: &gt; filename</span><br><span class="line">第三种：&gt; filename</span><br><span class="line">第四种：echo &quot;&quot; &gt; filename</span><br><span class="line">第五种：echo &gt; filename</span><br></pre></td></tr></table></figure>

<h2 id="sh"><a href="#sh" class="headerlink" title="sh"></a>sh</h2><p>可以用sh命令执行脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh xxx.sh</span><br></pre></td></tr></table></figure>

<h2 id="解压缩"><a href="#解压缩" class="headerlink" title="解压缩"></a>解压缩</h2><h3 id="gz"><a href="#gz" class="headerlink" title="gz"></a>gz</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">gzip -d xxx.gz</span><br></pre></td></tr></table></figure>

<h2 id="各个目录作用"><a href="#各个目录作用" class="headerlink" title="各个目录作用"></a>各个目录作用</h2><p>1、&#x2F; 根目录 ——— 所有目录挂在其下<br>2、&#x2F;boot　——— 存放Ubuntu内核和系统启动文件。系统启动时这些文件先被装载。<br>3、&#x2F;etc　——— 系统的配置文件目录。密码文件、设置网卡信息、环境变量的设置等都在此目录中，许多网络配置文件也在其中。<br>4、&#x2F;lib ——— 根文件系统目录下程序和核心模块的共享库。这个目录里存放着系统最基本的动态链接共享库，类似于Windows下的system32目录，几乎所有的应用程序都需要用到这些共享库。<br>5、&#x2F;media ——— 主要用于挂载多媒体设备。ubuntu系统自动挂载的光驱、usb设备，存放临时读入的文件。<br>6、&#x2F;proc ——— 这个目录是系统内存的映射，我们可以直接访问这个目录来获取系统信息。也就是说，这个目录的内容不在硬盘上而是在内存里。<br>7、&#x2F;sbin 　 ——— s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序，如系统管理、目录查询等关键命令文件。<br>8、&#x2F;tmp ——— 这个目录是用来存放一些临时文件的，所有用户对此目录都有读写权限。<br>9、&#x2F;home　 ——— 用户的主目录。下面是自己定义的用户名的文件夹。每个用户的设置文件，用户的桌面文件夹，还有用户的数据都放在这里。<br>10、&#x2F;mnt 　 ——— 此目录主要是作为挂载点使用。通常包括系统引导后被挂载的文件系统的挂载点。如挂载Windows下的某个分区。<br>11、&#x2F;root ——— 系统管理员（超级用户），即根用户的主目录。<br>12、&#x2F;srv　 ——— 存储系统提供的服务数据。<br>13、&#x2F;usr　——— 包括与系统用户直接有关的文件和目录。<br>&#x2F;usr&#x2F;X11R6 　　 存放X-Windows的目录；<br>&#x2F;usr&#x2F;games 　　存放着XteamLinux自带的小游戏；<br>&#x2F;usr&#x2F;bin 　　　 用户和管理员的标准命令；<br>&#x2F;usr&#x2F;sbin 　　　　存放root超级用户使用的管理程序；<br>&#x2F;usr&#x2F;doc 　　　　 Linux技术文档；<br>&#x2F;usr&#x2F;include　　　来存放Linux下开发和编译应用程序所需要的头文件，for c 或者c++；<br>&#x2F;usr&#x2F;lib 　　　　 应用程序和程序包的连接库；<br>&#x2F;usr&#x2F;local　　　　 系统管理员安装的应用程序目录；<br>&#x2F;usr&#x2F;man 　　　　帮助文档所在的目录；<br>&#x2F;usr&#x2F;src　　　　　Linux开放的源代码；<br>&#x2F;usr&#x2F;share　　 用于存放一些共享的数据，比如音乐文件或者图标等等<br>14、&#x2F;var 　 ——— 用于存放很多不断变化的文件，例如日志文件等。包含了日志文件、计划性任务和邮件等内容。<br>&#x2F;var&#x2F;cache 应用程序缓存目录；<br>&#x2F;var&#x2F;crash 系统错误信息；<br>&#x2F;var&#x2F;games 游戏数据；<br>&#x2F;var&#x2F;log 日志文件；<br>&#x2F;var&#x2F;mail 电子邮件；<br>&#x2F;var&#x2F;tmp 临时文件目录；<br>15、&#x2F;bin 　———bin是binary的缩写。这个目录沿袭了UNIX系统的结构，存放着使用者最经常使用的命令。例如cp、ls、cat，等等。<br>————————————————<br>版权声明：本文为CSDN博主「王立平的博客」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_37131111/article/details/82082630">https://blog.csdn.net/qq_37131111/article/details/82082630</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle系列之触发器</title>
    <url>/2019/03/04/oracle%E7%B3%BB%E5%88%97%E4%B9%8B%E8%A7%A6%E5%8F%91%E5%99%A8/</url>
    <content><![CDATA[<h2 id="什么是触发器"><a href="#什么是触发器" class="headerlink" title="什么是触发器"></a>什么是触发器</h2><p>触发器是一个特殊的存储过程，是一个与表相关联的，存储的PL&#x2F;SQL程序，每当一个特定的数据操作语句（insert，update，delete）在指定的表上发出时，Oracle自动地执行触发器中定义的语句序列。</p>
<h2 id="触发器的语法"><a href="#触发器的语法" class="headerlink" title="触发器的语法"></a>触发器的语法</h2><h4 id="如何创建触发器"><a href="#如何创建触发器" class="headerlink" title="如何创建触发器"></a>如何创建触发器</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--Print ’insert success‘ after insert record into the table.</span><br><span class="line">create [or replace] trigger trigger_name </span><br><span class="line">&#123;after|before&#125; &#123;insert|delete|update|of row_name&#125;</span><br><span class="line">on table_name</span><br><span class="line">[for each row [when(条件)]]</span><br><span class="line">declare</span><br><span class="line">begin</span><br><span class="line">    dbms_output.put_line(&#x27;insert success!&#x27;);</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<h2 id="触发器的类型"><a href="#触发器的类型" class="headerlink" title="触发器的类型"></a>触发器的类型</h2><h4 id="语句级触发器和行级触发器"><a href="#语句级触发器和行级触发器" class="headerlink" title="语句级触发器和行级触发器"></a>语句级触发器和行级触发器</h4><p>语句级没有for each row，行级反之。<br>语句级触发器：在指定的操作语句操作之前或之后执行一次，不管这条语句影响了多少行。<br>行级触发器：触发语句作用的每条记录都被触发。在其中使用:old和:new伪记录变量，识别值的状态。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into emp10 select * from emp where depno=10;</span><br><span class="line">-- 3 rows of records</span><br><span class="line">-- 语句级触发器：针对的是表，只执行一次。</span><br><span class="line">-- 行级触发器：针对的是行，执行了3次。</span><br></pre></td></tr></table></figure>
<h2 id="触发器的具体应用场景"><a href="#触发器的具体应用场景" class="headerlink" title="触发器的具体应用场景"></a>触发器的具体应用场景</h2><h4 id="复杂的安全性检查"><a href="#复杂的安全性检查" class="headerlink" title="复杂的安全性检查"></a>复杂的安全性检查</h4><blockquote>
<p>禁止在非工作时间插入新员工</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--周末:to_char(sysdate, &#x27;day&#x27;) in (&#x27;星期六&#x27;, &#x27;星期日&#x27;)</span><br><span class="line">--上班前，下班后:to_number(to_char(sysdate, &#x27;hh24&#x27;)) not between 9 and 18</span><br><span class="line"></span><br><span class="line">create or replace trigger security_emp</span><br><span class="line">before insert</span><br><span class="line">on emp</span><br><span class="line">-- declare 程序中不使用变量的话，这块可以不写</span><br><span class="line">begin</span><br><span class="line">    if to_char(sysdate, &#x27;day&#x27;) in (&#x27;星期六&#x27;, &#x27;星期日&#x27;) or </span><br><span class="line">        to_number(to_char(sysdate, &#x27;hh24&#x27;)) not between 9 and 18 then</span><br><span class="line">        --禁止insert</span><br><span class="line">        raise_application_error(-20001, &#x27;禁止在非工作时间插入新员工&#x27;);</span><br><span class="line">    end if;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<h4 id="数据确认"><a href="#数据确认" class="headerlink" title="数据确认"></a>数据确认</h4><blockquote>
<p>涨工资不能越涨越少</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--:old和:new 代表同一条记录，前者代表操作之前的值，后者反之。</span><br><span class="line">create or replace trigger check_salary</span><br><span class="line">before update</span><br><span class="line">on emp</span><br><span class="line">for each row</span><br><span class="line">begin</span><br><span class="line">    if :new.salary &lt; :old.salary then</span><br><span class="line">        raise_application_error(-20002, &#x27;涨薪水不带这么玩的,涨前&#x27;||:old.salary||&#x27;涨后&#x27;||:new.salary);    </span><br><span class="line">    end if;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<h4 id="实现审计功能"><a href="#实现审计功能" class="headerlink" title="实现审计功能"></a>实现审计功能</h4><blockquote>
<p>给员工涨工资，当涨后的薪水超过6000块的时候，审计该员工的信息</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--创建表，用于保存审计信息</span><br><span class="line">create table audit_emp</span><br><span class="line">(</span><br><span class="line">infomation varchar2(200);</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">create or replace trigger do_audit_emp_salary</span><br><span class="line">after update</span><br><span class="line">on emp</span><br><span class="line">for each row</span><br><span class="line">begin</span><br><span class="line">    if :new.salary &gt; 6000 then</span><br><span class="line">        insert into audit_emp values(&#x27;员工信息:&#x27;||:new.somerows);</span><br><span class="line">    end if;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>
<h3 id="完成数据的备份和同步"><a href="#完成数据的备份和同步" class="headerlink" title="完成数据的备份和同步"></a>完成数据的备份和同步</h3><p>给员工涨薪水之后，自动备份新工资到备份表</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create or replace trigger sync_salary</span><br><span class="line">after update</span><br><span class="line">on emp</span><br><span class="line">for earch row</span><br><span class="line">begin</span><br><span class="line">    update emp_bak set sal=:new.sal where empno=:new.empno;</span><br><span class="line">end;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>vim的使用技巧</title>
    <url>/2019/03/07/vim%E7%9A%84%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h1 id="TodoItem"><a href="#TodoItem" class="headerlink" title="TodoItem"></a>TodoItem</h1><h2 id="异常情况处理-todo"><a href="#异常情况处理-todo" class="headerlink" title="异常情况处理 todo"></a>异常情况处理 todo</h2><p>W10: Warning: Changing a readonly file</p>
<h1 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h1><h2 id="Hotkeys-In-Normal-Mode"><a href="#Hotkeys-In-Normal-Mode" class="headerlink" title="Hotkeys In Normal Mode"></a>Hotkeys In Normal Mode</h2><h4 id="Moving-移动"><a href="#Moving-移动" class="headerlink" title="Moving(移动)"></a>Moving(移动)</h4><table>
<thead>
<tr>
<th>key</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>移动到行首</td>
</tr>
<tr>
<td>$</td>
<td>移动到行尾</td>
</tr>
<tr>
<td>G</td>
<td>移动到最后一行</td>
</tr>
<tr>
<td>1G</td>
<td>移动到第一行</td>
</tr>
<tr>
<td>dG</td>
<td>从当前行删除到最后一行</td>
</tr>
<tr>
<td>v+hjkl</td>
<td>从当前位置开始移动并选中</td>
</tr>
<tr>
<td>V+jk</td>
<td>从当前行开始移动并选中</td>
</tr>
<tr>
<td>shift+&lt;or shift+&gt;</td>
<td>选择之后可以在命令行模式将代码进行左右移动。</td>
</tr>
</tbody></table>
<h4 id="Editing-编辑"><a href="#Editing-编辑" class="headerlink" title="Editing(编辑)"></a>Editing(编辑)</h4><table>
<thead>
<tr>
<th>key</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>dd</td>
<td>删除当前行</td>
</tr>
<tr>
<td>d1G</td>
<td>从当前行删除到第一行</td>
</tr>
<tr>
<td>Ndd</td>
<td>删除光标以下的N行</td>
</tr>
<tr>
<td>d$</td>
<td>删除光标所在到行尾</td>
</tr>
<tr>
<td>d0</td>
<td>删除光标所在到行首</td>
</tr>
<tr>
<td>daw</td>
<td>删除光标所在单词</td>
</tr>
</tbody></table>
<h4 id="View-视图"><a href="#View-视图" class="headerlink" title="View(视图)"></a>View(视图)</h4><table>
<thead>
<tr>
<th>key</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>^+w s</td>
<td>上下分割当前打开的文件。</td>
</tr>
<tr>
<td>^+w v</td>
<td>左右分割当前打开的文件。</td>
</tr>
<tr>
<td>^+w (h,l,j,k)</td>
<td>移动光标到不同的分屏。</td>
</tr>
<tr>
<td>^+w c</td>
<td>关闭当前窗口。</td>
</tr>
</tbody></table>
<h2 id="Commands-In-command-Mode"><a href="#Commands-In-command-Mode" class="headerlink" title="Commands In command Mode"></a>Commands In command Mode</h2><h4 id="search-搜索"><a href="#search-搜索" class="headerlink" title="search(搜索)"></a>search(搜索)</h4><table>
<thead>
<tr>
<th>command</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>:&#x2F; or ?</td>
<td>命令行模式输入要搜索的字符串,查看下一个匹配按n,查看上一个匹配按N</td>
</tr>
</tbody></table>
<h4 id="Moving-移动-1"><a href="#Moving-移动-1" class="headerlink" title="Moving(移动)"></a>Moving(移动)</h4><table>
<thead>
<tr>
<th>command</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>:1000</td>
<td>快速移动到第1000行，在命令行模式下</td>
</tr>
<tr>
<td>:m+</td>
<td>将当前行向下移动</td>
</tr>
<tr>
<td>:m+n</td>
<td>将当前行向下移动n行,最后一行使用$</td>
</tr>
<tr>
<td>:m-</td>
<td>将当前行向上移动</td>
</tr>
<tr>
<td>:m-n</td>
<td>将当前行向上移动n行,第一行使用0</td>
</tr>
<tr>
<td>:$</td>
<td>跳到文件最后一行</td>
</tr>
<tr>
<td>:0</td>
<td>跳到文件第一行</td>
</tr>
</tbody></table>
<h2 id="批量替换"><a href="#批量替换" class="headerlink" title="批量替换"></a>批量替换</h2><p><a href="https://www.cnblogs.com/configure/p/10233565.html">https://www.cnblogs.com/configure/p/10233565.html</a></p>
<h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>命令行模式搜索以”socket”开头以5结尾的字符串</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/socket.*5$</span><br></pre></td></tr></table></figure>

<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><h3 id="中文乱码"><a href="#中文乱码" class="headerlink" title="中文乱码"></a>中文乱码</h3><p>每次打开 vim 后，输入<br>:set encoding&#x3D;utf-8</p>
<p>或者，在当前用户目录下，新建 .vimrc文件，在里面添加<br>:set encoding&#x3D;utf-8</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>vim</tag>
        <tag>mac</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle系列之高级查询</title>
    <url>/2019/03/07/oracle%E7%B3%BB%E5%88%97%E4%B9%8B%E9%AB%98%E7%BA%A7%E6%9F%A5%E8%AF%A2/</url>
    <content><![CDATA[<h2 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h2><h4 id="常用分组函数"><a href="#常用分组函数" class="headerlink" title="常用分组函数"></a>常用分组函数</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- avg,sum,min,max,count,wm_concat</span><br><span class="line">select avg(sal),sum(sal),min(sal),max(sal),count(sal) from emp;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*),count(comm) from emp;</span><br></pre></td></tr></table></figure>
<p><em><strong>上面二个值不一样，是因为分组函数会自动忽略空值，会自动忽略空值。NVL函数可以使分组函数无法忽略空值，例如下面的sql：</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select count(*),count(nvl(comm, 0)) from emp;</span><br></pre></td></tr></table></figure>
<h4 id="group-by语句"><a href="#group-by语句" class="headerlink" title="group by语句"></a>group by语句</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select column, from table_name [where condition] [group by group_by_condition] [having group_condition] [order by column];</span><br><span class="line">-- 平均工资</span><br><span class="line">select deptno,avg(sal) from emp group by deptno;</span><br></pre></td></tr></table></figure>
<p><em><strong>错误写法：</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select a,b,avg(x) from emp group by a;</span><br><span class="line">-- b必须出现在group by 后面。</span><br></pre></td></tr></table></figure>
<p><em><strong>注意：在select列表中所有未包含在组函数中的列都应该包含在group by子句中；包含在group by子句中的列不必包含在select列表中。</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 按照部门，不同职位，统计员工的工资总额</span><br><span class="line">select deptno,job,sum(sal) from emp group by deptno,job order by deptno;</span><br><span class="line">-- 分组按照group by子句列的先后顺序。</span><br></pre></td></tr></table></figure>
<h4 id="过滤分组-having子句语法"><a href="#过滤分组-having子句语法" class="headerlink" title="过滤分组,having子句语法"></a>过滤分组,having子句语法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 求平均工资大于2000的部门</span><br><span class="line">select deptno,avg(sal) from emp group by deptno having avg(sal) &gt; 2000;</span><br></pre></td></tr></table></figure>
<p><em><strong>注意：where子句不能使用组函数，having才可以。没有组函数的时候，条件写在二者之后都是可以的，但是从sql优化的角度上，where的效率会更加高。</strong></em></p>
<blockquote>
<p>having是先分组，后过滤。where是先过滤，后分组。</p>
</blockquote>
<h4 id="分组函数的嵌套"><a href="#分组函数的嵌套" class="headerlink" title="分组函数的嵌套"></a>分组函数的嵌套</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 求部门平均工资的最大值</span><br><span class="line">select max(avg(sal)) from emp group by deptno;</span><br></pre></td></tr></table></figure>

<h4 id="group-by-的增强-rollup-a-b"><a href="#group-by-的增强-rollup-a-b" class="headerlink" title="group by 的增强 rollup(a,b)"></a>group by 的增强 rollup(a,b)</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">group by rollup(a,b)</span><br><span class="line">-- 等价于</span><br><span class="line">group by a,b </span><br><span class="line">+</span><br><span class="line">group by a </span><br><span class="line">+</span><br><span class="line">group by null(不分组)</span><br></pre></td></tr></table></figure>
<p><em><strong>rollup用于报表的生成非常有用</strong></em></p>
<blockquote>
<p>break on deptno skip 2（相同的部门号只显示一次，不同的部门号跳过2行）<br>select deptno,job,sum(sal) from emp group by rollup(deptno, job);–生成升序报表</p>
</blockquote>
<h4 id="order-by-排序"><a href="#order-by-排序" class="headerlink" title="order by 排序"></a>order by 排序</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select deptno,avg(sal) 平均工资 from emp group by deptno order by 平均工资</span><br></pre></td></tr></table></figure>
<p><em><strong>上面平均工资也可以用2来代替，2代表select出来的列的序号。</strong></em></p>
<h2 id="多表查询"><a href="#多表查询" class="headerlink" title="多表查询"></a>多表查询</h2><h4 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h4><blockquote>
<p>假定有部门表dept和员工表emp</p>
</blockquote>
<p>笛卡尔全集的列数&#x3D;dept行数*emp行数.<br>sql拼写的时候一定要注意避免错误的笛卡尔全集。</p>
<h4 id="等值连接"><a href="#等值连接" class="headerlink" title="等值连接"></a>等值连接</h4><blockquote>
<p>连接条件中如果是等于号，那就是等值连接。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询二个表的员工信息</span><br><span class="line">select ... from emp e, dept d where e.deptno=d.deptno</span><br></pre></td></tr></table></figure>
<h4 id="不等值连接"><a href="#不等值连接" class="headerlink" title="不等值连接"></a>不等值连接</h4><blockquote>
<p>连接条件中如果不是等于号，那就是等值连接。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- salgrade薪水级别表</span><br><span class="line">select ... from emp e, salgrade s where e.sal between s.lowsal and s.highsal</span><br><span class="line">-- 使用between一定要注意小的在前大的在后</span><br></pre></td></tr></table></figure>
<h4 id="外链接"><a href="#外链接" class="headerlink" title="外链接"></a>外链接</h4><blockquote>
<p>核心：通过外链接，把对于连接条件不成立的记录，仍然包含在最后的结果中。<br>左外连接：当连接条件不成立的时候，等号左边的表仍然被包含。<br>右外链接：当连接条件不成立的时候，等号右边的表仍然被包含。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 右外链接</span><br><span class="line">select ... from emp e, dept d where e.deptno(+)=d.deptno group by ...;</span><br><span class="line">-- 左外链接反之</span><br></pre></td></tr></table></figure>
<h4 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h4><blockquote>
<p>通过别名，将同一张表视为多张表</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询员工的老板，mgr员工老板的empno</span><br><span class="line">select ... from emp a, emp b where a.mgr=b.eepno;</span><br></pre></td></tr></table></figure>
<h5 id="自连接存在的问题"><a href="#自连接存在的问题" class="headerlink" title="自连接存在的问题"></a>自连接存在的问题</h5><blockquote>
<p>根据笛卡尔积，n个别名表，自连接的总行数是表记录的n次方，所以自连接不适合操作大表，解决方法：层次查询。</p>
</blockquote>
<h4 id="层次查询"><a href="#层次查询" class="headerlink" title="层次查询"></a>层次查询</h4><blockquote>
<p>单表查询，树结构查询</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 管理者和下属可以理解为树结构关系，emp.mgr指向管理者emp.empno</span><br><span class="line">select level, empno, ename, sal, mgr from emp connect by prior empno=mgr</span><br><span class="line">start with mgr is null order by 1;</span><br><span class="line">-- level是一个伪劣，相当于树结构的层次，越高层越小，从1开始，order by 1代表根据level排序</span><br></pre></td></tr></table></figure>

<blockquote>
<p>自连接优点是直观，缺点是不适合操作大表。<br>层次查询有点是单表查询，不会产生笛卡尔积，缺点是结果不直观，可能不满足某些应用场景。</p>
</blockquote>
<h2 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h2><blockquote>
<p>子查询说白了只是select语句的嵌套。</p>
</blockquote>
<h4 id="子查询要注意的10个问题"><a href="#子查询要注意的10个问题" class="headerlink" title="子查询要注意的10个问题"></a>子查询要注意的10个问题</h4><ol>
<li>语法的小括号不可缺少</li>
<li>书写风格，让语句方便阅读</li>
<li>可以使用子查询的位置：where，select，having，from</li>
<li>不可以使用子查询的位置：group by</li>
<li>强调：from后面的子查询</li>
<li>主查询和子查询可以不是同一张表</li>
<li>一般不在子查询中使用排序，但在top-n分析问题中，必须对子查询排序</li>
<li>一般先执行子查询，再执行主查询；但是相关子查询例外</li>
<li>单行子查询只能使用单行操作符；多行子查询只能使用多行操作符</li>
<li>注意：子查询中是null值问题</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- top-n分析问题</span><br><span class="line">-- 找到员工表中工资最高的前三名</span><br><span class="line">-- rownum：行号，伪列</span><br><span class="line"></span><br><span class="line">--以下是错误写法：</span><br><span class="line">select rownum, empno, ename, sal from emp where rownum&lt;=3 order by sal desc;</span><br></pre></td></tr></table></figure>
<p><em><strong>rownum 行号永远按照默认的顺序生成，行号只能使用&lt;, &lt;&#x3D;; 不能使用&gt;, &gt;&#x3D;。默认顺序是指select不加排序条件查出来的顺序，使用rownum排序是误区。</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 正确的写法</span><br><span class="line">select rownum, empno, ename, sal from（select * from emp order by sal desc）where rownum&lt;=3;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--一般先执行子查询，再执行主查询；但是相关子查询例外,例如下面的相关子查询（子查询要依赖于父查询）。</span><br><span class="line">-- 找到员工表中薪水大于本部门平均薪水的员工</span><br><span class="line">select empno，ename，sal, (select avg(e2.sal) from emp e where e2.dept=e1.dept) avgsal from emp e where e.sal &gt; (select avg(e2.sal) from emp e where e2.dept=e1.dept);</span><br><span class="line">以上就是相关子查询实例，</span><br></pre></td></tr></table></figure>


<h4 id="子查询的类型"><a href="#子查询的类型" class="headerlink" title="子查询的类型"></a>子查询的类型</h4><blockquote>
<p>子查询分单行子查询和多行子查询。<br>多行操作符：in，any，all</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查询工资大于部门号30的任意一个员工工资的员工</span><br><span class="line">select * from emp e where e.sal &gt; any (select sal from emp where deptno=30);</span><br><span class="line">-- 或者使用min函数</span><br><span class="line">select * from emp e where e.sal &gt; (select min(sal) from emp where deptno=30);</span><br><span class="line">查询工资大于部门号30所有人工资的员工</span><br><span class="line">select * from emp e where e.sal &gt; any (select sal from emp where deptno=30);</span><br><span class="line">-- 同样可以用max函数</span><br><span class="line">-- 查询不是老板的员工</span><br><span class="line">-- 下面是错误写法：</span><br><span class="line">select * from emp where empno not in (select mgr from emp);--空结果</span><br><span class="line">--原因：a not in (10,20,null) == a!=10 and a!=20 and a!=null  最后一个条件永远不假</span><br><span class="line">-- 正确写法</span><br><span class="line">select * from emp where empno not in (select mgr from emp where mgr is not null);</span><br></pre></td></tr></table></figure>

<h2 id="综合示例"><a href="#综合示例" class="headerlink" title="综合示例"></a>综合示例</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 分页案例 查询排序后的5到8条记录</span><br><span class="line">select * from (select rownum r,* from (select * from emp order by desc) e1  where rownum &lt;= 8) e2 where e2.r &gt; 5;</span><br><span class="line"></span><br><span class="line">-- 按照入职年份查询员工的人数, 例如1981</span><br><span class="line">select count(*) total, sum(decode(to_char(hiredate, &#x27;YYYY&#x27;), &#x27;1981&#x27;, 1, 0)) &#x27;1981&#x27; from emp;</span><br><span class="line">select (select count(*) from emp) total, (select count(*) from emp where ...) &#x27;1981&#x27; fro dual;</span><br></pre></td></tr></table></figure>
<p><em><strong>相关子查询效率正常比多表查询快</strong></em></p>
<h2 id="Extra-notes"><a href="#Extra-notes" class="headerlink" title="Extra notes"></a>Extra notes</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- desc emp</span><br><span class="line">-- show user</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>Git汇总</title>
    <url>/2019/03/20/Git%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<blockquote>
<p>自己总结的思维导图<a href="http://www.xmind.net/m/gtkJBV">Git</a></p>
</blockquote>
<h1 id="git基本命令"><a href="#git基本命令" class="headerlink" title="git基本命令"></a>git基本命令</h1><p>最近打算搞个web应用，练习一下新的技术栈，所以在github建了个私库</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">clone https://github.com/coding-by-feng/keep-yourself.git</span><br><span class="line">## 查看当前分支有哪些修改</span><br><span class="line">vi README.md</span><br><span class="line">git status</span><br><span class="line">## 提交为空，但是存在尚未跟踪的文件（使用 &quot;git add&quot; 建立跟踪）</span><br><span class="line">git add README.md</span><br><span class="line">## 提交 执行之后需要写入备注 </span><br><span class="line">git commit -m &quot;remark&quot;</span><br><span class="line">## 再次执行git status 提示无文件要提交</span><br><span class="line">## git push 推送本地文件到github</span><br><span class="line">## 回到过去</span><br><span class="line">git log</span><br><span class="line">git reset --hard XXXXX（当前版本指针）</span><br><span class="line">## git reflog找回被重置冲刷掉之前的log，防止错误重置。</span><br><span class="line">## 建立里程碑</span><br><span class="line">## 在github new Releases.</span><br></pre></td></tr></table></figure>
<h2 id="git-pull和git-fetch"><a href="#git-pull和git-fetch" class="headerlink" title="git pull和git fetch"></a>git pull和git fetch</h2><p>git pull<br>如果需要取回origin主机的erp01分支与本地的master分支合并，则写为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull origin erp01:master</span><br></pre></td></tr></table></figure>
<p>上面这句命令的意思相当于取回origin&#x2F;erp01分支的代码在与当前的分支合并。<br>如果本地分支和远程分支之间建立了一种追踪的关系，那么我们git pull的时候就可以省略远程的分支名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull origing</span><br></pre></td></tr></table></figure>
<p>上面命令表明本地分支自动与队对应的origin主机追踪分支进行合并。<br>git 允许手动建立追踪关系:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch --set-upstream master origin/erp01</span><br></pre></td></tr></table></figure>

<p>git fetch</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git fetch &lt;远程主机名&gt;（origin）&lt;分支名&gt;</span><br></pre></td></tr></table></figure>
<p>如果想要取回特定分支的更新就可以指定分支名；<br>所取回的更新，在本地主机上要用“远程主机名&#x2F;分支名”进行读取。比如origin主机的erp01，就要用origin&#x2F;erp01读取。<br>接下来可以用git branch -r命令查看远程分支，如果用到 -a选项，则表明查看所有的分支；<br>如果你需要合并分支，就可以用merge或rebase：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ git merge origin/erp01</span><br><span class="line">#或</span><br><span class="line">$ git rebase origin/erp01</span><br></pre></td></tr></table></figure>
<p>git pull和git fetch区别<br>这两个命令的主要区别在与：git pull是拉下更新后就自动合并本地分支，而git fetch是先吧更新拉下来，在用merge或rebase进行合并。</p>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git tag（查看标签）</span><br><span class="line">git tag name（创建标签）</span><br><span class="line">git tag -a name -m &quot;remark&quot;（指定备注创建标签）</span><br><span class="line">git tag -d name（删除标签）</span><br><span class="line">git push origin name（发布标签）</span><br></pre></td></tr></table></figure>

<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><p><a href="https://www.jianshu.com/p/2e162b544878">https://www.jianshu.com/p/2e162b544878</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git branch test1</span><br><span class="line">git branch (查看分支)</span><br><span class="line">git checkout test1 (切换分支)</span><br><span class="line">git checkout master</span><br><span class="line">git merge master（合并分支）</span><br><span class="line">git branch -d test1（删除分支）</span><br></pre></td></tr></table></figure>
<h2 id="强制更新本地和强制提交覆盖"><a href="#强制更新本地和强制提交覆盖" class="headerlink" title="强制更新本地和强制提交覆盖"></a>强制更新本地和强制提交覆盖</h2><p><a href="https://www.cnblogs.com/boundless-sky/p/10842700.html">https://www.cnblogs.com/boundless-sky/p/10842700.html</a></p>
<h2 id="git-commit回撤"><a href="#git-commit回撤" class="headerlink" title="git commit回撤"></a>git commit回撤</h2><p><a href="https://www.jianshu.com/p/c2ec5f06cf1a">Git Reset 三种模式</a></p>
<h1 id="Problem-Solution"><a href="#Problem-Solution" class="headerlink" title="Problem Solution"></a>Problem Solution</h1><h2 id="git仓库迁移（从github上拉下来的代码修改后push到自己的仓库）"><a href="#git仓库迁移（从github上拉下来的代码修改后push到自己的仓库）" class="headerlink" title="git仓库迁移（从github上拉下来的代码修改后push到自己的仓库）"></a>git仓库迁移（从github上拉下来的代码修改后push到自己的仓库）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -rf .git        //删除.git</span><br><span class="line"></span><br><span class="line">git init</span><br><span class="line"></span><br><span class="line">git add .</span><br><span class="line"></span><br><span class="line">git commit -m &quot;desc&quot;</span><br><span class="line"></span><br><span class="line">git remote add origin https://github.com/xxxxxxx</span><br><span class="line"></span><br><span class="line">git push -u origin master</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「LynnWonderLu」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/lynnwonder6/article/details/91892563</span><br></pre></td></tr></table></figure>
<h2 id="解决版本冲突"><a href="#解决版本冲突" class="headerlink" title="解决版本冲突"></a>解决版本冲突</h2><h2 id="删除本地缓存（改变目录或文件成未track状态）"><a href="#删除本地缓存（改变目录或文件成未track状态）" class="headerlink" title="删除本地缓存（改变目录或文件成未track状态）"></a>删除本地缓存（改变目录或文件成未track状态）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 目录的所有子目录和文件</span><br><span class="line">git rm --cached * </span><br></pre></td></tr></table></figure>
<h2 id="The-following-paths-are-ignored-by-one-of-your-gitignore-files"><a href="#The-following-paths-are-ignored-by-one-of-your-gitignore-files" class="headerlink" title="The following paths are ignored by one of your .gitignore files:"></a>The following paths are ignored by one of your .gitignore files:</h2><p>git add 时如果报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">The following paths are ignored by one of your .gitignore files:</span><br><span class="line">kiwi-common/kiwi-common-api/src/main/resources</span><br><span class="line">Use -f if you really want to add them.</span><br></pre></td></tr></table></figure>
<p>可以强制加入版本控制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git add -f  xxx.文件</span><br></pre></td></tr></table></figure>
<p>或者在.gitignore删除对应的非版本控制配置</p>
<h2 id="github项目不记录贡献度，格子不绿"><a href="#github项目不记录贡献度，格子不绿" class="headerlink" title="github项目不记录贡献度，格子不绿"></a>github项目不记录贡献度，格子不绿</h2><p><a href="https://www.jianshu.com/p/408efb964213">https://www.jianshu.com/p/408efb964213</a></p>
<h2 id="Push-failed-Invocation-failed-Server-returned-invalid-Response-java-lang-RuntimeException-Invocation-failed-Server-returned-invalid-Response-at"><a href="#Push-failed-Invocation-failed-Server-returned-invalid-Response-java-lang-RuntimeException-Invocation-failed-Server-returned-invalid-Response-at" class="headerlink" title="Push failed Invocation failed Server returned invalid Response. java.lang.RuntimeException: Invocation failed Server returned invalid Response. at"></a>Push failed Invocation failed Server returned invalid Response. java.lang.RuntimeException: Invocation failed Server returned invalid Response. at</h2><p>JetBrains系列软件git提交失败，解决方案：<br><a href="https://zhuanlan.zhihu.com/p/136365170">https://zhuanlan.zhihu.com/p/136365170</a></p>
<h2 id="解决git-pull-x2F-push每次都需要输入密码问题"><a href="#解决git-pull-x2F-push每次都需要输入密码问题" class="headerlink" title="解决git pull&#x2F;push每次都需要输入密码问题"></a>解决git pull&#x2F;push每次都需要输入密码问题</h2><p><a href="https://blog.csdn.net/m0_37633370/article/details/90439113">https://blog.csdn.net/m0_37633370&#x2F;article&#x2F;details&#x2F;90439113</a></p>
<h2 id="解决hexo-tag或者categories大小写不区分的问题"><a href="#解决hexo-tag或者categories大小写不区分的问题" class="headerlink" title="解决hexo tag或者categories大小写不区分的问题"></a>解决hexo tag或者categories大小写不区分的问题</h2><ul>
<li>打开.git目录下的config文件并修改ignorecase &#x3D; true 为 ignorecase &#x3D; false</li>
<li>将.deploy_git文件夹下面的内容删掉<ul>
<li>git rm -rf *</li>
<li>git commit -m ‘clean all file’</li>
<li>git push</li>
</ul>
</li>
<li>重新编译push<ul>
<li>cd ..</li>
<li>hexo clean</li>
<li>hexo g -d</li>
</ul>
</li>
</ul>
<p>如果方法失效可以将tag随便改个名字重复上面步骤，然后改回来再重复一遍即可。</p>
<h2 id="解决代码冲突"><a href="#解决代码冲突" class="headerlink" title="解决代码冲突"></a>解决代码冲突</h2><p>Your local changes would be overwritten by merge. Commit, stash or revert them to proceed.</p>
<h2 id="Idea分支切换local-changes存放在shelf"><a href="#Idea分支切换local-changes存放在shelf" class="headerlink" title="Idea分支切换local changes存放在shelf"></a>Idea分支切换local changes存放在shelf</h2><p>切换分支时选择SmartCheckout，本地的changes会被put到Shelf的Uncommitted changes里面，等下次分支checkout回来时，再将其Unshelve回来</p>
<h2 id="LibreSSL-SSL-connect-SSL-ERROR-SYSCALL-in-connection-to-github-com-443"><a href="#LibreSSL-SSL-connect-SSL-ERROR-SYSCALL-in-connection-to-github-com-443" class="headerlink" title="LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443"></a>LibreSSL SSL_connect: SSL_ERROR_SYSCALL in connection to github.com:443</h2><p>因为自己开了V2rayX的代理，将http和https请求代理到8001端口，所以需要添加一下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git config --global http.proxy http://127.0.0.1:8001</span><br><span class="line">git config --global https.proxy http://127.0.0.1:8001</span><br></pre></td></tr></table></figure>

<h2 id="There-is-no-tracking-information-for-the-current-branch"><a href="#There-is-no-tracking-information-for-the-current-branch" class="headerlink" title="There is no tracking information for the current branch"></a>There is no tracking information for the current branch</h2><p><a href="https://stackoverflow.com/questions/32056324/there-is-no-tracking-information-for-the-current-branch">stackoverflow的解决方案</a></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle系列之DBLink的使用</title>
    <url>/2019/04/07/oracle%E7%B3%BB%E5%88%97%E4%B9%8BDBLink%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="赋予权限"><a href="#赋予权限" class="headerlink" title="赋予权限"></a>赋予权限</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 查看feng用户是否具备创建database link 权限</span><br><span class="line">select * from user_sys_privs where privilege like upper(&#x27;%DATABASE LINK%&#x27;) AND USERNAME=&#x27;FENG&#x27;;</span><br><span class="line">-- 如果查出结果行说明没有权限，给FENG用户授予创建dblink的权限</span><br><span class="line">grant create public database link to feng;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="使用DBLink"><a href="#使用DBLink" class="headerlink" title="使用DBLink"></a>使用DBLink</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- sql创建DBlink，ORCL21是配置在tnsnames.ora的远程数据库的别名</span><br><span class="line">create public database link TESTLINK2 connect to FENG identified by &quot;123456&quot; USING &#x27;ORCL21&#x27;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>ORCL21&#x3D;<br>   (DESCRIPTION &#x3D;<br>    (ADDRESS_LIST &#x3D;<br>      (ADDRESS &#x3D; (PROTOCOL &#x3D; TCP)(HOST &#x3D; 127.0.0.1)(PORT &#x3D; 1521))<br>    )<br>    (CONNECT_DATA &#x3D;<br>      (SERVICE_NAME &#x3D; reportdb)<br>    )<br>  )</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--通过DBLink查询远程数据库的表</span><br><span class="line">select * from testTable@TESTLINK2 order by id;</span><br><span class="line">insert into testTable@TESTLINK2 values(...);</span><br><span class="line">udpate testTable@TESTLINK2 set infoColumn=&#x27;test&#x27; where ...;</span><br><span class="line">delete from testTable@TESTLINK2 where ...;</span><br></pre></td></tr></table></figure>

<h2 id="创建同义词"><a href="#创建同义词" class="headerlink" title="创建同义词"></a>创建同义词</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 创建同义词</span><br><span class="line">create synonym TESTSYNONYM FOR testTable@TESTLINK2;</span><br><span class="line">-- 查询ORCL2中FENG用户的表TESTable</span><br><span class="line">SELECT * FROM TESTSYNONYM order by id</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>K8S汇总</title>
    <url>/2019/03/20/K8S%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<blockquote>
<p>集群采用kubeadm搭建</p>
<p><a href="https://blog.csdn.net/fangfu123/article/details/105659155/">iTerm2多窗口命令同时输入</a></p>
<p><a href="http://www.xmind.net/m/46TD7f">K8S Xmind思维导图</a></p>
</blockquote>
<h1 id="集群环境搭建准备"><a href="#集群环境搭建准备" class="headerlink" title="集群环境搭建准备"></a>集群环境搭建准备</h1><h2 id="环境规划"><a href="#环境规划" class="headerlink" title="环境规划"></a>环境规划</h2><blockquote>
<p>采用腾讯云ECS机器搭建</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">IP</th>
<th align="center">System</th>
<th align="center">Role</th>
<th align="center">Specs</th>
</tr>
</thead>
<tbody><tr>
<td align="center">172.16.16.9</td>
<td align="center">CentOS 7.6 64位（腾讯云ECS）</td>
<td align="center">Master</td>
<td align="center">2核 4GB</td>
</tr>
<tr>
<td align="center">192.168.0.4</td>
<td align="center">CentOS 7.6 64位（腾讯云ECS）</td>
<td align="center">Node</td>
<td align="center">2核 4GB</td>
</tr>
<tr>
<td align="center">10.168.0.10</td>
<td align="center">CentOS 7.6 64位（腾讯云ECS）</td>
<td align="center">Node</td>
<td align="center">2核 8GB</td>
</tr>
</tbody></table>
<h2 id="所有节点配置yum源"><a href="#所有节点配置yum源" class="headerlink" title="所有节点配置yum源"></a>所有节点配置yum源</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -o /etc/yum.repos.d/epel.repo http://mirrors.aliyun.com/repo/epel-7.repo ;curl -o /etc/yum.repos.d/CentOS-Base.repo http://mirrors.aliyun.com/repo/Centos-7.repo</span><br></pre></td></tr></table></figure>

<h2 id="主机名解析"><a href="#主机名解析" class="headerlink" title="主机名解析"></a>主机名解析</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">172.16.16.9   k8s-master</span><br><span class="line">192.168.0.4  k8s-node1</span><br><span class="line">10.168.0.10    k8s-node2</span><br></pre></td></tr></table></figure>

<h2 id="修改主机名"><a href="#修改主机名" class="headerlink" title="修改主机名"></a>修改主机名</h2><p>分别在三台ECS执行下面中的一条命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hostnamectl set-hostname k8s-master</span><br><span class="line">hostnamectl set-hostname k8s-node1</span><br><span class="line">hostnamectl set-hostname k8s-node2</span><br></pre></td></tr></table></figure>
<p>之后重启：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>

<h2 id="时间同步"><a href="#时间同步" class="headerlink" title="时间同步"></a>时间同步</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start chronyd</span><br><span class="line">systemctl enable chronyd</span><br></pre></td></tr></table></figure>

<h2 id="禁用防火墙"><a href="#禁用防火墙" class="headerlink" title="禁用防火墙"></a>禁用防火墙</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br></pre></td></tr></table></figure>

<h2 id="禁用selinux"><a href="#禁用selinux" class="headerlink" title="禁用selinux"></a>禁用selinux</h2><blockquote>
<p>SELinux 主要作用就是最大限度地减小系统中服务进程可访问的资源（最小权限原则）</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">setenforce 0</span><br></pre></td></tr></table></figure>
<p>显示<code>setenforce: SELinux is disabled</code>表明已经关闭，未关闭建议先关闭：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -ri &#x27;/^SELINUX=/c SELINUX=disabled&#x27; /etc/sysconfig/selinux</span><br><span class="line">sed -ri &#x27;/^SELINUX=/c SELINUX=disabled&#x27; /etc/selinux/config </span><br></pre></td></tr></table></figure>

<h2 id="每个节点都禁用swapp分区"><a href="#每个节点都禁用swapp分区" class="headerlink" title="每个节点都禁用swapp分区"></a>每个节点都禁用swapp分区</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/fstab</span><br></pre></td></tr></table></figure>
<p>带有<code>swap</code>字眼的都注释掉，没有可以忽略：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#/dev/mapper/centos-swap swap                    swap    defaults        0 0</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# free -h</span><br><span class="line">              total        used        free      shared  buff/cache   available</span><br><span class="line">Mem:           3.7G        1.7G        169M        1.2M        1.8G        1.7G</span><br><span class="line">Swap:            0B          0B          0B</span><br></pre></td></tr></table></figure>
<h2 id="修改linux内核参数"><a href="#修改linux内核参数" class="headerlink" title="修改linux内核参数"></a>修改linux内核参数</h2><p>添加网桥过滤和地址转发功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/sysctl.d/kubernetes.conf</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables = 1</span><br><span class="line">net.bridge.bridge-nf-call-iptables = 1</span><br><span class="line">net.ipv4.ip_forward = 1</span><br></pre></td></tr></table></figure>
<p>加载配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>
<p>加载网桥过滤模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">modprobe br_netfilter</span><br></pre></td></tr></table></figure>
<p>查看是否加载成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# lsmod | grep br_netfilter</span><br><span class="line">br_netfilter           22256  0</span><br><span class="line">bridge                151336  1 br_netfilter</span><br></pre></td></tr></table></figure>

<h2 id="配置ipvs功能"><a href="#配置ipvs功能" class="headerlink" title="配置ipvs功能"></a>配置ipvs功能</h2><blockquote>
<p>在kubernetes中service有两种代理模式，一种是基于iptables的，一种是基于ipvs的<br>ipvs的性能比iptables要高，因此采用ipvs，如果要用ipvs，需要手动载入ipvs模块</p>
</blockquote>
<p>安装ipset和ipvsadm：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install ipset ipvsadmin</span><br></pre></td></tr></table></figure>
<p>配置加载模块脚本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/sysconfig/modules/ipvs.modules</span><br><span class="line">#!/bin/bash</span><br><span class="line">modprobe -- ip_vs</span><br><span class="line">modprobe -- ip_vs_rr</span><br><span class="line">modprobe -- ip_vs_wrr</span><br><span class="line">modprobe -- ip_vs_sh</span><br><span class="line">modprobe -- nf_conntrack_ipv4</span><br></pre></td></tr></table></figure>
<p>增加执行权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod a+x /etc/sysconfig/modules/ipvs.modules</span><br></pre></td></tr></table></figure>
<p>执行脚本文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sh /etc/sysconfig/modules/ipvs.modules</span><br></pre></td></tr></table></figure>
<p>查看是否加载成功：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# lsmod | grep -E &#x27;ip_vs|nf_conntrack&#x27;</span><br><span class="line">ip_vs_sh               12688  0</span><br><span class="line">ip_vs_wrr              12697  0</span><br><span class="line">ip_vs_rr               12600  0</span><br><span class="line">ip_vs                 145497  6 ip_vs_rr,ip_vs_sh,ip_vs_wrr</span><br><span class="line">nf_conntrack_netlink    36354  0</span><br><span class="line">nfnetlink              14519  2 nf_conntrack_netlink</span><br><span class="line">nf_conntrack_ipv4      15053  2</span><br><span class="line">nf_defrag_ipv4         12729  1 nf_conntrack_ipv4</span><br><span class="line">nf_conntrack          139224  7 ip_vs,nf_nat,nf_nat_ipv4,xt_conntrack,nf_nat_masquerade_ipv4,nf_conntrack_netlink,nf_conntrack_ipv4</span><br><span class="line">libcrc32c              12644  3 ip_vs,nf_nat,nf_conntrack</span><br></pre></td></tr></table></figure>

<h2 id="重启服务器"><a href="#重启服务器" class="headerlink" title="重启服务器"></a>重启服务器</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>
<h1 id="部署kubernetes集群"><a href="#部署kubernetes集群" class="headerlink" title="部署kubernetes集群"></a>部署kubernetes集群</h1><h2 id="所有节点部署docker"><a href="#所有节点部署docker" class="headerlink" title="所有节点部署docker"></a>所有节点部署docker</h2><p>准备镜像源：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo -O /etc/yum.repos.d/docker-ce.repo</span><br></pre></td></tr></table></figure>
<p>查看当前支持的docker版本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker version</span><br><span class="line"># 如果已经安装了docker，一般默认会安装docker-ce，不需要重新安装</span><br><span class="line"># 未安装的话可以直接安装最新版本</span><br><span class="line">yum list docker-ce --showduplicates</span><br></pre></td></tr></table></figure>
<p>安装和自己docker版本一致的的docker-ce（<code>--setopt=obsoletes=0</code>不指定的话，否则yum会自动安装更高版本）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install --setopt=obsoletes=0 docker-ce-20.10.7-3.el7</span><br></pre></td></tr></table></figure>
<p>创建docker配置文件，docker默认情况下使用cgroup driver作为cgroupfs，而k8s推荐使用systemd来代替cgroupfs，更换数据源：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir /etc/docker</span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line">&#123;</span><br><span class="line">        &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">        &quot;registry-mirrors&quot;: [&quot;https://zggyaen3.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">systemctl restart docker</span><br><span class="line">systemctl enable docker</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/rthQcW.png"></p>
<h2 id="所有节点安装kubernetes组件"><a href="#所有节点安装kubernetes组件" class="headerlink" title="所有节点安装kubernetes组件"></a>所有节点安装kubernetes组件</h2><p>准备k8s镜像源：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/yum.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes Repo</span><br><span class="line">baseurl=http://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64   </span><br><span class="line">gpgcheck=0</span><br><span class="line">enabled=1</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=http://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpgp</span><br><span class="line">       http://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br></pre></td></tr></table></figure>
<p>查询kubeadm可用的版本，选择和Docker版本对应的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum list kubeadm --showduplicates</span><br></pre></td></tr></table></figure>
<p>安装kubeadm、kubelet、kubectl：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum -y install --setopt=obsoletes=0 kubeadm-1.20.8-0 kubelet-1.20.8-0 kubectl-1.20.8-0 --downloaddir=/root/k8s</span><br></pre></td></tr></table></figure>
<p>配置kubelet的cgroup以及使用ipvs转发：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vim /etc/sysconfig/kubelet</span><br><span class="line">KUBELET_EXTRA_ARGS=&quot;--cgroup-driver=systemd&quot;</span><br><span class="line">KUBE_PROXY_MODE=&quot;ipvs&quot;</span><br></pre></td></tr></table></figure>
<p>设置kubelet开机自启：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 安装好kubelet后先不用启动，当集群初始化的时候会自动启动kubelet，选择启动kubelet会报错</span><br><span class="line"># 开机自启服务</span><br><span class="line">systemctl enable kubelet</span><br><span class="line"># kubelet先不用启动，启动会报错</span><br></pre></td></tr></table></figure>

<h2 id="所有节点准备集群组件镜像包"><a href="#所有节点准备集群组件镜像包" class="headerlink" title="所有节点准备集群组件镜像包"></a>所有节点准备集群组件镜像包</h2><blockquote>
<p>在安装kubernetes集群之前，必须要提前准备好集群需要的镜像</p>
</blockquote>
<h3 id="查看镜像包列表"><a href="#查看镜像包列表" class="headerlink" title="查看镜像包列表"></a>查看镜像包列表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubeadm config images list</span><br><span class="line">k8s.gcr.io/kube-apiserver:v1.20.8</span><br><span class="line">k8s.gcr.io/kube-controller-manager:v1.20.8</span><br><span class="line">k8s.gcr.io/kube-scheduler:v1.20.8</span><br><span class="line">k8s.gcr.io/kube-proxy:v1.20.8</span><br><span class="line">k8s.gcr.io/pause:3.2</span><br><span class="line">k8s.gcr.io/etcd:3.4.13-0</span><br><span class="line">k8s.gcr.io/coredns:1.7.0</span><br></pre></td></tr></table></figure>
<h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">images=(</span><br><span class="line">	kube-apiserver:v1.20.8</span><br><span class="line">	kube-controller-manager:v1.20.8</span><br><span class="line">	kube-scheduler:v1.20.8</span><br><span class="line">	kube-proxy:v1.20.8</span><br><span class="line">	pause:3.2</span><br><span class="line">	etcd:3.4.13-0</span><br><span class="line">	coredns:1.7.0</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">for imageName in $&#123;images[@]&#125;</span><br><span class="line">do</span><br><span class="line">	docker pull registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName</span><br><span class="line">	docker tag registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName k8s.gcr.io/$imageName</span><br><span class="line">	docker rmi registry.cn-hangzhou.aliyuncs.com/google_containers/$imageName</span><br><span class="line">done</span><br></pre></td></tr></table></figure>

<h2 id="master节点初始化"><a href="#master节点初始化" class="headerlink" title="master节点初始化"></a>master节点初始化</h2><blockquote>
<p>初始化成功后，kubelet组件会自动启动，使用kubectl get node命令也可以看到集群中已有master节点</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubeadm init --kubernetes-version=v1.20.8 --pod-network-cidr=10.244.0.0/16 --service-cidr=10.96.0.0/12 --apiserver-advertise-address=172.16.16.9                      </span><br><span class="line"># 注意将生成的token</span><br><span class="line"># 如果过期可先执行此命令 重新生成token</span><br><span class="line"># kubeadm token create</span><br><span class="line"># 列出token</span><br><span class="line"># kubeadm token list  | awk -F&quot; &quot; &#x27;&#123;print $1&#125;&#x27; |tail -n </span><br><span class="line"># 获取CA公钥的哈希值</span><br><span class="line"># openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2&gt;/de</span><br><span class="line"># kubeadm join 192.168.40.8:6443 --token token填这里   --discovery-token-ca-cert-hash sha256:哈希值填这里</span><br></pre></td></tr></table></figure>
<p>创建kubectl必要的文件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u).$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure>
<p>查看master是否加入集群：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl get node</span><br><span class="line">NAME         STATUS     ROLES                  AGE   VERSION</span><br><span class="line">k8s-master   NotReady   control-plane,master   56m   v1.20.8</span><br></pre></td></tr></table></figure>

<h2 id="node节点初始化"><a href="#node节点初始化" class="headerlink" title="node节点初始化"></a>node节点初始化</h2><h3 id="node加入master"><a href="#node加入master" class="headerlink" title="node加入master"></a>node加入master</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubeadm join 172.16.16.9:6443 --token 1juqzg.d242y66inoo9t98u --discovery-token-ca-cert-hash sha256:03c94995123d1483e6739419acf34ee9e0756f395b2b7c0d4bd1e168ec0d6f78</span><br></pre></td></tr></table></figure>
<h3 id="在master节点查看集群节点信息"><a href="#在master节点查看集群节点信息" class="headerlink" title="在master节点查看集群节点信息"></a>在master节点查看集群节点信息</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl get node</span><br><span class="line">NAME         STATUS     ROLES                  AGE     VERSION</span><br><span class="line">k8s-master   NotReady   control-plane,master   19h     v1.20.8</span><br><span class="line">k8s-node1    NotReady   &lt;none&gt;                 4m39s   v1.20.8</span><br><span class="line">k8s-node2    NotReady   &lt;none&gt;                 8s      v1.20.8</span><br></pre></td></tr></table></figure>
<h2 id="集群配置flannel网络"><a href="#集群配置flannel网络" class="headerlink" title="集群配置flannel网络"></a>集群配置flannel网络</h2><p>创建文件夹：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/root/k8s/yaml</span><br></pre></td></tr></table></figure>
<p>上传kube-flannel.yaml：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 可以直接在https://github.com/flannel-io/flannel/edit/master/Documentation/kube-flannel.yml复制</span><br><span class="line">sshpass -p XXX scp -r ~/Downloads/kube-flannel.yaml root@106.55.145.49:~/k8s/yaml</span><br></pre></td></tr></table></figure>
<p>将文件中quay.io仓库改为quay-mirror.qiniu.com：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -ri &#x27;s#quay.io#quay-mirror.qiniu.com#g&#x27; kube-flannel.yaml</span><br></pre></td></tr></table></figure>
<p>启动flannel网络：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master yaml]# kubectl apply -f kube-flannel.yaml</span><br><span class="line">podsecuritypolicy.policy/psp.flannel.unprivileged created</span><br><span class="line">Warning: rbac.authorization.k8s.io/v1beta1 ClusterRole is deprecated in v1.17+, unavailable in v1.22+; use rbac.authorization.k8s.io/v1 ClusterRole</span><br><span class="line">clusterrole.rbac.authorization.k8s.io/flannel created</span><br><span class="line">Warning: rbac.authorization.k8s.io/v1beta1 ClusterRoleBinding is deprecated in v1.17+, unavailable in v1.22+; use rbac.authorization.k8s.io/v1 ClusterRoleBinding</span><br><span class="line">clusterrolebinding.rbac.authorization.k8s.io/flannel created</span><br><span class="line">serviceaccount/flannel created</span><br><span class="line">configmap/kube-flannel-cfg created</span><br><span class="line">daemonset.apps/kube-flannel-ds-amd64 created</span><br><span class="line">daemonset.apps/kube-flannel-ds-arm64 created</span><br><span class="line">daemonset.apps/kube-flannel-ds-arm created</span><br><span class="line">daemonset.apps/kube-flannel-ds-ppc64le created</span><br><span class="line">daemonset.apps/kube-flannel-ds-s390x created</span><br></pre></td></tr></table></figure>
<p>flannel网络有时pull会失败可以从这里提取：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 链接：https://pan.baidu.com/s/1AqubJhTMIshf66ofOCkubQ </span><br><span class="line"># 提取码：ypbh </span><br><span class="line">docker load -i flanneld-v0.12.0-amd64.docker</span><br><span class="line">docker tag quay.io/coreos/flannel:v0.12.0-amd64 quay-mirror.qiniu.com/coreos/flannel:v0.12.0-amd64</span><br></pre></td></tr></table></figure>
<p>查看组件pod状态：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl get pods -n kube-system</span><br><span class="line">NAME                                 READY   STATUS                  RESTARTS   AGE</span><br><span class="line">coredns-74ff55c5b-6nbjl              0/1     Pending                 0          19h</span><br><span class="line">coredns-74ff55c5b-6sd8b              0/1     Pending                 0          19h</span><br><span class="line">etcd-k8s-master                      1/1     Running                 1          19h</span><br><span class="line">kube-apiserver-k8s-master            1/1     Running                 1          19h</span><br><span class="line">kube-controller-manager-k8s-master   1/1     Running                 2          19h</span><br><span class="line">kube-flannel-ds-amd64-997w8          0/1     Init:ImagePullBackOff   0          26m</span><br><span class="line">kube-flannel-ds-amd64-gv45v          0/1     Init:ImagePullBackOff   0          26m</span><br><span class="line">kube-flannel-ds-amd64-hg5s8          0/1     Init:ImagePullBackOff   0          26m</span><br><span class="line">kube-proxy-hlvwm                     1/1     Running                 1          19h</span><br><span class="line">kube-proxy-rvfms                     1/1     Running                 0          45m</span><br><span class="line">kube-proxy-tnc7c                     1/1     Running                 0          41m</span><br><span class="line">kube-scheduler-k8s-master            1/1     Running                 2          19h</span><br></pre></td></tr></table></figure>

<h2 id="部署一个nginx容器验证集群可用性"><a href="#部署一个nginx容器验证集群可用性" class="headerlink" title="部署一个nginx容器验证集群可用性"></a>部署一个nginx容器验证集群可用性</h2><p>创建一个deployment资源的nginx：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master yaml]# kubectl create deployment kiwi-ui --image=nginx</span><br><span class="line">deployment.apps/kiwi-ui created</span><br></pre></td></tr></table></figure>
<p>对外暴露端口：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master yaml]# kubectl expose deployment kiwi-ui --port=80 --type=NodePort</span><br><span class="line">service/kiwi-ui exposed</span><br></pre></td></tr></table></figure>
<p>查看pod资源：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master yaml]# kubectl get pod -o wide</span><br><span class="line">NAME                       READY   STATUS    RESTARTS   AGE     IP           NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">kiwi-ui-556656cb8c-d28hm   1/1     Running   0          3m39s   10.244.1.4   k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure>
<p>查看所有资源：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master yaml]# kubectl get all</span><br><span class="line">NAME                           READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/kiwi-ui-556656cb8c-d28hm   1/1     Running   0          4m9s</span><br><span class="line"></span><br><span class="line">NAME                 TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">service/kiwi-ui      NodePort    10.103.116.177   &lt;none&gt;        80:30685/TCP   5m23s</span><br><span class="line">service/kubernetes   ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP        22h</span><br><span class="line"></span><br><span class="line">NAME                      READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.apps/kiwi-ui   1/1     1            1           8m39s</span><br><span class="line"></span><br><span class="line">NAME                                 DESIRED   CURRENT   READY   AGE</span><br><span class="line">replicaset.apps/kiwi-ui-556656cb8c   1         1         1       8m39s</span><br></pre></td></tr></table></figure>
<p>访问Master节点的30685端口：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/MuOKRJ.png"></p>
<h2 id="k8s命令开启tab功能"><a href="#k8s命令开启tab功能" class="headerlink" title="k8s命令开启tab功能"></a>k8s命令开启tab功能</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">yum install -y bash-completion</span><br><span class="line">source /usr/share/bash-completion/bash_completio</span><br><span class="line">source &lt;(kubectl completion bash)</span><br><span class="line">echo &quot;source &lt;(kubectl completion bash)&quot; &gt;&gt; ~/.bashrc</span><br></pre></td></tr></table></figure>
<h2 id="部署rancher管理k8s"><a href="#部署rancher管理k8s" class="headerlink" title="部署rancher管理k8s"></a>部署rancher管理k8s</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 拉取镜像</span><br><span class="line">docker pull rancher/rancher:latest</span><br><span class="line"># 准备挂载点</span><br><span class="line">mkdir -p /docker_volume/rancher_home/rancher</span><br><span class="line">mkdir -p /docker_volume/rancher_home/auditlog</span><br><span class="line"># 运行rancher容器</span><br><span class="line">docker run -d --restart=unless-stopped -p 80:80 -p 443:443 \</span><br><span class="line">-v /docker_volume/rancher_home/rancher:/var/lib/rancher \</span><br><span class="line">-v /docker_volume/rancher_home/auditlog:/var/log/auditlog \</span><br><span class="line">--name rancher rancher/rancher:latest</span><br></pre></td></tr></table></figure>

<h1 id="资源管理"><a href="#资源管理" class="headerlink" title="资源管理"></a>资源管理</h1><blockquote>
<p>在kubernetes中，所有的内容都抽象称为资源，用户需要通过操作资源来管理k8s。<br>kubernetes的本质上就是一个集群系统，用户可以在集群中部署各种服务，所谓的部署，就是在k8s集群中运行一个个的容器，将执行的程序运行在容器中。<br>kubernetes的最小管理单元是pod而不是容器，所以只能将容器放在pod中，而k8s一般也不会直接管理pod，而是通过pod控制器来管理pod。<br>pod可以提供服务，就要考虑如何访问pod中的服务，kubernetes提供了service资源来实现这个功能。<br>当pod数据需要持久化，k8s也提供了很多种存储系统。</p>
</blockquote>
<p>资源操作流程（我们所学习的重点就是如何在集群中对各种资源的操作）：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/t5cRNR.png"></p>
<h2 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h2><blockquote>
<p>kubernetes中资源配置文件都是基于YAML语言编写</p>
</blockquote>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul>
<li>大小写敏感</li>
<li>使用缩进表示层级关系（低版本不允许使用Tab，高版本可以）</li>
<li>冒号后面至少有一个空格</li>
<li><code>#</code>表示注释</li>
<li>多段yaml写在同个文件里面要用一行<code>---</code>分隔开</li>
</ul>
<blockquote>
<p><a href="http://www.ruanyifeng.com/blog/2016/07/yaml.html">YAML 语言教程</a></p>
<p><a href="http://json2yaml.com/convert-yaml-to-json">yaml转换json工具</a></p>
</blockquote>
<h2 id="资源管理方式"><a href="#资源管理方式" class="headerlink" title="资源管理方式"></a>资源管理方式</h2><ul>
<li>命令式对象管理：直接使用命令对资源进行操作<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl run nginx-pod --image=nginx --port=80</span><br></pre></td></tr></table></figure></li>
<li>命令式对象配置：通过命令指定配置文件去操作资源<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl create -f nginx-pod.yaml</span><br></pre></td></tr></table></figure></li>
<li>声明式对象配置：通过apply命令和配置文件去操作资源，相当于更新（如果Pod存在则更新，不存在则创建）<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 该模式只有一个命令apply</span><br><span class="line">kubectl apply -f nginx-pod.yaml</span><br></pre></td></tr></table></figure></li>
</ul>
<p>Command Demo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">创建更新资源：kubectl apply -f xxx.yaml kubect create -f xxx.yaml</span><br><span class="line">删除资源：kubectl delete -f xxx.yaml</span><br><span class="line">查看资源：kubect get|describe 资源名</span><br></pre></td></tr></table></figure>
<h3 id="命令式对象管理"><a href="#命令式对象管理" class="headerlink" title="命令式对象管理"></a>命令式对象管理</h3><p>创建一个kiwi的namespace：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl create ns kiwi</span><br><span class="line">namespace/kiwi created</span><br></pre></td></tr></table></figure>
<p>查看所有的namespace：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl get ns</span><br><span class="line">NAME              STATUS   AGE</span><br><span class="line">default           Active   24h</span><br><span class="line">kiwi              Active   71s</span><br><span class="line">kube-node-lease   Active   24h</span><br><span class="line">kube-public       Active   24h</span><br><span class="line">kube-system       Active   24h</span><br></pre></td></tr></table></figure>
<p>运行一个nginx的pod：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl run pod --image=nginx -n kiwi</span><br><span class="line">pod/pod created</span><br><span class="line">[root@k8s-master ~]# kubectl get pod -n kiwi</span><br><span class="line">NAME   READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod    1/1     Running   0          21s</span><br></pre></td></tr></table></figure>
<p>删除一个pod：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl delete pod pod -n kiwi</span><br><span class="line">pod &quot;pod&quot; deleted</span><br></pre></td></tr></table></figure>
<p>删除一个namespace：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl delete ns kiwi</span><br><span class="line">namespace &quot;kiwi&quot; deleted</span><br></pre></td></tr></table></figure>

<h3 id="声明式对象配置"><a href="#声明式对象配置" class="headerlink" title="声明式对象配置"></a>声明式对象配置</h3><p>在自己的kiwi项目创建kiwi-ui.yaml：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">    name: kiwi</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-pod</span><br><span class="line">  namespace: kiwi</span><br><span class="line">spec:</span><br><span class="line">  containers:</span><br><span class="line">  - name: kiwi-ui</span><br><span class="line">    image: nginx</span><br></pre></td></tr></table></figure>
<p>使用kubectl create创建：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master yaml]# kubectl create -f kiwi-ui.yaml</span><br><span class="line">namespace/kiwi created</span><br><span class="line">pod/nginx-pod created</span><br></pre></td></tr></table></figure>
<p>更新yaml文件中镜像版本，nginx更改为1.15：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master yaml]# kubectl apply -f kiwi-ui.yaml</span><br><span class="line">Warning: resource namespaces/kiwi is missing the kubectl.kubernetes.io/last-applied-configuration annotation which is required by kubectl apply. kubectl apply should only be used on resources created declaratively by either kubectl create --save-config or kubectl apply. The missing annotation will be patched automatically.</span><br><span class="line">namespace/kiwi configured</span><br><span class="line">Warning: resource pods/nginx-pod is missing the kubectl.kubernetes.io/last-applied-configuration annotation which is required by kubectl apply. kubectl apply should only be used on resources created declaratively by either kubectl create --save-config or kubectl apply. The missing annotation will be patched automatically.</span><br><span class="line">pod/nginx-pod configured</span><br></pre></td></tr></table></figure>
<p>查看更新过程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[root@k8s-master yaml]# kubectl describe pod nginx-pod -n kiwi</span><br><span class="line">Name:         nginx-pod</span><br><span class="line">Namespace:    kiwi</span><br><span class="line">Priority:     0</span><br><span class="line">Node:         k8s-node1/192.168.0.4</span><br><span class="line">Start Time:   Sun, 20 Jun 2021 16:51:32 +0800</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  &lt;none&gt;</span><br><span class="line">Status:       Running</span><br><span class="line">IP:           10.244.1.8</span><br><span class="line">IPs:</span><br><span class="line">  IP:  10.244.1.8</span><br><span class="line">Containers:</span><br><span class="line">  kiwi-ui:</span><br><span class="line">    Container ID:   docker://be02457c14715ef891c6d6468b7525f735a97c77a23891f6be8ef3ca4b2a5eed</span><br><span class="line">    Image:          nginx:1.15</span><br><span class="line">    Image ID:       docker-pullable://nginx@sha256:6d75c99af15565a301e48297fa2d121e15d80ad526f8369c526324f0f7ccb750</span><br><span class="line">    Port:           &lt;none&gt;</span><br><span class="line">    Host Port:      &lt;none&gt;</span><br><span class="line">    State:          Running</span><br><span class="line">      Started:      Sun, 20 Jun 2021 16:51:51 +0800</span><br><span class="line">    Ready:          True</span><br><span class="line">    Restart Count:  0</span><br><span class="line">    Environment:    &lt;none&gt;</span><br><span class="line">    Mounts:</span><br><span class="line">      /var/run/secrets/kubernetes.io/serviceaccount from default-token-jthzv (ro)</span><br><span class="line">Conditions:</span><br><span class="line">  Type              Status</span><br><span class="line">  Initialized       True</span><br><span class="line">  Ready             True</span><br><span class="line">  ContainersReady   True</span><br><span class="line">  PodScheduled      True</span><br><span class="line">Volumes:</span><br><span class="line">  default-token-jthzv:</span><br><span class="line">    Type:        Secret (a volume populated by a Secret)</span><br><span class="line">    SecretName:  default-token-jthzv</span><br><span class="line">    Optional:    false</span><br><span class="line">QoS Class:       BestEffort</span><br><span class="line">Node-Selectors:  &lt;none&gt;</span><br><span class="line">Tolerations:     node.kubernetes.io/not-ready:NoExecute op=Exists for 300s</span><br><span class="line">                 node.kubernetes.io/unreachable:NoExecute op=Exists for 300s</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason     Age   From               Message</span><br><span class="line">  ----    ------     ----  ----               -------</span><br><span class="line">  Normal  Scheduled  101s  default-scheduler  Successfully assigned kiwi/nginx-pod to k8s-node1</span><br><span class="line">  Normal  Pulling    100s  kubelet            Pulling image &quot;nginx&quot;</span><br><span class="line">  Normal  Pulled     82s   kubelet            Successfully pulled image &quot;nginx&quot; in 18.06408301s</span><br><span class="line">  Normal  Created    82s   kubelet            Created container kiwi-ui</span><br><span class="line">  Normal  Started    82s   kubelet            Started container kiwi-ui</span><br><span class="line">  Normal  Killing    23s   kubelet            Container kiwi-ui definition changed, will be restarted</span><br><span class="line">  Normal  Pulling    23s   kubelet            Pulling image &quot;nginx:1.15&quot;</span><br></pre></td></tr></table></figure>


<h2 id="kubectl命令"><a href="#kubectl命令" class="headerlink" title="kubectl命令"></a>kubectl命令</h2><blockquote>
<p><a href="https://kubernetes.io/zh/docs/reference/kubectl/overview/">kubectl概述</a></p>
<p><a href="http://docs.kubernetes.org.cn/683.html">Kubernetes kubectl 命令表</a></p>
<p>一般不建议在node节点也开启kubectl命令</p>
</blockquote>
<h1 id="KiwiDict的各种资源yaml"><a href="#KiwiDict的各种资源yaml" class="headerlink" title="KiwiDict的各种资源yaml"></a>KiwiDict的各种资源yaml</h1><h2 id="创建namespace分割资源"><a href="#创建namespace分割资源" class="headerlink" title="创建namespace分割资源"></a>创建namespace分割资源</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">    name: kiwi-be-infrastructure</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">    name: kiwi-be-business</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Namespace</span><br><span class="line">metadata:</span><br><span class="line">    name: kiwi-fe</span><br></pre></td></tr></table></figure>
<h2 id="安装nginx"><a href="#安装nginx" class="headerlink" title="安装nginx"></a>安装nginx</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  name: nginx-deployment</span><br><span class="line">  namespace: kiwi-fe</span><br><span class="line">spec:</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      app: nginx</span><br><span class="line">  replicas: 3</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: nginx</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - name: nginx</span><br><span class="line">        image: nginx</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 80</span><br><span class="line">        volumeMounts:</span><br><span class="line">        - mountPath: &quot;/usr/local/nginx/html/&quot;</span><br><span class="line">          name: nginx-vol</span><br><span class="line">      volumes:</span><br><span class="line">      - name: nginx-vol</span><br><span class="line">        hostPath:</span><br><span class="line">          path: ~/docker/ui/dist/</span><br></pre></td></tr></table></figure>
<h2 id="安装rabbitmq"><a href="#安装rabbitmq" class="headerlink" title="安装rabbitmq"></a>安装rabbitmq</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kubectl run rabbitmq --image=rabbitmq:management --expose --port=15672 --restart=Never --dry-run -o yaml &gt; rabbitmq.yml</span><br><span class="line">kubectl create -f rabbitmq.yml</span><br><span class="line">kubectl expose po rabbitmq --port 15672</span><br></pre></td></tr></table></figure>
<h2 id="安装es单机版"><a href="#安装es单机版" class="headerlink" title="安装es单机版"></a>安装es单机版</h2><blockquote>
<p><a href="https://www.xswsym.online/pages/262349/#_6-%E9%AA%8C%E8%AF%81">参考</a></p>
</blockquote>
<p>创建k8s-es.yaml</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: Service</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: null</span><br><span class="line">  name: elasticsearch</span><br><span class="line">  namespace: kiwi-be-infrastructure</span><br><span class="line"></span><br><span class="line">spec:</span><br><span class="line">  type: NodePort</span><br><span class="line">  ports:</span><br><span class="line">  - name: db</span><br><span class="line">    nodePort: 30921</span><br><span class="line">    port: 9200</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 9200</span><br><span class="line">  - name: transport</span><br><span class="line">    nodePort: 30922</span><br><span class="line">    port: 9300</span><br><span class="line">    protocol: TCP</span><br><span class="line">    targetPort: 9300    </span><br><span class="line">  selector:</span><br><span class="line">    run: elasticsearch</span><br><span class="line">status:</span><br><span class="line">  loadBalancer: &#123;&#125;</span><br><span class="line">---</span><br><span class="line">apiVersion: apps/v1</span><br><span class="line">kind: Deployment</span><br><span class="line">metadata:</span><br><span class="line">  creationTimestamp: null</span><br><span class="line">  labels:</span><br><span class="line">    run: elasticsearch</span><br><span class="line">  name: elasticsearch</span><br><span class="line">  namespace: kiwi-be-infrastructure</span><br><span class="line"></span><br><span class="line">spec:</span><br><span class="line">  replicas: 1</span><br><span class="line">  selector:</span><br><span class="line">    matchLabels:</span><br><span class="line">      run: elasticsearch</span><br><span class="line">  strategy: &#123;&#125;</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      creationTimestamp: null</span><br><span class="line">      labels:</span><br><span class="line">        run: elasticsearch</span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">      - env:</span><br><span class="line">        - name: discovery.type</span><br><span class="line">          value: single-node</span><br><span class="line">        image: docker.elastic.co/elasticsearch/elasticsearch:6.3.1</span><br><span class="line">        name: elasticsearch</span><br><span class="line">        ports:</span><br><span class="line">        - containerPort: 9200</span><br><span class="line">          name: db</span><br><span class="line">          protocol: TCP</span><br><span class="line">        - containerPort: 9300</span><br><span class="line">          name: tramsport</span><br><span class="line">          protocol: TCP</span><br><span class="line">        resources:</span><br><span class="line">          limits:</span><br><span class="line">            cpu: 500m</span><br><span class="line">            memory: 2Gi</span><br><span class="line">          requests:</span><br><span class="line">            cpu: 500m</span><br><span class="line">            memory: 2Gi</span><br><span class="line">status: &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>测试es可用：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/i8EvMn.png"></p>
<h2 id="使用Kompose将docker-compose迁移至K8S"><a href="#使用Kompose将docker-compose迁移至K8S" class="headerlink" title="使用Kompose将docker-compose迁移至K8S"></a>使用Kompose将docker-compose迁移至K8S</h2><p><a href="https://kubernetes.io/zh/docs/tasks/configure-pod-container/translate-compose-kubernetes/">Kompose命令安装和说明</a></p>
<p>将原本的docker-compose配置文件做转换：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kompose --file docker-compose-base.yml convert</span><br><span class="line">kompose --file docker-compose-service.yml convert</span><br></pre></td></tr></table></figure>
<p>也可以不做转换直接：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">kompose --file docker-compose-base.yml up</span><br><span class="line">kompose --file docker-compose-service.yml up</span><br></pre></td></tr></table></figure>


<h1 id="AWS-Cloud-Training"><a href="#AWS-Cloud-Training" class="headerlink" title="AWS Cloud Training"></a>AWS Cloud Training</h1><h2 id="C2"><a href="#C2" class="headerlink" title="C2"></a>C2</h2><p>  aws_setup.bat脚本报错，或者走不到step 9的原因：</p>
<ul>
<li>Service Now的权限申请记得选择Stuff ID后面不带-AWS的Account</li>
<li>python从Service Now下载的只有3.9版本，3.9的貌似会报错，需要Raise a ticket，远程让人帮忙换3.6的python。</li>
<li>确认%JAVA_HOME%配置正确</li>
<li>确认Python配置到Path环境变量（父目录和Scripts都配置到Path里面）</li>
<li>确认ASW acount的权限已经下来，可以访问到控制台</li>
<li>确认XXXXXX_password.bat在.aws目录下有自动生成，不然可以删除整个.aws重新来过</li>
<li>确认bat脚本是否放在Temp目录下执行</li>
</ul>
<h2 id="AWS-Cloud-Training-Springboot-项目"><a href="#AWS-Cloud-Training-Springboot-项目" class="headerlink" title="AWS Cloud Training Springboot 项目"></a>AWS Cloud Training Springboot 项目</h2><p>spring-boot-starter-parent的pom.xml配置version要改成2.1.3.RELEASE，不然会报错。</p>
<h2 id="Springboot常用注解"><a href="#Springboot常用注解" class="headerlink" title="Springboot常用注解"></a>Springboot常用注解</h2><p><a href="http://www.xmind.net/m/u2rcc7">Springboot Xmind笔记</a></p>
]]></content>
      <categories>
        <category>K8S</category>
      </categories>
      <tags>
        <tag>K8S</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle系列之常用操作命令</title>
    <url>/2019/04/07/oracle%E7%B3%BB%E5%88%97%E4%B9%8B%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="将a表的某些列插入b表的某些列"><a href="#将a表的某些列插入b表的某些列" class="headerlink" title="将a表的某些列插入b表的某些列"></a>将a表的某些列插入b表的某些列</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insert into a(ac1,ac2) select bc1,bc2 from b where ...;</span><br></pre></td></tr></table></figure>

<h2 id="重命名表"><a href="#重命名表" class="headerlink" title="重命名表"></a>重命名表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name RENAME TO new_table_name；</span><br></pre></td></tr></table></figure>

<h2 id="重命名字段"><a href="#重命名字段" class="headerlink" title="重命名字段"></a>重命名字段</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name RENAME COLUMN column_name TO new_column_name;</span><br></pre></td></tr></table></figure>

<h2 id="修改字段类型"><a href="#修改字段类型" class="headerlink" title="修改字段类型"></a>修改字段类型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE tableName modify(columnName 类型);</span><br></pre></td></tr></table></figure>

<h2 id="增加多个字段"><a href="#增加多个字段" class="headerlink" title="增加多个字段"></a>增加多个字段</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">alter table test1 add (name varchar2(30) default ‘无名氏’ not null,</span><br><span class="line">age integer default 22 not null,</span><br><span class="line">has_money number(9,2));</span><br></pre></td></tr></table></figure>

<h2 id="主键操作"><a href="#主键操作" class="headerlink" title="主键操作"></a>主键操作</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--设置主键</span><br><span class="line">alter table jack add constraint pk_id primary key(object_id);</span><br></pre></td></tr></table></figure>

<h2 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop table tn;</span><br></pre></td></tr></table></figure>

<h2 id="查询表所属表空间"><a href="#查询表所属表空间" class="headerlink" title="查询表所属表空间"></a>查询表所属表空间</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select tablespace_name, table_name</span><br><span class="line">  from user_tables</span><br><span class="line"> where table_name = &#x27;EOMS_OUTER_PROJECT&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="查询索引所在表空间"><a href="#查询索引所在表空间" class="headerlink" title="查询索引所在表空间"></a>查询索引所在表空间</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select index_name,tablespace_name from dba_indexes where index_name=&#x27;INDEX_PS&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="查询表的建表DDL"><a href="#查询表的建表DDL" class="headerlink" title="查询表的建表DDL"></a>查询表的建表DDL</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select dbms_metadata.get_ddl(&#x27;TABLE&#x27;,&#x27;TABLE_NAME&#x27;,&#x27;DB_USER&#x27;) from dual;</span><br></pre></td></tr></table></figure>

<h2 id="查看所有表空间大小以及使用情况"><a href="#查看所有表空间大小以及使用情况" class="headerlink" title="查看所有表空间大小以及使用情况"></a>查看所有表空间大小以及使用情况</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT Upper(F.TABLESPACE_NAME) &quot;表空间名&quot;,</span><br><span class="line">       D.TOT_GROOTTE_MB &quot;表空间大小(M)&quot;,</span><br><span class="line">       D.TOT_GROOTTE_MB - F.TOTAL_BYTES &quot;已使用空间(M)&quot;,</span><br><span class="line">       To_char(Round((D.TOT_GROOTTE_MB - F.TOTAL_BYTES) / D.TOT_GROOTTE_MB * 100,</span><br><span class="line">                     2),</span><br><span class="line">               &#x27;990.99&#x27;) || &#x27;%&#x27; &quot;使用比&quot;,</span><br><span class="line">       F.TOTAL_BYTES &quot;空闲空间(M)&quot;,</span><br><span class="line">       F.MAX_BYTES &quot;最大块(M)&quot;</span><br><span class="line">  FROM (SELECT TABLESPACE_NAME,</span><br><span class="line">               Round(Sum(BYTES) / (1024 * 1024), 2) TOTAL_BYTES,</span><br><span class="line">               Round(Max(BYTES) / (1024 * 1024), 2) MAX_BYTES</span><br><span class="line">          FROM SYS.DBA_FREE_SPACE</span><br><span class="line">         GROUP BY TABLESPACE_NAME) F,</span><br><span class="line">       (SELECT DD.TABLESPACE_NAME,</span><br><span class="line">               Round(Sum(DD.BYTES) / (1024 * 1024), 2) TOT_GROOTTE_MB</span><br><span class="line">          FROM SYS.DBA_DATA_FILES DD</span><br><span class="line">         GROUP BY DD.TABLESPACE_NAME) D</span><br><span class="line"> WHERE D.TABLESPACE_NAME = F.TABLESPACE_NAME</span><br><span class="line"> ORDER BY &quot;使用比&quot; desc;</span><br></pre></td></tr></table></figure>

<h2 id="指定表空间查询所有表名"><a href="#指定表空间查询所有表名" class="headerlink" title="指定表空间查询所有表名"></a>指定表空间查询所有表名</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Select Table_Name, Tablespace_Name</span><br><span class="line">From Dba_Tables</span><br><span class="line">Where Tablespace_Name = &#x27;USERS&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="通过指定表空间查询所属表的占用空间"><a href="#通过指定表空间查询所属表的占用空间" class="headerlink" title="通过指定表空间查询所属表的占用空间"></a>通过指定表空间查询所属表的占用空间</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select segment_name, bytes/1024||&#x27;KB&#x27; &quot;占用空间&quot;</span><br><span class="line">from user_segments </span><br><span class="line">where segment_type=&#x27;TABLE&#x27; and tablespace_name=&#x27;USERS&#x27; order by segment_name asc;</span><br></pre></td></tr></table></figure>

<h2 id="删除列"><a href="#删除列" class="headerlink" title="删除列"></a>删除列</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER TABLE table_name DROP COLUMN column_name;</span><br></pre></td></tr></table></figure>

<h2 id="查询所有表及其所使用的表空间"><a href="#查询所有表及其所使用的表空间" class="headerlink" title="查询所有表及其所使用的表空间"></a>查询所有表及其所使用的表空间</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select table_name 表名 ,tablespace_name 所使用表空间 from user_tables t where t.TABLE_NAME=&#x27;T_PRE_AI_ACTIVITY&#x27;;</span><br></pre></td></tr></table></figure>

<h2 id="查询所有表空间大小"><a href="#查询所有表空间大小" class="headerlink" title="查询所有表空间大小"></a>查询所有表空间大小</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT t.tablespace_name, round(SUM(bytes / (1024 * 1024)), 0) ts_size</span><br><span class="line">  FROM dba_tablespaces t, dba_data_files d</span><br><span class="line"> WHERE t.tablespace_name = d.tablespace_name</span><br><span class="line"> GROUP BY t.tablespace_name;</span><br></pre></td></tr></table></figure>

<h2 id="查询版本"><a href="#查询版本" class="headerlink" title="查询版本"></a>查询版本</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from v$version;</span><br></pre></td></tr></table></figure>

<h2 id="查看长时间未commit会话，10秒未commit"><a href="#查看长时间未commit会话，10秒未commit" class="headerlink" title="查看长时间未commit会话，10秒未commit"></a>查看长时间未commit会话，10秒未commit</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT A.SID,</span><br><span class="line">       A.SERIAL#,</span><br><span class="line">       A.USERNAME,</span><br><span class="line">       A.EVENT,</span><br><span class="line">       A.WAIT_CLASS,</span><br><span class="line">       A.SECONDS_IN_WAIT,</span><br><span class="line">       b.LOCKED_MODE,</span><br><span class="line">       C.OWNER,</span><br><span class="line">       C.OBJECT_NAME,</span><br><span class="line">       C.OBJECT_TYPE</span><br><span class="line">  FROM V$SESSION A</span><br><span class="line"> INNER JOIN V$LOCKED_OBJECT B ON A.SID = b.SESSION_ID</span><br><span class="line"> INNER JOIN DBA_OBJECTS C ON B.OBJECT_ID = c.OBJECT_ID</span><br><span class="line"> WHERE A.WAIT_CLASS = &#x27;Idle&#x27;</span><br><span class="line">   AND A.SECONDS_IN_WAIT &gt; 10</span><br></pre></td></tr></table></figure>

<h2 id="查看锁主的记录rowid"><a href="#查看锁主的记录rowid" class="headerlink" title="查看锁主的记录rowid"></a>查看锁主的记录rowid</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT SID,</span><br><span class="line">       SERIAL#,</span><br><span class="line">       AUDSID,</span><br><span class="line">       PADDR,</span><br><span class="line">       USER#,</span><br><span class="line">       USERNAME,</span><br><span class="line">       EVENT,</span><br><span class="line">       WAIT_CLASS,</span><br><span class="line">       SECONDS_IN_WAIT,</span><br><span class="line">       ROW_WAIT_OBJ#,</span><br><span class="line">       ROW_WAIT_FILE#,</span><br><span class="line">       ROW_WAIT_BLOCK#,</span><br><span class="line">       ROW_WAIT_ROW#,</span><br><span class="line">       BLOCKING_SESSION_STATUS,</span><br><span class="line">       BLOCKING_INSTANCE,</span><br><span class="line">       BLOCKING_SESSION,</span><br><span class="line">       C.OWNER,</span><br><span class="line">       C.OBJECT_NAME,</span><br><span class="line">       C.OBJECT_TYPE,</span><br><span class="line">       dbms_rowid.rowid_create(1,</span><br><span class="line">                               ROW_WAIT_OBJ#,</span><br><span class="line">                               ROW_WAIT_FILE#,</span><br><span class="line">                               ROW_WAIT_BLOCK#,</span><br><span class="line">                               ROW_WAIT_ROW#)</span><br><span class="line">  FROM V$SESSION A</span><br><span class="line"> INNER JOIN V$LOCKED_OBJECT B ON A.SID = b.SESSION_ID</span><br><span class="line"> INNER JOIN DBA_OBJECTS C ON B.OBJECT_ID = c.OBJECT_ID</span><br><span class="line"> WHERE BLOCKING_SESSION IS NOT NULL;</span><br></pre></td></tr></table></figure>

<h2 id="oracle命令行导入SQL脚本"><a href="#oracle命令行导入SQL脚本" class="headerlink" title="oracle命令行导入SQL脚本"></a>oracle命令行导入SQL脚本</h2><p>使用@导入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SQL&gt;@/home/oracle/a.sql;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库三范式</title>
    <url>/2019/04/07/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%89%E8%8C%83%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="第一范式"><a href="#第一范式" class="headerlink" title="第一范式"></a>第一范式</h2><p>当关系模式R的所有属性都不能在分解为更基本的数据单位时，称R是满足第一范式的，简记为1NF。满足第一范式是关系模式规范化的最低要求，否则，将有很多基本操作在这样的关系模式中实现不了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">表（联系人信息）</span><br><span class="line">正例:</span><br><span class="line">表（联系人姓名，手机号码，地址）</span><br></pre></td></tr></table></figure>

<p>1，每一列属性都是不可再分的属性值，确保每一列的原子性。<br>2，两列的属性相近或相似或一样，尽量合并属性一样的列，确保不产生冗余数据。</p>
<h2 id="第二范式"><a href="#第二范式" class="headerlink" title="第二范式"></a>第二范式</h2><p>如果关系模式R满足第一范式，并且R得所有非主属性都完全依赖于R的每一个候选关键属性，称R满足第二范式，简记为2NF。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">反例：</span><br><span class="line">订单表（订单号，价格，用户，用户名，身份证）</span><br><span class="line">正例：</span><br><span class="line">订单表和用户表分表。</span><br></pre></td></tr></table></figure>

<h2 id="第三范式"><a href="#第三范式" class="headerlink" title="第三范式"></a>第三范式</h2><p>设R是一个满足第一范式条件的关系模式，X是R的任意属性集，如果X非传递依赖于R的任意一个候选关键字，称R满足第三范式，简记为3NF.<br>数据不能存在传递关系，即没个属性都跟主键有直接关系而不是间接关系。像：a–&gt;b–&gt;c  属性之间含有这样的关系，是不符合第三范式的。</p>
<p>比如Student表（学号，姓名，年龄，性别，所在院校，院校地址，院校电话）</p>
<p>这样一个表结构，就存在上述关系。 学号–&gt; 所在院校 –&gt; (院校地址，院校电话)</p>
<p>这样的表结构，我们应该拆开来，如下。</p>
<p>（学号，姓名，年龄，性别，所在院校）–（所在院校，院校地址，院校电话）</p>
<p><em><strong>三大范式只是一般设计数据库的基本理念，可以建立冗余较小、结构合理的数据库。如果有特殊情况，当然要特殊对待，数据库设计最重要的是看需求跟性能，需求&gt;性能&gt;表结构。所以不能一味的去追求范式建立数据库。</strong></em></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title>linux系列之防火墙iptable</title>
    <url>/2019/04/15/linux%E7%B3%BB%E5%88%97%E4%B9%8B%E9%98%B2%E7%81%AB%E5%A2%99iptable/</url>
    <content><![CDATA[<p>iptables是一个命令行防火墙实用程序，它使用策略链来允许或阻止流量。 当连接尝试在您的系上建立自己时，iptables会在其列表中查找与其匹配的规则。 如果不到，则转到默认操作。</p>
<h4 id="drop-掉所有类型的端口"><a href="#drop-掉所有类型的端口" class="headerlink" title="drop 掉所有类型的端口"></a>drop 掉所有类型的端口</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -P INPUT DROP</span><br><span class="line">iptables -P FORWARD DROP</span><br><span class="line">iptables -P OUTPUT DROP</span><br></pre></td></tr></table></figure>
<h4 id="查看当前规则"><a href="#查看当前规则" class="headerlink" title="查看当前规则"></a>查看当前规则</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -L -n</span><br></pre></td></tr></table></figure>
<h4 id="只打开22端口的进出配置以及保存命令如下："><a href="#只打开22端口的进出配置以及保存命令如下：" class="headerlink" title="只打开22端口的进出配置以及保存命令如下："></a>只打开22端口的进出配置以及保存命令如下：</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 26666 -j ACCEPT</span><br><span class="line">iptables -A OUTPUT -p tcp --sport 26666 -j ACCEPT</span><br><span class="line">service iptables save</span><br></pre></td></tr></table></figure>
<p>-A 参数就看成是添加一条 INPUT 的规则<br>-p 指定是什么协议 我们常用的tcp 协议<br>–dport 就是目标端口 当数据从外部进入服务器为目标端口<br>反之 数据从服务器出去 则为数据源端口 使用 –sport<br>-j 就是指定是 ACCEPT 接收 或者 DROP 不接收</p>
<h4 id="删除规则"><a href="#删除规则" class="headerlink" title="删除规则"></a>删除规则</h4><p>查看规则行标：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -L -n --line-number</span><br></pre></td></tr></table></figure>
<p>根据行标num删除对应规则：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -D INPUT 2</span><br></pre></td></tr></table></figure>
<p>注意删除之后行号会缩进，原本的6编程5，以免误删。</p>
<h2 id="保存或恢复iptables规则"><a href="#保存或恢复iptables规则" class="headerlink" title="保存或恢复iptables规则"></a>保存或恢复iptables规则</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables-save &gt; somefile</span><br><span class="line">iptables-restore &lt; somefiles</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>公司项目随想</title>
    <url>/2019/04/15/%E5%85%AC%E5%8F%B8%E9%A1%B9%E7%9B%AE%E9%9A%8F%E6%83%B3/</url>
    <content><![CDATA[<p><a href="http://note.youdao.com/noteshare?id=d7e137587951ea943c71d39df6fbcd5f">http://note.youdao.com/noteshare?id=d7e137587951ea943c71d39df6fbcd5f</a></p>
]]></content>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title>关于安装shadowsocks之后的iptables配置的坑</title>
    <url>/2019/04/15/%E5%85%B3%E4%BA%8E%E5%AE%89%E8%A3%85shadowsocks%E4%B9%8B%E5%90%8E%E7%9A%84iptables%E9%85%8D%E7%BD%AE%E7%9A%84%E5%9D%91/</url>
    <content><![CDATA[<p>利用shadowsocks科学上网的搭建方法网上教程很多，可以参考这个：<br><a href="https://www.vultrblog.com/vultr-ss.html">https://www.vultrblog.com/vultr-ss.html</a></p>
<h4 id="为了防止上面的地址被墙，记录一下command"><a href="#为了防止上面的地址被墙，记录一下command" class="headerlink" title="为了防止上面的地址被墙，记录一下command"></a>为了防止上面的地址被墙，记录一下command</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget --no-check-certificate -O shadowsocks.sh https://raw.githubusercontent.com/teddysun/shadowsocks_install/master/shadowsocks.sh</span><br><span class="line"></span><br><span class="line">chmod +x shadowsocks.sh</span><br><span class="line"></span><br><span class="line">./shadowsocks.sh 2&gt;&amp;1 | tee shadowsocks.log</span><br></pre></td></tr></table></figure>

<h4 id="修改shadowsocks端口"><a href="#修改shadowsocks端口" class="headerlink" title="修改shadowsocks端口"></a>修改shadowsocks端口</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /etc/shadowsocks.json</span><br><span class="line"></span><br><span class="line">/etc/init.d/shadowsocks restart</span><br></pre></td></tr></table></figure>

<p>我shadowsocks配置的端口是19726，所以iptables正确的配置命令是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 19726 -j ACCEPT</span><br><span class="line">iptables -I INPUT -m state --state NEW,ESTABLISHED,RELATED -j ACCEPT</span><br><span class="line">iptables -I INPUT -m state --state INVALID -j DROP</span><br><span class="line">service iptable save</span><br></pre></td></tr></table></figure>

<p>网上很多配置上面最后二条命令。</p>
]]></content>
      <categories>
        <category>shadowsocks</category>
      </categories>
      <tags>
        <tag>shadowsocks</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系列之工作流</title>
    <url>/2019/04/23/Java%E7%B3%BB%E5%88%97%E4%B9%8B%E5%B7%A5%E4%BD%9C%E6%B5%81/</url>
    <content><![CDATA[<p><a href="http://note.youdao.com/noteshare?id=7d92d13a66b9935efb45b39e504f228f">http://note.youdao.com/noteshare?id=7d92d13a66b9935efb45b39e504f228f</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>工作流</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>工作流</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系列之多线程并发</title>
    <url>/2019/04/23/Java%E7%B3%BB%E5%88%97%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B9%B6%E5%8F%91/</url>
    <content><![CDATA[<h1 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h1><p><a href="https://www.baeldung.com/tag/java-concurrency/">https://www.baeldung.com/tag/java-concurrency/</a><br><a href="https://www.baeldung.com/java-concurrent-locks">https://www.baeldung.com/java-concurrent-locks</a></p>
<h2 id="Overview-of-the-java-util-concurrent"><a href="#Overview-of-the-java-util-concurrent" class="headerlink" title="Overview of the java.util.concurrent"></a>Overview of the java.util.concurrent</h2><p><a href="https://www.baeldung.com/java-util-concurrent">https://www.baeldung.com/java-util-concurrent</a></p>
<ul>
<li>Executor</li>
<li>ExecutorService</li>
<li>ScheduledExecutorService</li>
<li>Future</li>
<li>CountDownLatch</li>
<li>CyclicBarrier</li>
<li>Semaphore</li>
<li>ThreadFactory</li>
<li>BlockingQueue</li>
<li>DelayQueue</li>
<li>Locks</li>
<li>Phaser</li>
</ul>
<h3 id="Semaphores-in-Java-API"><a href="#Semaphores-in-Java-API" class="headerlink" title="Semaphores in Java API"></a>Semaphores in Java API</h3><p><a href="https://www.baeldung.com/java-semaphore">https://www.baeldung.com/java-semaphore</a></p>
<h2 id="多线程知识的要点"><a href="#多线程知识的要点" class="headerlink" title="多线程知识的要点"></a>多线程知识的要点</h2><p><a href="https://zhuanlan.zhihu.com/p/29881777">参考自知乎这篇文章</a></p>
<h2 id="ThreadPoolExecutor-四种处理策略"><a href="#ThreadPoolExecutor-四种处理策略" class="headerlink" title="ThreadPoolExecutor 四种处理策略"></a>ThreadPoolExecutor 四种处理策略</h2><p>ThreadPoolExecutor.AbortPolicy()  抛出java.util.concurrent.RejectedExecutionException异常<br>ThreadPoolExecutor.CallerRunsPolicy() 重试添加当前的任务，他会自动重复调用execute()方法<br>ThreadPoolExecutor.DiscardOldestPolicy() 抛弃旧的任务<br>ThreadPoolExecutor.DiscardPolicy() 抛弃当前的任务 </p>
<h2 id="锁对象的声明"><a href="#锁对象的声明" class="headerlink" title="锁对象的声明"></a>锁对象的声明</h2><p>如果只是简单的一个锁对象，没有类额外的对象状态变更的话，可以将锁声明为final：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 来自org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter</span><br><span class="line">// Spring Security token校验机制</span><br><span class="line">private final Object delegateMonitor = new Object();</span><br></pre></td></tr></table></figure>

<h2 id="乐观锁-vs-悲观锁（PCC）"><a href="#乐观锁-vs-悲观锁（PCC）" class="headerlink" title="乐观锁 vs 悲观锁（PCC）"></a>乐观锁 vs 悲观锁（PCC）</h2><p><a href="http://www.imooc.com/article/285147">http://www.imooc.com/article/285147</a></p>
<h2 id="为什么要写成-final-ReentrantLock-lock-x3D-this-lock"><a href="#为什么要写成-final-ReentrantLock-lock-x3D-this-lock" class="headerlink" title="为什么要写成 final ReentrantLock lock &#x3D; this.lock; ?"></a>为什么要写成 final ReentrantLock lock &#x3D; this.lock; ?</h2><p><a href="https://blog.csdn.net/zqz_zqz/article/details/79438502">https://blog.csdn.net/zqz_zqz&#x2F;article&#x2F;details&#x2F;79438502</a></p>
<h2 id="LockSupport-parkNanos-1L"><a href="#LockSupport-parkNanos-1L" class="headerlink" title="LockSupport.parkNanos(1L); ???"></a>LockSupport.parkNanos(1L); ???</h2><h2 id="统计当前线程存活量"><a href="#统计当前线程存活量" class="headerlink" title="统计当前线程存活量"></a>统计当前线程存活量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while (Thread.activeCount() &gt; 1) &#123;</span><br><span class="line">    // do something.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单例双重锁定检查（Double-Checked-Locking-with-Singleton）"><a href="#单例双重锁定检查（Double-Checked-Locking-with-Singleton）" class="headerlink" title="单例双重锁定检查（Double-Checked Locking with Singleton）"></a>单例双重锁定检查（Double-Checked Locking with Singleton）</h2><p><a href="https://www.baeldung.com/java-singleton-double-checked-locking">https://www.baeldung.com/java-singleton-double-checked-locking</a></p>
<h2 id="必要时可以用上线程优先级来实现一些业务逻辑"><a href="#必要时可以用上线程优先级来实现一些业务逻辑" class="headerlink" title="必要时可以用上线程优先级来实现一些业务逻辑"></a>必要时可以用上线程优先级来实现一些业务逻辑</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Thread.currentThread().setPriority(Thread.MIN_PRIORITY);</span><br><span class="line">System.out.println(Thread.currentThread().getPriority());</span><br><span class="line">Thread.currentThread().setPriority(Thread.MAX_PRIORITY);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><a href="http://note.youdao.com/noteshare?id=5a758a5214a793176ed9c543a2011217">老旧的有道云笔记</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系列之设计模式随想</title>
    <url>/2019/04/23/Java%E7%B3%BB%E5%88%97%E4%B9%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E9%9A%8F%E6%83%B3/</url>
    <content><![CDATA[<p>父类 protected方法，通常应用于让子类自我重写，实现子类逻辑的差异化。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac加虚拟机实现华为TSMAgent认证代理</title>
    <url>/2019/04/28/Mac%E5%8A%A0%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%9E%E7%8E%B0%E5%8D%8E%E4%B8%BATSMAgent%E8%AE%A4%E8%AF%81%E4%BB%A3%E7%90%86/</url>
    <content><![CDATA[<p><a href="http://note.youdao.com/noteshare?id=38b5ac0d5bf70cd7796ca9a1e2f4bf4f">http://note.youdao.com/noteshare?id=38b5ac0d5bf70cd7796ca9a1e2f4bf4f</a></p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle系列之性能调优</title>
    <url>/2019/04/28/oracle%E7%B3%BB%E5%88%97%E4%B9%8B%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<p><a href="http://note.youdao.com/noteshare?id=9162b83c7c234ae534289003bc2ebb0e">http://note.youdao.com/noteshare?id=9162b83c7c234ae534289003bc2ebb0e</a></p>
]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列之策略模式</title>
    <url>/2019/05/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="http://note.youdao.com/noteshare?id=ba9e1f8e3298f010daf0e795401e8555">http://note.youdao.com/noteshare?id=ba9e1f8e3298f010daf0e795401e8555</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构系列之链表（Java）</title>
    <url>/2019/04/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E4%B9%8B%E9%93%BE%E8%A1%A8-Java/</url>
    <content><![CDATA[<p><a href="https://leetcode-cn.com/tag/linked-list/">leetcode链表专题</a></p>
<h2 id="链表分别都对应了那些Java类？"><a href="#链表分别都对应了那些Java类？" class="headerlink" title="链表分别都对应了那些Java类？"></a>链表分别都对应了那些Java类？</h2><ul>
<li>java.util.ArrayList</li>
<li>java.util.LinkedList</li>
<li>java.util.concurrent.CopyOnWriteArrayList</li>
</ul>
<h2 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h2><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/X2alLM.png"><br>单向链表包含两个域：</p>
<ul>
<li>信息域（上图的data，存放结点数据）</li>
<li>指针域（上图的next，链接指向列表中的下一个结点，而最后一个结点则指向一个空值）</li>
</ul>
<p><em><strong>每个结点只有一个指针的链表也叫单向链表，或者单链表。</strong></em></p>
<h3 id="在链表表头插入新结点"><a href="#在链表表头插入新结点" class="headerlink" title="在链表表头插入新结点"></a>在链表表头插入新结点</h3><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/AbY5Jl.png"><br>此时只需要变更Head的指向。</p>
<h3 id="在链表中间插入新结点"><a href="#在链表中间插入新结点" class="headerlink" title="在链表中间插入新结点"></a>在链表中间插入新结点</h3><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/zFgr4G.png"><br>此时需要变更front node的next值，将其指向new node，new node的next值指向next node。</p>
<h3 id="带头结点和尾结点的单链表"><a href="#带头结点和尾结点的单链表" class="headerlink" title="带头结点和尾结点的单链表"></a>带头结点和尾结点的单链表</h3><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/rlUd5C.png"><br>在不带头结点的单链表中，插入和删除都需要区分操作的结点下标，在链表表头插入新结点与在链表中间插入新结点是不同的。<br>而在带头结点的单链表中，就不再需要做这样的区分。<br>在带头结点的链表表头插入新结点：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/odYgoS.png"><br>在带头结点的链表中间插入新结点：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/hW9eHt.png"><br>上面操作都是变更front node的next值，将其指向new node，new node的next值指向next node。<br>删除结点同理。</p>
<h4 id="尾部插入"><a href="#尾部插入" class="headerlink" title="尾部插入"></a>尾部插入</h4><p>为了使链表在尾部插入时也和上面的头部、中间插入一直，以及达到更加高效，可在链表增加一个尾部指向的尾结点，这样一来，在尾部添加结点时，只要通过尾结点直接操作即可，无需从表头遍历到表尾。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/PWjUfy.png"><br>如上图，通过尾结点可能快速定位到front node，然后操作依然是变更front node的next值，将其指向new node，new node的next值指向next node（尾结点）。</p>
<blockquote>
<p>这样一来，头部、中间和尾部插入就可以视为同一种操作逻辑了。</p>
</blockquote>
<h3 id="循环单链表"><a href="#循环单链表" class="headerlink" title="循环单链表"></a>循环单链表</h3><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/GW4slV.png"><br>循环链表在实现遍历的时候要注意避免死循环，判断遍历到尾结点即可停止。</p>
<h3 id="单链表-vs-顺序表"><a href="#单链表-vs-顺序表" class="headerlink" title="单链表 vs 顺序表"></a>单链表 vs 顺序表</h3><p>由于不必须按顺序存储，链表在插入的时候可以达到 O(1) 的复杂度，比另一种线性表 —— 顺序表快得多，但是查找一个结点或者访问特定编号的结点则需要 O(n) 的时间，而顺序表相应的时间复杂度分别是 O(log n) 和 O(1)。<br>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。<br>在计算机科学中，链表作为一种基础的数据结构可以用来生成其它类型的数据结构。链表通常由一连串结点组成，每个结点包含任意的实例数据（data fields）和一或两个用来指向上一个&#x2F;或下一个结点的位置的链接（links）。链表最明显的好处就是，常规数组排列关联项目的方式可能不同于这些数据项目在记忆体或磁盘上顺序，数据的访问往往要在不同的排列顺序中转换。而链表是一种自我指示数据类型，因为它包含指向另一个相同类型的数据的指针（链接）。</p>
<blockquote>
<p>来源：<a href="https://leetcode-cn.com/tag/linked-list/">https://leetcode-cn.com/tag/linked-list/</a></p>
</blockquote>
<h3 id="单链表的弊端"><a href="#单链表的弊端" class="headerlink" title="单链表的弊端"></a>单链表的弊端</h3><p>指针域中没有前驱指针，无法知道前驱结点，假如指针this指向某个结点，想要在this的前面插入一个结点或删除this所在结点时，必须从链表的表头遍历至this的前一个结点再执行插入或者删除操作，这种情况使用双链表就更为高效了。</p>
<h2 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h2><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/Y1Zb9A.png"></p>
<ul>
<li>信息域（存放结点数据）</li>
<li>指针域（有两个链接）<ul>
<li>前链接：指向前一个结点，当此“前链接”为第一个时，指向空值或者空列表；</li>
<li>后链接：指向下一个结点，当此“后连接”为最后一个时，指向空值或者空列表；</li>
</ul>
</li>
</ul>
<p>双向链表也叫双链表。双链表可以从任何一个结点访问前一个结点，当然也可以访问后一个结点，</p>
<h3 id="java-util-LinkedList双链表的实现逻辑"><a href="#java-util-LinkedList双链表的实现逻辑" class="headerlink" title="java.util.LinkedList双链表的实现逻辑"></a>java.util.LinkedList双链表的实现逻辑</h3><blockquote>
<p>分析java.util.LinkedList的源码可以发现有成员变量<code>transient Node&lt;E&gt; first;</code>和<code>transient Node&lt;E&gt; last;</code>。</p>
</blockquote>
<p>初始化状态：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/gNi1Bf.png"><br>java.util.LinkedList插入数据的代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static class Node&lt;E&gt; &#123;</span><br><span class="line">    E item;</span><br><span class="line">    Node&lt;E&gt; next;</span><br><span class="line">    Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">        this.item = element;</span><br><span class="line">        this.next = next;</span><br><span class="line">        this.prev = prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    linkLast(e);</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void linkLast(E e) &#123;</span><br><span class="line">    final Node&lt;E&gt; l = last;</span><br><span class="line">    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</span><br><span class="line">    last = newNode;</span><br><span class="line">    if (l == null)</span><br><span class="line">        first = newNode;</span><br><span class="line">    else</span><br><span class="line">        l.next = newNode;</span><br><span class="line">    size++;</span><br><span class="line">    modCount++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可见空双链表插入第一个结点时，判断尾结点是否为空，如果为空是在first头结点插入，否则是插入到尾部结点之后，如图：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/zhs4xu.png"><br>当再次插入新结点时，如图：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/q0mXuS.png"></p>
<h2 id="循环双链表"><a href="#循环双链表" class="headerlink" title="循环双链表"></a>循环双链表</h2><p>空循环双链表：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/PJEkBp.png"><br>插入新结点：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/eyY1Zv.png"></p>
<h2 id="排序双链表"><a href="#排序双链表" class="headerlink" title="排序双链表"></a>排序双链表</h2><p>元素对象可以实现Comoarable接口，通过<code>compareTo</code>方法在插入元素的时候做对比。</p>
<h2 id="静态链表"><a href="#静态链表" class="headerlink" title="静态链表"></a>静态链表</h2><p>分配一整片连续的内存空间，各个结点集中安置。如图（图片来源王道考研）：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/X64NBw.png"></p>
<blockquote>
<p>静态链表内部也是要基于数组来实现。</p>
</blockquote>
<h2 id="链表的利与弊"><a href="#链表的利与弊" class="headerlink" title="链表的利与弊"></a>链表的利与弊</h2><p>使用链表的好处：</p>
<ul>
<li>链表在初始化时仅需要分配一个元素的存储空间，在内存分配上可以是不连续的内存，也不需要做任何内存复制和重新分配的操作，在访问单个元素的时间开销会更少。</li>
<li>链表在插入和删除结点方面相较于顺序表是十分高效的，因此链表比较适合那些插入删除频繁的场景使用。</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>设计模式系列之状态模式</title>
    <url>/2019/05/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%B3%BB%E5%88%97%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<p><a href="http://note.youdao.com/noteshare?id=9346be53ca0e314879de34bac525e06e">http://note.youdao.com/noteshare?id=9346be53ca0e314879de34bac525e06e</a></p>
]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Interview汇总</title>
    <url>/2019/10/15/Interview%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<blockquote>
<p><a href="http://www.xmind.net/m/RHmqYQ">Interview Tech XMind</a></p>
</blockquote>
<h1 id="CS"><a href="#CS" class="headerlink" title="CS"></a>CS</h1><h2 id="32位和64位系统底层的本质区别是什么？"><a href="#32位和64位系统底层的本质区别是什么？" class="headerlink" title="32位和64位系统底层的本质区别是什么？"></a>32位和64位系统底层的本质区别是什么？</h2><h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><p><a href="https://juejin.im/post/5e37b8ea6fb9a030080ca2df">2020年2月面试题100+大全（合适各级Java人员）</a></p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="通过new-String-“test”-与-“test”-与运行时常量池的关系"><a href="#通过new-String-“test”-与-“test”-与运行时常量池的关系" class="headerlink" title="通过new String(“test”) 与 “test” 与运行时常量池的关系"></a>通过new String(“test”) 与 “test” 与运行时常量池的关系</h3><ul>
<li>String a &#x3D; “aaa”;（保存在常量池中的）</li>
<li>String b &#x3D; new String(“aaa”);（new创建的对象会存放在堆内存中）</li>
</ul>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="ArrayList-vs-LinkedList-vs-SynchronizedList-vs-CopyOnWriteArrayList"><a href="#ArrayList-vs-LinkedList-vs-SynchronizedList-vs-CopyOnWriteArrayList" class="headerlink" title="ArrayList vs LinkedList vs SynchronizedList vs CopyOnWriteArrayList"></a>ArrayList vs LinkedList vs SynchronizedList vs CopyOnWriteArrayList</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p>ArrayList底层使用的是数组实现，也就是基于顺序表的原理，是线程不安全的。<br>默认初始化的时候，其内部的数组是一个静态的空数组：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private static final int DEFAULT_CAPACITY = 10;</span><br><span class="line">private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line">transient Object[] elementData; // non-private to simplify nested class access</span><br><span class="line">private int size;</span><br><span class="line">public ArrayList() &#123;</span><br><span class="line">    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以在初始化的时候指定默认容量，或者指定默认要承接的集合数据：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ArrayList(int initialCapacity) &#123;</span><br><span class="line">    if (initialCapacity &gt; 0) &#123;</span><br><span class="line">        this.elementData = new Object[initialCapacity];</span><br><span class="line">    &#125; else if (initialCapacity == 0) &#123;</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+</span><br><span class="line">                                           initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public ArrayList(Collection&lt;? extends E&gt; c) &#123;</span><br><span class="line">    elementData = c.toArray();</span><br><span class="line">    if ((size = elementData.length) != 0) &#123;</span><br><span class="line">        // c.toArray might (incorrectly) not return Object[] (see 6260652)</span><br><span class="line">        if (elementData.getClass() != Object[].class)</span><br><span class="line">            elementData = Arrays.copyOf(elementData, size, Object[].class);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // replace with empty array.</span><br><span class="line">        this.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当数组为空或者数组长度不够进行扩容的长度增长因子一般是1.5（但是要注意极端情况下，扩容到大于<code>Integer.MAX_VALUE-8</code>，会默认增长到ArrayList的最大长度<code>Integer.MAX_VALUE</code>，超过最大长度将抛出OutOfMemoryError异常）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private void grow(int minCapacity) &#123;</span><br><span class="line">    // overflow-conscious code</span><br><span class="line">    int oldCapacity = elementData.length;</span><br><span class="line">    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</span><br><span class="line">    if (newCapacity - minCapacity &lt; 0)</span><br><span class="line">        newCapacity = minCapacity;</span><br><span class="line">    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</span><br><span class="line">        newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">    // minCapacity is usually close to size, so this is a win:</span><br><span class="line">    elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>ArrayList因为其扩容因子是<code>1.5</code>，其内部的数组会预留出一定的空间，所以从资源利用的角度来讲，这存在一定程度的浪费。<br>正因为是基于顺序表原来实现，ArrayList元素的物理存储地址是连续的，在其内部数组中间插入或者删除元素的话，其后面的所有元素都要进行移位，所以性能开销会相对较大。</p>
</blockquote>
<h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p>LinkedList底层使用的是双链表来实现的，它默认初始化之后有着头尾两个空结点，同样也是线程不安全的。<br>可见空双链表插入第一个结点时，判断尾结点是否为空，如果为空是在first头结点插入，否则是插入到尾部结点之后。</p>
<blockquote>
<p>LinkedList得益于双链表的数据结构优势，在对单个元素的插入和删除操作上，一般性能开销会相对较小，但是在单个元素的访问上，会表现较差。</p>
</blockquote>
<h4 id="快速失败迭代器（fail-fast-Iterator）"><a href="#快速失败迭代器（fail-fast-Iterator）" class="headerlink" title="快速失败迭代器（fail-fast Iterator）"></a>快速失败迭代器（fail-fast Iterator）</h4><p>ArrayList、LinkedList等很多常用集合的Iterator实现中，都是通过快速失败检查机制来检查数据是否在外部不被期望的情况下修改了，常见的快速失败检查都是通过如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final void checkForComodification() &#123;</span><br><span class="line">    if (modCount != expectedModCount)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>异常时通过判断expectedModCount是否等于modCount，如果不相等就抛出异常。</p>
<ul>
<li>expectedModCount：被期望的修改次数，在Iterator初始化的时候被赋值，<code>int expectedModCount = modCount;</code>，在调用迭代器的remove方法时会被更新。</li>
<li>modCount：真实的修改次数，每次调用add()，remove()方法（非迭代器的方法）会导致modCount+1。</li>
</ul>
<p>迭代器在调用<code>next()</code>和<code>remove()</code>都会做<code>ConcurrentModificationException</code>的异常检测。</p>
<blockquote>
<p>所以，当集合是使用迭代器Iterator来遍历的时候，删除集合的元素记得用迭代器的<code>remove()</code>方法。</p>
</blockquote>
<h4 id="SynchronizedList（线程安全）"><a href="#SynchronizedList（线程安全）" class="headerlink" title="SynchronizedList（线程安全）"></a>SynchronizedList（线程安全）</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 线程安全List的创建方式</span><br><span class="line">List&lt;Object&gt; syncArrayList = Collections.synchronizedList(new ArrayList&lt;&gt;());</span><br><span class="line">List&lt;Object&gt; syncLinkedList = Collections.synchronizedList(new LinkedList&lt;&gt;());</span><br></pre></td></tr></table></figure>
<p>线程安全实现原理：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final Object mutex;     // Object on which to synchronize</span><br></pre></td></tr></table></figure>
<p>其内部具有线程安全问题的方法都被互斥量加了锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public int size() &#123;</span><br><span class="line">    synchronized (mutex) &#123;return c.size();&#125;</span><br><span class="line">&#125;</span><br><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    synchronized (mutex) &#123;return c.add(e);&#125;</span><br><span class="line">&#125;</span><br><span class="line">public boolean remove(Object o) &#123;</span><br><span class="line">    synchronized (mutex) &#123;return c.remove(o);&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h4><p>CopyOnWriteArrayList和ArrayList类似，其内部也是基于数组实现的，但是还额外多出了一个可重入锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/** The lock protecting all mutators */</span><br><span class="line">final transient ReentrantLock lock = new ReentrantLock();</span><br><span class="line">/** The array, accessed only via getArray/setArray. */</span><br><span class="line">private transient volatile Object[] array;</span><br></pre></td></tr></table></figure>
<p>因为加了transient修饰，所以其数据不支持序列化。<br>另外其内部存储数据的数组是通过volatile修饰的，避免了线程安全的问题。<br>插入和删除操作也加了锁机制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public boolean add(E e) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + 1);</span><br><span class="line">        newElements[len] = e;</span><br><span class="line">        setArray(newElements);</span><br><span class="line">        return true;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public E remove(int index) &#123;</span><br><span class="line">    final ReentrantLock lock = this.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    try &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        int len = elements.length;</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        int numMoved = len - index - 1;</span><br><span class="line">        if (numMoved == 0)</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - 1));</span><br><span class="line">        else &#123;</span><br><span class="line">            Object[] newElements = new Object[len - 1];</span><br><span class="line">            System.arraycopy(elements, 0, newElements, 0, index);</span><br><span class="line">            System.arraycopy(elements, index + 1, newElements, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        return oldValue;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>SynchronizedList是通过对读写方法使用synchronized修饰来实现同步的，即便只是多个线程在读数据，也不能进行，如果是读比较多的场景下，会性能不高，所以适合读写均匀的情况。<br>而CopyOnWriteArrayList是读写分离的，只对写操作加锁，但是每次写操作(添加和删除元素等)时都会复制出一个新数组，完成修改后，然后将新数组设置到旧数组的引用上，所以在写比较多的情况下，会有很大的性能开销，所以适合读比较多的应用场景。</p>
</blockquote>
<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="B-树和二叉树的区别"><a href="#B-树和二叉树的区别" class="headerlink" title="B+树和二叉树的区别"></a>B+树和二叉树的区别</h2><h2 id="红黑树和跳表"><a href="#红黑树和跳表" class="headerlink" title="红黑树和跳表"></a>红黑树和跳表</h2><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h2 id="一个接口太多事务操作是否要使用批量事务？"><a href="#一个接口太多事务操作是否要使用批量事务？" class="headerlink" title="一个接口太多事务操作是否要使用批量事务？"></a>一个接口太多事务操作是否要使用批量事务？</h2><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><p><a href="https://www.jianshu.com/p/ffe5ebe17c3a">SpringBoot VS Spring</a></p>
<h2 id="SpringBoot自动装配原理"><a href="#SpringBoot自动装配原理" class="headerlink" title="SpringBoot自动装配原理"></a>SpringBoot自动装配原理</h2><h1 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h1><h2 id="OLAP和OLTP"><a href="#OLAP和OLTP" class="headerlink" title="OLAP和OLTP"></a>OLAP和OLTP</h2><h2 id="冗余字段"><a href="#冗余字段" class="headerlink" title="冗余字段"></a>冗余字段</h2><p>微服务架构加上前后端分离的情况下。后端接口很多时候会出现太多联表查询的情况。其实可以数据库存储空间大小允许的情况下，留出一些关键字段的冗余字段来代替联表查询。甚至可以将一些数据拆分出来查询封装成比较合适的数据JSON结构，然后可以将需要连表查询的逻辑放到前端去计算拼接，这样一来可以减少服务器和数据库的压力，同时前端做这部分的计算能力其实也是绰绰有余了，毕竟目前相对来说这是一个用户端性能过剩的时代。</p>
<p>尽可能多的冗余字段也可以为一定业务场景带来便捷的查询，没必要一味得遵循数据库三方式。</p>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>必要时，时间字段也要上索引，索引一般是建立在字段值重复性比较少的，很多时候，时间字段基本不会重复，而且查询排序经常用到。</p>
<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><h2 id="redis如何清理过期key"><a href="#redis如何清理过期key" class="headerlink" title="redis如何清理过期key"></a>redis如何清理过期key</h2><h2 id="redis内存不足时的策略"><a href="#redis内存不足时的策略" class="headerlink" title="redis内存不足时的策略"></a>redis内存不足时的策略</h2><h2 id="缓存更新的套路"><a href="#缓存更新的套路" class="headerlink" title="缓存更新的套路"></a>缓存更新的套路</h2><p><a href="https://coolshell.cn/articles/17416.html[]">https://coolshell.cn/articles/17416.html[]</a>(<a href="https://coolshell.cn/articles/17416.html">https://coolshell.cn/articles/17416.html</a> “”)</p>
<h3 id="Cache-Aside-Pattern"><a href="#Cache-Aside-Pattern" class="headerlink" title="Cache Aside Pattern"></a>Cache Aside Pattern</h3><h3 id="Read-x2F-Write-Through-Pattern"><a href="#Read-x2F-Write-Through-Pattern" class="headerlink" title="Read&#x2F;Write Through Pattern"></a>Read&#x2F;Write Through Pattern</h3><h3 id="Write-Behind-Caching-Pattern"><a href="#Write-Behind-Caching-Pattern" class="headerlink" title="Write Behind Caching Pattern"></a>Write Behind Caching Pattern</h3><h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h2 id="Ribbon或者Nacos负载均衡有多少种实现机制？"><a href="#Ribbon或者Nacos负载均衡有多少种实现机制？" class="headerlink" title="Ribbon或者Nacos负载均衡有多少种实现机制？"></a>Ribbon或者Nacos负载均衡有多少种实现机制？</h2><h3 id="轮询调用"><a href="#轮询调用" class="headerlink" title="轮询调用"></a>轮询调用</h3><h2 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h2><h3 id="注册中心的作用是什么？"><a href="#注册中心的作用是什么？" class="headerlink" title="注册中心的作用是什么？"></a>注册中心的作用是什么？</h3><h3 id="注册中心的实现机制"><a href="#注册中心的实现机制" class="headerlink" title="注册中心的实现机制"></a>注册中心的实现机制</h3><ul>
<li>基于心跳包在注册中心与各个微服务之间保持通讯</li>
</ul>
<h3 id="Eureka-VS-Nacos"><a href="#Eureka-VS-Nacos" class="headerlink" title="Eureka VS Nacos"></a>Eureka VS Nacos</h3><h1 id="Combo"><a href="#Combo" class="headerlink" title="Combo"></a>Combo</h1><h2 id="后端架构"><a href="#后端架构" class="headerlink" title="后端架构"></a>后端架构</h2><p>每一个单一表的对应Service类里面有且只能有一个Mapper，这也遵守了类的单一责任原则。</p>
<h3 id="微服务架构的好处"><a href="#微服务架构的好处" class="headerlink" title="微服务架构的好处"></a>微服务架构的好处</h3><ul>
<li>解耦：系统之间业务的解耦，代码的维护和扩展比较方面；</li>
<li>影响面会更小：降低系统的依赖风险，微服务之后，如果某个单一模块业务代码出现问题，其影响可以控制在相对来说较小的范围；</li>
<li>三高：高并发、高流量、高可用性；扩容的时候可以针对某些处理业务比较繁忙的微服务模块进行水平扩容。</li>
</ul>
<h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>类似DO、DTO、VO这种有可能要做传输的类一定不要忘记实现Serializable，和唯一标识化serialVersionUID。</p>
<h2 id="COW（写时复制-x2F-Copy-on-write）"><a href="#COW（写时复制-x2F-Copy-on-write）" class="headerlink" title="COW（写时复制&#x2F;Copy-on-write）"></a>COW（写时复制&#x2F;Copy-on-write）</h2><p>Copy-on-write在对数据进行修改的时候，不会直接在原来的数据位置上进行操作，而是重新找个位置修改，这样的好处是一旦系统故障，能保证数据的完整性，容易恢复。</p>
<ul>
<li>比如说：要修改数据块A的内容，先把A读出来，写到B块里面去。如果这时候断电了，原来A的内容还在！</li>
</ul>
<h1 id="各种问题模拟回答"><a href="#各种问题模拟回答" class="headerlink" title="各种问题模拟回答"></a>各种问题模拟回答</h1><h2 id="描述一下什么是IO-x2F-NIO，以及它的原理和各种主流技术之间的关系？"><a href="#描述一下什么是IO-x2F-NIO，以及它的原理和各种主流技术之间的关系？" class="headerlink" title="描述一下什么是IO&#x2F;NIO，以及它的原理和各种主流技术之间的关系？"></a>描述一下什么是IO&#x2F;NIO，以及它的原理和各种主流技术之间的关系？</h2><p>IO是Input&#x2F;Output的简写，然后NIO是New IO的简写，简单来说IO就是我的代码程序去跟计算机的硬件资源做读写交互的一个过程，比如与内存、CPU和硬盘之间的输入和输出交互，与Java相关最常见的就是Socket通讯、文件流的读写、输入流输出流这一些，在Linux系统上可以通过strace命令去跟踪IO流的整一个详细的过程，早期的IO其实存在着一些明显弊端，对计算机的硬件资源利用不够充分，比较浪费CPU和内存资源，所以后面通过技术的改进才有个NIO。<br>NIO最关键的地方就是基于Linux的epoll对IO做了一个很大的改进，epoll更充分发挥硬件资源，尽量不浪费CPU和内存资源，现在主流的Redis、Nginx和消息队列Kafka这些其实底层都是基于NIO在计算机的一些端口去做网络请求的监听的。</p>
]]></content>
      <categories>
        <category>interview</category>
      </categories>
      <tags>
        <tag>interview</tag>
      </tags>
  </entry>
  <entry>
    <title>JUnit汇总</title>
    <url>/2019/10/15/JUnit%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="RunWith"><a href="#RunWith" class="headerlink" title="@RunWith"></a>@RunWith</h2><p>查阅官方API文档如下：<br>When a class is annotated with @RunWith or extends a class annotated with @RunWith, JUnit will invoke the class it references to run the tests in that class instead of the runner built into JUnit. We added this feature late in development. While it seems powerful we expect the runner API to change as we learn how people really use it. Some of the classes that are currently internal will likely be refined and become public. For example, suites in JUnit 4 are built using RunWith, and a custom runner named Suite:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(Suite.class)</span><br><span class="line">@SuiteClasses(ATest.class, BTest.class, CTest.class)</span><br><span class="line">public class ABCSuite &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>翻译：当一个类被@RunWith所注解或者继承了一个被@RunWith注解的父类，那么Junit将会调用到这个类它所引用到的测试类，而不是通过Junit构建的runner（运行器）去调用。</p>
<p>可以参考：<br><a href="https://www.tutorialspoint.com/junit/junit_suite_test.htm">https://www.tutorialspoint.com/junit/junit_suite_test.htm</a><br><a href="https://www.codejava.net/testing/junit-test-suite-example-how-to-create-and-run-test-suite-in-command-line-and-eclipse">https://www.codejava.net/testing/junit-test-suite-example-how-to-create-and-run-test-suite-in-command-line-and-eclipse</a></p>
<h2 id="结合Spring上下文做测试"><a href="#结合Spring上下文做测试" class="headerlink" title="结合Spring上下文做测试"></a>结合Spring上下文做测试</h2><p>在以往的Spring项目中，很多同学可能没有做到真正的单元测试，可能都是基于测试环境启动整个应用来针对功能做测试，这种方式其实效率是非常低的，利用JUnit的特性做Spring的单元测试可以如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.context.ApplicationContext;</span><br><span class="line">import org.springframework.test.context.ContextConfiguration;</span><br><span class="line">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * 代码来源：https://my.oschina.net/itblog/blog/1550753</span><br><span class="line"> */</span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(locations = &#123; &quot;classpath:applicationContext.xml&quot; &#125;)</span><br><span class="line">public class UserManagerTest &#123;</span><br><span class="line">　　@Autowired</span><br><span class="line">　　ApplicationContext ctx;</span><br><span class="line"></span><br><span class="line">　　@Test</span><br><span class="line">　　public void testAddUser() &#123;</span><br><span class="line">　　　　try &#123;</span><br><span class="line">　　　　　　UserManager userManager = ctx.getBean(UserManager.class); </span><br><span class="line">　　　　　　userManager.addUser();</span><br><span class="line">　　　　&#125; catch (Exception e) &#123;</span><br><span class="line">　　　　　　e.printStackTrace();</span><br><span class="line">　　　　&#125;</span><br><span class="line">　　&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子是指定一个Spring上下文配置文件的方式进行单元测试，这样子就加载很多本次单元测试不用到的注入，Spring官方文档给出了更加高效的方案：<br>Context Configuration with Annotated Classes<br>To load an ApplicationContext for your tests by using annotated classes (see Java-based container configuration), you can annotate your test class with @ContextConfiguration and configure the classes attribute with an array that contains references to annotated classes. The following example shows how to do so:<br>翻译：使用@ContextConfiguration里面的classes属性来指定加载的配置类信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">// ApplicationContext will be loaded from AppConfig and TestConfig</span><br><span class="line">@ContextConfiguration(classes = &#123;AppConfig.class, TestConfig.class&#125;) </span><br><span class="line">public class MyTest &#123;</span><br><span class="line">    // class body...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If you omit the classes attribute from the @ContextConfiguration annotation, the TestContext framework tries to detect the presence of default configuration classes. Specifically, AnnotationConfigContextLoader and AnnotationConfigWebContextLoader detect all static nested classes of the test class that meet the requirements for configuration class implementations, as specified in the @Configuration javadoc. Note that the name of the configuration class is arbitrary. In addition, a test class can contain more than one static nested configuration class if desired. In the following example, the OrderServiceTest class declares a static nested configuration class named Config that is automatically used to load the ApplicationContext for the test class:<br>翻译：此外，Spring官方还提供了更加简要的方式，可以省略掉@ContextConfiguration里面的classes属性。因为TestContext框架会去检测默认存在的配置类，特别是，测试类中存在的内部静态配置类，比如下面代码中的静态配置类将被加载到测试的Spring上下文中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">// ApplicationContext will be loaded from the</span><br><span class="line">// static nested Config class</span><br><span class="line">@ContextConfiguration </span><br><span class="line">public class OrderServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Configuration</span><br><span class="line">    static class Config &#123;</span><br><span class="line"></span><br><span class="line">        // this bean will be injected into the OrderServiceTest class</span><br><span class="line">        @Bean</span><br><span class="line">        public OrderService orderService() &#123;</span><br><span class="line">            OrderService orderService = new OrderServiceImpl();</span><br><span class="line">            // set properties, etc.</span><br><span class="line">            return orderService;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    private OrderService orderService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testOrderService() &#123;</span><br><span class="line">        // test the orderService</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="基于SpringBoot的单元测试"><a href="#基于SpringBoot的单元测试" class="headerlink" title="基于SpringBoot的单元测试"></a>基于SpringBoot的单元测试</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringRunner.class)</span><br><span class="line">@SpringBootTest</span><br><span class="line">@Import(MyTestsConfiguration.class)</span><br><span class="line">public class MyTests &#123;</span><br><span class="line"></span><br><span class="line">	@Test</span><br><span class="line">	public void exampleTest() &#123;</span><br><span class="line">		...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="指定类别的方式去进行多个单元测试"><a href="#指定类别的方式去进行多个单元测试" class="headerlink" title="指定类别的方式去进行多个单元测试"></a>指定类别的方式去进行多个单元测试</h2><p><a href="https://github.com/junit-team/junit4/wiki/Categories">https://github.com/junit-team/junit4/wiki/Categories</a></p>
<h2 id="可以自定义参数化的单元测试"><a href="#可以自定义参数化的单元测试" class="headerlink" title="可以自定义参数化的单元测试"></a>可以自定义参数化的单元测试</h2><p><a href="https://github.com/junit-team/junit4/wiki/Parameterized-tests">https://github.com/junit-team/junit4/wiki/Parameterized-tests</a><br><em><strong>这个暂时还来不及分析场景和用例</strong></em></p>
<p>更多的单元测试尽在<a href="https://github.com/junit-team/junit4/wiki">https://github.com/junit-team/junit4/wiki</a></p>
]]></content>
      <categories>
        <category>JUnit</category>
      </categories>
      <tags>
        <tag>JUnit</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac汇总</title>
    <url>/2019/10/15/Mac%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="Mac-Native-Function"><a href="#Mac-Native-Function" class="headerlink" title="Mac Native Function"></a>Mac Native Function</h1><h2 id="Mac-hotkey"><a href="#Mac-hotkey" class="headerlink" title="Mac hotkey"></a>Mac hotkey</h2><table>
<thead>
<tr>
<th>key</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>cmd + opt + esc</td>
<td>强制退出某个软件。通常在软件无响应时使用</td>
</tr>
<tr>
<td>cmd + shift+ 3</td>
<td>对整个屏幕进行截图</td>
</tr>
<tr>
<td>cmd + shift + 4</td>
<td>对自行选择的区域进行截图</td>
</tr>
<tr>
<td>cmd + shift + 5</td>
<td>更多方式截图和录屏（新版本系统）</td>
</tr>
<tr>
<td>cmd + &#96;</td>
<td>切换同个软件的不同窗口</td>
</tr>
<tr>
<td>cmd + opt + 8</td>
<td>open or close zoom</td>
</tr>
<tr>
<td>cmd + opt + -</td>
<td>zoom in</td>
</tr>
<tr>
<td>cmd + opt + &#x3D;</td>
<td>zoom out</td>
</tr>
<tr>
<td>opt + shift + 方向</td>
<td>先用触摸板选中一处，然后可以通过方向键叠加选中的内容</td>
</tr>
<tr>
<td>^ + A</td>
<td>行首</td>
</tr>
<tr>
<td>^ + E</td>
<td>行尾</td>
</tr>
</tbody></table>
<h2 id="MacOS"><a href="#MacOS" class="headerlink" title="MacOS"></a>MacOS</h2><p>非必要更新软件一定要在空闲时间更新，比如这个：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/TmZg0s.png" alt="macOS_img"><br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/yAU7qe.png" alt="macOS_img"></p>
<p>Dock的最佳位置是放在右边，并且隐藏起来，这样既有较大的屏幕可视区间，也不会经常因为移动鼠标到左边而误触，毕竟MacOS的窗口控制习惯是在左边。</p>
<h2 id="通过命令和粘贴文件"><a href="#通过命令和粘贴文件" class="headerlink" title="通过命令和粘贴文件"></a>通过命令和粘贴文件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将a.txt文件类容写入剪切板，相当于 cmd + C</span><br><span class="line">pbcopy &lt; blogpost.txt</span><br><span class="line">cat a.txt | pbcopy      </span><br><span class="line"># 将主目录的文件列表复制到剪贴板</span><br><span class="line">ls ~ | pbcopy      </span><br><span class="line"># 复制终端当前目录</span><br><span class="line">pwd | pbcopy     </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 将刚刚存入剪切板的a.txt内容复制到终端，相当于 cmd + v</span><br><span class="line">pbpaste              </span><br><span class="line"># 追加内容到对应的文件</span><br><span class="line">pbpaste &gt;&gt; tasklist.txt</span><br></pre></td></tr></table></figure>

<h2 id="Desktop"><a href="#Desktop" class="headerlink" title="Desktop"></a>Desktop</h2><p>把需要专注、高频使用到的软件窗口单独放到一个Desktop，四指滑动触摸板切换更加便捷，比如Xmind的多个窗口。</p>
<h2 id="System-Preferences"><a href="#System-Preferences" class="headerlink" title="System Preferences"></a>System Preferences</h2><h3 id="设置单击fn切换输入法"><a href="#设置单击fn切换输入法" class="headerlink" title="设置单击fn切换输入法"></a>设置单击fn切换输入法</h3><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/SmgLQE.png"></p>
<h1 id="Alfred"><a href="#Alfred" class="headerlink" title="Alfred"></a>Alfred</h1><h2 id="Powerful-command"><a href="#Powerful-command" class="headerlink" title="Powerful command"></a>Powerful command</h2><p>command of close any app：quit<br>command of search anything in file: in<br>快速用类vim软件打开选中文件<br>Search in finder: ‘</p>
<h2 id="剪贴板无法自动粘贴"><a href="#剪贴板无法自动粘贴" class="headerlink" title="剪贴板无法自动粘贴"></a>剪贴板无法自动粘贴</h2><p>在Security &amp;&amp; Privacy里面的Input Monitoring增加Alfred</p>
<h2 id="不搜索Parallels-Desktop的内容"><a href="#不搜索Parallels-Desktop的内容" class="headerlink" title="不搜索Parallels Desktop的内容"></a>不搜索Parallels Desktop的内容</h2><p>打开spotlight-&gt;private，将Applications(Parallels)添加进来</p>
<h2 id="有道词典的插件"><a href="#有道词典的插件" class="headerlink" title="有道词典的插件"></a>有道词典的插件</h2><p>通过yd 快捷翻译和查询，enter快捷复制。</p>
<h2 id="按右键有很多快捷操作"><a href="#按右键有很多快捷操作" class="headerlink" title="按右键有很多快捷操作"></a>按右键有很多快捷操作</h2><p>比如搜索某个目录<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/PXiZrB.png"><br>然后按右键可以有很多快捷操作<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/3Do9ZM.png"><br>然后可以选择open with，选择不同的软件打开，我喜欢用iterm打开，快捷操作。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/zpzWvn.png"></p>
<h1 id="brew"><a href="#brew" class="headerlink" title="brew"></a>brew</h1><h4 id="安装卸载"><a href="#安装卸载" class="headerlink" title="安装卸载"></a>安装卸载</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew --version 或者 brew -v 显示brew版本信息</span><br><span class="line">brew install &lt;formula&gt; 安装指定软件</span><br><span class="line">brew unistall &lt;formula 卸载指定软件</span><br><span class="line">brew list  显示所有的已安装的软件</span><br><span class="line">brew search text 搜索本地远程仓库的软件，已安装会显示绿色的勾</span><br><span class="line">brew search /text/ 使用正则表达式搜软件</span><br></pre></td></tr></table></figure>
<h4 id="升级"><a href="#升级" class="headerlink" title="升级"></a>升级</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew update 自动升级homebrew（从github下载最新版本）</span><br><span class="line">brew outdated 检测已经过时的软件</span><br><span class="line">brew upgrade  升级所有已过时的软件，即列出的以过时软件</span><br><span class="line">brew upgrade &lt;formula&gt;升级指定的软件</span><br><span class="line">brew pin &lt;formula&gt; 禁止指定软件升级</span><br><span class="line">brew unpin &lt;formula&gt; 解锁禁止升级</span><br><span class="line">brew upgrade --all 升级所有的软件包，包括未清理干净的旧版本的包</span><br></pre></td></tr></table></figure>
<h4 id="查询搜索"><a href="#查询搜索" class="headerlink" title="查询搜索"></a>查询搜索</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew search name</span><br></pre></td></tr></table></figure>
<h4 id="国内使用速度慢的解决方法"><a href="#国内使用速度慢的解决方法" class="headerlink" title="国内使用速度慢的解决方法"></a>国内使用速度慢的解决方法</h4><p><a href="https://mirrors.tuna.tsinghua.edu.cn/help/homebrew/">使用清华大学镜像</a></p>
<h4 id="Error-Cannot-install-in-Homebrew-on-ARM-processor-in-Intel-default-prefix-x2F-usr-x2F-local"><a href="#Error-Cannot-install-in-Homebrew-on-ARM-processor-in-Intel-default-prefix-x2F-usr-x2F-local" class="headerlink" title="Error: Cannot install in Homebrew on ARM processor in Intel default prefix (&#x2F;usr&#x2F;local)"></a>Error: Cannot install in Homebrew on ARM processor in Intel default prefix (&#x2F;usr&#x2F;local)</h4><p><a href="https://stackoverflow.com/questions/64963370/error-cannot-install-in-homebrew-on-arm-processor-in-intel-default-prefix-usr">解决方法</a></p>
<h1 id="sdkman"><a href="#sdkman" class="headerlink" title="sdkman"></a>sdkman</h1><p><a href="https://sdkman.io/usage#env">sdkman usage</a></p>
<h1 id="youtube-dl"><a href="#youtube-dl" class="headerlink" title="youtube-dl"></a>youtube-dl</h1><p><a href="https://www.jianshu.com/p/6bae57859325">youtube-dl使用介绍</a></p>
<h1 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h1><h2 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h2><p>刷新页面快捷键：cmd+R</p>
<h2 id="AppCleaner被锁住无法删除"><a href="#AppCleaner被锁住无法删除" class="headerlink" title="AppCleaner被锁住无法删除"></a>AppCleaner被锁住无法删除</h2><p>可能需要kill -9 掉正在运行的pid，然后切换AppClearner到Widgets，再切换回来Applications，就可以删除了。</p>
<h2 id="brew安装的骚气的命令"><a href="#brew安装的骚气的命令" class="headerlink" title="brew安装的骚气的命令"></a>brew安装的骚气的命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ccat # cat的升级版，自动字符高亮</span><br><span class="line">htop # top的升级版，展示界面更加高大上</span><br><span class="line">    点击不同的展示栏还可以排序，比如按照CPU占用排序或者按照RES（资源占用排序）等等</span><br><span class="line">tldr # 对展示的文档进行了简化，并展示了对应的例子</span><br></pre></td></tr></table></figure>
<h2 id="SlowQuitApps"><a href="#SlowQuitApps" class="headerlink" title="SlowQuitApps"></a>SlowQuitApps</h2><p>有时候会误按到cmd+Q，安装这个软件之后可以在误按的时候有个确认的操作，防止误触退出。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brew tap dteoh/sqa</span><br><span class="line">brew cask install slowquitapps</span><br></pre></td></tr></table></figure>
<p>安装之后要在system setting给上权限，然后可以开启开机自动启动。</p>
<h2 id="安装sshpass"><a href="#安装sshpass" class="headerlink" title="安装sshpass"></a>安装sshpass</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -O -L https://fossies.org/linux/privat/sshpass-1.06.tar.gz &amp;&amp; tar xvzf sshpass-1.06.tar.gz</span><br><span class="line"></span><br><span class="line">cd sshpass-1.06</span><br><span class="line"></span><br><span class="line">./configure</span><br><span class="line"></span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<h2 id="uPic"><a href="#uPic" class="headerlink" title="uPic"></a>uPic</h2><p><a href="https://blog.svend.cc/upic/tutorials/github/">uPic结合github做图床</a><br>github token如果忘记了，可以在github设置里面重新生成：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/ToYZBP.png"><br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/Vym2hq.png"></p>
<h2 id="SwitchHosts"><a href="#SwitchHosts" class="headerlink" title="SwitchHosts"></a>SwitchHosts</h2><p>快捷查询、修改hosts文件的软件<br><a href="https://github.com/oldj/SwitchHosts/releases">SwitchHosts Github Download</a></p>
<h2 id="外接显示器时注意把动态高亮范围关闭（High-Dynamic-Range）"><a href="#外接显示器时注意把动态高亮范围关闭（High-Dynamic-Range）" class="headerlink" title="外接显示器时注意把动态高亮范围关闭（High Dynamic Range）"></a>外接显示器时注意把动态高亮范围关闭（High Dynamic Range）</h2><p>在Display-&gt;Rotation里面讲打勾去掉即可，不然会亮瞎狗眼。</p>
<h2 id="误删了hosts导致网易云音乐无法联网"><a href="#误删了hosts导致网易云音乐无法联网" class="headerlink" title="误删了hosts导致网易云音乐无法联网"></a>误删了hosts导致网易云音乐无法联网</h2><p>终端执行以下命令，然后重启网抑云即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo launchctl stop com.apple.audio.coreaudiod &amp;&amp; sudo launchctl start com.apple.audio.coreaudiod</span><br></pre></td></tr></table></figure>

<h2 id="x2F-usr-x2F-libexec"><a href="#x2F-usr-x2F-libexec" class="headerlink" title="&#x2F;usr&#x2F;libexec"></a>&#x2F;usr&#x2F;libexec</h2><p>这个目录下有很多出其不意的好用命令</p>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
      </tags>
  </entry>
  <entry>
    <title>Maven汇总</title>
    <url>/2019/10/15/Maven%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h1><p><a href="https://www.cnblogs.com/shoshana-kong/p/11031388.html">Maven常用命令</a></p>
<h2 id="scope详解"><a href="#scope详解" class="headerlink" title="scope详解"></a>scope详解</h2><p><a href="https://www.cnblogs.com/hzzll/p/6738955.html">https://www.cnblogs.com/hzzll/p/6738955.html</a></p>
<h2 id="dependencies与dependencyManagement的区别"><a href="#dependencies与dependencyManagement的区别" class="headerlink" title="dependencies与dependencyManagement的区别"></a>dependencies与dependencyManagement的区别</h2><p>根据maven子模块继承父模块的特性，不难理解两者肯定都有继承父模块依赖的作用，但是要注意他们的区别是：</p>
<p><em><strong>dependencies里面声明的依赖，子模块会默认全部继承，不用手动去引入依赖；而dependencyManagement里面声明的依赖，则不会再子模块中自动去隐式依赖，只有子模块中声明了依赖，并且没有指明依赖的版本这种情况才会到父模块中寻找dependencyManagement中的对应依赖，要注意的是，如果子模块声明了依赖版本号，那么在dependencyManagement中如果也有同一依赖库的不同版本共存的话，maven优先去依赖的是子模块自己的版本</strong></em></p>
<h2 id="Maven仓库下载依赖太慢的解决方案"><a href="#Maven仓库下载依赖太慢的解决方案" class="headerlink" title="Maven仓库下载依赖太慢的解决方案"></a>Maven仓库下载依赖太慢的解决方案</h2><p>将仓库中心更改为阿里云的，修改setting.xml，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line"> &lt;settings xmlns=&quot;http://maven.apache.org/SETTINGS/1.0.0&quot;</span><br><span class="line">  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">  xsi:schemaLocation=&quot;http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd&quot;&gt;</span><br><span class="line">     &lt;mirrors&gt;</span><br><span class="line">         &lt;!-- 阿里云仓库 --&gt;</span><br><span class="line">         &lt;mirror&gt;</span><br><span class="line">             &lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">             &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">             &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">             &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;</span><br><span class="line">         &lt;/mirror&gt;</span><br><span class="line"></span><br><span class="line">         &lt;!-- 中央仓库1 --&gt;</span><br><span class="line">         &lt;mirror&gt;</span><br><span class="line">             &lt;id&gt;repo1&lt;/id&gt;</span><br><span class="line">             &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">             &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;</span><br><span class="line">             &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt;</span><br><span class="line">         &lt;/mirror&gt;</span><br><span class="line"></span><br><span class="line">         &lt;!-- 中央仓库2 --&gt;</span><br><span class="line">         &lt;mirror&gt;</span><br><span class="line">             &lt;id&gt;repo2&lt;/id&gt;</span><br><span class="line">             &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">             &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;</span><br><span class="line">             &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt;</span><br><span class="line">         &lt;/mirror&gt;</span><br><span class="line">     &lt;/mirrors&gt;</span><br><span class="line"> &lt;/settings&gt;</span><br></pre></td></tr></table></figure>

<h2 id="Maven-BOM"><a href="#Maven-BOM" class="headerlink" title="Maven BOM"></a>Maven BOM</h2><p>BOM stands for Bill Of Materials. A BOM is a special kind of POM that is used to control the versions of a project’s dependencies and provide a central place to define and update those versions.<br>BOM字面理解是”材料清单”，它是一种特别的POM，可以用来控制项目的多个依赖，相当于某个依赖集群的中心控制处。</p>
<h2 id="Transitive-Dependencies-依赖传递性"><a href="#Transitive-Dependencies-依赖传递性" class="headerlink" title="Transitive Dependencies 依赖传递性"></a>Transitive Dependencies 依赖传递性</h2><p>Maven can discover the libraries that are needed by our own dependencies in our pom.xml and includes them automatically. There’s no limit to the number of dependency levels that the libraries are gathered from.<br>Maven通过pom.xml的多层级依赖是没有限制的，也就是，父模块可以递归依赖子模块的任何依赖，所以可能会出现如下的矛盾：</p>
<blockquote>
<p>A -&gt; B -&gt; C -&gt; D 1.4  and  A -&gt; E -&gt; D 1.0</p>
</blockquote>
<p>那么Maven给出了两个解决方案：</p>
<ol>
<li>We can always guarantee a version by declaring it explicitly in our project’s POM. For instance, to guarantee that D 1.4 is used, we should add it explicitly as a dependency in the pom.xml file. 通过在A的pom.xml明确声明D的依赖版本，这样子就不会采用子模块传递过来的依赖了。</li>
<li>We can use the Dependency Management section to control artifact versions. 可以通过依赖管理来控制依赖版本，也就是直接继承父模块，通过<parent>；或者通过import BOM。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;parent&gt;</span><br><span class="line">        &lt;groupId&gt;baeldung&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;Baeldung-BOM&lt;/artifactId&gt;</span><br><span class="line">        &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">    &lt;/parent&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span><br><span class="line">        &lt;dependencies&gt;</span><br><span class="line">            &lt;dependency&gt;</span><br><span class="line">                &lt;groupId&gt;baeldung&lt;/groupId&gt;</span><br><span class="line">                &lt;artifactId&gt;Baeldung-BOM&lt;/artifactId&gt;</span><br><span class="line">                &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;</span><br><span class="line">                &lt;type&gt;pom&lt;/type&gt;</span><br><span class="line">                &lt;scope&gt;import&lt;/scope&gt;</span><br><span class="line">            &lt;/dependency&gt;</span><br><span class="line">        &lt;/dependencies&gt;</span><br><span class="line">    &lt;/dependencyManagement&gt;</span><br></pre></td></tr></table></figure>
maven依赖版本的优先权如下：<br>1、项目自己pom.xml里面直接声明的版本<br>2、从parent项目继承的版本<br>3、通过import形式的依赖版本，和import的顺序有关，先import进来的版本被优先采用。</li>
</ol>
<p>详情参考：<a href="https://www.baeldung.com/spring-maven-bom#2-what-is-maven-bom">https://www.baeldung.com/spring-maven-bom#2-what-is-maven-bom</a></p>
<h2 id="mvn-compile与mvn-install、mvn-deploy的区别"><a href="#mvn-compile与mvn-install、mvn-deploy的区别" class="headerlink" title="mvn compile与mvn install、mvn deploy的区别"></a>mvn compile与mvn install、mvn deploy的区别</h2><ul>
<li>mvn compile，编译类文件</li>
<li>mvn install，包含mvn compile，mvn package，然后上传到本地仓库</li>
<li>mvn deploy,包含mvn install,然后，上传到私服</li>
</ul>
<h2 id="maven-compiler-plugin-插件"><a href="#maven-compiler-plugin-插件" class="headerlink" title="maven-compiler-plugin 插件"></a>maven-compiler-plugin 插件</h2><p>可以用于指定模块编译的jdk版本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">        &lt;target&gt;$&#123;java.version&#125;&lt;/target&gt;</span><br><span class="line">        &lt;source&gt;$&#123;java.version&#125;&lt;/source&gt;</span><br><span class="line">        &lt;encoding&gt;UTF-8&lt;/encoding&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line">&lt;/plugin&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Maven中-DskipTests和-Dmaven-test-skip-x3D-true的区别"><a href="#Maven中-DskipTests和-Dmaven-test-skip-x3D-true的区别" class="headerlink" title="Maven中-DskipTests和-Dmaven.test.skip&#x3D;true的区别"></a>Maven中-DskipTests和-Dmaven.test.skip&#x3D;true的区别</h2><p>在使用mvn package进行编译、打包时，Maven会执行src&#x2F;test&#x2F;java中的JUnit测试用例，有时为了跳过测试，会使用参数-DskipTests和-Dmaven.test.skip&#x3D;true，这两个参数的主要区别是：<br>-DskipTests，不执行测试用例，但编译测试用例类生成相应的class文件至target&#x2F;test-classes下。<br>-Dmaven.test.skip&#x3D;true，不执行测试用例，也不编译测试用例类。</p>
<h2 id="profile切换正式环境和测试环境"><a href="#profile切换正式环境和测试环境" class="headerlink" title="profile切换正式环境和测试环境"></a>profile切换正式环境和测试环境</h2><p>可以使用<profiles>的<profile>通过id标签来切换不同环境的依赖</p>
<h2 id="mvn-install执行要注意的地方-错误笔记"><a href="#mvn-install执行要注意的地方-错误笔记" class="headerlink" title="mvn install执行要注意的地方 (错误笔记*)"></a>mvn install执行要注意的地方 (错误笔记*)</h2><p>通过在父项目的pom.xml目录执行mvn install可以连同子模块也一起安装，然后假如有多层级的父子模块依赖的情况下，mvn install是不会递归去安装子模块的子模块的。<br>比如，parent模块（BOM）下有subParent（BOM），subParent下面的子模块（jar），这个时候再parent模块下执行mvn install，subParent的jar是不会安装的，需要到subParent执行一次</p>
<h2 id="Maven整个声明周期"><a href="#Maven整个声明周期" class="headerlink" title="Maven整个声明周期"></a>Maven整个声明周期</h2><p>验证（validate） 验证项目是正确的，所有必要的信息可用。<br>初始化（initialize） 初始化构建状态，例如设置属性或创建目录。<br>产生来源（generate-sources） 生成包含在编译中的任何源代码。<br>流程源（process-sources） 处理源代码，例如过滤任何值。<br>生成资源（generate-resources） 生成包含在包中的资源。<br>流程资源（process-resources） 将资源复制并处理到目标目录中，准备打包。<br>编译（compile） 编译项目的源代码。<br>工艺类（process-classes） 从编译后处理生成的文件，例如对Java类进行字节码增强。<br>生成测试来源（generate-test-sources） 生成包含在编译中的任何测试源代码。<br>流程测试来源（process-test-sources） 处理测试源代码，例如过滤任何值。<br>生成测试资源（generate-test-resources） 创建测试资源。<br>流程测试资源（process-test-resources） 将资源复制并处理到测试目标目录中。<br>测试编译（test-compile） 将测试源代码编译到测试目标目录中<br>流程检验类（process-test-classes） 从测试编译中处理生成的文件，例如对Java类进行字节码增强。对于Maven 2.0.5及以上版本。<br>测试（test） 使用合适的单元测试框架运行测试。这些测试不应该要求代码被打包或部署。<br>制备包（prepare-package） 在实际包装之前，执行必要的准备包装的操作。这通常会导致打包的处理版本的包。（Maven 2.1及以上）<br>打包（package） 采取编译的代码，并以其可分发的格式（如JAR）进行打包。<br>预集成测试（pre-integration-test） 在执行集成测试之前执行所需的操作。这可能涉及诸如设置所需环境等。<br>集成测试（integration-test） 如果需要，可以将该包过程并部署到可以运行集成测试的环境中。<br>整合后的测试（post-integration-test） 执行集成测试后执行所需的操作。这可能包括清理环境。<br>校验（verify） 运行任何检查以验证包装是否有效并符合质量标准。<br>安装（install） 将软件包安装到本地存储库中，以作为本地其他项目的依赖关系。<br>部署（deploy） 在集成或发布环境中完成，将最终软件包复制到远程存储库，以与其他开发人员和项目共享。<br>————————————————<br>版权声明：本文为CSDN博主「zhangxitab」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/zhangxitab/article/details/91047445">https://blog.csdn.net/zhangxitab/article/details/91047445</a></p>
<h2 id="pl-am-amd"><a href="#pl-am-amd" class="headerlink" title="-pl -am -amd"></a>-pl -am -amd</h2><p><a href="https://www.cnblogs.com/hiver/p/7850954.html">参考</a></p>
<h1 id="Problem-Solution"><a href="#Problem-Solution" class="headerlink" title="Problem Solution"></a>Problem Solution</h1><h2 id="记录一个Idea中Maven的奇葩错误"><a href="#记录一个Idea中Maven的奇葩错误" class="headerlink" title="记录一个Idea中Maven的奇葩错误"></a>记录一个Idea中Maven的奇葩错误</h2><p>因为我从SVN拉代码下来是将项目根目录的名字修改为其他，导致根目录的pom.xml里面的name标签的值和文件不匹配，idea就一直报红，无法依赖其他依赖。。</p>
<h2 id="新增加properties的变量时，编译打包报错"><a href="#新增加properties的变量时，编译打包报错" class="headerlink" title="新增加properties的变量时，编译打包报错"></a>新增加properties的变量时，编译打包报错</h2><p>很有可能需要把子模块modules都注释掉，然后编译一个或者多个父模块之后再放开子模块的注释。</p>
<h2 id="jar-original"><a href="#jar-original" class="headerlink" title="jar.original"></a>jar.original</h2><ul>
<li>jar.original 是普通jar包，不包含依赖</li>
<li>.jar 是可执行jar包，包含了pom中的所有依赖，可以直接用java -jar 命令执行</li>
<li>如果是部署，就用.jar</li>
<li>如果是给别的项目用，就要给.jar.original这个包</li>
</ul>
]]></content>
      <categories>
        <category>maven</category>
      </categories>
      <tags>
        <tag>maven</tag>
      </tags>
  </entry>
  <entry>
    <title>Redis汇总</title>
    <url>/2019/10/15/Redis%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="TodoItem"><a href="#TodoItem" class="headerlink" title="TodoItem"></a>TodoItem</h1><h2 id="那些数据适合存储进去-todo"><a href="#那些数据适合存储进去-todo" class="headerlink" title="那些数据适合存储进去? todo"></a>那些数据适合存储进去? todo</h2><pre><code>维护的增删改查应不应该放弃使用缓存（只是为了不出现一种情况，就是修改了数据库，缓存依然还是老的数据）
另外还要考虑到维护的时候增删改其实使用的频率是不多的，所有没必要使用缓存，当然，高频率增删改的除外。
使用到缓存的一般是可以是高频率的查询
</code></pre>
<h1 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h1><h2 id="redis数据持久化，一般重启不丢失"><a href="#redis数据持久化，一般重启不丢失" class="headerlink" title="redis数据持久化，一般重启不丢失"></a>redis数据持久化，一般重启不丢失</h2><p><a href="https://redis.io/topics/persistence">https://redis.io/topics/persistence</a><br>会默认开启RDB 持久化</p>
<h2 id="Redis的数据类型"><a href="#Redis的数据类型" class="headerlink" title="Redis的数据类型"></a>Redis的数据类型</h2><ol>
<li>字符串（String）</li>
<li>字符串列表（list）</li>
<li>有序字符串集合（sorted set）</li>
<li>哈希（hash）</li>
<li>字符串集合（set）</li>
</ol>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><a href="https://www.runoob.com/redis/redis-commands.html">https://www.runoob.com/redis/redis-commands.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查询键keys * 查询所有的键,会遍历所有的键值,复杂度O(n)</span><br><span class="line">flushall</span><br><span class="line">incr num</span><br><span class="line">decr num</span><br><span class="line">incrby num 5</span><br><span class="line">decrby num 3</span><br><span class="line">append num str</span><br><span class="line">hset myhash keyname value</span><br><span class="line">hmset myhashs key1 v1 key2 v2</span><br><span class="line">hget myhashs key1</span><br><span class="line">hmget myhashs key1 key2</span><br><span class="line">hgetall myhashs</span><br><span class="line">hdel myhashs key1 key2</span><br><span class="line">hlen myhashs</span><br><span class="line">hkeys myhashs</span><br><span class="line">hvals myhashs</span><br><span class="line">lpush mylist a b c （左侧添加进去）</span><br><span class="line">rpush mylist 1 2 3 （右侧添加进去）</span><br><span class="line">lrange mylist 0 -1 (负数是倒数第n)</span><br><span class="line">lpop mylist （弹出首个）</span><br><span class="line">rpop mylist（弹出尾个）</span><br><span class="line">llen mylist</span><br><span class="line">lpushx mylist x （插入到头部）</span><br><span class="line">rpushx mylist x（插入到尾部）</span><br><span class="line">lrem mylist 2 3 (从头到尾删除2个值为3的元素)</span><br><span class="line">lrem mylist -2 3 (从尾到头删除2个值为3的元素)</span><br><span class="line">lrem mylist 0 3 （删除所有值为3的元素）</span><br><span class="line">lset mylist 3 mmm（在下标为3的位置插入mmm）</span><br><span class="line">linsert mylist before mmm haha（在第一个mmm之前插入haha）</span><br><span class="line">linsert mylist after mmm xixi（在第一个mmm之后插入xixi）</span><br><span class="line">rpoplpush mylist1 mylist2 （mylist1弹出首个元素给到mylist2）</span><br><span class="line">sadd myset a b c</span><br><span class="line">sismember myset a（判断是否成员）</span><br><span class="line">sdiff myset1 myset2（差集）</span><br><span class="line">sinter myset1 myset2（交集）</span><br><span class="line">sunion set1 set2 （并集）</span><br><span class="line">smembers myset</span><br><span class="line">scard myset</span><br></pre></td></tr></table></figure>

<h3 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h3><p><a href="https://www.cnblogs.com/xiaoxiongcanguan/p/9937433.html?utm_source=tuicool&utm_medium=referral">https://www.cnblogs.com/xiaoxiongcanguan/p/9937433.html?utm_source&#x3D;tuicool&amp;utm_medium&#x3D;referral</a></p>
<h2 id="redis-cli"><a href="#redis-cli" class="headerlink" title="redis-cli"></a>redis-cli</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">redis-cli -h 地址 -p 端口号</span><br></pre></td></tr></table></figure>

<h2 id="Redis与IO之间的关系和工作原理"><a href="#Redis与IO之间的关系和工作原理" class="headerlink" title="Redis与IO之间的关系和工作原理"></a>Redis与IO之间的关系和工作原理</h2><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/ENzI5b.png"></p>
<h1 id="Problem-Solution"><a href="#Problem-Solution" class="headerlink" title="Problem Solution"></a>Problem Solution</h1><h2 id="required-a-bean-of-type-‘org-springframework-cache-CacheManager’-that-could-not-be-found"><a href="#required-a-bean-of-type-‘org-springframework-cache-CacheManager’-that-could-not-be-found" class="headerlink" title="required a bean of type ‘org.springframework.cache.CacheManager’ that could not be found."></a>required a bean of type ‘org.springframework.cache.CacheManager’ that could not be found.</h2><p>需要再spring.foctories添加org.springframework.boot.autoconfigure.EnableAutoConfiguration配置，<br>至少需要配置RedisTemplate</p>
<h2 id="MISCONF-Redis-is-configured-to-save-RDB-snapshots-but-it-is-currently-not-able-to-persist-on-disk-Commands-that-may-modify-the-data-set-are-disabled-because-this-instance-is-configured-to-report-errors-during-writes-if-RDB-snapshotting-fails-stop-writes-on-bgsave-error-option-Please-check-the-Redis-logs-for-details-about-the-RDB-error"><a href="#MISCONF-Redis-is-configured-to-save-RDB-snapshots-but-it-is-currently-not-able-to-persist-on-disk-Commands-that-may-modify-the-data-set-are-disabled-because-this-instance-is-configured-to-report-errors-during-writes-if-RDB-snapshotting-fails-stop-writes-on-bgsave-error-option-Please-check-the-Redis-logs-for-details-about-the-RDB-error" class="headerlink" title="MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error."></a>MISCONF Redis is configured to save RDB snapshots, but it is currently not able to persist on disk. Commands that may modify the data set are disabled, because this instance is configured to report errors during writes if RDB snapshotting fails (stop-writes-on-bgsave-error option). Please check the Redis logs for details about the RDB error.</h2><p>网上说：关闭配置文件里面的stop-writes-on-bgsave-error，将其配置为no，然后重启redis，但是改成no之后刚开始能生效，隔一段时间之后还是会报这个错，所以问题的根源应该不是这个。</p>
<h2 id="Redis系列之一台机器启动多个服务"><a href="#Redis系列之一台机器启动多个服务" class="headerlink" title="Redis系列之一台机器启动多个服务"></a>Redis系列之一台机器启动多个服务</h2><h4 id="复制多个redis-conf"><a href="#复制多个redis-conf" class="headerlink" title="复制多个redis.conf"></a>复制多个redis.conf</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /usr/local/redis/etc/redis.conf /usr/local/redis/etc/redis02.conf</span><br></pre></td></tr></table></figure>
<p>修改redis02.conf内容防止冲突，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">pidfile /var/run/redis_6379.pid</span><br><span class="line">port 6379</span><br><span class="line">logfile /var/log/redis/redis_6379.log</span><br><span class="line">dir /var/lib/redis/637￿9</span><br></pre></td></tr></table></figure>
<p>dir注意要新建对应目录</p>
<h4 id="复制多个redis-server"><a href="#复制多个redis-server" class="headerlink" title="复制多个redis-server"></a>复制多个redis-server</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp /etc/init.d/redis-server /etc/init.d/redis-server02</span><br></pre></td></tr></table></figure>
<p>修改redis-service02里面的内容，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DAEMON_ARGS=/usr/local/redis/etc/redis02.conf</span><br><span class="line">NAME=redis-server02</span><br><span class="line">DESC=redis-server02</span><br><span class="line">PIDFILE=/var/run/redis/redis02.pid</span><br></pre></td></tr></table></figure>
<h4 id="然后启动redis-service02"><a href="#然后启动redis-service02" class="headerlink" title="然后启动redis-service02"></a>然后启动redis-service02</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./redis-serivce02 start</span><br></pre></td></tr></table></figure>

<h2 id="MySQL操作成功之后Redis操作失败的回滚问题"><a href="#MySQL操作成功之后Redis操作失败的回滚问题" class="headerlink" title="MySQL操作成功之后Redis操作失败的回滚问题"></a>MySQL操作成功之后Redis操作失败的回滚问题</h2><p>在项目中有个需求，需要保证MySQL数据库和Redis缓存数据的一致性。<br>一般增删改都是先操作MySQL数据库，成功之后再操作Redis，但这里有个问题，如果MySQL操作成功了，但Redis突然出现异常，操作失败，如何回滚MySQL操作。<br>使用注解@Transactional只会回滚MySQL异常的情况，Redis本身也不具备回滚功能，在MySQL操作成功的情况下，@Transactional注解会认为方法并没有异常，会继续执行而不回滚，这样就导致了MySQL和Redis不一致的情况。<br>为了避免这种情况，每次操作Redis之后，都会判断Redis有没有操作成功，操作失败则进行手动回滚，加一行代码：TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();  配合@Transactional注解即可解决问题。</p>
<h1 id="redis缓存设计"><a href="#redis缓存设计" class="headerlink" title="redis缓存设计"></a>redis缓存设计</h1><h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul>
<li>注意纳入redis管控的JavaBean一定要实现Serializable接口，这样才能序列化。JavaBean的子属性如果是JavaBean也都要实现Serializable接口。</li>
</ul>
<h1 id="Redisson实现分布式锁"><a href="#Redisson实现分布式锁" class="headerlink" title="Redisson实现分布式锁"></a>Redisson实现分布式锁</h1>]]></content>
      <categories>
        <category>redis</category>
      </categories>
      <tags>
        <tag>redis</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql系列之基础知识</title>
    <url>/2019/10/15/Mysql%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h1><p><a href="https://help.aliyun.com/wordpower/2596091-1.html">alibabaMysql开发规范和常见问题处理</a><br><a href="https://learnku.com/articles/25116">参考1</a></p>
<h1 id="建模工具PDMan"><a href="#建模工具PDMan" class="headerlink" title="建模工具PDMan"></a>建模工具PDMan</h1><p>还是可视化视图清晰点，还可以导出自动生成sql。</p>
<h1 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h1><h2 id="存储引擎"><a href="#存储引擎" class="headerlink" title="存储引擎"></a>存储引擎</h2><h3 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h3><p>MyISAM是MySQL的默认数据库引擎（5.5版之前），它不支持事务和表锁设计，支持全文索引，主要面向一些在线分析处理(OLAP)数据库应用。说白了主要就是查询数据，对数据的插入，更新操作比较少。</p>
<h3 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h3><p>MySQL的默认存储引擎，它支持事务，其设计目标主要面向在线事务处理(OLTP)的应用。</p>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 设置主键自增初始值</span><br><span class="line">alter table t_ins_sequence AUTO_INCREMENT = 100000;</span><br><span class="line"># 修改表名</span><br><span class="line">alter table sys_user_role rename to sys_user_role_rel;</span><br><span class="line"># 查询数据库里面各个表的大小</span><br><span class="line">SELECT CONCAT(table_schema,&#x27;.&#x27;,table_name) AS &#x27;Table Name&#x27;,</span><br><span class="line">    table_rows AS &#x27;Number of Rows&#x27;,</span><br><span class="line">    CONCAT(ROUND(data_length/(1024*1024*1024),6),&#x27; G&#x27;) AS &#x27;Data Size&#x27;,</span><br><span class="line">    CONCAT(ROUND(index_length/(1024*1024*1024),6),&#x27; G&#x27;) AS &#x27;Index Size&#x27; ,</span><br><span class="line">    CONCAT(ROUND((data_length+index_length)/(1024*1024*1024),6),&#x27; G&#x27;) AS&#x27;Total&#x27;</span><br><span class="line">FROM information_schema.TABLES</span><br><span class="line">WHERE table_schema LIKE &#x27;inspect_db&#x27;;</span><br><span class="line"># 修改主键自增</span><br><span class="line">alter table word_fetch_queue modify queue_id int auto_increment;</span><br><span class="line"># 修改主键被外键约束show create table table_name;</span><br><span class="line"></span><br><span class="line">SET FOREIGN_KEY_CHECKS = 0;</span><br><span class="line"># 约束解除，进行修改，完了还原</span><br><span class="line">SET FOREIGN_KEY_CHECKS = 1;</span><br><span class="line"># 查询表的建表DDL</span><br><span class="line">show create table table_name;</span><br><span class="line"># 查询表的索引</span><br><span class="line">SHOW INDEX FROM &lt;tablename&gt;;</span><br><span class="line"># 查看表空间模式</span><br><span class="line">show variables like &#x27;%innodb_file_per_table%&#x27; ;</span><br><span class="line"># Mysql基本可以将schema当成database；下面二个命令都会创建对应数据库</span><br><span class="line">create schema xxxName;</span><br><span class="line">create databse xxxName;</span><br><span class="line"># 查询某个字符开头的所有表</span><br><span class="line">show tables like &#x27;ACT_%&#x27;;</span><br></pre></td></tr></table></figure>

<h3 id="mysqladmin的用法"><a href="#mysqladmin的用法" class="headerlink" title="mysqladmin的用法"></a>mysqladmin的用法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqladmin -u root -p status</span><br></pre></td></tr></table></figure>
<p>然后输入密码，<a href="https://dev.mysql.com/doc/refman/8.0/en/mysqladmin.html">命令参考</a></p>
<h3 id="Using-Options-on-the-Command-Line-在命令行使用可选项"><a href="#Using-Options-on-the-Command-Line-在命令行使用可选项" class="headerlink" title="Using Options on the Command Line(在命令行使用可选项)"></a>Using Options on the Command Line(在命令行使用可选项)</h3><p>横线和下划线在命令中是可以互换来使用的，比如 –skip-grant-tables and –skip_grant_tables效果相同，但是官方默认使用的是-，看起来也比较直观。<br><em><strong>但是要注意的是，前面的起引导作用的横线不能被替换，–skip不能替换为__skip</strong></em></p>
<h2 id="执行计划EXPLAIN"><a href="#执行计划EXPLAIN" class="headerlink" title="执行计划EXPLAIN"></a>执行计划EXPLAIN</h2><p><a href="https://www.cnblogs.com/tufujie/p/9413852.html">Mysql执行计划教程</a></p>
<h2 id="Mysql的级联更新"><a href="#Mysql的级联更新" class="headerlink" title="Mysql的级联更新"></a>Mysql的级联更新</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update tb1,</span><br><span class="line">tb2</span><br><span class="line">set tb1.a=tb2.a,tb1.b=tb2.b</span><br><span class="line">where tb1.id=tb2.id;</span><br><span class="line"></span><br><span class="line">update tb1,</span><br><span class="line">(select * from tb2 where xxx) as tb2</span><br><span class="line">set tb1.a=tb2.a,tb1.b=tb2.b</span><br><span class="line">where tb1.id=tb2.id;</span><br><span class="line"></span><br><span class="line">update (select * from tb1 group by C) as temp,</span><br><span class="line">       tb2,</span><br><span class="line">       tb1</span><br><span class="line">set tb1.a = tb2.a,</span><br><span class="line">    tb1.b = tb2.b</span><br><span class="line">where tb1.id = tb2.id and</span><br><span class="line">      temp.id = tb2.id;</span><br><span class="line"></span><br><span class="line">update tb1 left join tb2 on tb1.id = tb2.id</span><br><span class="line">set tb1.a = tb2.a,</span><br><span class="line">    tb1.b = tb2.b</span><br><span class="line">where xxx;</span><br></pre></td></tr></table></figure>

<h2 id="Mysql和Oracle的Sql的不同之处"><a href="#Mysql和Oracle的Sql的不同之处" class="headerlink" title="Mysql和Oracle的Sql的不同之处"></a>Mysql和Oracle的Sql的不同之处</h2><p>delete在oracle中是支持别名的，mysql不支持</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete from table_name tn;// mysql error</span><br></pre></td></tr></table></figure>
<p>Oracle可以直接sequence，Mysql不能，如果非要在Mysql使用类似Oracle的sequence功能，可以通过一张表来模拟，参考：<br><a href="https://blog.csdn.net/u012373815/article/details/78179411" title="标题">https://blog.csdn.net/u012373815/article/details/78179411</a></p>
<p>Mysql没有类似Oracle一样的表空间概念，mysql的表空间分为两个文件一个是*.ibd文件存储数据索引…等数据信息，且只针对一张表，还有一个文件是*.frm这个文件是存储表的元数据。</p>
<h2 id="time、timestamp、date、datetime"><a href="#time、timestamp、date、datetime" class="headerlink" title="time、timestamp、date、datetime"></a>time、timestamp、date、datetime</h2><p>DATE: It is used for values with a date part but no time part. MySQL retrieves and displays DATE values in YYYY-MM-DD format. The supported range is 1000-01-01 to 9999-12-31.</p>
<p>DATETIME: It is used for values that contain both date and time parts. MySQL retrieves and displays DATETIME values in YYYY-MM-DD HH:MM:SS format. The supported range is 1000-01-01 00:00:00 to 9999-12-31 23:59:59.</p>
<p>TIMESTAMP: It is used for values that contain both date and time parts. TIMESTAMP has a range of 1970-01-01 00:00:01 UTC to 2038-01-19 03:14:07 UTC.</p>
<p>TIME: Its values are in HH:MM:SS format (or HHH:MM:SS format for large hours values). TIME values may range from -838:59:59 to 838:59:59. The hours part may be so large because the TIME type can be used not only to represent a time of day (which must be less than 24 hours), but also elapsed time or a time interval between two events (which may be much greater than 24 hours, or even negative).</p>
<h2 id="char-vs-varchar"><a href="#char-vs-varchar" class="headerlink" title="char vs varchar"></a>char vs varchar</h2><p>MySQL - CHAR vs VARCHAR - What is the difference? CHAR is fixed length while VARCHAR is variable length. That means, a CHAR(x) string has exactly x characters in length, including spaces. A VARCHAR(x) string can have up to x characters and it cuts off trailing spaces, thus might be shorter than the declared length.</p>
<h2 id="Mysql一对多数据显示成一行"><a href="#Mysql一对多数据显示成一行" class="headerlink" title="Mysql一对多数据显示成一行"></a>Mysql一对多数据显示成一行</h2><p><a href="https://www.cnblogs.com/lucky-girl/p/9482169.html">使用GROUP_CONCAT</a></p>
<h2 id="Mysql常用函数大全"><a href="#Mysql常用函数大全" class="headerlink" title="Mysql常用函数大全"></a>Mysql常用函数大全</h2><p><a href="https://www.cnblogs.com/panchanggui/p/10652322.html">常用函数</a></p>
<h2 id="数据库的导入导出（数据迁移、数据备份恢复）"><a href="#数据库的导入导出（数据迁移、数据备份恢复）" class="headerlink" title="数据库的导入导出（数据迁移、数据备份恢复）"></a>数据库的导入导出（数据迁移、数据备份恢复）</h2><blockquote>
<p><a href="https://www.jianshu.com/p/c3d8366326c1">mysqldump导入导出</a></p>
</blockquote>
<h3 id="快速备份某个表"><a href="#快速备份某个表" class="headerlink" title="快速备份某个表"></a>快速备份某个表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS B;</span><br><span class="line">CREATE TABLE B LIKE A;</span><br><span class="line">INSERT INTO B SELECT * FROM A;</span><br></pre></td></tr></table></figure>
<h3 id="导出备份单个表"><a href="#导出备份单个表" class="headerlink" title="导出备份单个表"></a>导出备份单个表</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump -u root -p dbname tablename &gt; table.sql</span><br></pre></td></tr></table></figure>
<h3 id="导出备份整个库"><a href="#导出备份整个库" class="headerlink" title="导出备份整个库"></a>导出备份整个库</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump -u root -p dbname &gt; db.sql</span><br></pre></td></tr></table></figure>
<h3 id="导入通过mysql命令"><a href="#导入通过mysql命令" class="headerlink" title="导入通过mysql命令"></a>导入通过mysql命令</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p vocabulary_enhancer_db &lt; /mysql_sql_temp/old_bak.sql</span><br></pre></td></tr></table></figure>
<h3 id="临时表备份"><a href="#临时表备份" class="headerlink" title="临时表备份"></a>临时表备份</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TEMPORARY TABLE tmp_table SELECT * FROM table_name;</span><br></pre></td></tr></table></figure>
<h3 id="跨服务器导出导入数据"><a href="#跨服务器导出导入数据" class="headerlink" title="跨服务器导出导入数据"></a>跨服务器导出导入数据</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysqldump --host=cdb-0bhxucw9.gz.tencentcdb.com --port=10069 -uroot -pfengORZ123 -C --databases kiwi_db |mysql --host=localhost -uroot -pfengORZ123 kiwi_db</span><br></pre></td></tr></table></figure>

<h2 id="所有子查询都要用唯一别名"><a href="#所有子查询都要用唯一别名" class="headerlink" title="所有子查询都要用唯一别名"></a>所有子查询都要用唯一别名</h2><h2 id="主键插入返回"><a href="#主键插入返回" class="headerlink" title="主键插入返回"></a>主键插入返回</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;insert id=&quot;genSequence&quot; parameterType=&quot;com.ccssoft.ngbip.sdk.core.entity.Sequence&quot;&gt;</span><br><span class="line">    insert into $&#123;tableName&#125; (stub) values (&#x27;b&#x27;)</span><br><span class="line">    &lt;selectKey resultType=&quot;integer&quot; keyProperty=&quot;id&quot;&gt;</span><br><span class="line">        select last_insert_id() as id</span><br><span class="line">        &lt;!-- select &#x27;NEXT VALUE FOR MYCATSEQ_$&#123;tableName&#125;&#x27; as id --&gt;</span><br><span class="line">    &lt;/selectKey&gt;</span><br><span class="line">&lt;/insert&gt;</span><br></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/czd3355/article/details/71302441/">https://blog.csdn.net/czd3355/article/details/71302441/</a></p>
<h1 id="表设计"><a href="#表设计" class="headerlink" title="表设计"></a>表设计</h1><h2 id="外键设计"><a href="#外键设计" class="headerlink" title="外键设计"></a>外键设计</h2><p>尽量避免使用外键，如果一定要使用外键的情况下，必须要考虑是否要在主表加上ON DELETE CASCADE或者ON UPDATE CASCADE，大部分情况下是必须要加上这个级联约束的，但是要注意的是，关系表中的外键，一定要建索引，否则在删除主键时级联删除外键会很慢很慢。</p>
<h2 id="主键使用uuid和自增int的区别"><a href="#主键使用uuid和自增int的区别" class="headerlink" title="主键使用uuid和自增int的区别"></a>主键使用uuid和自增int的区别</h2><p><a href="http://www.mysqltutorial.org/mysql-uuid/">http://www.mysqltutorial.org/mysql-uuid/</a><br><a href="https://juejin.im/post/5c32a7a86fb9a049ad7734b3">https://juejin.im/post/5c32a7a86fb9a049ad7734b3</a><br>最近在重构公司一个老的模块，重构当然要从数据库开始着手，关于数据表主键的实现方式选择，我想到的有二种方式，一种是uuid，一种是自增int，<br>先抛开是否分布式架构不说，选用uuid网上都会提到两个明显的弊端：<br>1、是数据暂用空间大.<br>2、数据无序性对索引这种树结构的存储有性能上的影响。</p>
<p>第一点我倒是觉得没什么大的影响，现在的硬盘已经不是缺那点点存储的问题了。<br>选用自增int的话，也有两个明显的弊端：<br>1、存在安全性问题，将一个已知主键加减某个值就得到另外一个主键了。<br>2、如果多个表数据合并，可能自增主键存在冲突。</p>
<p>真到了分布式的可以有第三方成熟的实现方案可供选择。<br>结论：尽量使用整型做主键，数据无序性的开销太大了，这点足以让整型的弊端再多，也必须竭力去解决弊端后选择整型做主键。</p>
<h2 id="主键自增int的实现方式"><a href="#主键自增int的实现方式" class="headerlink" title="主键自增int的实现方式"></a>主键自增int的实现方式</h2><h3 id="通过全局自增序列实现"><a href="#通过全局自增序列实现" class="headerlink" title="通过全局自增序列实现"></a>通过全局自增序列实现</h3><p>全局表设计：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">id   int(20) auto_increment</span><br><span class="line">    primary key,</span><br><span class="line">stub char not null</span><br></pre></td></tr></table></figure>
<p>stub用于标识不同表、不同业务<br>在利用last_insert_id()获取最新的ID，当对table进行insert操作时，返回具有Auto_increment（自动增长）特性的属性列的最新值。</p>
<h2 id="主键int还是bigint"><a href="#主键int还是bigint" class="headerlink" title="主键int还是bigint"></a>主键int还是bigint</h2><p>int的范围：从 -2^31 (-2,147,483,648) 到 2^31 - 1 (2,147,483,647) 的整型数据（所有数字）。存储大小为 4 个字节。int 的 SQL-92 同义字为 integer。<br>bigint的范围：从 -2^63 (-9223372036854775808) 到 2^63-1 (9223372036854775807) 的整型数据（所有数字）。存储大小为 8 个字节。</p>
<p>int的上限已经很大了，一般的应用不会超出这个范围，所以主键一般使用int，也可以节省存储。</p>
<h2 id="分布式主键自增实现方案"><a href="#分布式主键自增实现方案" class="headerlink" title="分布式主键自增实现方案"></a>分布式主键自增实现方案</h2><p><a href="https://tech.meituan.com/2017/04/21/mt-leaf.html">美团Leaf</a><br><a href="https://www.cnblogs.com/relucent/p/4955340.html">twitter的snowflake</a></p>
<h2 id="创建和更新时间"><a href="#创建和更新时间" class="headerlink" title="创建和更新时间"></a>创建和更新时间</h2><p>必要时，尽量在表里面添加创建时间（create_time）和更新事件（update_time）</p>
<h2 id="表的DDL维护成本高，必要时可以考虑多留几个扩展字段备用"><a href="#表的DDL维护成本高，必要时可以考虑多留几个扩展字段备用" class="headerlink" title="表的DDL维护成本高，必要时可以考虑多留几个扩展字段备用"></a>表的DDL维护成本高，必要时可以考虑多留几个扩展字段备用</h2><p><a href="https://www.jianshu.com/p/47a1d7998fe0">https://www.jianshu.com/p/47a1d7998fe0</a></p>
<h2 id="Mysql-的表尽量设置成-K-V-Key-Value-结构，什么情况下适合设计成K-V结构？"><a href="#Mysql-的表尽量设置成-K-V-Key-Value-结构，什么情况下适合设计成K-V结构？" class="headerlink" title="Mysql 的表尽量设置成 K-V (Key-Value) 结构，什么情况下适合设计成K-V结构？"></a>Mysql 的表尽量设置成 K-V (Key-Value) 结构，什么情况下适合设计成K-V结构？</h2><p><a href="https://blog.csdn.net/zcl_love_wx/article/details/81178339">表Key-value结构介绍</a><br>在存储一些数据结构经常变动的数据适合采用K-V结构。</p>
<h2 id="为什么要尽量避免表字段为NULL值"><a href="#为什么要尽量避免表字段为NULL值" class="headerlink" title="为什么要尽量避免表字段为NULL值"></a>为什么要尽量避免表字段为NULL值</h2><p>表字段避免 null 值出现，null 值很难查询优化且占用额外的索引空间，推荐默认数字 0 代替 null。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/43t5XR.png"></p>
<h2 id="字段类型的选择"><a href="#字段类型的选择" class="headerlink" title="字段类型的选择"></a>字段类型的选择</h2><ul>
<li>尽量使用 INT 而非 BIGINT，如果非负则加上 UNSIGNED（这样数值容量会扩大一倍），当然能使用 TINYINT、SMALLINT、MEDIUM_INT 更好。</li>
<li>使用整数代替字符串类型</li>
<li><a href="https://cloud.tencent.com/developer/news/155166">枚举类型的弊端</a></li>
</ul>
<h2 id="IP使用整型来存储"><a href="#IP使用整型来存储" class="headerlink" title="IP使用整型来存储"></a>IP使用整型来存储</h2><p><a href="https://bafford.com/2009/03/09/mysql-performance-benefits-of-storing-integer-ip-addresses/">为什么推荐使用</a><br>注意最后一段：<br>The load on MySQL when inserting integer IPs could likely be slightly reduced by doing that conversion in your application, rather than using MySQL’s INET_ATON() function.<br>ip的转换可以考虑放到应用程序来做，而不是通过Mysql的函数做转换。</p>
<h2 id="Mysql的分库分表，水平拆分-垂直拆分-todo"><a href="#Mysql的分库分表，水平拆分-垂直拆分-todo" class="headerlink" title="Mysql的分库分表，水平拆分-垂直拆分 todo"></a>Mysql的分库分表，水平拆分-垂直拆分 todo</h2><h2 id="共享表空间和独享表空间的区别和优缺点"><a href="#共享表空间和独享表空间的区别和优缺点" class="headerlink" title="共享表空间和独享表空间的区别和优缺点"></a>共享表空间和独享表空间的区别和优缺点</h2><p><a href="http://blog.itpub.net/15498/viewspace-2124040/">http://blog.itpub.net/15498/viewspace-2124040/</a></p>
<h2 id="单表大小限制与表空间的关系"><a href="#单表大小限制与表空间的关系" class="headerlink" title="单表大小限制与表空间的关系"></a>单表大小限制与表空间的关系</h2><p><a href="https://blog.csdn.net/wsh900221/article/details/80242299">https://blog.csdn.net/wsh900221/article/details/80242299</a></p>
<h2 id="timestamp-默认当前时间不能同时是not-null"><a href="#timestamp-默认当前时间不能同时是not-null" class="headerlink" title="timestamp 默认当前时间不能同时是not null"></a>timestamp 默认当前时间不能同时是not null</h2><h2 id="char-和-varchar-的区别"><a href="#char-和-varchar-的区别" class="headerlink" title="char 和 varchar 的区别"></a>char 和 varchar 的区别</h2><p>char列长度固定为创建表时声明的长度，长度值范围是1到255当char值被存储时，它们被用空格填充到特定长度。</p>
<h2 id="非负值的字段注意使用无符号数"><a href="#非负值的字段注意使用无符号数" class="headerlink" title="非负值的字段注意使用无符号数"></a>非负值的字段注意使用无符号数</h2><p>合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/3Ha1lc.png"></p>
<h2 id="布尔类型字段"><a href="#布尔类型字段" class="headerlink" title="布尔类型字段"></a>布尔类型字段</h2><p>表字段类型可以使用bit，同时类映射字段使用Boolean。</p>
<h2 id="Mysql的int和bigint字段类型，映射到Java的Integer和Long类型时，勾选UNSIGNED无符号会导致越界转换"><a href="#Mysql的int和bigint字段类型，映射到Java的Integer和Long类型时，勾选UNSIGNED无符号会导致越界转换" class="headerlink" title="Mysql的int和bigint字段类型，映射到Java的Integer和Long类型时，勾选UNSIGNED无符号会导致越界转换"></a>Mysql的int和bigint字段类型，映射到Java的Integer和Long类型时，勾选UNSIGNED无符号会导致越界转换</h2><p>使用Mysql查询数据时，自动映射数据类型。<br>有时候Mysql的int字段，会正确映射到Java的Integer类型，有时候又会映射到Java的Long类型上，最后终于找到原因。<br>原来是Mysql的int字段，勾选了unsigned无符号选项，这样就导致int类型，变成了long类型。<br>同理，MySQL的bigint类型，本来应该映射到Java的Long类型。但是如果勾选了unsigned无符号，则也会映射为BigInteger类型。<br>————————————————<br>版权声明：本文为CSDN博主「dalu2048」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/weixin_42127613/article/details/84791794">https://blog.csdn.net/weixin_42127613/article/details/84791794</a></p>
<h1 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h1><ul>
<li>索引使用_ind结尾，字段的多个单词取单词的首字母组合，例如：sample 表 member_id 上的索引:sample_mid_ind。</li>
<li>主键约束: pk 结尾，_pk;</li>
<li>unique 约束:_uk 结尾，uk;</li>
<li>check 约束: _ck 结尾，ck;</li>
<li>外键约束: _fk 结尾，以 pri 连接本表与主表，_pri_fk;</li>
<li>数据库表示是与否的值，使用 tinyint 类型，坚持 is_xxx 的 命名方式是为了明确其取值含义与取值范围;</li>
<li>表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只<br>出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑;</li>
</ul>
<h2 id="Mysql关键字大全"><a href="#Mysql关键字大全" class="headerlink" title="Mysql关键字大全"></a>Mysql关键字大全</h2><p><a href="https://blog.csdn.net/weixin_43201975/article/details/88953903">https://blog.csdn.net/weixin_43201975&#x2F;article&#x2F;details&#x2F;88953903</a></p>
<h1 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h1><h2 id="为什么推荐外键约束放在应用层，不在数据库库"><a href="#为什么推荐外键约束放在应用层，不在数据库库" class="headerlink" title="为什么推荐外键约束放在应用层，不在数据库库?"></a>为什么推荐外键约束放在应用层，不在数据库库?</h2><p><a href="https://learnku.com/articles/25116">https://learnku.com/articles/25116</a></p>
<h1 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h1><ul>
<li>索引并不是越多越好，要根据查询有针对性的创建，考虑在 WHERE 和 ORDER BY 命令上涉及的列建立索引，可根据 EXPLAIN 来查看是否用了索引还是全表扫描</li>
<li>应尽量避免在 WHERE 子句中对字段进行 NULL 值判断，否则将导致引擎放弃使用索引而进行全表扫描</li>
<li>值分布很稀少的字段不适合建索引，例如 “性别” 这种只有两三个值的字段</li>
<li>字符字段太长的话，考虑用前缀索引</li>
<li>字符字段最好不要做主键 - 超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致;多表关联查询时， 保证被关联的字段需要有索引。(即使双表 join 也要注意表索引、SQL 性能)</li>
</ul>
<h2 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h2><p><a href="https://blog.csdn.net/ma2595162349/article/details/79449493">前缀索引解释</a><br>如果是对已经存在的表建前缀索引，要先去比较重复率再择优创建索引：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/l55Uqw.png"></p>
<h2 id="联合索引之最左原则（左前缀原则）"><a href="#联合索引之最左原则（左前缀原则）" class="headerlink" title="联合索引之最左原则（左前缀原则）"></a>联合索引之最左原则（左前缀原则）</h2><p><a href="https://blog.csdn.net/wdjxxl/article/details/79790421">https://blog.csdn.net/wdjxxl/article/details/79790421</a><br><a href="https://blog.csdn.net/Wuhaotian1996/article/details/80469353">https://blog.csdn.net/Wuhaotian1996/article/details/80469353</a></p>
<h2 id="多对多的关联表索引"><a href="#多对多的关联表索引" class="headerlink" title="多对多的关联表索引"></a>多对多的关联表索引</h2><p>一般是在二个关联的主键字典建唯一联合索引，避免重复数据，提升查询效率。</p>
<h2 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h2><p>Order by的时候，如果一个索引包含(或覆盖)所有需要查询的字段的值，称为‘覆盖索引’。即只需扫描索引而无须扫表。</p>
<h2 id="order-by出现file-sort"><a href="#order-by出现file-sort" class="headerlink" title="order by出现file_sort"></a>order by出现file_sort</h2><p><a href="https://dev.mysql.com/doc/refman/8.0/en/order-by-optimization.html">order by 官方的优化文档</a><br><a href="https://www.cnblogs.com/developer_chan/p/9225638.html">Order by 优化</a><br>没有使用到索引来排序是，执行计划会显示file_sort。<br>需要重点注意的是，索引创建是也是有排序的，默认是ASC，如果Order by的排序和索引创建的时候指定的不一致，也会导致file_sort。  </p>
<p>非联合索引不受order by后面的升序和降序影响到是否使用索引排序，联合索引的情况下应该考虑order  by的升序降序是否和索引创建时一致。</p>
<h2 id="适合建立聚集索引的要求"><a href="#适合建立聚集索引的要求" class="headerlink" title="适合建立聚集索引的要求"></a>适合建立聚集索引的要求</h2><p>既不能绝大多数都相同，又不能只有极少数相同。</p>
<h2 id="聚集索引和非聚集索引使用原则"><a href="#聚集索引和非聚集索引使用原则" class="headerlink" title="聚集索引和非聚集索引使用原则"></a>聚集索引和非聚集索引使用原则</h2><p>动作描述             使用聚集索引   使用非聚集索引<br>列经常被分组排序     应             应<br>返回某范围内的数据   应             不应<br>一个或极少不同值     不应           不应<br>小数目的不同值       应             不应<br>大数目的不同值       不应           应<br>频繁更新的列         不应           应<br>外键列               应             应<br>主键列               应             应<br>频繁修改索引列       不应           应</p>
<h2 id="时间类字段是否应该建索引"><a href="#时间类字段是否应该建索引" class="headerlink" title="时间类字段是否应该建索引"></a>时间类字段是否应该建索引</h2><p>我自己测试了一下建索引确实是性能上有明显提升的，<br>没加索引：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2019-12-25 15:13:59] 1 row retrieved starting from 1 in 592 ms (execution: 576 ms, fetching: 16 ms)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/l55Uqw.png"><br>加上索引之后：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[2019-12-25 15:19:28] 1 row retrieved starting from 1 in 258 ms (execution: 239 ms, fetching: 19 ms)</span><br></pre></td></tr></table></figure>
<p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/otmOCJ.png"></p>
<h2 id="什么情况下SQL不会使用到索引"><a href="#什么情况下SQL不会使用到索引" class="headerlink" title="什么情况下SQL不会使用到索引"></a>什么情况下SQL不会使用到索引</h2><ul>
<li>like出现左匹配：’%XXX’</li>
<li>where语句中使用&lt;&gt;, !&#x3D;, not in</li>
<li>where语句中使用 or，但是没有把or中所有字段加上索引，这种情况，如果需要使用索引需要将or中所有的字段都加上索引。</li>
<li>where语句中对字段表达式操作（包括使用一些函数，比如if()等）</li>
<li>使用索引的时候没有遵从索引的左前缀原则</li>
</ul>
<h2 id="SQL编写优化"><a href="#SQL编写优化" class="headerlink" title="SQL编写优化"></a>SQL编写优化</h2><ul>
<li>避免 select *，将需要查找的字段列出来，这里并不是因为select * 就一定是性能明显更差的原因，具体解释参考<a href="https://blog.csdn.net/qq_38836118/article/details/88708933">https://blog.csdn.net/qq_38836118&#x2F;article&#x2F;details&#x2F;88708933</a></li>
</ul>
<h2 id="SQL手工拼写的防止注入"><a href="#SQL手工拼写的防止注入" class="headerlink" title="SQL手工拼写的防止注入"></a>SQL手工拼写的防止注入</h2><p>varchar类型的字段，在拼写条件值得时候，外面用单引号包围起来，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ objId + &quot; and o.disp_object_type=&#x27;&quot; + objType + &quot;&#x27;&quot;);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h1 id="Problem-Solution"><a href="#Problem-Solution" class="headerlink" title="Problem Solution"></a>Problem Solution</h1><h2 id="The-last-packet-sent-successfully-to-the-server-was-0-milliseconds-ago-The-driver-has-not-received-any-packets-from-the-server"><a href="#The-last-packet-sent-successfully-to-the-server-was-0-milliseconds-ago-The-driver-has-not-received-any-packets-from-the-server" class="headerlink" title="The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server."></a>The last packet sent successfully to the server was 0 milliseconds ago. The driver has not received any packets from the server.</h2><p>大部分原因是由于数据库回收了连接，而系统的缓冲池不知道，继续使用被回收的连接所致的。<br><a href="https://stackoverflow.com/questions/6865538/solving-a-communications-link-failure-with-jdbc-and-mysql">https://stackoverflow.com/questions/6865538/solving-a-communications-link-failure-with-jdbc-and-mysql</a><br>很有可能是jdk的版本有问题，比如我自己用到的：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/ghPynv.png"><br>换成常用的hostpot就可以了</p>
<p>也可能是数据连接池满了</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show global status like &#x27;Max_used_connections&#x27;;</span><br><span class="line">show variables like &#x27;%max_connections%&#x27;;</span><br></pre></td></tr></table></figure>
<p>也可以是时区问题：<br><a href="https://jingyan.baidu.com/article/647f01150f03557f2048a86c.html">mysql修改时区</a><br>jdbc连接的url可以加上时区：<br><a href="https://www.cnblogs.com/coderLeo/p/12739535.html">https://www.cnblogs.com/coderLeo/p/12739535.html</a></p>
<h2 id="required-a-bean-of-type-‘org-springframework-cache-CacheManager’-that-could-not-be-found"><a href="#required-a-bean-of-type-‘org-springframework-cache-CacheManager’-that-could-not-be-found" class="headerlink" title="required a bean of type ‘org.springframework.cache.CacheManager’ that could not be found."></a>required a bean of type ‘org.springframework.cache.CacheManager’ that could not be found.</h2><p>需要再spring.foctories添加org.springframework.boot.autoconfigure.EnableAutoConfiguration配置，<br>至少需要配置RedisTemplate</p>
<h2 id="ERROR-2002-HY000-Can’t-connect-to-local-MySQL-server-through-socket-‘-x2F-tmp-x2F-mysql-sock’-111"><a href="#ERROR-2002-HY000-Can’t-connect-to-local-MySQL-server-through-socket-‘-x2F-tmp-x2F-mysql-sock’-111" class="headerlink" title="ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘&#x2F;tmp&#x2F;mysql.sock’ (111)"></a>ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘&#x2F;tmp&#x2F;mysql.sock’ (111)</h2><p>可能是数据库服务资源紧张挂掉了，mysqld进程我已查看都不在了，重启mysql就好了，当然也有其他原因也会导致这个报错。</p>
<h2 id="delete语句子查询not-exists是不会生效的"><a href="#delete语句子查询not-exists是不会生效的" class="headerlink" title="delete语句子查询not exists是不会生效的"></a>delete语句子查询not exists是不会生效的</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete</span><br><span class="line">from word_paraphrase_star_rel</span><br><span class="line">where not exists(select * from word_paraphrase wp where wp.paraphrase_id = paraphrase_id);</span><br></pre></td></tr></table></figure>
<p>需要改成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete</span><br><span class="line">from word_paraphrase_star_rel</span><br><span class="line">where paraphrase_id in (select tmp.paraphrase_id</span><br><span class="line">                        from (select wpsr.paraphrase_id</span><br><span class="line">                              from word_paraphrase_star_rel wpsr</span><br><span class="line">                              where not exists(</span><br><span class="line">                                      select *</span><br><span class="line">                                      from word_paraphrase wp</span><br><span class="line">                                      where wp.paraphrase_id = wpsr.paraphrase_id)) tmp)</span><br></pre></td></tr></table></figure>

<h2 id="You-can’t-specify-target-table-‘word-paraphrase-star-rel’-for-update-in-FROM-clause"><a href="#You-can’t-specify-target-table-‘word-paraphrase-star-rel’-for-update-in-FROM-clause" class="headerlink" title="You can’t specify target table ‘word_paraphrase_star_rel’ for update in FROM clause"></a>You can’t specify target table ‘word_paraphrase_star_rel’ for update in FROM clause</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete</span><br><span class="line">from word_paraphrase_star_rel</span><br><span class="line">where paraphrase_id in (select wpsr.paraphrase_id</span><br><span class="line">                        from word_paraphrase_star_rel wpsr</span><br><span class="line">                        where not exists(</span><br><span class="line">                                select * from word_paraphrase wp where wp.paraphrase_id = wpsr.paraphrase_id))</span><br></pre></td></tr></table></figure>

<p>改成下面即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">delete</span><br><span class="line">from word_paraphrase_star_rel</span><br><span class="line">where paraphrase_id in (select tmp.paraphrase_id</span><br><span class="line">                        from (select wpsr.paraphrase_id</span><br><span class="line">                              from word_paraphrase_star_rel wpsr</span><br><span class="line">                              where not exists(</span><br><span class="line">                                      select *</span><br><span class="line">                                      from word_paraphrase wp</span><br><span class="line">                                      where wp.paraphrase_id = wpsr.paraphrase_id)) tmp)</span><br></pre></td></tr></table></figure>

<h1 id="Show-Status"><a href="#Show-Status" class="headerlink" title="Show Status"></a>Show Status</h1><p>MySQL的 show status命令<br>命令：show status like ‘%下面变量%’;</p>
<p>Aborted_clients 由于客户没有正确关闭连接已经死掉，已经放弃的连接数量。</p>
<p>Aborted_connects 尝试已经失败的MySQL服务器的连接的次数。</p>
<p>Connections 试图连接MySQL服务器的次数。</p>
<p>Created_tmp_tables 当执行语句时，已经被创造了的隐含临时表的数量。</p>
<p>Delayed_insert_threads 正在使用的延迟插入处理器线程的数量。</p>
<p>Delayed_writes 用INSERT DELAYED写入的行数。</p>
<p>Delayed_errors 用INSERT DELAYED写入的发生某些错误(可能重复键值)的行数。</p>
<p>Flush_commands 执行FLUSH命令的次数。</p>
<p>Handler_delete 请求从一张表中删除行的次数。</p>
<p>Handler_read_first 请求读入表中第一行的次数。</p>
<p>Handler_read_key 请求数字基于键读行。</p>
<p>Handler_read_next 请求读入基于一个键的一行的次数。</p>
<p>Handler_read_rnd 请求读入基于一个固定位置的一行的次数。</p>
<p>Handler_update 请求更新表中一行的次数。</p>
<p>Handler_write 请求向表中插入一行的次数。</p>
<p>Key_blocks_used 用于关键字缓存的块的数量。</p>
<p>Key_read_requests 请求从缓存读入一个键值的次数。</p>
<p>Key_reads 从磁盘物理读入一个键值的次数。</p>
<p>Key_write_requests 请求将一个关键字块写入缓存次数。</p>
<p>Key_writes 将一个键值块物理写入磁盘的次数。</p>
<p>Max_used_connections 同时使用的连接的最大数目。</p>
<p>Not_flushed_key_blocks 在键缓存中已经改变但是还没被清空到磁盘上的键块。</p>
<p>Not_flushed_delayed_rows 在INSERT DELAY队列中等待写入的行的数量。</p>
<p>Open_tables 打开表的数量。</p>
<p>Open_files 打开文件的数量。</p>
<p>Open_streams 打开流的数量(主要用于日志记载）</p>
<p>Opened_tables 已经打开的表的数量。</p>
<p>Questions 发往服务器的查询的数量。</p>
<p>Slow_queries 要花超过long_query_time时间的查询数量。</p>
<p>Threads_connected 当前打开的连接的数量。</p>
<p>Threads_running 不在睡眠的线程数量。</p>
<p>Uptime 服务器工作了多少秒。</p>
]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring系列之SpringCloudConfig</title>
    <url>/2019/10/15/Spring%E7%B3%BB%E5%88%97%E4%B9%8BSpringCloudConfig/</url>
    <content><![CDATA[<p>参考<a href="https://www.cnblogs.com/hellxz/p/9306507.html">https://www.cnblogs.com/hellxz/p/9306507.html</a></p>
<h1 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h1><h2 id="配置服务端修改配置，不需要重启服务端和客户端的服务？"><a href="#配置服务端修改配置，不需要重启服务端和客户端的服务？" class="headerlink" title="配置服务端修改配置，不需要重启服务端和客户端的服务？"></a>配置服务端修改配置，不需要重启服务端和客户端的服务？</h2><p>在配置中心的服务端修改了配置，还是要先启动配置中心的服务端，再重启配置中心的客户端。。。</p>
<h2 id="配置中心的yml"><a href="#配置中心的yml" class="headerlink" title="配置中心的yml"></a>配置中心的yml</h2><p>编写yml配置文件的时候，可以自动提示，但是这个自动提示貌似只会提示Spring Boot的基础配置，如果是在配置中心的话，其他的依赖配置要在配置中心引入其spring-boot-starter的依赖才能自动提示对应的配置。</p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>SpringCloudConfig</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringCloudConfig</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring系列之SpringGateway</title>
    <url>/2019/10/15/Spring%E7%B3%BB%E5%88%97%E4%B9%8BSpringGateway/</url>
    <content><![CDATA[<h1 id="TodoItem"><a href="#TodoItem" class="headerlink" title="TodoItem"></a>TodoItem</h1><h2 id="如果统一通过网关来控制请求的话，其他业务服务提供者要怎么关闭外部请求权限？-todo"><a href="#如果统一通过网关来控制请求的话，其他业务服务提供者要怎么关闭外部请求权限？-todo" class="headerlink" title="如果统一通过网关来控制请求的话，其他业务服务提供者要怎么关闭外部请求权限？ todo"></a>如果统一通过网关来控制请求的话，其他业务服务提供者要怎么关闭外部请求权限？ todo</h2><h1 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h1><h2 id="两种实现过滤器方式的区别"><a href="#两种实现过滤器方式的区别" class="headerlink" title="两种实现过滤器方式的区别"></a>两种实现过滤器方式的区别</h2><ol>
<li>通过继承AbstractGatewayFilterFactory工厂类</li>
<li>通过实现GlobalFilter和Ordered</li>
</ol>
<p>简单来说就是：前者需要通过spring.cloud.routes.filters配置作用在指定的路由上，或者通过spring.cloud.default-filters配置，作用在全局路由上；后者无需配置，系统初始化的时候自动加载，作用在每个路由上。</p>
<h1 id="Problem-Solution"><a href="#Problem-Solution" class="headerlink" title="Problem Solution"></a>Problem Solution</h1><h2 id="No-operations-allowed-after-connection-closed-Possibly-consider-using-a-shorter-maxLifetime-value"><a href="#No-operations-allowed-after-connection-closed-Possibly-consider-using-a-shorter-maxLifetime-value" class="headerlink" title="(No operations allowed after connection closed.). Possibly consider using a shorter maxLifetime value."></a>(No operations allowed after connection closed.). Possibly consider using a shorter maxLifetime value.</h2><p>HikariCP maxLifetime 参数设置太小了，或者太大，跟进HikariCP源码会发现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">if (maxLifetime != 0 &amp;&amp; maxLifetime &lt; SECONDS.toMillis(30)) &#123;</span><br><span class="line">   LOGGER.warn(&quot;&#123;&#125; - maxLifetime is less than 30000ms, setting to default &#123;&#125;ms.&quot;, poolName, MAX_LIFETIME);</span><br><span class="line">   maxLifetime = MAX_LIFETIME;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   private static final long MAX_LIFETIME = MINUTES.toMillis(30);</span><br></pre></td></tr></table></figure>
<p>时间默认是30秒<br>这个要和MySQL的wait_timeout的值对应，建议略小于这个值即可，不能大于wait_timeout。</p>
<h2 id="Dependency-annotations-org-springframework-beans-factory-annotation-Qualifier-value-x3D-webFluxConversionService"><a href="#Dependency-annotations-org-springframework-beans-factory-annotation-Qualifier-value-x3D-webFluxConversionService" class="headerlink" title="Dependency annotations: {@org.springframework.beans.factory.annotation.Qualifier(value&#x3D;webFluxConversionService)}"></a>Dependency annotations: {@org.springframework.beans.factory.annotation.Qualifier(value&#x3D;webFluxConversionService)}</h2><p><a href="https://blog.csdn.net/a807719447/article/details/97105422">参考</a></p>
<h2 id="记录一次SpringGateway转发请求失败的问题定位过程"><a href="#记录一次SpringGateway转发请求失败的问题定位过程" class="headerlink" title="记录一次SpringGateway转发请求失败的问题定位过程"></a>记录一次SpringGateway转发请求失败的问题定位过程</h2><p>HookRegisteringBeanDefinitionRegistryPostProcessor.setupHooks(BeanFactory)  (org.springframework.cloud.sleuth.instrument.reactor)</p>
<p>springGateway集成feign、hystrix和SpringSecurity之后，底层通过ReactorProject再到netty的NioEventLoop，实现微服务之间的内部调用NioEventLoop的run，run方法会一直循环做一些调用逻辑？？？</p>
<p>跟了几天代码，最后发现和postman的tab删除，完了将另外一个微服务可以调通的duplicate一份就ok了。。。</p>
<h2 id="org-springframework-beans-factory-annotation-Qualifier-value-x3D-webFluxConversionService"><a href="#org-springframework-beans-factory-annotation-Qualifier-value-x3D-webFluxConversionService" class="headerlink" title="{@org.springframework.beans.factory.annotation.Qualifier(value&#x3D;webFluxConversionService)}"></a>{@org.springframework.beans.factory.annotation.Qualifier(value&#x3D;webFluxConversionService)}</h2><p>某次重构代码之后报这个错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">No qualifying bean of type &#x27;org.springframework.core.convert.ConversionService&#x27; available: expected at least 1 bean which qualifies as autowire candidate. Dependency annotations: &#123;@org.springframework.beans.factory.annotation.Qualifier(value=webFluxConversionService)&#125;</span><br></pre></td></tr></table></figure>
<p>谷歌了一番，发现是因为pom同时引入了spring-cloud-starter-gateway 和 spring-boot-starter-web，把spring-boot-starter-web去掉即可。</p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>SpringGateway</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringGateway</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring系列之SpringBoot</title>
    <url>/2019/10/15/Spring%E7%B3%BB%E5%88%97%E4%B9%8BSpringBoot/</url>
    <content><![CDATA[<h1 id="TodoItem"><a href="#TodoItem" class="headerlink" title="TodoItem"></a>TodoItem</h1><h2 id="如果配置文件不再Application启动器的同目录或者子目录下，就需要采用-Import引入？-todo"><a href="#如果配置文件不再Application启动器的同目录或者子目录下，就需要采用-Import引入？-todo" class="headerlink" title="如果配置文件不再Application启动器的同目录或者子目录下，就需要采用@Import引入？ todo"></a>如果配置文件不再Application启动器的同目录或者子目录下，就需要采用@Import引入？ todo</h2><h2 id="有没有自动生成banner的工具？-todo"><a href="#有没有自动生成banner的工具？-todo" class="headerlink" title="有没有自动生成banner的工具？ todo"></a>有没有自动生成banner的工具？ todo</h2><h2 id="SpringBootConfiguration和-SpringBootApplication区别-todo"><a href="#SpringBootConfiguration和-SpringBootApplication区别-todo" class="headerlink" title="@SpringBootConfiguration和@SpringBootApplication区别 todo"></a>@SpringBootConfiguration和@SpringBootApplication区别 todo</h2><h2 id="bootstrap-yml非默认的情况下怎样才能被application-yml覆盖？todo"><a href="#bootstrap-yml非默认的情况下怎样才能被application-yml覆盖？todo" class="headerlink" title="bootstrap.yml非默认的情况下怎样才能被application.yml覆盖？todo"></a>bootstrap.yml非默认的情况下怎样才能被application.yml覆盖？todo</h2><h1 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h1><h2 id="采用SpringBoot处理国际化问题"><a href="#采用SpringBoot处理国际化问题" class="headerlink" title="采用SpringBoot处理国际化问题"></a>采用SpringBoot处理国际化问题</h2><p><a href="https://www.baeldung.com/spring-boot-internationalization">Guide to Internationalization in Spring Boot</a></p>
<h2 id="SpringBoot基础教程"><a href="#SpringBoot基础教程" class="headerlink" title="SpringBoot基础教程"></a>SpringBoot基础教程</h2><ul>
<li><a href="baeldung.com/spring-boot-start">Spring Boot Tutorial – Bootstrap a Simple Application</a></li>
<li><a href="https://www.baeldung.com/spring-boot-annotations">Spring Boot Annotations</a></li>
<li><a href="https://www.baeldung.com/spring-boot-custom-auto-configuration">Create a Custom Auto-Configuration with Spring Boot</a><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 标记自动配置类的优先权</span><br><span class="line">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span><br></pre></td></tr></table></figure></li>
<li><a href="https://www.baeldung.com/spring-boot-starters">Intro to Spring Boot Starters</a></li>
<li><a href="https://www.baeldung.com/spring-boot-actuators#1-endpoints">Spring Boot Actuator</a></li>
</ul>
<h2 id="spring-boot-configuration-processor"><a href="#spring-boot-configuration-processor" class="headerlink" title="spring-boot-configuration-processor"></a>spring-boot-configuration-processor</h2><p>可以更加优雅地读取配置文件的值，参考<a href="https://blog.csdn.net/fzbbw/article/details/101175595">https://blog.csdn.net/fzbbw/article/details/101175595</a></p>
<h2 id="远程Debug（Remote-Debug）"><a href="#远程Debug（Remote-Debug）" class="headerlink" title="远程Debug（Remote Debug）"></a>远程Debug（Remote Debug）</h2><p><a href="https://blog.csdn.net/weixin_42740530/article/details/89524509">https://blog.csdn.net/weixin_42740530&#x2F;article&#x2F;details&#x2F;89524509</a></p>
<h1 id="Problem-Solution"><a href="#Problem-Solution" class="headerlink" title="Problem Solution"></a>Problem Solution</h1><h2 id="required-a-bean-of-type-‘javax-sql-DataSource’-that-could-not-be-found"><a href="#required-a-bean-of-type-‘javax-sql-DataSource’-that-could-not-be-found" class="headerlink" title="required a bean of type ‘javax.sql.DataSource’ that could not be found."></a>required a bean of type ‘javax.sql.DataSource’ that could not be found.</h2><p>需要手动配置spring-boot-starter-jdbc的依赖jar</p>
<h2 id="Consider-revisiting-the-entries-above-or-defining-a-bean-of-type-‘org-springframework-security-core-userdetails-UserDetailsService’-in-your-configuration"><a href="#Consider-revisiting-the-entries-above-or-defining-a-bean-of-type-‘org-springframework-security-core-userdetails-UserDetailsService’-in-your-configuration" class="headerlink" title="Consider revisiting the entries above or defining a bean of type ‘org.springframework.security.core.userdetails.UserDetailsService’ in your configuration."></a>Consider revisiting the entries above or defining a bean of type ‘org.springframework.security.core.userdetails.UserDetailsService’ in your configuration.</h2><p>需要自己实现UserDetailsService，并注入到Spring。</p>
<h2 id="2019-12-19-14-24-44-064-WARN-2849-—-XNIO-1-task-7-com-zaxxer-hikari-pool-PoolBase-HikariPool-1-Failed-to-validate-connection-com-mysql-cj-jdbc-ConnectionImpl-6bee636d-No-operations-allowed-after-connection-closed-Possibly-consider-using-a-shorter-maxLifetime-value"><a href="#2019-12-19-14-24-44-064-WARN-2849-—-XNIO-1-task-7-com-zaxxer-hikari-pool-PoolBase-HikariPool-1-Failed-to-validate-connection-com-mysql-cj-jdbc-ConnectionImpl-6bee636d-No-operations-allowed-after-connection-closed-Possibly-consider-using-a-shorter-maxLifetime-value" class="headerlink" title="2019-12-19 14:24:44.064  WARN 2849 — [  XNIO-1 task-7] com.zaxxer.hikari.pool.PoolBase          : HikariPool-1 - Failed to validate connection com.mysql.cj.jdbc.ConnectionImpl@6bee636d (No operations allowed after connection closed.). Possibly consider using a shorter maxLifetime value."></a>2019-12-19 14:24:44.064  WARN 2849 — [  XNIO-1 task-7] com.zaxxer.hikari.pool.PoolBase          : HikariPool-1 - Failed to validate connection com.mysql.cj.jdbc.ConnectionImpl@6bee636d (No operations allowed after connection closed.). Possibly consider using a shorter maxLifetime value.</h2><p>使用hikari需要配置加上max-lifetime: 27700000，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 数据源</span><br><span class="line">spring:</span><br><span class="line">  datasource:</span><br><span class="line">    type: com.zaxxer.hikari.HikariDataSource</span><br><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span><br><span class="line">    username: root</span><br><span class="line">    password: raubbhWy</span><br><span class="line">    url: jdbc:mysql://39.100.106.97:3306/inspect_db?characterEncoding=utf8&amp;zeroDateTimeBehavior=convertToNull&amp;useSSL=false&amp;useJDBCCompliantTimezoneShift=true&amp;useLegacyDatetimeCode=false&amp;serverTimezone=Asia/Shanghai</span><br><span class="line">    hikari:</span><br><span class="line">      max-lifetime: 27700000</span><br></pre></td></tr></table></figure>

<h2 id="Caused-by-java-lang-ClassNotFoundException-org-springframework-cloud-context-named-NamedContextFactory-Specification"><a href="#Caused-by-java-lang-ClassNotFoundException-org-springframework-cloud-context-named-NamedContextFactory-Specification" class="headerlink" title="Caused by: java.lang.ClassNotFoundException: org.springframework.cloud.context.named.NamedContextFactory$Specification"></a>Caused by: java.lang.ClassNotFoundException: org.springframework.cloud.context.named.NamedContextFactory$Specification</h2><p>原因：OpcApplication 中有注解@EnableFeignClients，但是在控制器或对外实现接口中，SpringBoot没有扫描到@FeignClient注解的程序</p>
<p>解决：要么给程序加注解@FeignClient，要么把 OpcApplication 中有注解@EnableFeignClients 暂时去掉</p>
<p>还有网上提到需要增加对应的依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;spring-cloud-context&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Spring</category>
        <category>SpringBoot</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringBoot</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring系列之SpringSecurity</title>
    <url>/2019/10/15/Spring%E7%B3%BB%E5%88%97%E4%B9%8BSpringSecurity/</url>
    <content><![CDATA[<h1 id="TodoItem"><a href="#TodoItem" class="headerlink" title="TodoItem"></a>TodoItem</h1><h2 id="OAuth2标准研究-todo"><a href="#OAuth2标准研究-todo" class="headerlink" title="OAuth2标准研究 todo"></a>OAuth2标准研究 todo</h2><h2 id="AuthorizationServerConfigurerAdapter-vsWebSecurityConfigurerAdapter-todo"><a href="#AuthorizationServerConfigurerAdapter-vsWebSecurityConfigurerAdapter-todo" class="headerlink" title="AuthorizationServerConfigurerAdapter vsWebSecurityConfigurerAdapter todo"></a>AuthorizationServerConfigurerAdapter vsWebSecurityConfigurerAdapter todo</h2><h2 id="判断是否超时的逻辑-todo"><a href="#判断是否超时的逻辑-todo" class="headerlink" title="判断是否超时的逻辑 todo"></a>判断是否超时的逻辑 todo</h2><h2 id="CORS-todo"><a href="#CORS-todo" class="headerlink" title="CORS todo"></a>CORS todo</h2><h2 id="JSR-250-todo"><a href="#JSR-250-todo" class="headerlink" title="JSR-250 todo"></a>JSR-250 todo</h2><h1 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h1><h2 id="很好的基础教程"><a href="#很好的基础教程" class="headerlink" title="很好的基础教程"></a>很好的基础教程</h2><p><a href="https://www.baeldung.com/security-spring">Security with Spring</a></p>
<h2 id="token值在哪里生成？怎么生成？"><a href="#token值在哪里生成？怎么生成？" class="headerlink" title="token值在哪里生成？怎么生成？"></a>token值在哪里生成？怎么生成？</h2><p>默认鉴权生成token的url是”&#x2F;oauth&#x2F;token”，在TokenEndpoint里面生成。<br>SpringSecurity默认的token生成url是：<a href="http://hostname:port/oauth/token">http://hostname:port/oauth/token</a><br>但是要进入到真正的TokenEndpoint里面还需要经过一道道关卡：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 = &#123;WebAsyncManagerIntegrationFilter@13114&#125; </span><br><span class="line">1 = &#123;SecurityContextPersistenceFilter@13113&#125; </span><br><span class="line">2 = &#123;HeaderWriterFilter@13112&#125; </span><br><span class="line">3 = &#123;LogoutFilter@13111&#125; </span><br><span class="line">4 = &#123;ClientCredentialsTokenEndpointFilter@13110&#125; </span><br><span class="line">5 = &#123;BasicAuthenticationFilter@13108&#125; </span><br><span class="line">6 = &#123;RequestCacheAwareFilter@13248&#125; </span><br><span class="line">7 = &#123;SecurityContextHolderAwareRequestFilter@13247&#125; </span><br><span class="line">8 = &#123;AnonymousAuthenticationFilter@13246&#125; </span><br><span class="line">9 = &#123;SessionManagementFilter@13245&#125; </span><br><span class="line">10 = &#123;ExceptionTranslationFilter@13244&#125; </span><br><span class="line">11 = &#123;FilterSecurityInterceptor@13243&#125; </span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 = &#123;OrderedGatewayFilter@13342&#125; &quot;OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.RemoveCachedBodyFilter@25a2c4dc&#125;, order=-2147483648&#125;&quot;</span><br><span class="line">1 = &#123;OrderedGatewayFilter@13343&#125; &quot;OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.AdaptCachedBodyGlobalFilter@62dfe152&#125;, order=-2147482648&#125;&quot;</span><br><span class="line">2 = &#123;OrderedGatewayFilter@13344&#125; &quot;OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=me.fengorz.kiwi.gateway.filter.GenericRequestGlobalFilter@430f0c63&#125;, order=-1000&#125;&quot;</span><br><span class="line">3 = &#123;OrderedGatewayFilter@13345&#125; &quot;OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.NettyWriteResponseFilter@1e75af65&#125;, order=-1&#125;&quot;</span><br><span class="line">4 = &#123;OrderedGatewayFilter@13346&#125; &quot;OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.ForwardPathFilter@2bee1c13&#125;, order=0&#125;&quot;</span><br><span class="line">5 = &#123;OrderedGatewayFilter@13347&#125; &quot;OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.GatewayMetricsFilter@71098fb3&#125;, order=0&#125;&quot;</span><br><span class="line">6 = &#123;OrderedGatewayFilter@13936&#125; &quot;OrderedGatewayFilter&#123;delegate=me.fengorz.kiwi.gateway.filter.ValidateCodeGatewayFilter$$Lambda$854/120561697@1f06c463, order=1&#125;&quot;</span><br><span class="line">7 = &#123;OrderedGatewayFilter@14156&#125; &quot;OrderedGatewayFilter&#123;delegate=me.fengorz.kiwi.gateway.filter.PasswordDecoderGatewayFilter$$Lambda$855/473170143@13f576a8, order=2&#125;&quot;</span><br><span class="line">8 = &#123;OrderedGatewayFilter@13349&#125; &quot;OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.RouteToRequestUrlFilter@29d81c22&#125;, order=10000&#125;&quot;</span><br><span class="line">9 = &#123;OrderedGatewayFilter@13350&#125; &quot;OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.LoadBalancerClientFilter@25a52a60&#125;, order=10100&#125;&quot;</span><br><span class="line">10 = &#123;OrderedGatewayFilter@13351&#125; &quot;OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.WebsocketRoutingFilter@1859b996&#125;, order=2147483646&#125;&quot;</span><br><span class="line">11 = &#123;OrderedGatewayFilter@13352&#125; &quot;OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.NettyRoutingFilter@15549dd7&#125;, order=2147483647&#125;&quot;</span><br><span class="line">12 = &#123;OrderedGatewayFilter@13353&#125; &quot;OrderedGatewayFilter&#123;delegate=GatewayFilterAdapter&#123;delegate=org.springframework.cloud.gateway.filter.ForwardRoutingFilter@18d396eb&#125;, order=2147483647&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>最终默认情况下是通过DefaultTokenServices里面的createAccessToken方法调用到RedisTokenStore的storeAccessToken方法对token一系列的详细信息存储到redis里面。</p>
<h2 id="Spring-Security默认的过滤器栈"><a href="#Spring-Security默认的过滤器栈" class="headerlink" title="Spring Security默认的过滤器栈"></a>Spring Security默认的过滤器栈</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0 = &#123;WebAsyncManagerIntegrationFilter@12983&#125; </span><br><span class="line">1 = &#123;SecurityContextPersistenceFilter@12982&#125; </span><br><span class="line">2 = &#123;HeaderWriterFilter@12981&#125; </span><br><span class="line">3 = &#123;LogoutFilter@12980&#125; </span><br><span class="line">4 = &#123;ClientCredentialsTokenEndpointFilter@12979&#125; </span><br><span class="line">5 = &#123;BasicAuthenticationFilter@12977&#125; </span><br><span class="line">6 = &#123;RequestCacheAwareFilter@13387&#125; </span><br><span class="line">7 = &#123;SecurityContextHolderAwareRequestFilter@13386&#125; </span><br><span class="line">8 = &#123;AnonymousAuthenticationFilter@13385&#125; </span><br><span class="line">9 = &#123;SessionManagementFilter@13384&#125; </span><br><span class="line">10 = &#123;ExceptionTranslationFilter@13383&#125; </span><br><span class="line">11 = &#123;FilterSecurityInterceptor@13382&#125; </span><br></pre></td></tr></table></figure>

<h2 id="AuthorizationServerSecurityConfigurer"><a href="#AuthorizationServerSecurityConfigurer" class="headerlink" title="AuthorizationServerSecurityConfigurer"></a>AuthorizationServerSecurityConfigurer</h2><p>allowFormAuthenticationForClients()：<br>在BasicAuthenticationFilter之前添加clientCredentialsTokenEndpointFilter。</p>
<h1 id="Problem-Solution"><a href="#Problem-Solution" class="headerlink" title="Problem Solution"></a>Problem Solution</h1><h2 id="maven依赖出现了不同版本的TokenEndpoint"><a href="#maven依赖出现了不同版本的TokenEndpoint" class="headerlink" title="maven依赖出现了不同版本的TokenEndpoint"></a>maven依赖出现了不同版本的TokenEndpoint</h2><p>原因是Spring自己的依赖冲突了，在父工程根目录的dependencyManagement里面添加</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--稳定版本，替代spring security bom内置--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;$&#123;security.oauth.version&#125;&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="权限校验的配置不能冲突"><a href="#权限校验的配置不能冲突" class="headerlink" title="权限校验的配置不能冲突"></a>权限校验的配置不能冲突</h2><p>比如我在某个配置类配置了：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/wH4Lai.png"><br>这样会导致全局的权限放开失效：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 直接放行URL</span><br><span class="line">ignore:</span><br><span class="line">  urls:</span><br><span class="line">    - /EnhancerTokenEndpoint/**</span><br></pre></td></tr></table></figure>
<p>全局的安全配置一般放在common-security模块：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/cTim2v.png"></p>
<h2 id="Spring-Security默认不会打印debug日志"><a href="#Spring-Security默认不会打印debug日志" class="headerlink" title="Spring Security默认不会打印debug日志"></a>Spring Security默认不会打印debug日志</h2><p>可通过配置类打开：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void configure(WebSecurity web) throws Exception &#123;</span><br><span class="line">    web.debug(true);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但是这种配置类打印的error日志不全，很多时候一些深层次的报错是不会打印出来的，因为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">catch (AuthenticationException failed) &#123;</span><br><span class="line">	SecurityContextHolder.clearContext();</span><br><span class="line"></span><br><span class="line">	if (debug) &#123;</span><br><span class="line">		this.logger.debug(&quot;Authentication request for failed: &quot; + failed);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	this.rememberMeServices.loginFail(request, response);</span><br><span class="line"></span><br><span class="line">	onUnsuccessfulAuthentication(request, response, failed);</span><br><span class="line"></span><br><span class="line">	if (this.ignoreFailure) &#123;</span><br><span class="line">		chain.doFilter(request, response);</span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		this.authenticationEntryPoint.commence(request, response, failed);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类似这样的代码都有判断if(debug),这种事因为spring security默认用的是logback-classic，需要在classpath加上logback-spring.xml日志打印配置文件。</p>
<h2 id="通过postman调用接口token验证不通过"><a href="#通过postman调用接口token验证不通过" class="headerlink" title="通过postman调用接口token验证不通过"></a>通过postman调用接口token验证不通过</h2><p>我有二个微服务应用，一个是可以正常验证通过，另一个不能，这种问题只能跟源码分析了，最开始发现问题的端倪是：<br>接口请求之后，SpringSecurity会自动将严重的token转发给<a href="http://localhost:9991/auth/oauth/token%E5%9C%A8%E5%86%85%E9%83%A8%E5%81%9A%E9%AA%8C%E8%AF%81%EF%BC%8C%E9%80%9A%E8%BF%87%E7%9A%84%E8%AF%9D%E5%86%8D%E7%BB%A7%E7%BB%AD%E8%B5%B0%E4%B8%9A%E5%8A%A1%E6%8E%A5%E5%8F%A3%E3%80%82">http://localhost:9991/auth/oauth/token在内部做验证，通过的话再继续走业务接口。</a><br>在<a href="http://localhost:9991/auth/oauth/token%E9%AA%8C%E8%AF%81%E6%8E%A5%E5%8F%A3%E9%9C%80%E8%A6%81%E7%BB%8F%E8%BF%87%E4%B8%80%E4%BA%9B%E5%88%97%E7%9A%84%E8%BF%87%E6%BB%A4%E5%99%A8%EF%BC%8C%E4%B8%8A%E9%9D%A2%E6%9C%89%E6%8F%90%E5%88%B0%E3%80%82">http://localhost:9991/auth/oauth/token验证接口需要经过一些列的过滤器，上面有提到。</a><br>在BasicAuthenticationFilter的doFilterInternal方法中对：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">String header = request.getHeader(&quot;Authorization&quot;);</span><br></pre></td></tr></table></figure>
<p>这个Authorization进行解密，异常的应用解密出来是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tokens = &#123;String[2]@15312&#125; </span><br><span class="line"> 0 = &quot;null&quot;</span><br><span class="line"> 1 = &quot;5951061b-856f-47cf-8f1b-dc34f975438c&quot;</span><br></pre></td></tr></table></figure>
<p>这里null就出现问题了，因为正常的那个不会是null，所以要研究一下转发到<a href="http://localhost:9991/auth/oauth/token%E4%B9%8B%E5%89%8D%E5%A1%9E%E8%BF%9BHeader%E9%87%8C%E9%9D%A2%E7%9A%84Authorization%E6%98%AF%E6%80%8E%E4%B9%88%E6%9D%A5%E7%9A%84%EF%BC%9F">http://localhost:9991/auth/oauth/token之前塞进Header里面的Authorization是怎么来的？</a><br>于是只能先从SpringSecurity的过滤器栈中每个过滤器跟起，最终发现是在OAuth2AuthenticationProcessingFilter的doFilter方法的这一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Authentication authResult = authenticationManager.authenticate(authentication);</span><br></pre></td></tr></table></figure>
<p>发现了这里的authentication里面的getCredentials()返回是null，这才导致了上面转发到<a href="http://localhost:9991/auth/oauth/token%E9%AA%8C%E8%AF%81token%E7%9A%84%E6%97%B6%E5%80%99%E5%87%BA%E7%8E%B00">http://localhost:9991/auth/oauth/token验证token的时候出现0</a> &#x3D; “null”，继续跟踪getCredentials()的来源，然后发现credentials是依赖于RemoteTokenServices的clientId属性，getPrincipal()依赖的是clientSecret属性，接着跟一下RemoteTokenServices是在哪里被注入到Spring的，发现其注入如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">         @Bean</span><br><span class="line">public RemoteTokenServices remoteTokenServices() &#123;</span><br><span class="line">	RemoteTokenServices services = new RemoteTokenServices();</span><br><span class="line">	services.setCheckTokenEndpointUrl(this.resource.getTokenInfoUri());</span><br><span class="line">	services.setClientId(this.resource.getClientId());</span><br><span class="line">	services.setClientSecret(this.resource.getClientSecret());</span><br><span class="line">	return services;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>this.resource，属性如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;security.oauth2.resource&quot;)</span><br><span class="line">public class ResourceServerProperties implements BeanFactoryAware, InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">	@JsonIgnore</span><br><span class="line">	private final String clientId;</span><br><span class="line"></span><br><span class="line">	@JsonIgnore</span><br><span class="line">	private final String clientSecret;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这就和明确了，yml或者properties没有配置这二个对应的属性，于是配置上，这里采用了jasypt的加密方式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">security:</span><br><span class="line">  oauth2:</span><br><span class="line">    client:</span><br><span class="line">      client-id: ENC(wORgugqWfXlIuzbal/3pjXTNXij/RSpo)</span><br><span class="line">      client-secret: ENC(rMd1buB3iI+si+W99eB+QFa3QburIEmY)</span><br><span class="line">      scope: server</span><br></pre></td></tr></table></figure>
<p>本来以为这个就正常了，结果报了新的错误：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Caused by: java.lang.IllegalArgumentException: Authorities must be either a String or a Collection</span><br></pre></td></tr></table></figure>
<p>debug了一下，发现上面的client-id和client-secret是注入成功的，那么异常应该是出现在其他地方，继续跟进。<br>最终发现，是在EnhancerUserAuthenticationConverter这个token认证转换器中的extractAuthentication方法报错，报错原因是因为admin用户没有赋权，在这段代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Collection&lt;? extends GrantedAuthority&gt; getAuthorities(Map&lt;String, ?&gt; map) &#123;</span><br><span class="line">    Object authorities = map.get(AUTHORITIES);</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; userNames = this.filterIgnorePropertiesConfig.getUserNames();</span><br><span class="line">    if (CollUtil.contains(userNames, map.get(SecurityConstants.DETAILS_USERNAME))) &#123;</span><br><span class="line">        authorities = CommonConstants.EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (authorities instanceof String) &#123;</span><br><span class="line">        return AuthorityUtils.commaSeparatedStringToAuthorityList((String) authorities);</span><br><span class="line">    &#125;</span><br><span class="line">    if (authorities instanceof Collection) &#123;</span><br><span class="line">        return AuthorityUtils.commaSeparatedStringToAuthorityList(StringUtils</span><br><span class="line">                .collectionToCommaDelimitedString((Collection&lt;?&gt;) authorities));</span><br><span class="line">    &#125;</span><br><span class="line">    throw new IllegalArgumentException(&quot;Authorities must be either a String or a Collection&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样如果直接写死代码忽略admin用户的话代码就太硬了，于是通过yml配置映射到配置独享filterIgnorePropertiesConfig，这样子比较灵活。</p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>SpringSecurity</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringSecurity</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring系列之核心Feature</title>
    <url>/2019/10/15/Spring%E7%B3%BB%E5%88%97%E4%B9%8B%E6%A0%B8%E5%BF%83Feature/</url>
    <content><![CDATA[<h1 id="TodoItem"><a href="#TodoItem" class="headerlink" title="TodoItem"></a>TodoItem</h1><h2 id="深入理解IOC和DI之间的关系"><a href="#深入理解IOC和DI之间的关系" class="headerlink" title="深入理解IOC和DI之间的关系"></a>深入理解IOC和DI之间的关系</h2><h1 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h1><h2 id="Service层的代码相互调用，可能会导致依赖死循环"><a href="#Service层的代码相互调用，可能会导致依赖死循环" class="headerlink" title="Service层的代码相互调用，可能会导致依赖死循环"></a>Service层的代码相互调用，可能会导致依赖死循环</h2><p>可以在二个需要相互依赖的Service之间抽出一层OperateService，通过OperateService解耦。</p>
<h2 id="Transactional引发的思考"><a href="#Transactional引发的思考" class="headerlink" title="@Transactional引发的思考"></a>@Transactional引发的思考</h2><p>加入有这样的场景：<br>AService.doA()方法调用到BService.doB()方法，而且二者都是注解了事务，抛出异常时会回滚。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Transactional(rollbackFor = Exception.class)</span><br></pre></td></tr></table></figure>
<p>加入在doA()中调用了doB()之后才出现的异常，这个时候doB()的事务会不会回滚？<br>根据我自己的测试，doB()中正常执行完毕，这个时候事务依然还不会被提交，而doA()在doB()执行完了之后如果抛出异常，那么doA()和doB都会回滚。<br><em><strong>那么问题来了，如果有这样的业务场景，需要在doB执行之后必须提交事务，即使在其执行之后doA()后面的逻辑抛出异常，doB的事务也要提交到数据库的时候，要怎么处理?</strong></em><br>可以通过@Trancational注解去处理，注解在doB上：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Transactional(rollbackFor = Exception.class, noRollbackFor = ServiceDoAException.class)</span><br></pre></td></tr></table></figure>

<h4 id="Transactional什么时候加，什么时候由Spring自动加"><a href="#Transactional什么时候加，什么时候由Spring自动加" class="headerlink" title="@Transactional什么时候加，什么时候由Spring自动加"></a>@Transactional什么时候加，什么时候由Spring自动加</h4><h2 id="Primary"><a href="#Primary" class="headerlink" title="@Primary"></a>@Primary</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Indicates that a bean should be given preference when multiple candidates are qualified to autowire a single-valued dependency. If exactly one &#x27;primary&#x27; bean exists among the candidates, it will be the autowired value.</span><br><span class="line">This annotation is semantically equivalent to the &lt;bean&gt; element&#x27;s primary attribute in Spring XML.</span><br><span class="line">May be used on any class directly or indirectly annotated with @Component or on methods annotated with @Bean.</span><br></pre></td></tr></table></figure>
<p>比如接口有多个候选依赖，指定一个具体的依赖实现用于自动注入。</p>
<h2 id="Order"><a href="#Order" class="headerlink" title="@Order"></a>@Order</h2><p>自定义不指定其顺序的优先权值小一些，很多时候配置可能没有覆盖掉Spring默认的配置类。</p>
<h2 id="ControllerAdvice-vs-RestControllerAdvice"><a href="#ControllerAdvice-vs-RestControllerAdvice" class="headerlink" title="@ControllerAdvice vs @RestControllerAdvice"></a>@ControllerAdvice vs @RestControllerAdvice</h2><p>@ControllerAdvice can be used even for REST web services as well, but you need to additionally use @ResponseBody.</p>
<h2 id="Spring封装好的便捷线程池ThreadPoolTaskExecutor"><a href="#Spring封装好的便捷线程池ThreadPoolTaskExecutor" class="headerlink" title="Spring封装好的便捷线程池ThreadPoolTaskExecutor"></a>Spring封装好的便捷线程池ThreadPoolTaskExecutor</h2><p><a href="https://www.cnblogs.com/achengmu/p/8137276.html">https://www.cnblogs.com/achengmu/p/8137276.html</a><br><a href="https://blog.csdn.net/lipc_/article/details/52786377">https://blog.csdn.net/lipc_&#x2F;article&#x2F;details&#x2F;52786377</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">corePoolSize： 线程池维护线程的最少数量 </span><br><span class="line">keepAliveSeconds  线程池维护线程所允许的空闲时间（TimeUnit unit: 时间单位,现有纳秒,微秒,毫秒,秒枚举值. ）</span><br><span class="line">maxPoolSize   线程池维护线程的最大数量 </span><br><span class="line">queueCapacity 线程池所使用的缓冲队列 </span><br></pre></td></tr></table></figure>
<p>当一个任务通过execute(Runnable)方法欲添加到线程池时，线程池的处理逻辑如下：</p>
<ul>
<li>如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。</li>
<li>如果此时线程池中的数量等于corePoolSize，但是缓冲队列workQueue未满，那么任务被放入缓冲队列。 </li>
<li>如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，建新的线程来处理被添加的任务。</li>
<li>如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。也就是：处理任务的优先级为：核心线程corePoolSize、任务队列workQueue、最大线程 maximumPoolSize，如果三者都满了，使用handler处理被拒绝的任务。<br>线程池自我维护的功能：</li>
<li>当线程池中的线程数量大于corePoolSize时，如果某线程空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。</li>
</ul>
<h3 id="RejectedExecutionHandler"><a href="#RejectedExecutionHandler" class="headerlink" title="RejectedExecutionHandler"></a>RejectedExecutionHandler</h3><p>RejectedExecutionHandler handler: 用来拒绝一个任务的执行，有两种情况会触发拒绝处理器：</p>
<ul>
<li>在execute方法中若addIfUnderMaximumPoolSize(command)为false，即线程池已经饱和。</li>
<li>在execute方法中, 发现runState!&#x3D;RUNNING || poolSize &#x3D;&#x3D; 0,即已经shutdown,就调用ensureQueuedTaskHandled(Runnable command)，在该方法中有可能调用reject。</li>
</ul>
<h2 id="Async注解其背后的原理"><a href="#Async注解其背后的原理" class="headerlink" title="@Async注解其背后的原理"></a>@Async注解其背后的原理</h2><p>Spring默认的线程执行器defaultExecutor为什么要用SingletonSupplier封装起来？<br>ConcurrentHashMap</p>
<p>Spring线程池debug跟到最底层如下，用到的也是Java的ExecutorService。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/jvGK5D.png" alt="image"></p>
<h2 id="ResourceLoader和ResourceLoaderAware"><a href="#ResourceLoader和ResourceLoaderAware" class="headerlink" title="ResourceLoader和ResourceLoaderAware"></a>ResourceLoader和ResourceLoaderAware</h2><p><a href="https://www.cnblogs.com/achengmu/p/8430961.html">参考文章</a></p>
<h2 id="为什么Spring5注入推荐用final去声明？"><a href="#为什么Spring5注入推荐用final去声明？" class="headerlink" title="为什么Spring5注入推荐用final去声明？"></a>为什么Spring5注入推荐用final去声明？</h2><p><a href="https://www.cnblogs.com/joemsu/p/7688307.html">浅谈spring为什么推荐使用构造器注入</a></p>
<h4 id="总结来说有这几个优点"><a href="#总结来说有这几个优点" class="headerlink" title="总结来说有这几个优点"></a>总结来说有这几个优点</h4><ol>
<li>保证依赖不可变（final关键字）</li>
<li>保证依赖不为空（省去了我们对其检查）</li>
<li>保证返回客户端（调用）的代码的时候是完全初始化的状态</li>
<li>避免了循环依赖</li>
<li>提升了代码的可复用性<br><a href="https://spring.io/blog/2007/07/11/setter-injection-versus-constructor-injection-and-the-use-of-required/">Setter injection versus constructor injection and the use of @Required</a></li>
</ol>
<h2 id="Spring中propagation的7种事务配置"><a href="#Spring中propagation的7种事务配置" class="headerlink" title="Spring中propagation的7种事务配置"></a>Spring中propagation的7种事务配置</h2><ul>
<li><p>REQUIRED：支持当前事务，如果当前没有事务，就新建一个事务。这是最常见的选择。 </p>
</li>
<li><p>SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。 </p>
</li>
<li><p>MANDATORY：支持当前事务，如果当前没有事务，就抛出异常。 </p>
</li>
<li><p>REQUIRES_NEW：新建事务，如果当前存在事务，把当前事务挂起。 </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">标志REQUIRES_NEW会新开启事务，外层事务不会影响内部事务的提交/回滚</span><br></pre></td></tr></table></figure></li>
</ul>
<p>- NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 </p>
<p>- NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。 </p>
<ul>
<li>NESTED：支持当前事务，如果当前事务存在，则执行一个嵌套事务，如果当前没有事务，就新建一个事务。<br>————————————————<br>版权声明：本文为CSDN博主「sayok_why」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/sayoko06/article/details/79164858">https://blog.csdn.net/sayoko06/article/details/79164858</a></li>
</ul>
<h2 id="org-springframework-core-io-Resource"><a href="#org-springframework-core-io-Resource" class="headerlink" title="org.springframework.core.io.Resource"></a>org.springframework.core.io.Resource</h2><h2 id="Spring-AOP-vs-Aspectj"><a href="#Spring-AOP-vs-Aspectj" class="headerlink" title="Spring AOP vs Aspectj"></a>Spring AOP vs Aspectj</h2><p><a href="https://www.baeldung.com/spring-aop-vs-aspectj">https://www.baeldung.com/spring-aop-vs-aspectj</a></p>
<h2 id="Implementing-a-Custom-Spring-AOP-Annotation"><a href="#Implementing-a-Custom-Spring-AOP-Annotation" class="headerlink" title="Implementing a Custom Spring AOP Annotation"></a>Implementing a Custom Spring AOP Annotation</h2><p>Aspect Oriented Programming（AOP）：面向切面编程。</p>
<ul>
<li>连接点（JoinPoint） ：程序执行的某个特定位置，如某个方法调用前，调用后，方法抛出异常后，这些代码中的特定点称为连接点。简单来说，就是在哪加入你的逻辑增强，连接点表示具体要拦截的方法，切点是定义一个范围，而连接点是具体到某个方法；</li>
<li>切点（PointCut）：每个程序的连接点有多个，如何定位到某个感兴趣的连接点，就需要通过切点来定位，切点用于来限定Spring-AOP启动的范围，通常我们采用表达式的方式来设置范围；</li>
<li>增强（Advice） 增强是织入到目标类连接点上的一段程序代码；</li>
<li>前置通知（before）：在执行业务代码前做些操作；</li>
<li>后置通知（after）：在执行业务代码后做些操作，无论是否发生异常，它都会执行，比如关闭连接对象；</li>
<li>异常通知（afterThrowing）：在执行业务代码后出现异常，需要做的操作，比如回滚事务；</li>
<li>返回通知（afterReturning）：在执行业务代码后无异常，会执行的操作；</li>
<li>环绕通知（around）：方法调用前后执行；</li>
<li>目标对象（Target）：需要被加强的业务对象；</li>
<li>织入（Weaving）：织入就是将增强添加到对目标类具体连接点上的过程，织入是一个形象的说法，具体来说，就是生成代理对象并将切面内容融入到业务流程的过程；</li>
<li>代理类（Proxy）：一个类被AOP织入增强后，就产生了一个代理类；</li>
<li>切面（Aspect）：切面由切点和增强组成，它既包括了横切逻辑的定义，也包括了连接点的定义，SpringAOP就是将切面所定义的横切逻辑织入到切面所制定的连接点中。</li>
</ul>
<p><a href="https://www.baeldung.com/spring-aop-annotation">https://www.baeldung.com/spring-aop-annotation</a></p>
<h2 id="Spring-AOP系列文章"><a href="#Spring-AOP系列文章" class="headerlink" title="Spring AOP系列文章"></a>Spring AOP系列文章</h2><p><a href="https://www.baeldung.com/spring-aop">https://www.baeldung.com/spring-aop</a></p>
<h1 id="Problem-Solution"><a href="#Problem-Solution" class="headerlink" title="Problem Solution"></a>Problem Solution</h1><h2 id="Connection-will-not-be-managed-by-Spring"><a href="#Connection-will-not-be-managed-by-Spring" class="headerlink" title="Connection will not be managed by Spring"></a>Connection will not be managed by Spring</h2><p>原因是service 没有加@transactional 注解，未加注解的情况下，出现异常的时候spring将不会回滚事物 </p>
<h2 id="Null-return-value-from-advice-does-not-match-primitive-return-type-for"><a href="#Null-return-value-from-advice-does-not-match-primitive-return-type-for" class="headerlink" title="Null return value from advice does not match primitive return type for"></a>Null return value from advice does not match primitive return type for</h2><p>如果是使用了Spring的异步处理注解@Async的方法，不要有返回，直接void</p>
<h2 id="开启ajc编译的事务问题"><a href="#开启ajc编译的事务问题" class="headerlink" title="开启ajc编译的事务问题"></a>开启ajc编译的事务问题</h2>]]></content>
      <categories>
        <category>Spring</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>iTerm2汇总</title>
    <url>/2019/10/15/iTerm2%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h1><h2 id="HotKey"><a href="#HotKey" class="headerlink" title="HotKey"></a>HotKey</h2><p>按方向切换 pane：⌘+Option+方向键<br>切分屏幕：⌘+d 水平切分，⌘+Shift+d 垂直切分<br>智能查找，支持正则查找：⌘+f<br>自动查找历史命令: ⌘+;<br>ctrl+r 搜索历史命令，一直按可以切换更多的关联历史<br>查看剪贴板历史: cmd+shift+h</p>
<h2 id="keymap"><a href="#keymap" class="headerlink" title="keymap"></a>keymap</h2><p>新建标签：command + t</p>
<p>关闭标签：command + w</p>
<p>切换标签：command + 数字 command + 左右方向键</p>
<p>切换全屏：command + enter</p>
<p>查找：command + f</p>
<p>垂直分屏：command + d</p>
<p>水平分屏：command + shift + d</p>
<p>切换屏幕：command + option + 方向键 command + [ 或 command + ]</p>
<p>查看历史命令：command + ;</p>
<p>查看剪贴板历史：command + shift + h</p>
<p>清除当前行：ctrl + u</p>
<p>到行首：ctrl + a</p>
<p>到行尾：ctrl + e</p>
<p>前进后退：ctrl + f&#x2F;b (相当于左右方向键)</p>
<p>上一条命令：ctrl + p</p>
<p>搜索命令历史：ctrl + r</p>
<p>删除当前光标的字符：ctrl + d</p>
<p>删除光标之前的字符：ctrl + h</p>
<p>删除光标之前的单词：ctrl + w</p>
<p>删除到文本末尾：ctrl + k</p>
<p>交换光标处文本：ctrl + t</p>
<p>清屏1：command + r</p>
<p>清屏2：ctrl + l</p>
<p>自带有哪些很实用的功能&#x2F;快捷键</p>
<p>⌘ + 数字在各 tab 标签直接来回切换</p>
<p>选择即复制 + 鼠标中键粘贴，这个很实用</p>
<p>⌘ + f 所查找的内容会被自动复制</p>
<p>⌘ + d 横着分屏 &#x2F; ⌘ + shift + d 竖着分屏</p>
<p>⌘ + r &#x3D; clear，而且只是换到新一屏，不会想 clear 一样创建一个空屏</p>
<p>ctrl + u 清空当前行，无论光标在什么位置</p>
<p>输入开头命令后 按 ⌘ + ; 会自动列出输入过的命令</p>
<h1 id="oh-my-zsh"><a href="#oh-my-zsh" class="headerlink" title="oh-my-zsh"></a>oh-my-zsh</h1><h2 id="好看清晰的主题"><a href="#好看清晰的主题" class="headerlink" title="好看清晰的主题"></a>好看清晰的主题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">af-magic.zsh-theme</span><br></pre></td></tr></table></figure>

<h1 id="iterm2-ranger强大的终端文件管理器-todo"><a href="#iterm2-ranger强大的终端文件管理器-todo" class="headerlink" title="iterm2+ranger强大的终端文件管理器 todo"></a>iterm2+ranger强大的终端文件管理器 todo</h1>]]></content>
      <categories>
        <category>iTerm2</category>
      </categories>
      <tags>
        <tag>iTerm2</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue系列之基础知识</title>
    <url>/2019/10/15/Vue%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="TodoItem"><a href="#TodoItem" class="headerlink" title="TodoItem"></a>TodoItem</h1><h2 id="eslint-plugin-vue-todo"><a href="#eslint-plugin-vue-todo" class="headerlink" title="eslint-plugin-vue todo"></a>eslint-plugin-vue todo</h2><h2 id="调试技巧-todo"><a href="#调试技巧-todo" class="headerlink" title="调试技巧 todo"></a>调试技巧 todo</h2><h2 id="前端加密的库CryptoJS使用demo-todo"><a href="#前端加密的库CryptoJS使用demo-todo" class="headerlink" title="前端加密的库CryptoJS使用demo todo"></a>前端加密的库CryptoJS使用demo todo</h2><p>以及相同的流行的库有什么？</p>
<h2 id="Vue的生命周期-todo"><a href="#Vue的生命周期-todo" class="headerlink" title="Vue的生命周期 todo"></a>Vue的生命周期 todo</h2><h1 id="Problem-Solution"><a href="#Problem-Solution" class="headerlink" title="Problem Solution"></a>Problem Solution</h1><h2 id="Vue-js-devtools灰色状态"><a href="#Vue-js-devtools灰色状态" class="headerlink" title="Vue.js devtools灰色状态"></a>Vue.js devtools灰色状态</h2><p>首先要确保编译的控制台没有error,在Sources里面有源码可以debug。</p>
<h2 id="Invalid-prop-type-check-failed-for-prop-“queryForm”-Expected-Array-got-Promise"><a href="#Invalid-prop-type-check-failed-for-prop-“queryForm”-Expected-Array-got-Promise" class="headerlink" title="Invalid prop: type check failed for prop “queryForm”. Expected Array, got Promise"></a>Invalid prop: type check failed for prop “queryForm”. Expected Array, got Promise</h2><p>原因是因为prop “queryForm”，期待拿到的是一个Array数组对象，但是传进去的却是一个Promise对象，所以抛出这个报错，类似的错误一般会有：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[Vue warn]: Invalid prop: type check failed for prop &quot;data&quot;. Expected Array, got String.</span><br></pre></td></tr></table></figure>

<h2 id="Vue中监听路由参数变化的方法"><a href="#Vue中监听路由参数变化的方法" class="headerlink" title="Vue中监听路由参数变化的方法"></a>Vue中监听路由参数变化的方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">watch: &#123;</span><br><span class="line">      $route()&#123;</span><br><span class="line">        this.pjtid = this.$route.query.pjtid</span><br><span class="line">      &#125;,</span><br><span class="line">      pjtid() &#123;</span><br><span class="line">        this.pjtdetail()</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以监听url的前后变化：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$route (to, from) &#123;</span><br><span class="line">      this.init()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="VueRouter进不去组件的原因"><a href="#VueRouter进不去组件的原因" class="headerlink" title="VueRouter进不去组件的原因"></a>VueRouter进不去组件的原因</h2><blockquote>
<p>有可能是父路径的path忘记以&#x2F;开头了，比如：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default [&#123;</span><br><span class="line">  path: &#x27;index&#x27;,</span><br><span class="line">  component: $ =&gt; import(&#x27;@/page/index/Index&#x27;)</span><br><span class="line">&#125;, &#123;</span><br><span class="line">  path: &#x27;vocabulary&#x27;,</span><br><span class="line">  component: $ =&gt; import(&#x27;@/page/word/Search&#x27;),</span><br><span class="line">  children: [&#123;</span><br><span class="line">    path: &#x27;detail&#x27;,</span><br><span class="line">    component: $ =&gt; import(&#x27;@/page/word/Detail&#x27;)</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: &#x27;starList&#x27;,</span><br><span class="line">    component: $ =&gt; import(&#x27;@/page/word/StarList&#x27;)</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    path: &#x27;starListDetail&#x27;,</span><br><span class="line">    component: $ =&gt; import(&#x27;@/page/word/StarListDetail&#x27;)</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>
<p>这样子的话浏览器访问<a href="http://localhost:8080/#/index%E4%BC%9A%E5%87%BA%E7%8E%B0%E7%A9%BA%E7%99%BD">http://localhost:8080/#/index会出现空白</a>!</p>
<h2 id="filters-调用到this对象的data、methods"><a href="#filters-调用到this对象的data、methods" class="headerlink" title="filters 调用到this对象的data、methods"></a>filters 调用到this对象的data、methods</h2><p><a href="https://blog.csdn.net/ee_11eeeeee/article/details/102961376">https://blog.csdn.net/ee_11eeeeee&#x2F;article&#x2F;details&#x2F;102961376</a></p>
<h2 id="Avoid-mutating-a-prop-directly-since-the-value-will-be-overwritten-whenever"><a href="#Avoid-mutating-a-prop-directly-since-the-value-will-be-overwritten-whenever" class="headerlink" title="Avoid mutating a prop directly since the value will be overwritten whenever"></a>Avoid mutating a prop directly since the value will be overwritten whenever</h2><p>props从父组件传递数据到子组件，不能子组件更改修改父组件，单向传递，用临时局部变量代替。</p>
<h2 id="ios手机点击输入框页面放大，输入框失焦后，页面不复原，仍保持放大状态"><a href="#ios手机点击输入框页面放大，输入框失焦后，页面不复原，仍保持放大状态" class="headerlink" title="ios手机点击输入框页面放大，输入框失焦后，页面不复原，仍保持放大状态"></a>ios手机点击输入框页面放大，输入框失焦后，页面不复原，仍保持放大状态</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no&quot;&gt;</span><br></pre></td></tr></table></figure>

<h1 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h1><h2 id="重要备忘"><a href="#重要备忘" class="headerlink" title="重要备忘"></a>重要备忘</h2><ul>
<li>在标签的属性与vue的变量或者方法绑定中，千万记得不要使用this.开头，这样子会读取到标签本身的属性值的</li>
<li>vue的html标签如果属性绑定调用的是方法返回的，注意要在方法名后面加上()，不然可能会被解析为变量名</li>
<li>引入js的单个或这个静态的方法或变量，一定要加{}，比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import &#123;BILL_BUTTON_CONFIGS&#125; from &#x27;./buttonConfig&#x27;</span><br></pre></td></tr></table></figure>
不能是：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">import BILL_BUTTON_CONFIGS from &#x27;./buttonConfig&#x27;</span><br></pre></td></tr></table></figure>
不然里面的BILL_BUTTON_CONFIGS常量使用会undefined</li>
<li>v-bind绑定是可以使用三目运算符的<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">:class=&quot;taskVO.selected?&#x27;selected&#x27;:&#x27;&#x27;&quot;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="log打印"><a href="#log打印" class="headerlink" title="log打印"></a>log打印</h2><p>如果变量打印前面加了字符串拼接的话，chrome是不会自动打印变量的具体内容的！</p>
<h2 id="API-in-common-use"><a href="#API-in-common-use" class="headerlink" title="API in common use"></a>API in common use</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">v:bind:attribute</span><br><span class="line">v-html</span><br><span class="line">v-on:click</span><br><span class="line">v-on:dblclick</span><br><span class="line">v-on:mousemove</span><br><span class="line"></span><br><span class="line">v-on:可以用@代替</span><br></pre></td></tr></table></figure>
<h2 id="vue-import"><a href="#vue-import" class="headerlink" title="vue import @"></a>vue import @</h2><p>@ 等价于 &#x2F;src 这个目录，避免写麻烦又易错的相对路径</p>
<h2 id="使用Vue-prototype实现全局变量"><a href="#使用Vue-prototype实现全局变量" class="headerlink" title="使用Vue.prototype实现全局变量"></a>使用Vue.prototype实现全局变量</h2><p>当你在main.js里声明了Vue.prototype.a &#x3D; 1后，因为你的每一个vue组件都是一个Vue对象的实例，所以即使你没有在组件内部使用data(){return{……}}声明a，你依然可以在组件中通过this.a来访问。</p>
<h2 id="Template-Literals（模板对象）-in-ES6"><a href="#Template-Literals（模板对象）-in-ES6" class="headerlink" title="Template Literals（模板对象） in ES6"></a>Template Literals（模板对象） in ES6</h2><p>如在es5中拼凑字符串需要+’’以及变量名</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var name = &#x27;Your name is &#x27; + first + &#x27; &#x27; + last + &#x27;.&#x27;;</span><br><span class="line">var url = &#x27;http://localhost:3000/api/messages/&#x27; + id;</span><br></pre></td></tr></table></figure>
<p>在es6中新增添了${}的使用方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var name = `Your name is $&#123;first&#125; $&#123;last&#125;. `;</span><br><span class="line">var url = `http://localhost:3000/api/messages/$&#123;id&#125;`;</span><br></pre></td></tr></table></figure>

<h2 id="no-undef"><a href="#no-undef" class="headerlink" title="no-undef"></a>no-undef</h2><p>“extends”: “eslint:recommended”配置文件中的属性启用此规则。<br>此规则可以帮助您查找由变量和参数名称拼写错误或意外隐式全局变量（例如，var在for循环初始值设定项中遗忘关键字）导致的潜在ReferenceErrors 。</p>
<h2 id="style-scoped"><a href="#style-scoped" class="headerlink" title="style scoped"></a>style scoped</h2><p>在Vue组件中，为了使样式私有化（模块化），不对全局造成污染，可以在style标签上添加scoped属性以表示它的只属于当下的模块，局部有效。如果一个项目中的所有vue组件style标签全部加上了scoped，相当于实现了样式的私有化。如果引用了第三方组件，需要在当前组件中局部修改第三方组件的样式，而又不想去除scoped属性造成组件之间的样式污染。</p>
<h2 id="v-model-vs-model"><a href="#v-model-vs-model" class="headerlink" title="v-model vs :model"></a>v-model vs :model</h2><p>v-model是vue内置的控件和变量之间双向数据绑定的指令，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--input输入框，值会在&lt;p&gt;标签打印出来--&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">     &lt;input type=&quot;text&quot; v-model=&quot;message&quot; placeholder=&quot;请输入&quot;&gt;</span><br><span class="line">    &lt;p&gt;输入的内容是: &#123;&#123;message&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var  vue=new Vue(&#123;</span><br><span class="line">        el:&#x27;#app&#x27;,</span><br><span class="line">        data:&#123;</span><br><span class="line">           message:&#x27;&#x27;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>:model相当于v-bind:model的缩写，<br>    v-bind动态绑定指令，默认情况下控件自带属性的值是固定的。<br>    这种只是将父组件的数据传递到了子组件，并没有实现子组件和父组件数据的双向绑定。<br>    当然引用类型除外，子组件改变引用类型的数据的话，父组件也会改变的。</p>
<p>用v-bind和v-on指令实现v-model，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--input输入框--&gt;</span><br><span class="line">&lt;div id=&quot;app&quot;&gt;</span><br><span class="line">    &lt;!--把message字段的值作为input标签的value属性值，同时监听输入事件，实时更新message的值--&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; @input=&quot;handleInput($event)&quot;  placeholder=&quot;请输入&quot;  v-bind:value=&quot;message&quot;&gt;</span><br><span class="line">    &lt;p&gt;输入的内容是: &#123;&#123;message&#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">    var  vue=new Vue(&#123;</span><br><span class="line">        el:&#x27;#app&#x27;,</span><br><span class="line">        data:&#123;</span><br><span class="line">            message:&#x27;&#x27;</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            handleInput: function (event) &#123;</span><br><span class="line">                console.info(&quot;控制台打印event详情&quot;)</span><br><span class="line">                console.info(event)</span><br><span class="line">                console.info(event.toLocaleString());</span><br><span class="line">                this.message=event.target.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="XML-DOM自带的validate方法"><a href="#XML-DOM自带的validate方法" class="headerlink" title="XML DOM自带的validate方法"></a>XML DOM自带的validate方法</h2><p>查看js源码发现，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export interface IXMLDOMSchemaCollection &#123;</span><br><span class="line">        length: number;</span><br><span class="line">        namespaceURI(index: number): string;</span><br><span class="line">        validateOnLoad: boolean;</span><br><span class="line"></span><br><span class="line">        add(namespaceURI: string, schema: string|IXMLDOMNode): void;</span><br><span class="line">        addCollection(collection: IXMLDOMSchemaCollection): void;</span><br><span class="line">        get(namespaceURI: string): IXMLDOMNode;</span><br><span class="line">        getDeclaration(node: IXMLDOMNode): ISchemaItem;</span><br><span class="line">        getSchema(namespaceURI: string): ISchema;</span><br><span class="line">        remove(namespaceURI: string): void;</span><br><span class="line">        validate(): void;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>因此，在vue的代码中，form对象可以直接调用validate()，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">handleLogin () &#123;</span><br><span class="line">  this.$refs.loginForm.validate(valid =&gt; &#123;</span><br><span class="line">    if (valid) &#123;</span><br><span class="line">      this.$store.dispatch(&quot;LoginByUsername&quot;, this.loginForm).then(() =&gt; &#123;</span><br><span class="line">        this.$router.push(&#123; path: this.tagWel.value &#125;);</span><br><span class="line">      &#125;).catch(()=&gt;&#123;</span><br><span class="line">        this.refreshCode()</span><br><span class="line">      &#125;)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vue中this-router-push-路由传值和获取的两种常见方法"><a href="#vue中this-router-push-路由传值和获取的两种常见方法" class="headerlink" title="vue中this.$router.push()路由传值和获取的两种常见方法"></a>vue中this.$router.push()路由传值和获取的两种常见方法</h2><p><a href="https://www.cnblogs.com/toonezhr/p/10325457.html">https://www.cnblogs.com/toonezhr/p/10325457.html</a></p>
<h2 id="Vue-extend-new-Vue-Vue-component-render"><a href="#Vue-extend-new-Vue-Vue-component-render" class="headerlink" title="Vue.extend, new Vue(), Vue.component(), render"></a>Vue.extend, new Vue(), Vue.component(), render</h2><p><a href="https://www.jianshu.com/p/ae319db5b456">https://www.jianshu.com/p/ae319db5b456</a></p>
<h2 id="vue-sync修饰符"><a href="#vue-sync修饰符" class="headerlink" title="vue sync修饰符"></a>vue sync修饰符</h2><p>vue 修饰符sync的功能是：当一个子组件改变了一个 prop 的值时，这个变化也会同步到父组件中所绑定。<br><a href="https://www.jianshu.com/p/6b062af8cf01">https://www.jianshu.com/p/6b062af8cf01</a></p>
<h2 id="常用属性"><a href="#常用属性" class="headerlink" title="常用属性"></a>常用属性</h2><p>vm.$el<br>获取Vue实例关联的DOM元素；</p>
<p>vm.$data<br>获取Vue实例的data选项（对象）</p>
<p>vm.$options<br>获取Vue实例的自定义属性（如vm.$options.methods,获取Vue实例的自定义属性methods）</p>
<p>vm.$refs<br>获取页面中所有含有ref属性的DOM元素（如vm.$refs.hello，获取页面中含有属性ref &#x3D; “hello”的DOM元素，如果有多个元素，那么只返回最后一个）<br><a href="https://www.jianshu.com/p/f6f3f00cd923">https://www.jianshu.com/p/f6f3f00cd923</a></p>
<h2 id="vue-use和vue-prototype的区别"><a href="#vue-use和vue-prototype的区别" class="headerlink" title="vue.use和vue.prototype的区别"></a>vue.use和vue.prototype的区别</h2><h2 id="watch、mounted、computed、created的区别-todo"><a href="#watch、mounted、computed、created的区别-todo" class="headerlink" title="watch、mounted、computed、created的区别 todo"></a>watch、mounted、computed、created的区别 todo</h2><h3 id="created和mounted的区别"><a href="#created和mounted的区别" class="headerlink" title="created和mounted的区别"></a>created和mounted的区别</h3><p>created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。</p>
<p>mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点。</p>
<h4 id="二者的执行顺序"><a href="#二者的执行顺序" class="headerlink" title="二者的执行顺序"></a>二者的执行顺序</h4><p>嵌套组件中两者的执行顺序不同。</p>
<p>父组件 created</p>
<p>子组件 created</p>
<p>子组件 mounted</p>
<p>父组件 mounted</p>
<h3 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h3><h4 id="watch的高级用法"><a href="#watch的高级用法" class="headerlink" title="watch的高级用法"></a>watch的高级用法</h4><p>监听变量originList的变化，如果变化了调用init方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mounted () &#123;</span><br><span class="line">    this.$watch(&quot;originList&quot;, this.init)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="x3D-gt-import-“-x2F-components-x2F-common-x2F-Empty”-这是什么写法？"><a href="#x3D-gt-import-“-x2F-components-x2F-common-x2F-Empty”-这是什么写法？" class="headerlink" title="$&#x3D;&gt;import(“@&#x2F;components&#x2F;common&#x2F;Empty”)这是什么写法？"></a>$&#x3D;&gt;import(“@&#x2F;components&#x2F;common&#x2F;Empty”)这是什么写法？</h2><h2 id="this-options"><a href="#this-options" class="headerlink" title="this.$options"></a>this.$options</h2><p>通过this.$options调用方法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">his.$options.methods.getPicData.call(this)</span><br></pre></td></tr></table></figure>
<p>带参数的调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$options.methods.getPicData.call(this,data)</span><br></pre></td></tr></table></figure>

<h2 id="this-emit-x2F-Vue子组件向父组件传值"><a href="#this-emit-x2F-Vue子组件向父组件传值" class="headerlink" title="this.$emit()&#x2F;Vue子组件向父组件传值"></a>this.$emit()&#x2F;Vue子组件向父组件传值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$emit(&#x27;refreshCodeTreeFun&#x27;)</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;vercode-info ref=&quot;vercodeInfo&quot; v-if=&quot;showVercodeTable&quot;</span><br><span class="line">				:parent-id=&quot;parentId&quot;</span><br><span class="line">				:current-id=&quot;currentId&quot;</span><br><span class="line">				:parent-name=&quot;parentName&quot;</span><br><span class="line">				:default-node-type=&quot;defaultNodeType&quot;</span><br><span class="line">				:specialty-name=&quot;specialtyName&quot;</span><br><span class="line">				:specialty-id=&quot;specialtyId&quot;</span><br><span class="line">				@refreshCodeTreeFun=&quot;refreshCodeTreeFun&quot;&gt;&lt;/vercode-info&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">refreshCodeTreeFun () &#123;</span><br><span class="line">			this.showCodeTree = false</span><br><span class="line">			setTimeout(() =&gt; &#123;</span><br><span class="line">				this.showCodeTree = true</span><br><span class="line">			&#125;, 1)</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ref属性"><a href="#ref属性" class="headerlink" title="ref属性"></a>ref属性</h2><p>ref 被用来给元素或子组件注册引用信息。引用信息将会注册在父组件的 $refs 对象上。</p>
<p>$refs 是所有注册过的ref的一个集合。</p>
<h2 id="vue语法-（模版字符串）"><a href="#vue语法-（模版字符串）" class="headerlink" title="vue语法 ${ }（模版字符串）"></a>vue语法 <code>$&#123; &#125;</code>（模版字符串）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const name = &#x27;小缘&#x27;</span><br><span class="line">const age = 14</span><br><span class="line">console.info(`大家好，我叫$&#123;name&#125;，今年$&#123;age&#125;岁了`)</span><br><span class="line">// 等价于</span><br><span class="line">console.info(&#x27;大家好，我叫&#x27; + name + &#x27;，今年&#x27; + age + &#x27;岁了&#x27;)</span><br><span class="line"> </span><br><span class="line">// 最大的优势是支持换行字符串</span><br><span class="line">const url = &#x27;//baidu.com&#x27;</span><br><span class="line">const text = &#x27;百度一下，你就知道&#x27;</span><br><span class="line">const html = `</span><br><span class="line">  &lt;div class=&quot;container&quot;&gt;</span><br><span class="line">    &lt;a href=&quot;$&#123;url&#125;&quot;&gt;$&#123;text&#125;&lt;/a&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">`</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「Hzsilvana」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/weixin_42776027/java/article/details/101197879</span><br></pre></td></tr></table></figure>


<h2 id="自定义setter方法，调用时一并返回对象"><a href="#自定义setter方法，调用时一并返回对象" class="headerlink" title="自定义setter方法，调用时一并返回对象"></a>自定义setter方法，调用时一并返回对象</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export const createQueryFieldEnhance = function () &#123;</span><br><span class="line">	let field = &#123;</span><br><span class="line">		type: &#x27;&#x27;, propertyName: &#x27;&#x27;, fieldName: &#x27;&#x27;, dataSource: [], dataSourceCode: &#x27;&#x27;, isMultiple: false,</span><br><span class="line">		setType (type) &#123;</span><br><span class="line">			this.type = type</span><br><span class="line">			return this</span><br><span class="line">		&#125;,</span><br><span class="line">		setPropertyName (propertyName) &#123;</span><br><span class="line">			this.propertyName = propertyName</span><br><span class="line">			return this</span><br><span class="line">		&#125;,</span><br><span class="line">		setFieldName (fieldName) &#123;</span><br><span class="line">			this.fieldName = fieldName</span><br><span class="line">			return this</span><br><span class="line">		&#125;,</span><br><span class="line">		setDataSource (dataSource) &#123;</span><br><span class="line">			this.dataSource = dataSource</span><br><span class="line">			return this</span><br><span class="line">		&#125;,</span><br><span class="line">		setDataSourceCode (dataSourceCode) &#123;</span><br><span class="line">			this.dataSourceCode = dataSourceCode</span><br><span class="line">			return this</span><br><span class="line">		&#125;,</span><br><span class="line">		setIsMultiple (isMultiple) &#123;</span><br><span class="line">			this.isMultiple = isMultiple</span><br><span class="line">			return this</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return field</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vue组件之间通信的6种方式"><a href="#vue组件之间通信的6种方式" class="headerlink" title="vue组件之间通信的6种方式"></a>vue组件之间通信的6种方式</h2><h3 id="emit-x2F-on"><a href="#emit-x2F-on" class="headerlink" title="$emit &#x2F; $on"></a>$emit &#x2F; $on</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">this.$emit(事件名,数据);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">async mounted ()&#123;</span><br><span class="line">    this.$on(&quot;refresh&quot;, $=&gt;&#123;</span><br><span class="line">        // xxx</span><br><span class="line">	&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="输入框Input监听回车"><a href="#输入框Input监听回车" class="headerlink" title="输入框Input监听回车"></a>输入框Input监听回车</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;el-input v-model=&quot;name&quot; @keyup.enter.native=&quot;onSubmit&quot; placeholder=&quot;User Name&quot;&gt;&lt;/el-input&gt;</span><br></pre></td></tr></table></figure>

<h2 id="vue监听浏览器窗口的变化"><a href="#vue监听浏览器窗口的变化" class="headerlink" title="vue监听浏览器窗口的变化"></a>vue监听浏览器窗口的变化</h2><p><a href="https://blog.csdn.net/weixin_34049948/article/details/86021903">https://blog.csdn.net/weixin_34049948&#x2F;article&#x2F;details&#x2F;86021903</a></p>
<h2 id="package-json中-和-的区别"><a href="#package-json中-和-的区别" class="headerlink" title="package.json中^和~的区别"></a>package.json中^和~的区别</h2><p><a href="https://blog.csdn.net/Amnesiac666/article/details/111194388">https://blog.csdn.net/Amnesiac666/article/details/111194388</a></p>
<h1 id="Tool"><a href="#Tool" class="headerlink" title="Tool"></a>Tool</h1><p><a href="http://www.html2jade.org/">html和pug之间的转换</a></p>
<h2 id="倒计时组件"><a href="#倒计时组件" class="headerlink" title="倒计时组件"></a>倒计时组件</h2><p><a href="https://www.cnblogs.com/haoning/p/11686674.html">https://www.cnblogs.com/haoning/p/11686674.html</a></p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>lombok汇总</title>
    <url>/2019/10/15/lombok%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="SneakyThrows是否可以大量使用？"><a href="#SneakyThrows是否可以大量使用？" class="headerlink" title="@SneakyThrows是否可以大量使用？"></a>@SneakyThrows是否可以大量使用？</h2><p>不建议大量使用，异常还是要研究地做好各种catch和处理，在单元测试中为了效率可以使用。</p>
<h2 id="AllArgsConstructor"><a href="#AllArgsConstructor" class="headerlink" title="@AllArgsConstructor"></a>@AllArgsConstructor</h2><p>生成所有成员变量的有参构造器，同时因为Spring的新特性：<br>In the newest Spring release, it’s constructor does not need to be annotated with @Autowired annotation.</p>
<p>所以成员变量会被自动注入。<br><em><strong>要注意的是，如果bean中有多个构造器的话，那么就要声明@Autowired给其中一个构造器，不然Spring不会默认去选择构造器。</strong></em></p>
<h2 id="RequiredArgsConstructor"><a href="#RequiredArgsConstructor" class="headerlink" title="@RequiredArgsConstructor"></a>@RequiredArgsConstructor</h2><p>Required arguments are final fields and fields with constraints such as {@code @NonNull}.<br>RequiredArgsConstructor是针对final成员变量去生成有参构造器。</p>
<h2 id="UtilityClass"><a href="#UtilityClass" class="headerlink" title="@UtilityClass"></a>@UtilityClass</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * An annotation to create utility classes.</span><br><span class="line"> * </span><br><span class="line"> * If a class is annotated with &#123;@code @UtilityClass&#125;, the following things happen to it:&lt;ul&gt;</span><br><span class="line"> * &lt;li&gt;It is marked final.&lt;/li&gt;</span><br><span class="line"> * &lt;li&gt;If any constructors are declared in it, an error is generated. Otherwise, a private no-args constructor is generated; it throws a &#123;@code UnsupportedOperationException&#125;.&lt;/li&gt;</span><br><span class="line"> * &lt;li&gt;All methods, inner classes, and fields in the class are marked static.&lt;/li&gt;</span><br><span class="line"> * &lt;li&gt;&lt;em&gt;WARNING:&lt;/em&gt; Do not use non-star static imports to import these members; javac won&#x27;t be able to figure it out. Use either:</span><br><span class="line"> *    &lt;code&gt;import static ThisType.*;&lt;/code&gt; or don&#x27;t static-import.&lt;/li&gt;</span><br><span class="line"> * &lt;/ul&gt;</span><br><span class="line"> */</span><br></pre></td></tr></table></figure>
<p>被@UtilityClass定义的类会被视为工具类，该类会被编译成final类型，同时生成一个私有的无参构造器，禁止被实例化，此外，该类的所有方法，内部类和变量都会被编程成静态类型。</p>
<h2 id="EqualsAndHashCode-callSuper-x3D-true"><a href="#EqualsAndHashCode-callSuper-x3D-true" class="headerlink" title="@EqualsAndHashCode(callSuper &#x3D; true)"></a>@EqualsAndHashCode(callSuper &#x3D; true)</h2><p>@Data相当于@Getter @Setter @RequiredArgsConstructor @ToString @EqualsAndHashCode这5个注解的合集。<br>通过官方文档，可以得知，当使用@Data注解时，则有了@EqualsAndHashCode注解，那么就会在此类中存在equals(Object other) 和 hashCode()方法，且不会使用父类的属性，这就导致了可能的问题。<br>加上callSuper &#x3D; true表示需要使用父类的属性</p>
]]></content>
      <categories>
        <category>lombok</category>
      </categories>
      <tags>
        <tag>lombok</tag>
      </tags>
  </entry>
  <entry>
    <title>oracle系列之索引</title>
    <url>/2019/04/28/oracle%E7%B3%BB%E5%88%97%E4%B9%8B%E7%B4%A2%E5%BC%95%E6%B7%B1%E5%85%A5%E7%A0%94%E7%A9%B6/</url>
    <content><![CDATA[<h2 id="为什么加索引后会使写入、修改、删除变慢？"><a href="#为什么加索引后会使写入、修改、删除变慢？" class="headerlink" title="为什么加索引后会使写入、修改、删除变慢？"></a>为什么加索引后会使写入、修改、删除变慢？</h2><p>事物都是有两面的， 索引能让数据库查询数据的速度上升， 而使写入数据的速度下降，原因很简单的， 因为平衡树这个结构必须一直维持在一个正确的状态， 增删改数据都会改变平衡树各节点中的索引数据内容，破坏树结构， 因此，在每次数据改变时， DBMS必须去重新梳理树（索引）的结构以确保它的正确，这会带来不小的性能开销，也就是为什么索引会给查询以外的操作带来副作用的原因。</p>
<h2 id="什么情况下要同时在两个字段上建索引？"><a href="#什么情况下要同时在两个字段上建索引？" class="headerlink" title="什么情况下要同时在两个字段上建索引？"></a>什么情况下要同时在两个字段上建索引？</h2><p>有一种例外可以不使用聚集索引就能查询出所需要的数据， 这种非主流的方法 称之为「覆盖索引」查询， 也就是平时所说的复合索引或者多字段索引查询。 文章上面的内容已经指出， 当为字段建立索引以后， 字段中的内容会被同步到索引之中， 如果为一个索引指定两个字段， 那么这个两个字段的内容都会被同步至索引之中。</p>
<p>先看下面这个SQL语句</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//建立索引</span><br><span class="line">create index index_birthday on user_info(birthday);</span><br><span class="line">//查询生日在1991年11月1日出生用户的用户名</span><br><span class="line">select user_name from user_info where birthday = &#x27;1991-11-1&#x27;</span><br></pre></td></tr></table></figure>
<p>这句SQL语句的执行过程如下</p>
<ul>
<li><p>首先，通过非聚集索引index_birthday查找birthday等于1991-11-1的所有记录的主键ID值</p>
</li>
<li><p>然后，通过得到的主键ID值执行聚集索引查找，找到主键ID值对就的真实数据（数据行）存储的位置</p>
</li>
<li><p>最后， 从得到的真实数据中取得user_name字段的值返回， 也就是取得最终的结果</p>
</li>
</ul>
<p>我们把birthday字段上的索引改成双字段的覆盖索引</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create index index_birthday_and_user_name on user_info(birthday, user_name);</span><br></pre></td></tr></table></figure>
<p>这句SQL语句的执行过程就会变为:</p>
<blockquote>
<p>通过非聚集索引index_birthday_and_user_name查找birthday等于1991-11-1的叶节点的内容，然而， 叶节点中除了有user_name表主键ID的值以外， user_name字段的值也在里面， 因此不需要通过主键ID值的查找数据行的真实所在， 直接取得叶节点中user_name的值返回即可。 通过这种覆盖索引直接查找的方式， 可以省略不使用覆盖索引查找的后面两个步骤， 大大的提高了查询性能.</p>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/aspwebchh/p/6652855.html">https://www.cnblogs.com/aspwebchh/p/6652855.html</a></p>
</blockquote>
<h2 id="B树索引-B-Tree"><a href="#B树索引-B-Tree" class="headerlink" title="B树索引(B-Tree)"></a>B树索引(B-Tree)</h2><h2 id="位图索引"><a href="#位图索引" class="headerlink" title="位图索引"></a>位图索引</h2><p>位图索引的应用场景:</p>
<ol>
<li>适合只有几个固定值的列,比如性别,行政区,祖籍等,这种基数很低的情况.</li>
<li>适合相对静态的数据,不适合值频繁更新的字段.</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># demo:</span><br><span class="line">create bitmap index random_empno_bmx on test_random(empno);</span><br><span class="line"></span><br><span class="line"># 这个时候有人会说使用位图索引，因为busy只有两个值。好，我们使用位图索引索引busy字段！假设用户A使用update更新某个机器的busy值，比如update table set table.busy=1 where rowid=100;，但还没有commit，而用户B也使用update更新另一个机器的busy值，update table set table.busy=1 where rowid=12; 这个时候用户B怎么也更新不了，需要等待用户A commit。</span><br><span class="line">　　原因：用户A更新了某个机器的busy值为1，会导致所有busy为1的机器的位图向量发生改变，因此数据库会将busy＝1的所有行锁定，只有commit之后才解锁。</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="http://hongyitong.github.io/2016/08/22/%E4%BD%8D%E5%9B%BE%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%EF%BC%88BitMap%20index%EF%BC%89/">http://hongyitong.github.io/2016/08/22/%E4%BD%8D%E5%9B%BE%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%EF%BC%88BitMap%20index%EF%BC%89/</a></p>
</blockquote>
<h2 id="反向键索引"><a href="#反向键索引" class="headerlink" title="反向键索引"></a>反向键索引</h2><ol>
<li>反向键索引是特殊的B数索引</li>
<li>适用于在表中严格排序的列上创建反向键索引</li>
</ol>
<p>在常规的B树索引中，如果主键列时递增的，那么往表中添加新的数据时，B树索引将直接访问最后一个数据，而不是一个节点一个节点的访问。这种情况造成的现象是：随着数据行的不断添加，已经原有数据行的删除，B树索引的很多空间会被浪费掉，如1012节点上方的几个数据行都是空的。而且B树索引将会变得越来越不均匀。如下图这般。</p>


<p>反向键索引原理<br>如果用户使用序列编号在表中添加新的纪录，则反向键索引首先反向转换每个键值的字节，然后在反向后的新数据在进行索引.</p>
<p>例如：用户输入的索引键是4201，那么反向键索引将其反向转换为1024，这样索引键就变成非递增了，也就意味着，如果将反向后的索引键添加到叶子节点中，可能在任意的叶子节点中进行，从而使新的数据在值得范围分布式比原来的均匀。</p>
<blockquote>
<p>原文：<a href="https://blog.csdn.net/zhou920786312/article/details/72792355">https://blog.csdn.net/zhou920786312/article/details/72792355</a> </p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 创建反向索引的demo</span><br><span class="line">create unique index re_emp2no_idx on emp2(empno) reverse;</span><br><span class="line">alter table emp2 add constraint pk_emp2 primary key (empno) USING INDEX re_emp2no_idx;</span><br><span class="line">SELECT TABLE_NAME, CONSTRAINT_NAME, CONSTRAINT_TYPE FROM all_constraints WHERE TABLE_NAME = &#x27;EMP2&#x27;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>oracle</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>网络、密码与安全</title>
    <url>/2019/10/15/%E7%BD%91%E7%BB%9C%E3%80%81%E5%AF%86%E7%A0%81%E4%B8%8E%E5%AE%89%E5%85%A8/</url>
    <content><![CDATA[<h1 id="TodoItem"><a href="#TodoItem" class="headerlink" title="TodoItem"></a>TodoItem</h1><h2 id="JWT-todo"><a href="#JWT-todo" class="headerlink" title="JWT todo"></a>JWT todo</h2><h2 id="互联网-20-大安全隐患-todo"><a href="#互联网-20-大安全隐患-todo" class="headerlink" title="互联网 20 大安全隐患 todo"></a>互联网 20 大安全隐患 todo</h2><h4 id="CSRF-攻击的应对之道-todo"><a href="#CSRF-攻击的应对之道-todo" class="headerlink" title="CSRF 攻击的应对之道 todo"></a>CSRF 攻击的应对之道 todo</h4><p><a href="https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/">https://www.ibm.com/developerworks/cn/web/1102_niugang_csrf/</a></p>
<p><a href="https://segmentfault.com/a/1190000006944760?utm_source=tag-newest">https://segmentfault.com/a/1190000006944760?utm_source=tag-newest</a></p>
<p><a href="https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html">https://www.cnblogs.com/hyddd/archive/2009/04/09/1432744.html</a></p>
<h2 id="RS256加密算法研究-todo"><a href="#RS256加密算法研究-todo" class="headerlink" title="RS256加密算法研究 todo"></a>RS256加密算法研究 todo</h2><h2 id="http-vs-https-todo"><a href="#http-vs-https-todo" class="headerlink" title="http vs https todo"></a>http vs https todo</h2><h2 id="SSL-vs-TLS-todo"><a href="#SSL-vs-TLS-todo" class="headerlink" title="SSL vs TLS todo"></a>SSL vs TLS todo</h2><h2 id="AES-是对称加密，不安全-todo"><a href="#AES-是对称加密，不安全-todo" class="headerlink" title="AES 是对称加密，不安全? todo"></a>AES 是对称加密，不安全? todo</h2><h2 id="TCP-vs-WebSocket-vs-KCP"><a href="#TCP-vs-WebSocket-vs-KCP" class="headerlink" title="TCP vs WebSocket vs KCP"></a>TCP vs WebSocket vs KCP</h2><h1 id="两种基本的加解密算法类型"><a href="#两种基本的加解密算法类型" class="headerlink" title="两种基本的加解密算法类型"></a>两种基本的加解密算法类型</h1><ol>
<li><p>对称加密（symmetrcic encryption）：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES，RC5，3DES等；对称加密主要问题是共享秘钥，除你的计算机（客户端）知道另外一台计算机（服务器）的私钥秘钥，否则无法对通信流进行加密解密。解决这个问题的方案非对称秘钥。</p>
</li>
<li><p>非对称加密：使用两个秘钥：公共秘钥和私有秘钥。私有秘钥由一方密码保存（一般是服务器保存），另一方任何人都可以获得公共秘钥。<br>这种密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</p>
</li>
</ol>
<h1 id="网络通讯协议"><a href="#网络通讯协议" class="headerlink" title="网络通讯协议"></a>网络通讯协议</h1><blockquote>
<p><a href="https://www.jianshu.com/p/947a2673102a">参考来源</a></p>
</blockquote>
<h2 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h2><p>TCP协议主要是在传输层，基于三次握手原理。</p>
<h3 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h3><ul>
<li>第一次握手：客户端尝试连接服务器，向服务器发送syn包（同步序列编号Synchronize Sequence Numbers），syn&#x3D;j，客户端进入SYN_SEND状态等待服务器确认；</li>
<li>第二次握手：服务器接收客户端syn包并确认（ack&#x3D;j+1），同时向客户端发送一个SYN包（syn&#x3D;k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li>
<li>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack&#x3D;k+1），此包发送完毕，客户端和服务器进入ESTABLISHED状态，完成三次握手。</li>
</ul>
<h3 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h3><h2 id="Http"><a href="#Http" class="headerlink" title="Http"></a>Http</h2><p>TCP协议对应于传输层，而HTTP协议对应于应用层，从本质上来说，二者没有可比性，<em><strong>Http协议是建立在TCP协议基础之上的。</strong></em></p>
<h3 id="Http的特点"><a href="#Http的特点" class="headerlink" title="Http的特点"></a>Http的特点</h3><ul>
<li>简单快速（只需传送请求方法和路径。请求方法常用的有GET、POST等。每种方法规定了客户与服务器交互的类型不同，由于HTTP协议简单，使得HTTP服务器的程序规模小，因而通信速度很快）</li>
<li>灵活（请求头部的Content-Type信息可以代表任意类型的数据，比如图片、文件、字符串数据等）</li>
<li>短连接（限制每次连接只处理一个请求。服务器处理完客户的请求，收到客户的应答后，即断开连接，节省端到端的交互成本）</li>
<li>无状态（无状态是指协议对于事务处理没有记忆能力，在没有自定义特定的标示时，服务端无法判断两个请求的相互关联性，缺少状态意味着如果后续处理需要前面的信息，则它必须重传关键数据信息，这样可能导致每次连接传送的数据量增大）</li>
</ul>
<h3 id="HTTP的请求方法"><a href="#HTTP的请求方法" class="headerlink" title="HTTP的请求方法"></a>HTTP的请求方法</h3><ul>
<li>GET（根据url请求指定的页面信息，并返回实体主体）</li>
<li>HEAD（类似于get请求，只不过返回的响应中没有具体的内容，用于获取报头）</li>
<li>POST（向指定资源提交数据进行处理请求，例如提交表单或者上传文件，数据被包含在请求体中）</li>
<li>PUT（从客户端向服务器传送更新数据）</li>
<li>DELETE（请求服务器删除指定的页面）</li>
<li>CONNECT（HTTP1.1协议中预留给能够将连接改为管道方式的代理服务器）</li>
<li>OPTIONS（允许客户端查看服务器的性能）</li>
<li>TRACE（回显服务器收到的请求，主要用于测试或诊断）</li>
</ul>
<h3 id="Unsupported-Media-Type"><a href="#Unsupported-Media-Type" class="headerlink" title="Unsupported Media Type"></a>Unsupported Media Type</h3><p>在PostMan中调用后端微服务的Post接口，报了这个错，解决方法：<br>Headers增加Content-Type:application&#x2F;json<br>Body采用raw和JSON(application&#x2F;json)的方式发送，然后再下方填入json数据。</p>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><blockquote>
<p>Socket可以看成在两个程序进行通讯连接中的一个端点，一个程序将一段信息写入Socket中，该Socket将这段信息发送给另外一个Socket中，使这段信息能传送到其他程序中。<br>通过Socket编程使用TCP协议的时候，因为我们自己可以通过代码区控制什么时候打开连接什么时候关闭连接，只要我们不通过代码把连接关闭，这个连接就会在客户端和服务端的进程中一直存在。</p>
</blockquote>
<h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>生成套接字，主要有3个参数：通信的目的IP地址、使用的传输层协议(TCP或UDP)和使用的端口号。Socket原意是“插座”。通过将这3个参数结合起来，与一个“插座”Socket绑定，应用层就可以和传输层通过套接字接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。<br>要通过互联网进行通信，至少需要一对套接字，一个运行于客户机端，称之为ClientSocket，另一个运行于服务器端，称之为serverSocket。<br><em><strong>Socket连接一旦建立，通信双方即可开始相互发送数据内容，直到双方连接断开。</strong></em><br>套接字之间的连接过程可以分为三个步骤：</p>
<ul>
<li>服务器监听：是服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态；</li>
<li>客户端请求：是指由客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。为此，客户端的套接字必须，首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</li>
<li>连接确认：是指当服务器端套接字监听到或者说接收到客户端套接字的连接请求，它就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，连接就建立好了，而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</li>
</ul>
<blockquote>
<p>实际上socket是对TCP&#x2F;IP协议的封装，Socket本身并不是协议，而是一个调用接口（API），通过Socket，我们才能使用TCP&#x2F;IP协议。 实际上，Socket跟TCP&#x2F;IP协议没有必然的联系。Socket编程接口在设计的时候，就希望也能适应其他的网络协议。所以说，Socket的出现只是使得程序员更方便地使用TCP&#x2F;IP协议栈而已，是对TCP&#x2F;IP协议的抽象，从而形成了我们知道的一些最基本的函数接口，比如create、 listen、connect、accept、send、read和write等等。<br>实际上，传输层的TCP是基于网络层的IP协议的，而应用层的HTTP协议又是基于传输层的TCP协议的，而Socket本身不算是协议，就像上面所说，它只是提供了一个针对TCP或者UDP编程的接口。socket是对端口通信开发的工具,它要更底层一些。</p>
</blockquote>
<h3 id="HTTP-VS-Socket"><a href="#HTTP-VS-Socket" class="headerlink" title="HTTP VS Socket"></a>HTTP VS Socket</h3><p>HTTP是轿车，提供了封装或者显示数据的具体形式；Socket是发动机，提供了网络通信的能力。</p>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="Apache-Jmeter（高并发模拟测压）"><a href="#Apache-Jmeter（高并发模拟测压）" class="headerlink" title="Apache Jmeter（高并发模拟测压）"></a>Apache Jmeter（高并发模拟测压）</h2><p>网站或服务请求压力模拟测试工具。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>WebStorm汇总</title>
    <url>/2019/10/17/WebStorm%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="shortcut"><a href="#shortcut" class="headerlink" title="shortcut"></a>shortcut</h1><p>新建文件的时候可以这样操作来脱离鼠标：<br>cmd+1跳到Project目录上下移动到目标目录，然后cmd+shift+A跳出Action，输入new+文件类型或者手动选择文件类型就可以了。</p>
<h1 id="高效率编码"><a href="#高效率编码" class="headerlink" title="高效率编码"></a>高效率编码</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--</span><br><span class="line">&gt;：下一个子标签</span><br><span class="line">*：多少个标签</span><br><span class="line">$：标签的名称序号</span><br><span class="line">&#123;&#125;:标签的内容</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--输入：h1,按tab键--&gt;</span><br><span class="line">&lt;h1&gt;&lt;/h1&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--输入：div#abc,按Tab键--&gt;</span><br><span class="line">&lt;div id=&quot;abc&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--输入：div.abc,按Tab键--&gt;</span><br><span class="line">&lt;div class=&quot;abc&quot;&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--输入: div&gt;p*6 ,按Tab键--&gt;</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &lt;p&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;/p&gt;</span><br><span class="line">    &lt;p&gt;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--输入 a[href=#] 按tab键--&gt;</span><br><span class="line">&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--输入：ul.menu&gt;li*6&gt;a[href=#]&#123;HTML&#125; 按tab键--&gt;</span><br><span class="line">&lt;ul class=&quot;menu&quot;&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;HTML&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--输入  ul&gt;li*5&gt;a[href=#]&#123;我是第$个&#125; 再按tab键--&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我是第1个&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我是第2个&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我是第3个&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我是第4个&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">    &lt;li&gt;&lt;a href=&quot;#&quot;&gt;我是第5个&lt;/a&gt;&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--输入 img[src=&#x27;images/$.jpg&#x27;]*3 再按tab键--&gt;</span><br><span class="line">&lt;img src=&quot;images/1.jpg&quot; alt=&quot;&quot;&gt;     </span><br><span class="line">&lt;img src=&quot;images/2.jpg&quot; alt=&quot;&quot;&gt;     </span><br><span class="line">&lt;img src=&quot;images/3.jpg&quot; alt=&quot;&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--输入 li*3&gt;div.img&gt;img[src=&#x27;images/$.jpg&#x27;] 再按tab键--&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">    &lt;div class=&quot;img&quot;&gt;&lt;img src=&quot;images/1.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">    &lt;div class=&quot;img&quot;&gt;&lt;img src=&quot;images/2.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/li&gt;</span><br><span class="line">&lt;li&gt;</span><br><span class="line">    &lt;div class=&quot;img&quot;&gt;&lt;img src=&quot;images/3.jpg&quot; alt=&quot;&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;/li&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/* for循环：输入itar,再点击tab键*/</span><br><span class="line">        for (var i = 0; i &lt; array.length; i++) &#123;</span><br><span class="line">            var obj = array[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">+ : 并列的标签</span><br><span class="line">&lt;!--div#tab1+div#tab2--&gt;</span><br><span class="line"></span><br><span class="line">&lt;div id=&quot;tab1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;tab2&quot;&gt;&lt;/div&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><a href="https://blog.csdn.net/sinat_31057219/article/details/79158978">https://blog.csdn.net/sinat_31057219/article/details/79158978</a></p>
</blockquote>
<h1 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h1><h2 id="ESLint"><a href="#ESLint" class="headerlink" title="ESLint"></a>ESLint</h2><p>指定项目的eslint配置文件：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/yI1T2Z.png"><br>然后再快捷键设置 Fix ESLint Problems，将原来的代码格式化快捷键去掉，就可以取代WebStorm的格式化了。</p>
]]></content>
      <categories>
        <category>WebStorm</category>
      </categories>
      <tags>
        <tag>WebStorm</tag>
      </tags>
  </entry>
  <entry>
    <title>Element-ui汇总</title>
    <url>/2019/10/17/Element-ui%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="v-contextmenu的使用-树形控件右键菜单"><a href="#v-contextmenu的使用-树形控件右键菜单" class="headerlink" title="v-contextmenu的使用(树形控件右键菜单)"></a>v-contextmenu的使用(树形控件右键菜单)</h1><p><a href="https://github.com/heynext/v-contextmenu/blob/a852e61278711ffaa811ad60bedef167e09782e8/examples/Simple.vue">Simple Demo</a><br><a href="https://github.com/heynext/v-contextmenu">Github 仓库代码</a></p>
<h1 id="el-autocomplete失去焦点-获得焦点"><a href="#el-autocomplete失去焦点-获得焦点" class="headerlink" title="el-autocomplete失去焦点 获得焦点"></a>el-autocomplete失去焦点 获得焦点</h1><p><a href="https://blog.csdn.net/weixin_34138139/article/details/91427293">https://blog.csdn.net/weixin_34138139&#x2F;article&#x2F;details&#x2F;91427293</a></p>
]]></content>
      <categories>
        <category>element-ui</category>
      </categories>
      <tags>
        <tag>element-ui</tag>
      </tags>
  </entry>
  <entry>
    <title>mockito</title>
    <url>/2019/11/08/mockito/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>RabbitMQ汇总</title>
    <url>/2019/10/28/RabbitMQ%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="BASIC-KNOWLEDGE"><a href="#BASIC-KNOWLEDGE" class="headerlink" title="BASIC KNOWLEDGE"></a>BASIC KNOWLEDGE</h1><h2 id="网上的基础教程"><a href="#网上的基础教程" class="headerlink" title="网上的基础教程"></a>网上的基础教程</h2><p><a href="https://blog.csdn.net/hellozpc/article/details/81436980">https://blog.csdn.net/hellozpc/article/details/81436980</a></p>
<h2 id="两个消息分发机制"><a href="#两个消息分发机制" class="headerlink" title="两个消息分发机制"></a>两个消息分发机制</h2><ul>
<li>Round-robin dispatch（轮训分发）</li>
<li>Fair dispatch（公平分发）</li>
</ul>
<h2 id="开启Browser后台界面管理插件"><a href="#开启Browser后台界面管理插件" class="headerlink" title="开启Browser后台界面管理插件"></a>开启Browser后台界面管理插件</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br><span class="line">docker run -d --hostname my-rabbit --name some-rabbit -p 15555:15672 rabbitmq:management</span><br></pre></td></tr></table></figure>
<p>15555端口可以自定义</p>
<h1 id="PROBLEM-SOLUTION"><a href="#PROBLEM-SOLUTION" class="headerlink" title="PROBLEM SOLUTION"></a>PROBLEM SOLUTION</h1><h2 id="guest取消本地登录限制"><a href="#guest取消本地登录限制" class="headerlink" title="guest取消本地登录限制"></a>guest取消本地登录限制</h2><p><a href="https://blog.csdn.net/shenhonglei1234/article/details/82745601">https://blog.csdn.net/shenhonglei1234/article/details/82745601</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">## 注意对应版本</span><br><span class="line">vi /usr/lib/rabbitmq/lib/rabbitmq_server-3.7.7/ebin/rabbit.app</span><br><span class="line"></span><br><span class="line">将：&#123;loopback_users, [&lt;&lt;”guest”&gt;&gt;]&#125;，</span><br><span class="line">改为：&#123;loopback_users, []&#125;，</span><br><span class="line">原因：rabbitmq从3.3.0开始禁止使用guest/guest权限通过除localhost外的访问</span><br><span class="line"></span><br><span class="line">service rabbitmq-server restart</span><br></pre></td></tr></table></figure>
<h2 id="org-springframework-amqp-AmqpConnectException-java-net-ConnectException-Connection-refused-Connection-refused"><a href="#org-springframework-amqp-AmqpConnectException-java-net-ConnectException-Connection-refused-Connection-refused" class="headerlink" title="org.springframework.amqp.AmqpConnectException: java.net.ConnectException: Connection refused (Connection refused)"></a>org.springframework.amqp.AmqpConnectException: java.net.ConnectException: Connection refused (Connection refused)</h2><p>默认基于tcp的连接端口是5672，详情可见rabbit.app配置文件里面的</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;tcp_listeners, [5672]&#125;</span><br></pre></td></tr></table></figure>
<p>还要注意防火墙是否屏蔽端口。</p>
<h2 id="cannot-deserialize-from-Object-value-no-delegate-or-property-based-Creator"><a href="#cannot-deserialize-from-Object-value-no-delegate-or-property-based-Creator" class="headerlink" title="cannot deserialize from Object value (no delegate- or property-based Creator)"></a>cannot deserialize from Object value (no delegate- or property-based Creator)</h2><p>不小心在POJO加了lombok的@AllArgsConstructor注解，这个方法会私有化无参构造器，导致序列化失败。</p>
<h2 id="How-to-delete-all-messages-from-a-Queue"><a href="#How-to-delete-all-messages-from-a-Queue" class="headerlink" title="How to delete all messages from a Queue"></a>How to delete all messages from a Queue</h2><p><a href="https://www.cloudamqp.com/blog/2016-06-14_how_to_delete_all_messages_in_a_queue.html#mgmt_interface">https://www.cloudamqp.com/blog/2016-06-14_how_to_delete_all_messages_in_a_queue.html#mgmt_interface</a></p>
]]></content>
      <categories>
        <category>rabbitmq</category>
      </categories>
      <tags>
        <tag>rabbitmq</tag>
      </tags>
  </entry>
  <entry>
    <title>feign汇总</title>
    <url>/2019/11/09/feign%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="Method-has-too-many-Body-parameters"><a href="#Method-has-too-many-Body-parameters" class="headerlink" title="Method has too many Body parameters"></a>Method has too many Body parameters</h1><p><a href="https://www.cnblogs.com/chenkeyu/p/8482276.html">https://www.cnblogs.com/chenkeyu/p/8482276.html</a><br><a href="https://stackoverflow.com/questions/43604734/springboot-feignclient-method-has-too-many-paramters">https://stackoverflow.com/questions/43604734/springboot-feignclient-method-has-too-many-paramters</a></p>
<p>比如可以改成这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(WORD_MAIN_VARIANT + &quot;/insertVariant&quot;)</span><br><span class="line">R&lt;Void&gt; insertVariant(@RequestParam String inputWordName, @RequestParam String fetchWordName);</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>feign</category>
      </categories>
      <tags>
        <tag>feign</tag>
      </tags>
  </entry>
  <entry>
    <title>VSCode汇总</title>
    <url>/2019/11/10/VSCode%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p>vscode用着用着用出bug了，放弃了。</p>
<h2 id="vscode强大的插件"><a href="#vscode强大的插件" class="headerlink" title="vscode强大的插件"></a>vscode强大的插件</h2><p>MetaGo: 字符跳转选择<br>Markdown Preview Enhanced: MarkDown预览插件，cmd-k v（边栏预览），cmd-shift-v（新窗口预览）</p>
]]></content>
      <categories>
        <category>vsCode</category>
      </categories>
      <tags>
        <tag>vsCode</tag>
      </tags>
  </entry>
  <entry>
    <title>DataGrip汇总</title>
    <url>/2019/11/21/DataGrip%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="Hotkey"><a href="#Hotkey" class="headerlink" title="Hotkey"></a>Hotkey</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Plug-ins | Database Tools and SQL | Transpose       快速转换查询结果的视图模式   ^+cmd+T</span><br><span class="line">Plug-ins | Database Tools and SQL | To Clipboard    快速导出查询结果    ^+cmd+C</span><br></pre></td></tr></table></figure>
<h2 id="手动修改查询接口"><a href="#手动修改查询接口" class="headerlink" title="手动修改查询接口"></a>手动修改查询接口</h2><p>可以在Output上选中某一行按cmd+D，复制当前行</p>
<h1 id="Live-Template"><a href="#Live-Template" class="headerlink" title="Live Template"></a>Live Template</h1><p>利用Live Template可以自定义一些快捷的SQL模板生成.</p>
<h1 id="开启新的Tab展示查询结果"><a href="#开启新的Tab展示查询结果" class="headerlink" title="开启新的Tab展示查询结果"></a>开启新的Tab展示查询结果</h1><p>勾选Open results in new tab，这样子查看历史数据比较方便。</p>
]]></content>
      <categories>
        <category>DataGrip</category>
      </categories>
      <tags>
        <tag>DataGrip</tag>
      </tags>
  </entry>
  <entry>
    <title>fastdfs</title>
    <url>/2019/11/06/fastdfs/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://www.cnblogs.com/chiangchou/p/fastdfs.html">https://www.cnblogs.com/chiangchou/p/fastdfs.html</a></p>
</blockquote>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><p><a href="https://www.bbsmax.com/A/MAzAr2jRJ9/">https://www.bbsmax.com/A/MAzAr2jRJ9/</a></p>
<h3 id="测试上传"><a href="#测试上传" class="headerlink" title="测试上传"></a>测试上传</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fdfs_test /etc/fdfs/client.conf upload test.tx</span><br></pre></td></tr></table></figure>

<h2 id="查看Storage和Tracker是否在通信"><a href="#查看Storage和Tracker是否在通信" class="headerlink" title="查看Storage和Tracker是否在通信"></a>查看Storage和Tracker是否在通信</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fdfs_monitor /etc/fdfs/storage.conf</span><br></pre></td></tr></table></figure>
<h2 id="查看Storage和Tracker是否状态都正常"><a href="#查看Storage和Tracker是否状态都正常" class="headerlink" title="查看Storage和Tracker是否状态都正常"></a>查看Storage和Tracker是否状态都正常</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">netstat -unltp|grep fdfs</span><br></pre></td></tr></table></figure>
<p>正常的话结果如下：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/Q53RzT.png" alt="image"><br>只要没有二个都出现那么可能是其中一个down掉了。</p>
<h2 id="Storage两种启动方式"><a href="#Storage两种启动方式" class="headerlink" title="Storage两种启动方式"></a>Storage两种启动方式</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/etc/init.d/fdfs_storaged start</span><br><span class="line"></span><br><span class="line">service fdfs_storaged start</span><br></pre></td></tr></table></figure>
<h2 id="tracker-重启"><a href="#tracker-重启" class="headerlink" title="tracker 重启"></a>tracker 重启</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fdfs_trackerd fdfs_conf/tracker.conf</span><br></pre></td></tr></table></figure>


<h2 id="com-github-tobato-fastdfs-exception-FdfsConnectException-无法获取服务端连接资源：can’t-create-connection-to-x2F-172-26-64-218-23000"><a href="#com-github-tobato-fastdfs-exception-FdfsConnectException-无法获取服务端连接资源：can’t-create-connection-to-x2F-172-26-64-218-23000" class="headerlink" title="com.github.tobato.fastdfs.exception.FdfsConnectException: 无法获取服务端连接资源：can’t create connection to&#x2F;172.26.64.218:23000"></a>com.github.tobato.fastdfs.exception.FdfsConnectException: 无法获取服务端连接资源：can’t create connection to&#x2F;172.26.64.218:23000</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">查看启动日志，看看是否启动成功</span><br><span class="line">tail -n10 /home/xxx/xxx/logs/xxx.log</span><br></pre></td></tr></table></figure>

<h2 id="错误码：2，错误信息：找不到节点或文件"><a href="#错误码：2，错误信息：找不到节点或文件" class="headerlink" title="错误码：2，错误信息：找不到节点或文件"></a>错误码：2，错误信息：找不到节点或文件</h2><p><a href="https://blog.csdn.net/csp_6666/article/details/97912732">https://blog.csdn.net/csp_6666&#x2F;article&#x2F;details&#x2F;97912732</a></p>
<h2 id="season-x2F-fastdfs"><a href="#season-x2F-fastdfs" class="headerlink" title="season&#x2F;fastdfs"></a>season&#x2F;fastdfs</h2><p><a href="https://www.bbsmax.com/A/MAzAr2jRJ9/">https://www.bbsmax.com/A/MAzAr2jRJ9/</a></p>
<ul>
<li>配置文件在&#x2F;fdfs_conf&#x2F;下面</li>
<li>重新拉去至少要更改storage节点的&#x2F;fdfs_conf&#x2F;storage.conf文件里面的tracker_server的ip</li>
<li>再分别启动一下tracker和storage，storage可能已经启动了提示端口占用<br>tracker启动：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fdfs_trackered %FastDFS%/tracker.conf</span><br></pre></td></tr></table></figure>
看下storage是否有效<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fdfs_monitor /etc/fdfs/storage.conf</span><br></pre></td></tr></table></figure>
<em><strong>特别要注意IP地址要改成外网配置的地址</strong></em></li>
</ul>
]]></content>
      <categories>
        <category>fastdfs</category>
      </categories>
      <tags>
        <tag>fastdfs</tag>
      </tags>
  </entry>
  <entry>
    <title>显示器选购指南</title>
    <url>/2019/11/22/%E6%98%BE%E7%A4%BA%E5%99%A8%E9%80%89%E8%B4%AD%E6%8C%87%E5%8D%97/</url>
    <content><![CDATA[<h1 id="LG27UK850体验总结"><a href="#LG27UK850体验总结" class="headerlink" title="LG27UK850体验总结"></a>LG27UK850体验总结</h1><pre><code>本来我都不想浪费时间来写下这个总结的，因为一贯都很懒，但是有个事情激发了我的动力，入手了LG27UK850之后，本来还想在微信群里面分享一波，那个微信群本来是三五个好友的撩骚群，但是在天朝特色的环境下，曾经最活跃的好群，慢慢的变成了各自炫耀自己仅有的一点点成绩的地方，在卑微的虚荣心驱使之下，影响到我们的独善其身，这也是我现在慢慢得想淡化静默一些群的原因。
在我分享了一张刚买的显示器照片之后，果然不出我的意料，有二个朋友回复的是，&quot;辣鸡，LG泛白严重&quot;，&quot;内心毫无波动&quot;等，诸如此类的回复。我在寻思，也许是多年的好友，才能够肆无忌惮的各种踩，也许是有好友出自内心的提醒，毕竟忠言逆耳利于行，而又或许，虚荣心在作祟？不过都无所谓，我将仔细分析一下我这次的体验，冷暖自知。
此外，我TM昨晚刚下单，今天中午就降价100块，狗东一定是在针对我。
</code></pre>
<p>先说明一下我为什么要买显示器以及选中了LG27UK850的原因：</p>
<ol>
<li>我是MBP18，MBP18四个Type-C都支持Thunderbolt3</li>
<li>我的扩展坞没有DP接口，只有一个HDMI1.4，1.4它不香了，无法支持4k&#x2F;60Hz，所以如果我使用原有的扩展坞的话的话，那么买的显示器如果没有Type-C接口，将支持不了4k&#x2F;60Hz，而我又测试了一下HDMI1.4，明显感觉掉帧和卡顿，又或者我需要买那种Type-C转DP的线。</li>
<li>同时这块显示器电源之后用Type-C来输入的话，可以给MBP反向充电</li>
<li>可以通过Type-C CtoC连接，这样一来就是基于DP来传输的，速率上杠杠的。</li>
<li>有了Type-C直连，我就可以减少有线的很多连接和转接头，有时候我比较喜欢简约美。</li>
<li>为什么我不选择戴尔U2718Q，网上对于戴尔显示器的显示效果确实好评声音高于LG，但是我对比了二款显示器，价位戴尔高几百块，当然这个不是重点，主要戴尔U2718Q没有Type-C口，而其他各种参数他们基本一致，抛开品控不说，苹果的显示器也都是和LG合作的，所以上车LG，我不是很方。</li>
<li>我是真的迫不及待想要体验用上大屏 or 双屏，这样会更好能够利用好我的时间，提交效率。</li>
<li>每天上班都是用MBP，十足十的低头族，加上经常看手机，脖子已经吃不消了，搞不好还容易驼背圆肩什么的，大屏显示器它势在必得！</li>
</ol>
<h1 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h1><ul>
<li>旋转屏幕之后不会自动感应旋转画面，需要在系统额外设置，之前我一直以为是会自动旋转画面的。</li>
<li>朋友说的泛白，肉眼看上去，确实没有MBP屏幕那样的恰到好处，加上我本身自己是高度近视，眼镜其实已经用了很久了，貌似是有点点泛白的感觉，但是不做设计，感觉我自己没有这方面的极致追求。</li>
<li>我看到网上有人说反向充电会充不满，但是我自己试了一个下午，一直都是100%，所以不存在这个问题。</li>
<li>LG原装里面送的Type-C线不是雷电3，我看没有雷电标记，也就是普通的Type-C先，郁闷。。。</li>
<li>睡眠之后通过鼠标or键盘重新唤醒，需要等好几秒，如果待机很久，比如一整个晚上，会出现无法唤醒，必须打开笔记本盖子，才能唤醒，这个应该是MBP彻底休眠了。。。</li>
<li>亮度已经调整为最低，但是实际上还是偏亮，需要辅助性软件或者对比度也调低，才能找到合适的亮度，可能我本人眼睛也不适合看亮的东西。</li>
</ul>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><p>显示器传输接口DP、HDMI（1.0和2.0）、VGA（上古时代的产品）、DVI（也是时代的遗物）  </p>
<h2 id="DP"><a href="#DP" class="headerlink" title="DP"></a>DP</h2><p>DisplayPort接口</p>
<h2 id="HDMI"><a href="#HDMI" class="headerlink" title="HDMI"></a>HDMI</h2><p>HDMI现在最新版本已经是2.x了，只有2.0之后的版本才支持4k+60p，最新2.1版本支持 8K&#x2F;60Hz、4K&#x2F;120Hz 视频、Dynamic HDR（动态HDR，对于一些电影、游戏或图片的较灰暗的画面貌似有更好的纠正显示效果），将频宽大幅提升到 48Gbps。</p>
<h2 id="DP-VS-HDMI"><a href="#DP-VS-HDMI" class="headerlink" title="DP VS HDMI"></a>DP VS HDMI</h2><ul>
<li>DP的最新版本是1.4，发布于2016年3月，1.5版本迟迟没有发布</li>
<li>HDMI最新版本为2.1，发布于2017年11月<br>查看网上对于两者的比较，基本得出的结论大概是这样：<br>如果是电脑显示器，优先选择DP。HDMI主要是影音应用的，带宽不如DP。<br>如果论专业度，首选DP吧，虽然HDMI与DP都支持4K*2K，但DP的宽带会更高。<br>但是我个人一眼扫过去他们二者的数据比较，感觉单从数据来看，可能差不多已经是不相上下了。</li>
</ul>
<h2 id="Thunderbolt3"><a href="#Thunderbolt3" class="headerlink" title="Thunderbolt3"></a>Thunderbolt3</h2><p>雷电三的数据线都是带有雷电标记的，如：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/4AsmkY.png" alt="image"><br>MBP2018一共有四个Type-C接口，都是支持雷电3的</p>
<h2 id="Thunderbolt3、USB-3-1-Gen2、-Type-C的区别"><a href="#Thunderbolt3、USB-3-1-Gen2、-Type-C的区别" class="headerlink" title="Thunderbolt3、USB 3.1 Gen2、 Type-C的区别"></a>Thunderbolt3、USB 3.1 Gen2、 Type-C的区别</h2><p>想要弄清楚这两种电缆的区别，首先就需要先理清雷电3、USB 3.1、Type-C这三个名词的概念。其实，雷电3（Thunderbolt 3）和USB 3.1都是数据传输协议。<br>不同传输标准区别主要在于传输速率。拿USB 3.1来说，还分为USB 3.1 Gen1和USB 3.1 Gen2，USB 3.1 Gen1的最大传输速率为5Gb&#x2F;s，USB3.1 Gen2最大传输速率为10Gb&#x2F;s。<br>而Type-C则是一种接口规格，除此之外还有Type-A、Type-B等其他接口规格。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/OzaYIT.png" alt="image"><br>而用户容易把雷电3和USB Type-C搞混淆的原因之一，就是两种电缆均采用了Type-C接口规格，看起来几乎完全相同。现在为了更好的区分两者，苹果最新的雷电3数据线上都会带有雷电标志，所以很重要的区别是线本身的电缆不一样。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/9b8HMD.png" alt="image"><br>雷电3和USB Type-C虽然有相同的接口，却与不同的传输协议配对，分别是雷电3（Thunderbolt 3）和USB 3.1。<br>一些 Thunderbolt 3 连接线可以作为 USB 3.1 Type-C 连接线使用，但不是所有的线缆都可以。而 USB 3.1 Type-C 连接线，却永远无法当做 Thunderbolt 3 连接线使用，就算大家都是相同的 USB-C 接口也不行。同时，并不是所有的 USB Type-C 线缆都能胜任规范中的最高 100W 传输功率，无论是 Thunderbolt 3 还是 USB 3.1 Type-C 都不一定能够达到。</p>
<p>USB Type-C 接口其实本身并不支持视频输出，但是它拥有替代模式，通过转接到其他芯片上来实现不同功能，它实际使用的是DP标准的信号传输，好处是可以通过一根线解决显示器的画面输出和供电问题。</p>
<h2 id="为什么LG送的Type-C非雷电3可以做传输？"><a href="#为什么LG送的Type-C非雷电3可以做传输？" class="headerlink" title="为什么LG送的Type-C非雷电3可以做传输？"></a>为什么LG送的Type-C非雷电3可以做传输？</h2><p>我用自己MBP的电源充电线连接显示器，显示无信号连接，显然不起作用，但是用LG附带的Type-C线就可以，询问客户说是普通的线。<br>于是我搜了苹果原装雷电3数据线，TM要两百多，LG难怪不送雷电3的线，然后我发现了双Type-C原来还可以这么玩：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/X2FuqL.png" alt="image"><br>难怪显示器用Type-C的线能够给MBP反向充电。<br>翻了半天，没找到合理的科普，暂且搁置。</p>
<h1 id="坏点测试网站"><a href="#坏点测试网站" class="headerlink" title="坏点测试网站"></a>坏点测试网站</h1><p><a href="http://pingmu.zh-ang.com/">http://pingmu.zh-ang.com/</a></p>
<h1 id="下面附上我的测试结果"><a href="#下面附上我的测试结果" class="headerlink" title="下面附上我的测试结果"></a>下面附上我的测试结果</h1><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/pLSliT.png" alt="image"><br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/LL5L5z.png" alt="image"><br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/lBaLO9.png" alt="image"><br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/8ZhCcI.png" alt="image"><br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/56Xsiu.png" alt="image"><br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/NrtREc.png" alt="image"><br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/l2YypC.png" alt="image"></p>
<blockquote>
<p>下面是一些显示器选购的参数</p>
</blockquote>
<h1 id="色域"><a href="#色域" class="headerlink" title="色域"></a>色域</h1><ul>
<li>sRGB</li>
<li>NTSC</li>
</ul>
<h1 id="色差"><a href="#色差" class="headerlink" title="色差"></a>色差</h1><h1 id="分辨率-尺寸"><a href="#分辨率-尺寸" class="headerlink" title="分辨率 尺寸"></a>分辨率 尺寸</h1><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/Jhr774.png" alt="image"><br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/UNfhPV.png" alt="image"></p>
<h1 id="刷新率-灰阶响应时间"><a href="#刷新率-灰阶响应时间" class="headerlink" title="刷新率 灰阶响应时间"></a>刷新率 灰阶响应时间</h1><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/aXNYhn.png" alt="image"></p>
<ul>
<li>IPS：漏光听说可能会比较严重</li>
<li>TN：色彩太差，尽量不考虑，</li>
</ul>
<h1 id="带鱼屏"><a href="#带鱼屏" class="headerlink" title="带鱼屏"></a>带鱼屏</h1><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/wbAnv9.png" alt="image"><br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/I7TEW7.png" alt="image"></p>
<h1 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h1><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/uw7LCF.png" alt="image"><br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/XepCvX.png" alt="image"><br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/YP7wN7.png" alt="image"><br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/IYBayE.png" alt="image"></p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/PDLjPX.png" alt="image"></p>
]]></content>
      <categories>
        <category>显示器</category>
      </categories>
      <tags>
        <tag>显示器</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring系列之SpringMVC</title>
    <url>/2019/11/26/Spring%E7%B3%BB%E5%88%97%E4%B9%8BSpringMVC/</url>
    <content><![CDATA[<h1 id="处理过的问题"><a href="#处理过的问题" class="headerlink" title="处理过的问题"></a>处理过的问题</h1><h4 id="Required-request-body-is-missing"><a href="#Required-request-body-is-missing" class="headerlink" title="Required request body is missing"></a>Required request body is missing</h4><p>一般都是@RequestBody注解的参数，而请求数据空；或者用postman的话，注意要这样选择参数：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/BiF57m.png" alt="image"></p>
<h4 id="What-is-difference-between-RequestBody-and-RequestParam"><a href="#What-is-difference-between-RequestBody-and-RequestParam" class="headerlink" title="What is difference between @RequestBody and @RequestParam?"></a>What is difference between @RequestBody and @RequestParam?</h4><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/KCfLZy.png" alt="image"></p>
<h4 id="postman请求时，如果Controller的方法出现参数接收不到为null"><a href="#postman请求时，如果Controller的方法出现参数接收不到为null" class="headerlink" title="postman请求时，如果Controller的方法出现参数接收不到为null"></a>postman请求时，如果Controller的方法出现参数接收不到为null</h4><p>这个时候考虑是否PostMapping注解的方法参数是否为多个，如果多个的话用postman请求记得不要在Body选择为raw和json类型，可以选择form-data或者x-www-form-urlencoded。</p>
<h4 id="ResponseBody注解之后是在哪里将对象自动转成Json响应的"><a href="#ResponseBody注解之后是在哪里将对象自动转成Json响应的" class="headerlink" title="@ResponseBody注解之后是在哪里将对象自动转成Json响应的"></a>@ResponseBody注解之后是在哪里将对象自动转成Json响应的</h4><p>0 &#x3D; {ManagedFilter@12664} “ManagedFilter{filterInfo&#x3D;FilterInfo{filterClass&#x3D;class org.springframework.boot.web.servlet.filter.OrderedCharacterEncodingFilter, name&#x3D;’characterEncodingFilter’}}”<br>1 &#x3D; {ManagedFilter@12662} “ManagedFilter{filterInfo&#x3D;FilterInfo{filterClass&#x3D;class org.springframework.boot.actuate.metrics.web.servlet.WebMvcMetricsFilter, name&#x3D;’webMvcMetricsFilter’}}”<br>2 &#x3D; {ManagedFilter@12658} “ManagedFilter{filterInfo&#x3D;FilterInfo{filterClass&#x3D;class org.springframework.boot.web.servlet.filter.OrderedHiddenHttpMethodFilter, name&#x3D;’hiddenHttpMethodFilter’}}”<br>3 &#x3D; {ManagedFilter@12656} “ManagedFilter{filterInfo&#x3D;FilterInfo{filterClass&#x3D;class org.springframework.boot.web.servlet.filter.OrderedFormContentFilter, name&#x3D;’formContentFilter’}}”<br>4 &#x3D; {ManagedFilter@12654} “ManagedFilter{filterInfo&#x3D;FilterInfo{filterClass&#x3D;class org.springframework.boot.web.servlet.filter.OrderedRequestContextFilter, name&#x3D;’requestContextFilter’}}”<br>5 &#x3D; {ManagedFilter@12652} “ManagedFilter{filterInfo&#x3D;FilterInfo{filterClass&#x3D;class org.springframework.boot.web.servlet.DelegatingFilterProxyRegistrationBean$1, name&#x3D;’springSecurityFilterChain’}}”<br>6 &#x3D; {ManagedFilter@12637} “ManagedFilter{filterInfo&#x3D;FilterInfo{filterClass&#x3D;class org.springframework.boot.actuate.web.trace.servlet.HttpTraceFilter, name&#x3D;’httpTraceFilter’}}”</p>
<p><a href="https://www.baeldung.com/spring-httpmessageconverter-rest">how to Configure HttpMessageConverters in Spring.</a><br><a href="https://chenzhihao.cc/2019/06/13/Springmvc%E8%AF%B7%E6%B1%82%E5%8F%82%E6%95%B0%E7%9A%84%E4%BC%98%E9%9B%85%E5%A4%84%E6%96%B9%E5%BC%8F/">参考1</a></p>
<p>因为底层AbstractJackson2HttpMessageConverter调用了writeInternal方法默认通过jackson来做json解析，所以可以使用jackson的各种强大的注解，如：<br><a href="https://www.jianshu.com/p/201943f8d579">Jackson注解翻译</a></p>
<h1 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h1><h2 id="前端接口调用的入口"><a href="#前端接口调用的入口" class="headerlink" title="前端接口调用的入口"></a>前端接口调用的入口</h2><p>HttpServlet（无论tomcat还是undertow容器，都是继承了HttpServlet抽象类，通过service方法分发前端的Http请求的）<br>所以如果某个http请求出现了莫名其妙的问题，如果实在找不到原因，就可以从最原始的这个入口debug跟踪，一步步深入，最终肯定能解决问题的。</p>
<h2 id="前端传进来的入参转换为Controller方法的入参过程"><a href="#前端传进来的入参转换为Controller方法的入参过程" class="headerlink" title="前端传进来的入参转换为Controller方法的入参过程"></a>前端传进来的入参转换为Controller方法的入参过程</h2><p>InvocableHandlerMethod.invokeForRequest方法</p>
<h2 id="InitBinder的使用"><a href="#InitBinder的使用" class="headerlink" title="@InitBinder的使用"></a>@InitBinder的使用</h2><p><a href="https://medium.com/stackavenue/how-to-use-initbinder-in-spring-mvc-ecb974a6884">https://medium.com/stackavenue/how-to-use-initbinder-in-spring-mvc-ecb974a6884</a></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>SpringMVC</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringMVC</tag>
      </tags>
  </entry>
  <entry>
    <title>Hystrix汇总</title>
    <url>/2019/11/27/Hystrix%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="各种配置属性文章"><a href="#各种配置属性文章" class="headerlink" title="各种配置属性文章"></a>各种配置属性文章</h2><p><a href="https://github.com/Netflix/Hystrix/wiki/Configuration">https://github.com/Netflix/Hystrix/wiki/Configuration</a></p>
]]></content>
      <categories>
        <category>Hystrix</category>
      </categories>
      <tags>
        <tag>Hystrix</tag>
      </tags>
  </entry>
  <entry>
    <title>Web前端汇总</title>
    <url>/2019/11/27/Web%E5%89%8D%E7%AB%AF%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="Resource"><a href="#Resource" class="headerlink" title="Resource"></a>Resource</h1><h2 id="图标库"><a href="#图标库" class="headerlink" title="图标库"></a>图标库</h2><p><a href="http://www.fontawesome.com.cn/faicons/">fontawesome</a></p>
<h2 id="w3c参考手册"><a href="#w3c参考手册" class="headerlink" title="w3c参考手册"></a>w3c参考手册</h2><p><a href="https://www.w3school.com.cn/jsref/index.asp">w3c参考手册详情</a></p>
<h1 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h1><h2 id="npm国内慢"><a href="#npm国内慢" class="headerlink" title="npm国内慢"></a>npm国内慢</h2><p><a href="https://www.cnblogs.com/sddai/p/9388261.html">https://www.cnblogs.com/sddai/p/9388261.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install cnpm -g --registry=https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure>

<h2 id="npm-安装命令"><a href="#npm-安装命令" class="headerlink" title="npm 安装命令"></a>npm 安装命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install moduleName</span><br></pre></td></tr></table></figure>
<p>安装模块到项目node_modules目录下。<br>不会将模块依赖写入devDependencies或dependencies 节点。<br>运行 npm install 初始化项目时不会下载模块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -g moduleName</span><br></pre></td></tr></table></figure>
<p>安装模块到全局，不会在项目node_modules目录中保存模块包。<br>不会将模块依赖写入devDependencies或dependencies 节点。<br>运行 npm install 初始化项目时不会下载模块。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -save moduleName</span><br></pre></td></tr></table></figure>
<p>安装模块到项目node_modules目录下。<br>会将模块依赖写入dependencies 节点。<br>运行 npm install 初始化项目时，会将模块下载到项目目录下。<br>运行npm install –production或者注明NODE_ENV变量值为production时，会自动下载模块到node_modules目录中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm install -save-dev moduleName</span><br></pre></td></tr></table></figure>
<p>安装模块到项目node_modules目录下。<br>会将模块依赖写入devDependencies 节点。<br>运行 npm install 初始化项目时，会将模块下载到项目目录下。<br>运行npm install –production或者注明NODE_ENV变量值为production时，不会自动下载模块到node_modules目录中。</p>
<blockquote>
<p>devDependencies 节点下的模块是我们在开发时需要用的，比如项目中使用的 gulp ，压缩css、js的模块。这些模块在我们的项目部署后是不需要的，所以我们可以使用 -save-dev 的形式安装。像 express 这些模块是项目运行必备的，应该安装在 dependencies 节点下，所以我们应该使用 -save 的形式安装。</p>
</blockquote>
<p>from <a href="https://www.jianshu.com/p/939aa816893c">https://www.jianshu.com/p/939aa816893c</a></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><p>npm uninstall 模块：删除模块，但不删除模块留在package.json中的对应信息<br>npm uninstall 模块 –save 删除模块，同时删除模块留在package.json中dependencies下的对应信息<br>npm uninstall 模块 –save-dev删除模块，同时删除模块留在package.json中devDependencies下的对应信息</p>
<h2 id="npm-安装报错的解决方案"><a href="#npm-安装报错的解决方案" class="headerlink" title="npm 安装报错的解决方案"></a>npm 安装报错的解决方案</h2><p>比如这个报错:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">npm ERR! enoent ENOENT: no such file or directory, access &#x27;~/Documents/myDocument/idea-project/pig-ui/node_modules/_@babel_highlight@7.5.0@@babel/highlight/node_modules/esutils&#x27;</span><br></pre></td></tr></table></figure>
<p>我是在项目pig-ui下面执行的npm install dev命令，报了esutils找不到，但是实际上目录上有esutils这个文件or目录，可以删除原来的esutils，切换到esutils的上级模块highlight执行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  highlight git:(master) ✗ npm install esutils</span><br><span class="line">npm notice created a lockfile as package-lock.json. You should commit this file.</span><br><span class="line">+ esutils@2.0.3</span><br><span class="line">added 1 package and removed 1 package in 1.418s</span><br></pre></td></tr></table></figure>
<p>但是有很多子模块都会报这种莫名其妙的错，可以直接将所有依赖模块删除，重新安装依赖。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rm -rf node_modules</span><br><span class="line">rm package-lock.json</span><br><span class="line">npm cache clear --force</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure>

<h2 id="npm-–save-dev-–save-的区别"><a href="#npm-–save-dev-–save-的区别" class="headerlink" title="npm –save-dev –save 的区别"></a>npm –save-dev –save 的区别</h2><p><a href="https://blog.csdn.net/star0311/article/details/90899013">https://blog.csdn.net/star0311/article/details/90899013</a></p>
<h2 id="npm-relocation-error-npm-symbol-SSL-set-cert-cb-version-libssl-so-10-not-defined-in-file-libssl-so-10-with-link-time-reference"><a href="#npm-relocation-error-npm-symbol-SSL-set-cert-cb-version-libssl-so-10-not-defined-in-file-libssl-so-10-with-link-time-reference" class="headerlink" title="npm: relocation error: npm: symbol SSL_set_cert_cb, version libssl.so.10 not defined in file libssl.so.10 with link time reference"></a>npm: relocation error: npm: symbol SSL_set_cert_cb, version libssl.so.10 not defined in file libssl.so.10 with link time reference</h2><p><a href="https://blog.csdn.net/test1280/article/details/102937023">https://blog.csdn.net/test1280/article/details/102937023</a></p>
<h1 id="Javascript"><a href="#Javascript" class="headerlink" title="Javascript"></a>Javascript</h1><h2 id="Javascript之BOM与DOM"><a href="#Javascript之BOM与DOM" class="headerlink" title="Javascript之BOM与DOM"></a>Javascript之BOM与DOM</h2><p>引用自<a href="https://blog.csdn.net/qq877507054/article/details/51395830">Javascript之BOM与DOM讲解</a></p>
<ul>
<li>ECMAScript(核心) ： 描述了JS的语法和基本对象。</li>
<li>文档对象模型 （DOM） ： 处理网页内容的方法和接口</li>
<li>浏览器对象模型（BOM） ： 与浏览器交互的方法和接口</li>
</ul>
<hr>
<ul>
<li>DOM 是 W3C 的标准； [所有浏览器公共遵守的标准]</li>
<li>BOM 是 各个浏览器厂商根据 DOM在各自浏览器上的实现;[表现为不同浏览器定义有差别,实现方式不同]</li>
<li>window 是 BOM 对象，而非 js 对象；javascript是通过访问BOM（Browser Object Model）对象来访问、控制、修改客户端(浏览器)</li>
</ul>
<h2 id="DOM-DOCUMENT-BOM-WINDOW-区别"><a href="#DOM-DOCUMENT-BOM-WINDOW-区别" class="headerlink" title="DOM, DOCUMENT, BOM, WINDOW 区别"></a>DOM, DOCUMENT, BOM, WINDOW 区别</h2><ul>
<li>DOM 是为了操作文档出现的 API，document 是其的一个对象；</li>
<li>BOM 是为了操作浏览器出现的 API，window 是其的一个对象。</li>
</ul>
<h3 id="DOM和BOM的操作对象区别"><a href="#DOM和BOM的操作对象区别" class="headerlink" title="DOM和BOM的操作对象区别"></a>DOM和BOM的操作对象区别</h3><ul>
<li>BOM是浏览器对象模型，是对浏览器本身进行操作;</li>
<li>DOM是文档对象模型，是对浏览器（可看成容器）内的内容进行操作；</li>
</ul>
<p>可以说BOM包含了DOM(对象)，window.document</p>
<h1 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h1><h2 id="style-vs-class"><a href="#style-vs-class" class="headerlink" title="style vs class"></a>style vs class</h2><p>style是html元素的一个属性，在这里可以直接设置元素的样式，class也是一个属性，但它是通过预定义的样式使元素应用样式的。比如：div .box {width:80%;} 那么只要div的class引用了这个box那它的宽度就是父级容器的80%宽。<br>也就是style的优先级高于class。也就是说在style和class同时定义一种样式时，页面选择展示的是style中的样式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;.a1&#123;backgroung:#ccc;&#125;&lt;/style&gt;</span><br><span class="line">&lt;div class=&quot;a1&quot; style=&quot;background:#f00&quot;&gt;&lt;/div&gt;</span><br><span class="line">// 此时，div的背景颜色应该是#f00的红色。</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>MybatisPlus汇总</title>
    <url>/2019/11/27/MybatisPlus%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h1><h2 id="各种查询条件组装"><a href="#各种查询条件组装" class="headerlink" title="各种查询条件组装"></a>各种查询条件组装</h2><p>参考：<a href="https://mynews.likecoder.com/News/54208">https://mynews.likecoder.com/News/54208</a></p>
<h2 id="mybaties数据源配置类型（POOLED、JNDI、UNPOOLED）"><a href="#mybaties数据源配置类型（POOLED、JNDI、UNPOOLED）" class="headerlink" title="mybaties数据源配置类型（POOLED、JNDI、UNPOOLED）"></a>mybaties数据源配置类型（POOLED、JNDI、UNPOOLED）</h2><ul>
<li>dataSource的类型可以配置成其内置类型之一，如UNPOOLED、POOLED、JNDI。<ul>
<li>如果将类型设置成UNPOOLED，mybaties会为每一个数据库操作创建一个新的连接，并关闭它。该方式适用于只有小规模数量并发用户的简单应用程序上。</li>
<li>如果将属性设置成POOLED，mybaties会创建一个数据库连接池，连接池的一个连接将会被用作数据库操作。一旦数据库操作完成，mybaties会将此连接返回给连接池。在开发或测试环境中经常用到此方式。</li>
<li>如果将类型设置成JNDI。mybaties会从在应用服务器向配置好的JNDI数据源DataSource获取数据库连接。在生产环境中优先考虑这种方式。</li>
</ul>
</li>
</ul>
<h2 id="自动分页要开启PaginationInterceptor插件"><a href="#自动分页要开启PaginationInterceptor插件" class="headerlink" title="自动分页要开启PaginationInterceptor插件"></a>自动分页要开启PaginationInterceptor插件</h2><p><a href="https://mybatis.plus/guide/page.html">https://mybatis.plus/guide/page.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public PaginationInterceptor paginationInterceptor() &#123;</span><br><span class="line">    PaginationInterceptor paginationInterceptor = new PaginationInterceptor();</span><br><span class="line">    paginationInterceptor.setCountSqlParser(new JsqlParserCountOptimize(true));</span><br><span class="line">    return paginationInterceptor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="vs"><a href="#vs" class="headerlink" title="${} vs #{}"></a>${} vs #{}</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#方式能够很大程度防止sql注入。</span><br><span class="line">#方式会在外面加一层字符串标识的包装：&quot;xxx&quot; or &#x27;xxx&#x27;</span><br><span class="line">$方式无法防止Sql注入。</span><br></pre></td></tr></table></figure>

<h2 id="mybatis的二级缓存-vs-redis"><a href="#mybatis的二级缓存-vs-redis" class="headerlink" title="mybatis的二级缓存 vs redis"></a>mybatis的二级缓存 vs redis</h2><p>Mybatis一级缓存作用域是session，session commit之后缓存就失效了。</p>
<p>Mybatis二级缓存作用域是sessionFactory，该缓存是以namespace为单位的（也就是一个Mapper.xml文件），不同namespace下的操作互不影响。所有对数据表的改变操作都会刷新缓存。但是一般不要用二级缓存，例如在UserMapper.xml中有大多数针对user表的操作。但是在另一个XXXMapper.xml中，还有针对user单表的操作。这会导致user在两个命名空间下的数据不一致。如果在UserMapper.xml中做了刷新缓存的操作，在XXXMapper.xml中缓存仍然有效，如果有针对user的单表查询，使用缓存的结果可能会不正确，读到脏数据。</p>
<p>Redis比之一、二级缓存的好处很多，Redis可以搭建在其他服务器上，缓存容量可扩展。Redis可以灵活的使用在需要缓存的数据上，比如一些热点数据。<br><a href="http://www.imooc.com/qadetail/248957">来源</a></p>
<h1 id="Problem-Solution"><a href="#Problem-Solution" class="headerlink" title="Problem Solution"></a>Problem Solution</h1><h2 id="mapping-xml映射文件中order-by后面的参数如果是变量传进去的话"><a href="#mapping-xml映射文件中order-by后面的参数如果是变量传进去的话" class="headerlink" title="mapping xml映射文件中order by后面的参数如果是变量传进去的话"></a>mapping xml映射文件中order by后面的参数如果是变量传进去的话</h2><p>排序如果直接这样写：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">order by #&#123;params.orderBy&#125; #&#123;params.order&#125;</span><br></pre></td></tr></table></figure>
<p>会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">order by ? ?; nested exception is java.sql.SQLException: sql injection violation, syntax error: syntax error, error in :&#x27;rder by ? ?&#x27;, expect QUES</span><br></pre></td></tr></table></figure>
<p>升降序不能通过变量#{}传进去，因为这样会被底层解释为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">order by xxx &#x27;desc&#x27;</span><br><span class="line">order by xxx &#x27;asc&#x27;</span><br></pre></td></tr></table></figure>


<p>　　</p>
]]></content>
      <categories>
        <category>MybatisPlus</category>
      </categories>
      <tags>
        <tag>MybatisPlus</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之句型结构和短语大全</title>
    <url>/2019/11/30/English%E7%B3%BB%E5%88%97%E4%B9%8B%E5%8F%A5%E5%9E%8B%E7%BB%93%E6%9E%84%E5%92%8C%E7%9F%AD%E8%AF%AD%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<h1 id="口语"><a href="#口语" class="headerlink" title="口语"></a>口语</h1><h1 id="写作短语词组"><a href="#写作短语词组" class="headerlink" title="写作短语词组"></a>写作短语词组</h1><ul>
<li>In addition to</li>
<li>For simplicity</li>
<li>Straight away</li>
<li>Less and less</li>
</ul>
<h1 id="规则"><a href="#规则" class="headerlink" title="规则"></a>规则</h1><h2 id="小品词"><a href="#小品词" class="headerlink" title="小品词"></a>小品词</h2><p>todo</p>
<h2 id="交通工具介词"><a href="#交通工具介词" class="headerlink" title="交通工具介词"></a>交通工具介词</h2><p>在里面能够站直身体的用on：</p>
<ul>
<li>on a bus</li>
<li>on a plane</li>
<li>on a train</li>
</ul>
<p>在里面不能站直身体的用in：</p>
<ul>
<li>in a car</li>
<li>in a taxi</li>
</ul>
<h2 id="时间介词"><a href="#时间介词" class="headerlink" title="时间介词"></a>时间介词</h2><ul>
<li>时间&gt;1天，用in<ul>
<li>in 2020</li>
<li>in July</li>
<li>in winter</li>
</ul>
</li>
<li>时间&#x3D;1天，用on<ul>
<li>on June. 11th</li>
<li>on Sunday</li>
<li>on Christmas Day</li>
<li>on National Day</li>
</ul>
</li>
<li>时间&lt;1天，用at<ul>
<li>at 9 am</li>
<li>at that time</li>
<li>at lunch</li>
</ul>
</li>
<li>早中晚是特殊情况，用in<ul>
<li>in the morning</li>
<li>in the afternoon</li>
<li>in the evening</li>
</ul>
</li>
</ul>
<h2 id="to-do-VS-doing"><a href="#to-do-VS-doing" class="headerlink" title="to do VS doing"></a>to do VS doing</h2><ul>
<li>to do：有意味着未来即将去做的含义（打算去做）<ul>
<li>I want to learn English. （不存在该句意用learning）</li>
</ul>
</li>
<li>doing：有表达正在做的那件事情的含义<ul>
<li>I enjoy learning English.（不存在该句意用to learn）</li>
</ul>
</li>
</ul>
<h2 id="名词前面的多个形容词的排序问题"><a href="#名词前面的多个形容词的排序问题" class="headerlink" title="名词前面的多个形容词的排序问题"></a>名词前面的多个形容词的排序问题</h2><p>越主观、越带有个人感情色彩的形容词越靠前，越客观、越靠近名词的本质的形容词越靠后。</p>
<h2 id="that-VS-which"><a href="#that-VS-which" class="headerlink" title="that VS which"></a>that VS which</h2><p>限定之后能确定下来的唯一名词就用that，反之一般用which。</p>
<ul>
<li>anything、everything、nothing、all等要视为整合成一种情况来看待，所以也是用that；</li>
<li>some要理解为某一种，也是可以确定下来的名词；</li>
</ul>
<h2 id="动词与of、from、about搭配的区别"><a href="#动词与of、from、about搭配的区别" class="headerlink" title="动词与of、from、about搭配的区别"></a>动词与of、from、about搭配的区别</h2><ul>
<li>of（有在里面的意思，要关注的是内在的层面）</li>
<li>about（about拆分开其实是on by out的意思，要住的是在外面、在周围的层面）</li>
<li>from（todo）</li>
</ul>
<h2 id="介词-VS-副词"><a href="#介词-VS-副词" class="headerlink" title="介词 VS 副词"></a>介词 VS 副词</h2><ul>
<li>介词后面跟名词（介词如果跟着前面动词走就可以当副词，跟着后面的名词走就可以当介词）</li>
<li>二把手，辅助别的词的词</li>
</ul>
<h1 id="名言名句"><a href="#名言名句" class="headerlink" title="名言名句"></a>名言名句</h1><ul>
<li>We’re here to put a dent in the world. Otherwise, why else even be here?</li>
<li>Nothing is immortal.（没有什么是永垂不朽）</li>
</ul>
<h1 id="各种容易混淆的单词"><a href="#各种容易混淆的单词" class="headerlink" title="各种容易混淆的单词"></a>各种容易混淆的单词</h1><h2 id="各种标点符号"><a href="#各种标点符号" class="headerlink" title="各种标点符号"></a>各种标点符号</h2><ul>
<li>句号。period</li>
<li>逗号，comma</li>
<li>冒号：colon</li>
<li>分号；semicolon</li>
<li>感叹号！exclamation mark</li>
<li>问号？question mark</li>
<li>连字符- hayhen</li>
<li>破折号—— dash</li>
<li>双引号”” quotation mark</li>
<li>单引号’’ single quotation mark</li>
<li>圆括号（）parenthesis</li>
<li>方括号【】[] square brackets</li>
<li>斜线 &#x2F; slash</li>
</ul>
<h2 id="各种”钱”"><a href="#各种”钱”" class="headerlink" title="各种”钱”"></a>各种”钱”</h2><ul>
<li>money</li>
<li>allowance</li>
<li>tuition</li>
<li>salary</li>
<li>tax</li>
<li>loan</li>
<li>debt</li>
<li>fee</li>
<li>fine</li>
<li>pension</li>
</ul>
<h2 id="提议、建议"><a href="#提议、建议" class="headerlink" title="提议、建议"></a>提议、建议</h2><ul>
<li>suggest</li>
<li>advise</li>
</ul>
<h1 id="句型"><a href="#句型" class="headerlink" title="句型"></a>句型</h1><h2 id="etc-用法"><a href="#etc-用法" class="headerlink" title="etc.用法"></a>etc.用法</h2><ul>
<li>to provide financial aid to hurricane&#x2F;flood, etc. victims（为飓风／洪水等的受灾者提供经济援助）</li>
</ul>
<h2 id="once"><a href="#once" class="headerlink" title="once"></a>once</h2><ul>
<li>had once done.（有一次做过…）</li>
</ul>
<h2 id="Ways-to-Say-“I’M-NOT-SURE…”"><a href="#Ways-to-Say-“I’M-NOT-SURE…”" class="headerlink" title="Ways to Say “I’M NOT SURE…”"></a>Ways to Say “I’M NOT SURE…”</h2><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/IDST2k.png"></p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系列之零碎笔记</title>
    <url>/2019/11/30/Java%E7%B3%BB%E5%88%97%E4%B9%8B%E9%9B%B6%E7%A2%8E%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="基本类型的零值"><a href="#基本类型的零值" class="headerlink" title="基本类型的零值"></a>基本类型的零值</h2><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/2yFTP5.png"></p>
<h2 id="自动类型转换顺序"><a href="#自动类型转换顺序" class="headerlink" title="自动类型转换顺序"></a>自动类型转换顺序</h2><p>char&gt;int&gt;long&gt;float&gt;double</p>
<h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><p>所有成员变量的调用附带上this，防止代码产生歧义或冲突。</p>
<h3 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h3><p>以某个代码片段为例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void fizz(Runnable printFizz) throws InterruptedException &#123;</span><br><span class="line">    while (i &lt;= n) &#123;</span><br><span class="line">        synchronized (this) &#123;</span><br><span class="line">            if (i % 3 == 0 &amp;&amp; i % 5 != 0) &#123;</span><br><span class="line">                printFizz.run();</span><br><span class="line">                i++;</span><br><span class="line">                this.notifyAll();</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                this.wait();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用javap -v命令查看其class文件，得到如下的字节码命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void fizz(java.lang.Runnable) throws java.lang.InterruptedException;</span><br><span class="line">    descriptor: (Ljava/lang/Runnable;)V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=3, locals=4, args_size=2</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: getfield      #2                  // Field i:I</span><br><span class="line">         4: aload_0</span><br><span class="line">         5: getfield      #3                  // Field n:I</span><br><span class="line">         8: if_icmpgt     73</span><br><span class="line">        11: aload_0</span><br><span class="line">        12: dup</span><br><span class="line">        13: astore_2</span><br><span class="line">        14: monitorenter                      // 在这里锁住</span><br><span class="line">        15: aload_0</span><br><span class="line">        16: getfield      #2                  // Field i:I</span><br><span class="line">        19: iconst_3</span><br><span class="line">        20: irem</span><br><span class="line">        21: ifne          56</span><br><span class="line">        24: aload_0</span><br><span class="line">        25: getfield      #2                  // Field i:I</span><br><span class="line">        28: iconst_5</span><br><span class="line">        29: irem</span><br><span class="line">        30: ifeq          56</span><br><span class="line">        33: aload_1</span><br><span class="line">        34: invokeinterface #4,  1            // InterfaceMethod java/lang/Runnable.run:()V</span><br><span class="line">        39: aload_0</span><br><span class="line">        40: dup</span><br><span class="line">        41: getfield      #2                  // Field i:I</span><br><span class="line">        44: iconst_1</span><br><span class="line">        45: iadd</span><br><span class="line">        46: putfield      #2                  // Field i:I</span><br><span class="line">        49: aload_0</span><br><span class="line">        50: invokevirtual #5                  // Method java/lang/Object.notifyAll:()V</span><br><span class="line">        53: goto          60</span><br><span class="line">        56: aload_0</span><br><span class="line">        57: invokevirtual #6                  // Method java/lang/Object.wait:()V</span><br><span class="line">        60: aload_2</span><br><span class="line">        61: monitorexit                       // 在这里第一次释放锁</span><br><span class="line">        62: goto          70</span><br><span class="line">        65: astore_3</span><br><span class="line">        66: aload_2</span><br><span class="line">        67: monitorexit                       // 这里会再次释放锁</span><br><span class="line">        68: aload_3</span><br><span class="line">        69: athrow</span><br><span class="line">        70: goto          0</span><br><span class="line">        73: return</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">            15    62    65   any</span><br><span class="line">            65    68    65   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 47: 0</span><br><span class="line">        line 48: 11</span><br><span class="line">        line 49: 15</span><br><span class="line">        line 50: 33</span><br><span class="line">        line 51: 39</span><br><span class="line">        line 52: 49</span><br><span class="line">        line 54: 56</span><br><span class="line">        line 56: 60</span><br><span class="line">        line 58: 73</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      74     0  this   Lme/fengorz/leetcode/concurrency/fizz_buzz_multithreaded/FizzBuzz;</span><br><span class="line">            0      74     1 printFizz   Ljava/lang/Runnable;</span><br><span class="line">      StackMapTable: number_of_entries = 6</span><br><span class="line">        frame_type = 0 /* same */</span><br><span class="line">        frame_type = 252 /* append */</span><br><span class="line">          offset_delta = 55</span><br><span class="line">          locals = [ class java/lang/Object ]</span><br><span class="line">        frame_type = 3 /* same */</span><br><span class="line">        frame_type = 68 /* same_locals_1_stack_item */</span><br><span class="line">          stack = [ class java/lang/Throwable ]</span><br><span class="line">        frame_type = 250 /* chop */</span><br><span class="line">          offset_delta = 4</span><br><span class="line">        frame_type = 2 /* same */</span><br><span class="line">    Exceptions:</span><br><span class="line">      throws java.lang.InterruptedException</span><br></pre></td></tr></table></figure>
<p>发现上面有两条关键字节码<code>monitorenter</code>和<code>monitorexit</code>：</p>
<ul>
<li>每个对象有一个监视器锁（monitor）。当monitor被占用时就会处于锁定状态，线程执行<code>monitorenter</code>指令时尝试获取monitor的所有权。</li>
<li>monitorexit会释放锁</li>
</ul>
<p>上面的字节码文件中出现了一次<code>monitorenter</code>和二次<code>monitorexit</code>。</p>
<blockquote>
<p>两次<code>monitorexit</code>指令的原因是为了保证抛异常的情况下也能释放锁，所以javac为同步代码块添加了一个隐式的try-finally，在finally中会调用<code>monitorexit</code>命令释放锁。</p>
</blockquote>
<h3 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h3><p><a href="https://baijiahao.baidu.com/s?id=1636557218432721275&wfr=spider&for=pc">https://baijiahao.baidu.com/s?id=1636557218432721275&wfr=spider&for=pc</a></p>
<h3 id="Class"><a href="#Class" class="headerlink" title="Class"></a>Class</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void.class // 罕见又骚气的用法</span><br></pre></td></tr></table></figure>


<h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public &lt;T&gt; T readObjectData(ByteBuffer buffer, Class&lt;T&gt; type) &#123;</span><br><span class="line">...</span><br><span class="line">T retVal = (T) summaries;</span><br><span class="line">return retVal;</span><br></pre></td></tr></table></figure>
<p>我在stackoverflow发现一个很好的解析：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public &lt;T&gt; T readObjectData(...</span><br><span class="line">        ^  ^</span><br><span class="line">        |  + Return type</span><br><span class="line">        + Generic type argument</span><br></pre></td></tr></table></figure>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Unimagined"><a href="#Unimagined" class="headerlink" title="Unimagined"></a>Unimagined</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 一个集合并入到另一个集合的安全写法</span><br><span class="line">Collections.addAll(Collection&lt;? super T&gt; c, T... elements);</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Collections.singletonMap(...);</span><br></pre></td></tr></table></figure>
<h3 id="快速失败机制（fast-fail）"><a href="#快速失败机制（fast-fail）" class="headerlink" title="快速失败机制（fast-fail）"></a>快速失败机制（fast-fail）</h3><p>集合常见的快速失败检查都是通过如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">final void checkForComodification() &#123;</span><br><span class="line">    if (modCount != expectedModCount)</span><br><span class="line">        throw new ConcurrentModificationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="来自网上的Java集合体系图"><a href="#来自网上的Java集合体系图" class="headerlink" title="来自网上的Java集合体系图"></a>来自网上的Java集合体系图</h3><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/FIG9fa.png"><br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/36r68I.png"></p>
<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="一些自定义常用异常可以抽成公用的静态final异常，如："><a href="#一些自定义常用异常可以抽成公用的静态final异常，如：" class="headerlink" title="一些自定义常用异常可以抽成公用的静态final异常，如："></a>一些自定义常用异常可以抽成公用的静态final异常，如：</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public final class PrematureCloseException extends IOException &#123;</span><br><span class="line"></span><br><span class="line">	public static final PrematureCloseException BEFORE_RESPONSE_SENDING_REQUEST =</span><br><span class="line">			new PrematureCloseException(&quot;Connection has been closed BEFORE response, while sending request body&quot;);</span><br><span class="line"></span><br><span class="line">	public static final PrematureCloseException BEFORE_RESPONSE =</span><br><span class="line">			new PrematureCloseException(&quot;Connection prematurely closed BEFORE response&quot;);</span><br><span class="line"></span><br><span class="line">	public static final PrematureCloseException DURING_RESPONSE =</span><br><span class="line">			new PrematureCloseException(&quot;Connection prematurely closed DURING response&quot;);</span><br><span class="line"></span><br><span class="line">	PrematureCloseException(String message) &#123;</span><br><span class="line">		super(message);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	@Override</span><br><span class="line">	public synchronized Throwable fillInStackTrace() &#123;</span><br><span class="line">		// omit stacktrace for this exception</span><br><span class="line">		return this;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="一些运行时异常可以用Spring内置的断言API比较高逼格"><a href="#一些运行时异常可以用Spring内置的断言API比较高逼格" class="headerlink" title="一些运行时异常可以用Spring内置的断言API比较高逼格"></a>一些运行时异常可以用Spring内置的断言API比较高逼格</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Assert.notNull etc.</span><br></pre></td></tr></table></figure>

<h2 id="非null异常的优雅写法"><a href="#非null异常的优雅写法" class="headerlink" title="非null异常的优雅写法"></a>非null异常的优雅写法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Objects.requireNonNull(obj);</span><br></pre></td></tr></table></figure>

<h2 id="try资源句式"><a href="#try资源句式" class="headerlink" title="try资源句式"></a>try资源句式</h2><p>如果代码调用的类是实现java.lang.AutoCloseable的，用try资源句式来释放关闭资源这样代码就优雅多了。</p>
<h2 id="PropertyDescriptor"><a href="#PropertyDescriptor" class="headerlink" title="PropertyDescriptor"></a>PropertyDescriptor</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PropertyDescriptor descriptor = new PropertyDescriptor(&quot;propertyName&quot;, param.getClass());</span><br><span class="line">Method getPropertyMethod = descriptor.getReadMethod();</span><br><span class="line">property = (Integer) getPropertyMethod.invoke(param);</span><br></pre></td></tr></table></figure>

<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String-format"><a href="#String-format" class="headerlink" title="String.format"></a>String.format</h3><p><a href="https://blog.csdn.net/u010137760/article/details/82869637">https://blog.csdn.net/u010137760/article/details/82869637</a></p>
<h3 id="String-intern"><a href="#String-intern" class="headerlink" title="String.intern"></a>String.intern</h3><p><a href="https://www.cnblogs.com/Yintianhao/p/12273714.html">https://www.cnblogs.com/Yintianhao/p/12273714.html</a></p>
<h2 id="n次方写法"><a href="#n次方写法" class="headerlink" title="n次方写法"></a>n次方写法</h2><p>在Java中一个数的N次方不可以写成：a^0这种形式，算得的数不正确；<br>正确的写法为Math.pow(a,0);</p>
<h2 id="废弃对象手动赋值为null有助于GC即将生效"><a href="#废弃对象手动赋值为null有助于GC即将生效" class="headerlink" title="废弃对象手动赋值为null有助于GC即将生效"></a>废弃对象手动赋值为null有助于GC即将生效</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Object o = new Object();</span><br><span class="line">o = null;</span><br><span class="line">o = new Object(); // 这里将触发上面null的GC，又或者调用System.gc(); 但是System.gc()是Full GC</span><br></pre></td></tr></table></figure>

<h2 id="Integer-valueOf-x-缓存"><a href="#Integer-valueOf-x-缓存" class="headerlink" title="Integer.valueOf(x)缓存"></a>Integer.valueOf(x)缓存</h2><p>如果x的范围在-128~127之间，那么会直接返回缓存中的对象，也就是只要数值被调用过一次，以后返回的都是同个对象实例了。</p>
<hr>
<h1 id="避坑"><a href="#避坑" class="headerlink" title="避坑"></a>避坑</h1><h2 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h2><p>一个团队你的代码格式一定要统一，不然代码冲突时，比对代码非常麻烦。</p>
<h2 id="Service与Controller的交互"><a href="#Service与Controller的交互" class="headerlink" title="Service与Controller的交互"></a>Service与Controller的交互</h2><p>Service最终返回给Controller层的数据如果比较复杂，尽量不要用Map，可以封装成DTO，而且这样一来还可以结合JSR303或者其各种扩展，对DTO进行优雅的数据校验。</p>
<h2 id="减少箭头型代码"><a href="#减少箭头型代码" class="headerlink" title="减少箭头型代码"></a>减少箭头型代码</h2><p><a href="https://blog.csdn.net/weixin_33858485/article/details/88768985">https://blog.csdn.net/weixin_33858485/article/details/88768985</a><br>但是个人认为，一味的追求箭头代码也会有弊端，比如这样:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Task task = monTask.getTask();</span><br><span class="line">if (task == null) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">MonAssignTaskExample monAssignTaskExample = new MonAssignTaskExample();</span><br><span class="line">monAssignTaskExample.createCriteria().andTaskIdEqualTo(task.getTaskId()).andDealObjectIdEqualTo(task.getDealObjectId())</span><br><span class="line">        .andIsFinishEqualTo(&quot;N&quot;);</span><br><span class="line">List&lt;MonAssignTask&gt; monAssignTasks = this.baseMonAssignTaskBO.selectByExample(monAssignTaskExample);</span><br><span class="line">if (ObjectUtils.isEmpty(monAssignTasks)) &#123;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br><span class="line">for (MonAssignTask monAssignTask : monAssignTasks) &#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样写固然是可以减少箭头代码，但是如若这段代码下面今后要添加一些额外的业务逻辑，这些业务逻辑与task是否为null没有必要的联系，<br>那么可能会因为task&#x3D;&#x3D;null退出了整个函数，导致额外的业务逻辑不被执行。</p>
<h2 id="Utils-工具类的命名"><a href="#Utils-工具类的命名" class="headerlink" title="Utils 工具类的命名"></a>Utils 工具类的命名</h2><p>每次在使用工具类的时候，总是会出现一个类名出现N个工具类比如：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/xLpjyO.png" alt="image"><br>而且自己也会有自定义的Utils类，为了更好地区分，我喜欢在Utils类价格前缀Enhanced，这样找自己的工具类就方便多了，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EnhancedBeanUtils</span><br></pre></td></tr></table></figure>
<h2 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h2><p>有些被封装的业务方法或者工具类方法如果有做修改，增加了方法的升级版，老旧的方法可以用@Deprecated标记为过时，防止新业务逻辑用到废弃的API。</p>
<h2 id="魔法值应该尽量避免"><a href="#魔法值应该尽量避免" class="headerlink" title="魔法值应该尽量避免"></a>魔法值应该尽量避免</h2><p>阿里巴巴说java规范里面说杜绝一切魔法值，但是我觉得也不用可以完全追求零魔法值，我认为需要用常量代替魔法值的有以下这些：</p>
<ol>
<li>使用频率高的，或者被频繁调用的逻辑块中的魔法值。</li>
<li>可读性很差的魔法值和表达式，应该禁止，最好都声明成可读性较好的常量或者变量。</li>
</ol>
<h2 id="多余的super"><a href="#多余的super" class="headerlink" title="多余的super();"></a>多余的super();</h2><p>在看公司的上古代码发现这种写法：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public CreateRepairBillThread(SaInterfaceAccept accept) &#123;</span><br><span class="line">	super();</span><br><span class="line">	this.accept = accept;</span><br><span class="line">	this.timeout = timeout * 60L * 1000L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面super();是一句多余的代码，因为子类的构造器会默认先调用父类无参构造器。</p>
<h2 id="尽量避免大对象"><a href="#尽量避免大对象" class="headerlink" title="尽量避免大对象"></a>尽量避免大对象</h2><p>大对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组。<br>比遇到大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，我们写程序的时候应注意避免。<br>在Java虚拟机中要避免大对象的原因是，在分配空间时，它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置好它们，而当复制对象时，大对象就意味着高额的内存复制开销。HotSpot虚拟机提供了<code>-XX: PretenureSizeThreshold</code>参数， 指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作。</p>
<h2 id="接口与方法的实现注意形参尽量用可传送的DTO对象（实现Serializable）"><a href="#接口与方法的实现注意形参尽量用可传送的DTO对象（实现Serializable）" class="headerlink" title="接口与方法的实现注意形参尽量用可传送的DTO对象（实现Serializable）"></a>接口与方法的实现注意形参尽量用可传送的DTO对象（实现Serializable）</h2><p>这个将来方便各种动态扩展参数。</p>
<h2 id="自动装箱和拆箱的坑"><a href="#自动装箱和拆箱的坑" class="headerlink" title="自动装箱和拆箱的坑"></a>自动装箱和拆箱的坑</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    Integer a = 1;</span><br><span class="line">    Integer b = 2;</span><br><span class="line">    Integer c = 3;</span><br><span class="line">    Integer d = 3;</span><br><span class="line">    Integer e = 128;</span><br><span class="line">    Integer f = 128;</span><br><span class="line">    Integer e1 = 127;</span><br><span class="line">    Integer f1 = 127;</span><br><span class="line">    Long g = 3L;</span><br><span class="line">    System.out.println(c.equals(d));</span><br><span class="line">    System.out.println(e == f);// 不在-128~127范围内不相等</span><br><span class="line">    System.out.println(e.equals(f));// 替换成equals才会相等</span><br><span class="line">    System.out.println(e1 == f1);// 只有在-128~127之间，读取缓存中的值才会相等</span><br><span class="line">    System.out.println(g == (a + b));// == 会处理自动类型转换</span><br><span class="line">    System.out.println(g.equals(a + b));// equals方法不处理自动类型转换</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="涉及到日志输出注意避免无意义日志大量产生"><a href="#涉及到日志输出注意避免无意义日志大量产生" class="headerlink" title="涉及到日志输出注意避免无意义日志大量产生"></a>涉及到日志输出注意避免无意义日志大量产生</h2><p>对于某些重复性很高的业务逻辑，日志的输出要注意在可控的范围内，千万不能引起日志巨量产生而导致磁盘爆满。</p>
<h2 id="读取IO流要注意尾部数据失真问题"><a href="#读取IO流要注意尾部数据失真问题" class="headerlink" title="读取IO流要注意尾部数据失真问题"></a>读取IO流要注意尾部数据失真问题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">temps = response.getOutputStream();</span><br><span class="line">in = new DataInputStream(inputStream);</span><br><span class="line">// 这个方法写入音频流时有个致命问题，如果是音频流会出现尾部有杂音，因为byte数组如果尾部空流在音频当还是会被当做声音处理</span><br><span class="line">// 如果采用下面注释掉的这种写法的话</span><br><span class="line">byte[] b = new byte[2048];</span><br><span class="line">while ((in.read(b)) != -1) &#123;</span><br><span class="line">    temps.write(b);</span><br><span class="line">    temps.flush();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以采用HuTool工具API，或者使用其内部的实现机制：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte[] b = new byte[length];</span><br><span class="line">int readLength;</span><br><span class="line">try &#123;</span><br><span class="line">    readLength = in.read(b);</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">    throw new IORuntimeException(e);</span><br><span class="line">&#125;</span><br><span class="line">if (readLength &gt; 0 &amp;&amp; readLength &lt; length) &#123;</span><br><span class="line">    byte[] b2 = new byte[length];</span><br><span class="line">    System.arraycopy(b, 0, b2, 0, readLength);</span><br><span class="line">    return b2;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    return b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">byte[] b = IoUtil.readBytes(in, 1024);</span><br><span class="line">while (b != null &amp;&amp; b.length &gt; 0) &#123;</span><br><span class="line">    temps.write(b);</span><br><span class="line">    temps.flush();</span><br><span class="line">    b = IoUtil.readBytes(in, 1024);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="集合在new的时候通过构造器传入初始数据时，要避免是null值"><a href="#集合在new的时候通过构造器传入初始数据时，要避免是null值" class="headerlink" title="集合在new的时候通过构造器传入初始数据时，要避免是null值"></a>集合在new的时候通过构造器传入初始数据时，要避免是null值</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List list = new LinkedLIst(...);</span><br><span class="line">// ...里面要避免是null值</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="Combo"><a href="#Combo" class="headerlink" title="Combo"></a>Combo</h1><h2 id="jar"><a href="#jar" class="headerlink" title="jar"></a>jar</h2><h3 id="Mac中jar运行之后窗口无法粘贴"><a href="#Mac中jar运行之后窗口无法粘贴" class="headerlink" title="Mac中jar运行之后窗口无法粘贴"></a>Mac中jar运行之后窗口无法粘贴</h3><p>有些情况下需要使用windows的复制粘贴快捷键才能生效</p>
<h3 id="jar指定目录的所有classes去打包"><a href="#jar指定目录的所有classes去打包" class="headerlink" title="jar指定目录的所有classes去打包"></a>jar指定目录的所有classes去打包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jar cvf test.jar -C unwoven-classes .</span><br></pre></td></tr></table></figure>

<h2 id="Jackson-Convert-Error-Cannot-construct-instance-of-java-time-LocalDateTime"><a href="#Jackson-Convert-Error-Cannot-construct-instance-of-java-time-LocalDateTime" class="headerlink" title="Jackson Convert Error: Cannot construct instance of java.time.LocalDateTime"></a>Jackson Convert Error: Cannot construct instance of <code>java.time.LocalDateTime</code></h2><p>LocalDateTime属性加上注解<br>@JsonDeserialize(using &#x3D; LocalDateTimeDeserializer.class)<br>@JsonSerialize(using &#x3D; LocalDateTimeSerializer.class)</p>
<h2 id="Thread-sleep-使用-TimeUnit-XXX-sleep-x-代替（可读性更好）"><a href="#Thread-sleep-使用-TimeUnit-XXX-sleep-x-代替（可读性更好）" class="headerlink" title="Thread.sleep 使用 TimeUnit.XXX.sleep(x) 代替（可读性更好）"></a>Thread.sleep 使用 TimeUnit.XXX.sleep(x) 代替（可读性更好）</h2><p><a href="https://stackoverflow.com/questions/9587673/thread-sleep-vs-timeunit-seconds-sleep">https://stackoverflow.com/questions/9587673/thread-sleep-vs-timeunit-seconds-sleep</a></p>
<h2 id="音频格式转换"><a href="#音频格式转换" class="headerlink" title="音频格式转换"></a>音频格式转换</h2><p>使用<a href="http://www.sauronsoftware.it/projects/jave/manual.php#2">JAVE 音频转换包</a>库</p>
<h2 id="Mac下JDK目录"><a href="#Mac下JDK目录" class="headerlink" title="Mac下JDK目录"></a>Mac下JDK目录</h2><p>可以通过<code>/usr/libexec</code>目录下的<code>java_home</code>命令找到Mac下安装过的JDK所在目录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123;/usr/libexec&#125; # ./java_home</span><br><span class="line">/Library/Java/JavaVirtualMachines/jdk-11.0.8.jdk/Contents/Home</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>IDEA Usage</title>
    <url>/2019/12/01/%20IDEA%20Usage/</url>
    <content><![CDATA[<h1 id="HOTKEY"><a href="#HOTKEY" class="headerlink" title="HOTKEY"></a>HOTKEY</h1><h2 id="Usage-Search（使用查询）"><a href="#Usage-Search（使用查询）" class="headerlink" title="Usage Search（使用查询）"></a>Usage Search（使用查询）</h2><p>key(Mac) | key(Win) | desc</p>
<ul>
<li>| -<br>cmd+opt+F7 | win+alt+F7 | 搜索光标所在方法的声明之处或者被调用到的地方，以弹窗方式显示<br>opt+F7 | alt+F7 | 全局搜索引用<br>cmd+shift+F7 | ^+shift+F7 | 高亮显示当前代码域使用到的地方<br>F3 or shift+F3 | 搜索当前文件的模式下，按向下 or F3跳到下一处，按向上 or shift+F3跳到上一处<br>tab or tab+shift | 在ctrl+shift+f全局搜索的时候，可以通过tab和来移动输入聚焦，可以脱离鼠标来选择右上角的File mask</li>
</ul>
<h2 id="Editing（编辑）"><a href="#Editing（编辑）" class="headerlink" title="Editing（编辑）"></a>Editing（编辑）</h2><p>key(Mac) | key(Win)  | desc</p>
<ul>
<li>| -<br>cmd+P | ^+P |显示方法的参数，这个方法的强大之处在于，展示了参数之后，在写入传参的时候，弹框会一直存在，让参数更加直观<br>cmd++ | ^++ |展开折叠的代码<br>cmd+- | ^+- | 折叠代码<br>shift+上下方向键 | shift+上下方向键 | 有时候用vim插件的jk上下移动太慢了，而且又不能明确知道要用emacsIdeas调整到哪里，可以用idea自带的shift+上下方向键来快速上下移动代码<br>cmd+shift+F12 | ^+shift+F12 | 最大化编辑窗口<br>^+shift+P | ^+shift+P | 查看方法返回变量类型</li>
</ul>
<h2 id="debug"><a href="#debug" class="headerlink" title="debug"></a>debug</h2><p>key(Mac)| key(Win) | desc</p>
<ul>
<li>| -<br>cmd+shift+F8 | 查看断点信息<br>shift+F7 | 智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法<br>^+F5 | 重启debug服务<br>cmd+F2 | 终止debug服务<br>^+cmd+W | 将Add to Watches绑定快捷键，可以快速查看变量或者表达式的值</li>
</ul>
<h2 id="Spring-Boot-微服务"><a href="#Spring-Boot-微服务" class="headerlink" title="Spring Boot 微服务"></a>Spring Boot 微服务</h2><p>cmd+8 弹出多个微服务的启动控制窗口，可以通过上下左右移动快速定位到某个微服务，通过快捷键^+shiftF10 Runing,或者通过^+shift+F9 Debuging</p>
<h2 id="General（通用）"><a href="#General（通用）" class="headerlink" title="General（通用）"></a>General（通用）</h2><p>key(Mac) | key(Win) | desc</p>
<ul>
<li>| -<br>cmd+, | ^+Alt+S | 打开Settings<br>^+cmd+F | 切换全屏模式<br>^+cmd+C | 清理控制台的日志之类的，需要再keymap里面设置Other | Clear All<br>opt+F12 | 打开或关闭Terminal</li>
</ul>
<h2 id="Refactoring（重构）"><a href="#Refactoring（重构）" class="headerlink" title="Refactoring（重构）"></a>Refactoring（重构）</h2><table>
<thead>
<tr>
<th>key</th>
<th>desc</th>
</tr>
</thead>
<tbody><tr>
<td>F5</td>
<td>复制文件到指定包路径</td>
</tr>
<tr>
<td>F6</td>
<td>移动文件到指定包路径</td>
</tr>
<tr>
<td>opt+cmd+t</td>
<td>surround with 快捷得用各种模板语法包括代码（这个很强大&#96;）</td>
</tr>
<tr>
<td>opt+cmd+m</td>
<td>提取代码为方法</td>
</tr>
<tr>
<td>opt+cmd+c</td>
<td>提取代码为常量</td>
</tr>
<tr>
<td>opt+cmd+v</td>
<td>提取代码为变量</td>
</tr>
<tr>
<td>opt+cmd+f</td>
<td>提取代码为成员变量</td>
</tr>
<tr>
<td>opt+cmd+p</td>
<td>提取代码为方法的形参</td>
</tr>
<tr>
<td>opt+cmd+o</td>
<td>快速去掉多余的import</td>
</tr>
</tbody></table>
<h2 id="Navigation（导航）"><a href="#Navigation（导航）" class="headerlink" title="Navigation（导航）"></a>Navigation（导航）</h2><p>key(Mac) | key(Win) | desc</p>
<ul>
<li>| -<br>opt+F1 | alt+F1 | 跳转到当前代码文件很多相关的功能（强大）<br>cmd+u | 前往当前光标所在方法的父类的方法 &#x2F; 接口定义<br>cmd+b | 进入定义处<br>cmd+opt+b | 进入实现处<br>cmd+o | 查询当前类可以继承实现的所有方法<br>cmd+F12 | ^+F12 | 展示当前文件的结果大纲（可用于查询变量、方法等）<br>^+shift+B | 跳转到类型声明处，可以直接从类变量跳到对应的类里面<br>F12 | 返回前一个工具窗口<br>shift+esc | 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口<br>opt+F1 | 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择（如在代码编辑窗口可以选择显示该文件的 Finder）<br>⌃H | 显示当前类的层次结构(在类的任何地方可以快速跳转到父类、父接口、子类)<br>^+opt+H | 显示所有调用的层次结构<br>^+h | 显示类的所有子类型的相关内容<br>shift+F4 | 在新窗口打开文件<br>^+F2 | 可以快速跳到idea的菜单栏，然后通过方向键和enter，可以快速进行一下菜单栏的操作，这个快捷键适合其他软件<br>^+opt+cmd+N | 跳到next method，这个是我自定义的<br>^+opt+cmd+P | 跳到previous method，这个是我自定义的<br>跳到光标所在方法的方法名 | 先^+opt+cmd+N再^+opt+cmd+P，如果是最后一个方法就反之<br>cmd+鼠标点击（在变量定义处） | 可以使用<code>Field Accessors Found</code>查找使用到该变量的地方</li>
</ul>
<h2 id="后缀补全"><a href="#后缀补全" class="headerlink" title="后缀补全"></a>后缀补全</h2><h3 id="var"><a href="#var" class="headerlink" title="var"></a>var</h3><p>声明变量或者调用方法之后输入<code>.var</code>，可以自动生成前面的变量声明</p>
<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p>某个变量或者表达式之后输入<code>.null</code>，自动生成if空判断</p>
<h3 id="nn"><a href="#nn" class="headerlink" title="nn"></a>nn</h3><p>某个变量或者表达式之后输入<code>.nn</code>，自动生成if不为空判断</p>
<h3 id="not"><a href="#not" class="headerlink" title="not"></a>not</h3><p>某个变量或者表达式之后输入<code>.not</code>，自动生成取反</p>
<h3 id="还有for、return、if、opt等等常用的"><a href="#还有for、return、if、opt等等常用的" class="headerlink" title="还有for、return、if、opt等等常用的"></a>还有for、return、if、opt等等常用的</h3><h1 id="PLUGIN-插件"><a href="#PLUGIN-插件" class="headerlink" title="PLUGIN(插件)"></a>PLUGIN(插件)</h1><h2 id="emacsIdeas-最强大没有之一"><a href="#emacsIdeas-最强大没有之一" class="headerlink" title="emacsIdeas 最强大没有之一"></a>emacsIdeas 最强大没有之一</h2><blockquote>
<p>注意如果和IdeaVim一同使用的话，类似^+W的快捷键要更改，不然会和IdeaVim的屏幕分割快捷键冲突了</p>
</blockquote>
<h4 id="jump"><a href="#jump" class="headerlink" title="jump"></a>jump</h4><ul>
<li>Plug-ins | emacsIDEAs | AceJumpSelect       选中当前位置到某个字符</li>
<li>Plug-ins | emacsIDEAs | HighlightPrevSymbol 高亮跳到上一个一样的字符</li>
<li>Plug-ins | emacsIDEAs | HighlightNextSymbol 高亮跳到下一个一样的字符</li>
</ul>
<h4 id="emacsIdeas-copy"><a href="#emacsIdeas-copy" class="headerlink" title="emacsIdeas copy"></a>emacsIdeas copy</h4><ul>
<li>Plug-ins | emacsIDEAs | AceJumpCopy.Block       复制特定代码块到当前光标(可以是函数里面的整个形参定义)</li>
<li>Plug-ins | emacsIDEAs | AceJumpCopy.Line        复制特定行到当前光标</li>
<li>Plug-ins | emacsIDEAs | AceJumpCopy.Quote       复制特定的引用到当前光标，比如某个引号里面的内容</li>
<li>Plug-ins | emacsIDEAs | AceJumpCopy.String      复制特定的代码到当前光标，一般是某块前后由空格隔开的代码</li>
<li>Plug-ins | emacsIDEAs | AceJumpCopy.ToLineEnd   从当前位置复制到行尾</li>
<li>Plug-ins | emacsIDEAs | AceJumpCopy.ToLineStart 从当前位置复制到行首</li>
<li>Plug-ins | emacsIDEAs | AceJumpCopy.Paragraph   复制某个特定段落，比如类的某段注释</li>
<li>Plug-ins | emacsIDEAs | AceJumpCopy.Group       复制某块代码，可以使某个判断的条件+整个花括号{}里面的内容</li>
</ul>
<h4 id="emacsIdeas-delete"><a href="#emacsIdeas-delete" class="headerlink" title="emacsIdeas delete"></a>emacsIdeas delete</h4><ul>
<li>Plug-ins | emacsIDEAs | AceJumpCut                  从当前位置剪切到某个位置</li>
<li>Plug-ins | emacsIDEAs | AceJumpDelete.Block         删除特定的代码块 </li>
<li>Plug-ins | emacsIDEAs | AceJumpDelete.Line          删除特定的代码行</li>
<li>Plug-ins | emacsIDEAs | AceJumpDelete.Quote         删除特定的引用代码，比如某个引号里面的内容</li>
<li>Plug-ins | emacsIDEAs | AceJumpDelete.String        删除特定的二个空格之间的字符 </li>
<li>Plug-ins | emacsIDEAs | AceJumpDelete.Word          删除特定的某个变量方法名（紧挨在一起的代码标识）</li>
<li>Plug-ins | emacsIDEAs | AceJumpDelete.ToLineEnd     从当前位置删除到行尾</li>
<li>Plug-ins | emacsIDEAs | AceJumpDelete.ToLineStart   从当前位置删除到行首</li>
<li>Plug-ins | emacsIDEAs | AceJumpDelete.Paragraph     删除某个特定段落，比如类的某段注释</li>
</ul>
<h4 id="emacsIdeas-cut"><a href="#emacsIdeas-cut" class="headerlink" title="emacsIdeas cut"></a>emacsIdeas cut</h4><ul>
<li>Plug-ins | emacsIDEAs | AceJumpCut  从光标当前位置剪切到某个位置</li>
</ul>
<h4 id="emacsIdeas-more"><a href="#emacsIdeas-more" class="headerlink" title="emacsIdeas more"></a>emacsIdeas more</h4><p>AceJumpMove模式，各种快捷键的变种和上面的一样.etc.</p>
<h2 id="ideaVim"><a href="#ideaVim" class="headerlink" title="ideaVim"></a>ideaVim</h2><p>yy 复制当值当前行，或者选中后y复制，然后输入数字n，再输入p，代表连续粘贴n次。<br>gg 快速移动到文件的开头<br>G  快速移动到文件的结尾</p>
<h2 id="CamelCase"><a href="#CamelCase" class="headerlink" title="CamelCase"></a>CamelCase</h2><p>opt+shift+u 可以对字符进行驼峰式的不同格式变换，非常实用。</p>
<h2 id="Grep-Console"><a href="#Grep-Console" class="headerlink" title="Grep Console"></a>Grep Console</h2><p>安装该日志插件，控制台的日志输出可以更加直观，还可以自定义颜色。</p>
<h2 id="spring-assistant-yml或者properties文件编写提示"><a href="#spring-assistant-yml或者properties文件编写提示" class="headerlink" title="spring assistant(yml或者properties文件编写提示)"></a>spring assistant(yml或者properties文件编写提示)</h2><p>编写yml配置文件的时候，可以自动提示，但是这个自动提示貌似自会提示Spring Boot的基础配置，如果是在配置中心的话，其他的第三方依赖配置要在配置中心引入其spring-boot-starter的依赖才能自动提示对应的配置。</p>
<p><em><strong>如果对应的依赖引入了之后还不会自动提示，那就需要再idea的模块配置里面将自定义的配置文件加入到配置文件的类别中，如下图:</strong></em><br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/EpjOSE.png"><br>选择右边的第一个Configuration Files，因为通常配置中心新增的都不会是Bootstrap类别的配置文件，如下图，然后点击下面的绿色按钮，也就是最后一个按钮<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/RWKXhb.png"><br>再点击下面的+号，选择对一个的yml或者properties，然后确认就ok了。</p>
<h2 id="RestfulToolkit"><a href="#RestfulToolkit" class="headerlink" title="RestfulToolkit"></a>RestfulToolkit</h2><p>这个插件可以自动收集项目的Restful风格的接口，还可以在idea里面直接填写参数调用接口<br>快捷键为<code>cmd+\</code></p>
<h2 id="MyBatis-Log-Plugin"><a href="#MyBatis-Log-Plugin" class="headerlink" title="MyBatis Log Plugin"></a>MyBatis Log Plugin</h2><p>自动打印Mybatis的每一个SQL，有时候我们要抽取SQL不是很方便</p>
<h2 id="Free-Mybatis-plugin"><a href="#Free-Mybatis-plugin" class="headerlink" title="Free Mybatis plugin"></a>Free Mybatis plugin</h2><p>Mapper与Mapper XML映射之间的调整，方便代码的跟踪查看。<br>而且还可以自动通过Mapper的方法矫正或者生成Mapper.xml的每个xml节点</p>
<h2 id="ignore（版本控制忽略文件的好插件）支持各种文件忽略的配置"><a href="#ignore（版本控制忽略文件的好插件）支持各种文件忽略的配置" class="headerlink" title=".ignore（版本控制忽略文件的好插件）支持各种文件忽略的配置"></a>.ignore（版本控制忽略文件的好插件）支持各种文件忽略的配置</h2><p><a href="https://blog.csdn.net/byy8023/article/details/82259155">https://blog.csdn.net/byy8023/article/details/82259155</a></p>
<h3 id="可以根据项目的引用的构建工具能来针对性忽略"><a href="#可以根据项目的引用的构建工具能来针对性忽略" class="headerlink" title="可以根据项目的引用的构建工具能来针对性忽略"></a>可以根据项目的引用的构建工具能来针对性忽略</h3><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/A8xyJA.png"><br>比如我的项目选择了JetBrains、MacOS、Java、Maven、Example user template</p>
<h3 id="如果出现-gitgnore忽略了某些要被纳入版本控制的文件或目录比如："><a href="#如果出现-gitgnore忽略了某些要被纳入版本控制的文件或目录比如：" class="headerlink" title="如果出现.gitgnore忽略了某些要被纳入版本控制的文件或目录比如："></a>如果出现.gitgnore忽略了某些要被纳入版本控制的文件或目录比如：</h3><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/rXGSPh.png"><br>直接删除掉想要重新纳入版本控制的目录或文件即可</p>
<h3 id="maven的target反复被纳入版本控制"><a href="#maven的target反复被纳入版本控制" class="headerlink" title="maven的target反复被纳入版本控制"></a>maven的target反复被纳入版本控制</h3><p>这个是因为之前target目录已经被版本控制了，需要先关闭idea的自动编译，然后mvn clean一下，再提交所有删除的target文件，然后恢复自动编译配置。</p>
<p>前提是.gitignore文件里面配置了Maven的忽略目录</p>
<h2 id="JUnitGenerator-V2-0"><a href="#JUnitGenerator-V2-0" class="headerlink" title="JUnitGenerator V2.0"></a>JUnitGenerator V2.0</h2><p>选中代码中的类名，按cmd+shift+T，可以生成自定义测试类。<br><a href="https://blog.51cto.com/12066352/2134091">https://blog.51cto.com/12066352/2134091</a></p>
<h2 id="jclasslib-Bytecode-viewer"><a href="#jclasslib-Bytecode-viewer" class="headerlink" title="jclasslib Bytecode viewer"></a>jclasslib Bytecode viewer</h2><p>查看分析字节码的插件</p>
<h2 id="JRebel"><a href="#JRebel" class="headerlink" title="JRebel"></a>JRebel</h2><p>热部署插件，修改代码不用重启服务。</p>
<h2 id="Alibaba-Cloud-Toolkit"><a href="#Alibaba-Cloud-Toolkit" class="headerlink" title="Alibaba Cloud Toolkit"></a>Alibaba Cloud Toolkit</h2><p>阿里云发布的免费本地 IDE 插件，帮助开发者更高效地开发、测试、诊断并部署应用。通过插件，可以将本地应用一键部署到任意服务器，甚至云端（ECS、EDAS、ACK、ACR 和 小程序云等）；并且还内置了 Arthas 诊断、Dubbo工具、Terminal 终端、文件上传、函数计算 和 MySQL 执行器等工具。不仅仅有 IntelliJ IDEA 主流版本，还有 Eclipse、Pycharm、Maven 等其他版本。</p>
<h1 id="IDEA调优记录"><a href="#IDEA调优记录" class="headerlink" title="IDEA调优记录"></a>IDEA调优记录</h1><h2 id="Server模式"><a href="#Server模式" class="headerlink" title="Server模式"></a>Server模式</h2><blockquote>
<p>Selects server application runtime optimizations. The directory server will take longer to start and “warm up” but will be more aggressively optimized to produce higher throughput.</p>
</blockquote>
<p>服务器模式对于应用的运行时优化得更好，可能启动和”预热”会较慢，但将进行更积极的优化运行期的性能，以产生更高的吞吐量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- server</span><br></pre></td></tr></table></figure>
<h2 id="固定-Xmx与-Xms的大小，可能存在频繁扩容的消耗"><a href="#固定-Xmx与-Xms的大小，可能存在频繁扩容的消耗" class="headerlink" title="固定-Xmx与-Xms的大小，可能存在频繁扩容的消耗"></a>固定-Xmx与-Xms的大小，可能存在频繁扩容的消耗</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xms2048m</span><br><span class="line">-Xmx2048m</span><br></pre></td></tr></table></figure>
<h2 id="提高Minor的内存容量"><a href="#提高Minor的内存容量" class="headerlink" title="提高Minor的内存容量"></a>提高Minor的内存容量</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xmn800m</span><br></pre></td></tr></table></figure>
<h2 id="Xverify-none"><a href="#Xverify-none" class="headerlink" title="-Xverify:none"></a>-Xverify:none</h2><blockquote>
<p>Enables verification for all non-bootstrap classes.</p>
</blockquote>
<p>该参数默认是<code>-Xverify:remote</code>等同于<code>-Xverify</code>，会对class加载验证，对性能有影响，毕竟IDEA已经被反复使用和验证过，没必要每次都验证。</p>
<blockquote>
<p>For compatibility, this parameter is accepted, but is equivalent to the default -Xverify.<br>Note: This setting might have an impact on performance(<code>-Xverify:all</code>).</p>
</blockquote>
<p>不过从JDK13开始，<code>-Xverify:none</code>已经被声明为<code>deprecated</code>了，并且在后面的版本中会有被删除的风险。</p>
<blockquote>
<p>The option -Xverify:none (and its equivalent -noverify) was deprecated in Java 13. Both options might be removed in a future release. OpenJ9 issues a warning if these options are used in Java 13 and later versions.<br><a href="https://www.eclipse.org/openj9/docs/xverify/">参考来源</a></p>
</blockquote>
<h1 id="Others-其他"><a href="#Others-其他" class="headerlink" title="Others(其他)"></a>Others(其他)</h1><h2 id="修改包名要注意的地方"><a href="#修改包名要注意的地方" class="headerlink" title="修改包名要注意的地方"></a>修改包名要注意的地方</h2><p>修改了包名之后注意在编译输出的目录要清空之前的老的class，不然可能会引起意想不到的冲突。</p>
<h2 id="有没有更加智能化的API注释查看方法，比如鼠标-cmd的方式就完整地将注释都展示出来？"><a href="#有没有更加智能化的API注释查看方法，比如鼠标-cmd的方式就完整地将注释都展示出来？" class="headerlink" title="有没有更加智能化的API注释查看方法，比如鼠标+cmd的方式就完整地将注释都展示出来？"></a>有没有更加智能化的API注释查看方法，比如鼠标+cmd的方式就完整地将注释都展示出来？</h2><p>ctrl+J<br>可以搜索keymap需改热键，Quick Documentation</p>
<h2 id="debug的时候变量的多种不同的View"><a href="#debug的时候变量的多种不同的View" class="headerlink" title="debug的时候变量的多种不同的View"></a>debug的时候变量的多种不同的View</h2><p>在Variables右键要跟踪的变量,可以view text，或者view as 其他类型.</p>
<h2 id="Performance-enhancements（性能增加）"><a href="#Performance-enhancements（性能增加）" class="headerlink" title="Performance enhancements（性能增加）"></a>Performance enhancements（性能增加）</h2><p>idea吃内存确实是有点恐怖，对于调大内存，网上基本都是说调整idea.vmoptions里面的这三个参数：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xms1024m</span><br><span class="line">-Xmx3000m</span><br><span class="line">-XX:ReservedCodeCacheSize=1024m</span><br></pre></td></tr></table></figure>
<p>但是我自己是基于2019.02的版本，发现即使调整了之后重启，idea右下角的内存显示还是原来的Max。<br>其实要这样调整才能真正生效：<br>Help-&gt;Edit Custom VM Options<br>打开这个会发现里面的配置还是原来的，在这里更改再重启，右下角的内存Max才会变大，才能生效。</p>
<h2 id="cmd-shift-A按第二次的时候老是换出Terminal"><a href="#cmd-shift-A按第二次的时候老是换出Terminal" class="headerlink" title="cmd+shift+A按第二次的时候老是换出Terminal"></a>cmd+shift+A按第二次的时候老是换出Terminal</h2><p><a href="https://intellij-support.jetbrains.com/hc/en-us/articles/360005137400-Cmd-Shift-A-hotkey-opens-Terminal-with-apropos-search-instead-of-the-Find-Action-dialog">https://intellij-support.jetbrains.com/hc/en-us/articles/360005137400-Cmd-Shift-A-hotkey-opens-Terminal-with-apropos-search-instead-of-the-Find-Action-dialog</a></p>
<h2 id="Bug"><a href="#Bug" class="headerlink" title="Bug"></a>Bug</h2><p>有时候会出现复制进来的新文件编译之后没有被输出到target对应的目录，应该是idea潜在的bug，如果点击重新加载文件索引太慢了，一般重启一下重新编译可以解决。</p>
<h2 id="search（搜索）"><a href="#search（搜索）" class="headerlink" title="search（搜索）"></a>search（搜索）</h2><p>全局搜索的时候记得利用好Scope，比如要搜索某个模块，某所最近更改的内容，搜索版本控制的所有更改等等。</p>
<h2 id="Services"><a href="#Services" class="headerlink" title="Services"></a>Services</h2><p>cmd+8可以将多个SpringBoot的服务（微服务）整一个打开控制，可以结合其他快捷键进行启动、重启和停止，不过第一次使用需要再右下角的弹框中点击确认。<br>此外在Spring Cloud多个微服务的情况下，还可以将不同的微服务分组然后统一对某个组别进行run、debug或者静默断点等操作。</p>
<h2 id="使用lombok跟踪bean属性调用栈"><a href="#使用lombok跟踪bean属性调用栈" class="headerlink" title="使用lombok跟踪bean属性调用栈"></a>使用lombok跟踪bean属性调用栈</h2><p>opt+F7依然可以看到getter和setter的调用栈。</p>
<h2 id="SpringBoot-Application的热加载"><a href="#SpringBoot-Application的热加载" class="headerlink" title="SpringBoot Application的热加载"></a>SpringBoot Application的热加载</h2><p>要在debug模式下，设置Hot swap classes and update trigger file if failed，就可以自动热加载class了。</p>
<h2 id="idea的svn的删除操作"><a href="#idea的svn的删除操作" class="headerlink" title="idea的svn的删除操作"></a>idea的svn的删除操作</h2><p>本地删除之后要在，Locally Deleted Files中点击Remove from VCS，然后再回来上面的Default Changelist去执行Commit删除。</p>
<h2 id="折叠显示文件"><a href="#折叠显示文件" class="headerlink" title="折叠显示文件"></a>折叠显示文件</h2><p>可以在设置中搜索Soft-Wrap，根据文件格式配置是否折叠显示超过屏幕的行，也可以通过快捷键绑定折叠当前文件。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/dPTK3g.png"></p>
<h2 id="提交代码前要先Optimize-Imports一下"><a href="#提交代码前要先Optimize-Imports一下" class="headerlink" title="提交代码前要先Optimize Imports一下"></a>提交代码前要先Optimize Imports一下</h2><p>可以cmd+9，在Default Changelist上Optimize Imports（opt+cmd+O）,这样就不会优化到其他没有修改到的代码，只操作自己改过的代码。</p>
<h2 id="Run-x2F-Debug-Configurations中Build和Build-Project的区别"><a href="#Run-x2F-Debug-Configurations中Build和Build-Project的区别" class="headerlink" title="Run&#x2F;Debug Configurations中Build和Build Project的区别"></a>Run&#x2F;Debug Configurations中Build和Build Project的区别</h2><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/sSnMvO.png"><br>Build只会编译配置依赖的模块，Build Project会编译模块依赖的所有项目，将编译器交给Maven代工的话注意要选择Build Project。</p>
<h2 id="重要日志可以在控制台Create-Gist"><a href="#重要日志可以在控制台Create-Gist" class="headerlink" title="重要日志可以在控制台Create Gist"></a>重要日志可以在控制台Create Gist</h2><p>创建之后的日志会被发送到已经在Idea登录的github账号里面的Github Gist</p>
<h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><p>自带的Maven功能中，注意小浮窗的右上角有个闪电符号（Toggle Skip Test），可以开启是否跳过Test。<br>扳手按钮里里面的Auto-Reload Settings可以设置是否自动探测任何pom.xml的改动自动重新加载。</p>
<h2 id="只编译每次改动的每个module"><a href="#只编译每次改动的每个module" class="headerlink" title="只编译每次改动的每个module"></a>只编译每次改动的每个module</h2><p>在未commit的Default Changelist中，选中list，快捷键编译一下全部改动过的代码，idea会编译每个代码对应的module。</p>
<h1 id="all-shortcut"><a href="#all-shortcut" class="headerlink" title="all shortcut"></a>all shortcut</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">新建文件的时候可以这样操作来脱离鼠标：</span><br><span class="line">cmd+1跳到Project目录上下移动到目标目录，然后cmd+shift+A跳出Action，输入new+文件类型或者手动选择文件类型就可以了。</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">option+cmd+c 抽取局部字符串为静态变量</span><br><span class="line">cmd+shift+方向键  可以控制模态框的大小，和左右移动编辑区的内容</span><br><span class="line">ctrl+j  展示API文档</span><br><span class="line">ctrl+shift+F,[words 打钩可以搜索是否为单词]</span><br><span class="line">command+D,</span><br><span class="line">commond+F12(file structure)</span><br><span class="line">command+shift+N(search file&#x27;s name and global)</span><br><span class="line">commond+option+shift+N(search method d variable global)</span><br><span class="line">shirt + option + (向上箭头)/（向下箭头）(move codes up or down)</span><br><span class="line">Command + Option + L(Format code)</span><br><span class="line">option+enter（add javadoc）</span><br><span class="line">option+command+b(jump into the class impl)</span><br><span class="line">command+e(recent file)</span><br><span class="line">command+shift+a(search action)</span><br><span class="line">command+number(window tab jump)</span><br><span class="line">shift(ctrl)+command+del(last(next) edit location)</span><br><span class="line">F11，command+F11，ctrl+number(alphabet)(bookmarks)</span><br><span class="line">option+shift+F(add to favorites)</span><br><span class="line">shift+option+U(toggle case)</span><br><span class="line">command+1,esc(switch between file navigate and edit area)</span><br><span class="line">option+F7(find usage)</span><br><span class="line">shift+option+方向(move caret to next word)</span><br><span class="line">command+方向(move to first or end of line)</span><br><span class="line">ctrl+command+G(sellect all occurrences) HOT</span><br><span class="line">F2(Quickly locate the wrong line)</span><br><span class="line">option+command+V(generate locate variable)</span><br><span class="line">shift+command+enter(generate some code)</span><br><span class="line">option+enter(generate some method)</span><br><span class="line">command+R(replace)</span><br><span class="line">shift+F6(rename)</span><br><span class="line">option+command+V(Extract Variable)</span><br><span class="line">option+command+C(Extract static Variable) HOT</span><br><span class="line">option+command+F(Extract field Variable)</span><br><span class="line">option+command+P(Extract field Variable into method)</span><br><span class="line">option+command+M(Extract some code to be a new method)HOT</span><br><span class="line">shift+command+F8(show all breakPoints)</span><br><span class="line">shift+command+V(copy history)</span><br><span class="line">shift+option+command+U(show maven dependencies)</span><br><span class="line">option+command+U(show class inherit) HOT</span><br><span class="line">ctrl+option+H(call method or be called history)</span><br><span class="line">ctrl+N(Generate anything)</span><br><span class="line">ctrl+w(select something)</span><br><span class="line">ctrl+&lt; or &gt; (move up or down next method) HOT</span><br><span class="line">cmd+option+T (surround) HOT</span><br></pre></td></tr></table></figure>

<h1 id="Problem-Solution"><a href="#Problem-Solution" class="headerlink" title="Problem Solution"></a>Problem Solution</h1><h2 id="编译出现莫名其妙的找不到符号的Error"><a href="#编译出现莫名其妙的找不到符号的Error" class="headerlink" title="编译出现莫名其妙的找不到符号的Error"></a>编译出现莫名其妙的找不到符号的Error</h2><p>如果找不到符号的错误行数，刚好式同包下的某个类找不到符号报错，那么可能式idea的类编译顺序冲突了，找到报错行上引用到的类，先单独编译应用到的类，再编译报错的类，最后编译整个项目就可以了。</p>
<h2 id="非静默模式下断点失效-96"><a href="#非静默模式下断点失效-96" class="headerlink" title="非静默模式下断点失效&#96;"></a>非静默模式下断点失效&#96;</h2><p>断点处提示：idea debug no executable code found<br>这个一般是class和idea的代码不一致导致的。<br>解决办法：<br>1、invalidate Caches&#x2F;Restart<br>2、rebuild Project<br>3、class的输出路径正确<br>4、我自己是因为jboss的On ‘update’ action 被设置成了Restart Server，热部署应该改为：Update classes and resources</p>
<h2 id="某个jar依赖冲突问题的解决"><a href="#某个jar依赖冲突问题的解决" class="headerlink" title="某个jar依赖冲突问题的解决"></a>某个jar依赖冲突问题的解决</h2><p>公司项目中cglib的包依赖了二个log4j的包，导致控制台启动会报错。 删除项目输出目录下的lib，设置依赖jar的scope为provided。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/7vAT8L.png"><br>然后重新部署启动就可以了。</p>
<h2 id="debug启动微服务莫名其妙卡住的情况"><a href="#debug启动微服务莫名其妙卡住的情况" class="headerlink" title="debug启动微服务莫名其妙卡住的情况"></a>debug启动微服务莫名其妙卡住的情况</h2><p>竟然是因为我在某个方法的声明上打了断点，然后我静默断点时就可以debug启动微服务了：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/Qtfqng.png"><br>于是我果断把断点去掉，然后再检查一遍有没有打到方法声明上的断点，全都取消之后重启debug就可以了。</p>
<h2 id="记录Idea关于Maven依赖的一个致命Bug"><a href="#记录Idea关于Maven依赖的一个致命Bug" class="headerlink" title="记录Idea关于Maven依赖的一个致命Bug"></a>记录Idea关于Maven依赖的一个致命Bug</h2><blockquote>
<p>基于版本2019.3.4</p>
</blockquote>
<p>公司的微服务架构的用的Maven管理依赖，关于流程flowable的的模块ngbip-flow及其几个子模块我放在一个单独的文件夹下面；</p>
<p>另外的一个项目也是基于微服务架构依赖ngbip-flow及其几个子模块，然后由于启动报了个莫名其妙的错误，于是我删掉了项目对公司自研的所有依赖，重新引入；</p>
<p>但是这个时候idea移动将ngbip-flow的几个模块的依赖强制指向了上面提到的单独的文件夹下面的ngbip-flow几个子模块的代码文件，不走maven去依赖了，我TM是不同的文件夹（不同的工作区间啊，打开的是不同的idea窗口）；</p>
<p>最后的硬核解决方法是，将原来的单独文件夹重命名个名字，这个时候另外的项目一下子就自动重新引入ngbip-flow的maven依赖，不会强制走开发机的其他文件夹下面的依赖，然后我再把文件夹名字改回来即可。</p>
<h2 id="Maven代码不能指向本地工程module代码"><a href="#Maven代码不能指向本地工程module代码" class="headerlink" title="Maven代码不能指向本地工程module代码"></a>Maven代码不能指向本地工程module代码</h2><p>如果出现idea的Modules已经存在，但是代码不能通过Maven依赖到已经引入的module时（此时Maven管理界面可能会出现已经引入的model的maven可视化没有出现），这个时候在工程的Modules删除重新引入应该就可以了。</p>
<h2 id="Idea出现所有引导到的类报错，连jdk的基础类也报错的情况"><a href="#Idea出现所有引导到的类报错，连jdk的基础类也报错的情况" class="headerlink" title="Idea出现所有引导到的类报错，连jdk的基础类也报错的情况"></a>Idea出现所有引导到的类报错，连jdk的基础类也报错的情况</h2><p>可能是不了心设置了Editor-&gt;File Type中忽略了*.class导致的。<br>如果是项目引入自己项目的代码也报错，可以删掉模块重新import。</p>
<h2 id="Idea关闭写代码形参提示（会导致变卡）"><a href="#Idea关闭写代码形参提示（会导致变卡）" class="headerlink" title="Idea关闭写代码形参提示（会导致变卡）"></a>Idea关闭写代码形参提示（会导致变卡）</h2><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/RVmJT6.png" alt="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/RVmJT6.png"></p>
<blockquote>
<p>有部分内容来自网络，一般都有注明出处，如若侵权，请联系我删除，谢谢！</p>
</blockquote>
<h2 id="将默认编译委托为Maven编译时，运行main方法报错"><a href="#将默认编译委托为Maven编译时，运行main方法报错" class="headerlink" title="将默认编译委托为Maven编译时，运行main方法报错"></a>将默认编译委托为Maven编译时，运行main方法报错</h2><p>默认的Application Run&#x2F;Debug Configurations配置的Before launch会有一个Build，要将其删掉，Before launch留空即可，因为此时Idea本身已经不再参与编译了，交由Maven来处理。</p>
<h2 id="Cannot-start-under-Java-1-8-0-152-release-b1024-Java-11-or-later-is-required"><a href="#Cannot-start-under-Java-1-8-0-152-release-b1024-Java-11-or-later-is-required" class="headerlink" title="Cannot start under Java 1.8.0_152-release-b1024: Java 11 or later is required."></a>Cannot start under Java 1.8.0_152-release-b1024: Java 11 or later is required.</h2><p>通过<code>/usr/libexec/java_home</code>找到自己版本适合的jdk目录，在Mac下面修改Idea启动的依赖jdk即可：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /Users/zhanshifeng/Library/Application Support/JetBrains/IntelliJIdea2020.3/idea.jdk</span><br></pre></td></tr></table></figure>

<h2 id="Idea出现写代码频繁卡死，特别是在括号之间输入一直卡死的问题"><a href="#Idea出现写代码频繁卡死，特别是在括号之间输入一直卡死的问题" class="headerlink" title="Idea出现写代码频繁卡死，特别是在括号之间输入一直卡死的问题"></a>Idea出现写代码频繁卡死，特别是在括号之间输入一直卡死的问题</h2><p>关闭Inspections里面的Ali-Check，阿里的东西，要慎用！</p>
]]></content>
      <categories>
        <category>IDEA</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring系列之SpringCloud</title>
    <url>/2019/11/25/Spring%E7%B3%BB%E5%88%97%E4%B9%8BSpringCloud/</url>
    <content><![CDATA[<h1 id="TodoItem"><a href="#TodoItem" class="headerlink" title="TodoItem"></a>TodoItem</h1><h2 id="整理一下springcloud一站式解决方案的每个环节中，现在有哪些框架已经是不维护的？-todo"><a href="#整理一下springcloud一站式解决方案的每个环节中，现在有哪些框架已经是不维护的？-todo" class="headerlink" title="整理一下springcloud一站式解决方案的每个环节中，现在有哪些框架已经是不维护的？ todo"></a>整理一下springcloud一站式解决方案的每个环节中，现在有哪些框架已经是不维护的？ todo</h2><h2 id="Dubbo的生态在最近有没有经常颠覆性的完善？-todo"><a href="#Dubbo的生态在最近有没有经常颠覆性的完善？-todo" class="headerlink" title="Dubbo的生态在最近有没有经常颠覆性的完善？ todo"></a>Dubbo的生态在最近有没有经常颠覆性的完善？ todo</h2><h2 id="为什么本地配置文件还要有从git加载的模式？-todo"><a href="#为什么本地配置文件还要有从git加载的模式？-todo" class="headerlink" title="为什么本地配置文件还要有从git加载的模式？ todo"></a>为什么本地配置文件还要有从git加载的模式？ todo</h2><h2 id="RefreshScope用法和避坑-todo"><a href="#RefreshScope用法和避坑-todo" class="headerlink" title="@RefreshScope用法和避坑 todo"></a>@RefreshScope用法和避坑 todo</h2><p>Refresh Scope<br>A Spring @Bean that is marked as @RefreshScope will get special treatment when there is a configuration change. This addresses the problem of stateful beans that only get their configuration injected when they are initialized. For instance if a DataSource has open connections when the database URL is changed via the Environment, we probably want the holders of those connections to be able to complete what they are doing. Then the next time someone borrows a connection from the pool he gets one with the new URL.</p>
<p>Refresh scope beans are lazy proxies that initialize when they are used (i.e. when a method is called), and the scope acts as a cache of initialized values. To force a bean to re-initialize on the next method call you just need to invalidate its cache entry.</p>
<h2 id="spring-cloud-config-uri的默认值作用是什么？启动警告是否需要排除掉？todo"><a href="#spring-cloud-config-uri的默认值作用是什么？启动警告是否需要排除掉？todo" class="headerlink" title="spring.cloud.config.uri的默认值作用是什么？启动警告是否需要排除掉？todo"></a>spring.cloud.config.uri的默认值作用是什么？启动警告是否需要排除掉？todo</h2><h2 id="SpringBootApplication中指定scanBasePackages和不指定scanBasePackages的区别-todo"><a href="#SpringBootApplication中指定scanBasePackages和不指定scanBasePackages的区别-todo" class="headerlink" title="@SpringBootApplication中指定scanBasePackages和不指定scanBasePackages的区别 todo"></a>@SpringBootApplication中指定scanBasePackages和不指定scanBasePackages的区别 todo</h2><h1 id="spring-profiles-yml配置文件"><a href="#spring-profiles-yml配置文件" class="headerlink" title="spring.profiles || yml配置文件"></a>spring.profiles || yml配置文件</h1><p>关于spring boot profiles可以参考：<br><a href="https://dzone.com/articles/spring-boot-profiles-1">https://dzone.com/articles/spring-boot-profiles-1</a><br>文中翻译的大概意思如下：<br>spring.profiles会以灵活切换的方式切换整个应用环境配置的各种相关属性，通过相关属性所在配置文件的文件名为条件做切换。</p>
<h4 id="spring-profiles-active-native"><a href="#spring-profiles-active-native" class="headerlink" title="spring.profiles.active:native"></a>spring.profiles.active:native</h4><p>这个标记为配置文件从本地路径加载，但是有点奇怪，按道理这么危险的配置文件应该只能本地才对，即使从svn或者git上加载也只能从私服去取，在非开发模式下不应该存在去公网取配置文件才对。<br>网上说可以从native，svn和git加载，但是官方的最新文档其comma-separated list出现的有</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">active: dev,mysql,git,redis,awss3,credhub,composite,vault</span><br></pre></td></tr></table></figure>
<p>在查阅官方文档之后发现这几段话：</p>
<blockquote>
<p>There is also a “native” profile in the Config Server that does not use Git but loads the config files from the local classpath or file system (any static URL you want to point to with spring.cloud.config.server.native.searchLocations). To use the native profile, launch the Config Server with spring.profiles.active&#x3D;native.</p>
</blockquote>
<p>意思是，当spring.profiles.active&#x3D;native，配置服务会从本地的类路径classpath读取配置文件，如果指定了spring.cloud.config.server.native.searchLocations的话，那么将从指定的路径去读取配置属性文件。</p>
<blockquote>
<p>Remember to use the file: prefix for file resources (the default without a prefix is usually the classpath). As with any Spring Boot configuration, you can embed ${}-style environment placeholders, but remember that absolute paths in Windows require an extra &#x2F; (for example, file:&#x2F;&#x2F;&#x2F;${user.home}&#x2F;config-repo).</p>
</blockquote>
<p>意思是，spring.cloud.config.server.native.searchLocations可以用${}引用变量这种占位符的方式指定路径。</p>
<blockquote>
<p>The default value of the searchLocations is identical to a local Spring Boot application (that is, [classpath:&#x2F;, classpath:&#x2F;config, file:.&#x2F;, file:.&#x2F;config]). This does not expose the application.properties from the server to all clients, because any property sources present in the server are removed before being sent to the client.</p>
</blockquote>
<p>意思是，spring.cloud.config.server.native.searchLocations有四个默认值，在不配置它的时候可以默认生效,并且如果配置了native的话，路径下所有的配置文件都会被默认加载。</p>
<h4 id="prefer-ip-address"><a href="#prefer-ip-address" class="headerlink" title="prefer-ip-address"></a>prefer-ip-address</h4><p>这个配置我在官方文档找到的解释是这样的：<br>In some cases, it is preferable for Eureka to advertise the IP addresses of services rather than the hostname. Set eureka.instance.preferIpAddress to true and, when the application registers with eureka, it uses its IP address rather than its hostname.<br>翻译：在某些情况下，Eureka显示服务列表用ip地址的形式来展示比用hostname的形式可能更加合适。把eureka.instance.preferIpAddress（低版本）设置为true，当服务被注册到eureka的时候，注册中心会使用它的ip地址而不是hostname。</p>
<h4 id="lease-renewal-interval-in-seconds"><a href="#lease-renewal-interval-in-seconds" class="headerlink" title="lease-renewal-interval-in-seconds"></a>lease-renewal-interval-in-seconds</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   /**</span><br><span class="line"> * Indicates how often (in seconds) the eureka client needs to send heartbeats to</span><br><span class="line"> * eureka server to indicate that it is still alive. If the heartbeats are not</span><br><span class="line"> * received for the period specified in leaseExpirationDurationInSeconds, eureka</span><br><span class="line"> * server will remove the instance from its view, there by disallowing traffic to this</span><br><span class="line"> * instance.</span><br><span class="line"> *</span><br><span class="line"> * Note that the instance could still not take traffic if it implements</span><br><span class="line"> * HealthCheckCallback and then decides to make itself unavailable.</span><br><span class="line"> */</span><br><span class="line">private int leaseRenewalIntervalInSeconds = 30;</span><br></pre></td></tr></table></figure>
<p>翻译：指定一个eureka客户端发送心跳包给eureka服务的频率（以秒为单位），以此来确保服务是否还活着。如果心跳包在leaseExpirationDurationInSeconds指定的时间段之内没有收到回应，那么eureka的服务将从他们可用微服务列表中移除掉对应的微服务实例，不再允许向该实例发送流量。要注意的是，如果实例实现了HealthCheckCallback接口，并且决定让实例自己置为不可用的话，那么它任然是不能接受流量的。</p>
<h4 id="lease-expiration-duration-in-seconds"><a href="#lease-expiration-duration-in-seconds" class="headerlink" title="lease-expiration-duration-in-seconds"></a>lease-expiration-duration-in-seconds</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">   /**</span><br><span class="line"> * Indicates the time in seconds that the eureka server waits since it received the</span><br><span class="line"> * last heartbeat before it can remove this instance from its view and there by</span><br><span class="line"> * disallowing traffic to this instance.</span><br><span class="line"> *</span><br><span class="line"> * Setting this value too long could mean that the traffic could be routed to the</span><br><span class="line"> * instance even though the instance is not alive. Setting this value too small could</span><br><span class="line"> * mean, the instance may be taken out of traffic because of temporary network</span><br><span class="line"> * glitches.This value to be set to atleast higher than the value specified in</span><br><span class="line"> * leaseRenewalIntervalInSeconds.</span><br><span class="line"> */</span><br><span class="line">private int leaseExpirationDurationInSeconds = 90;</span><br></pre></td></tr></table></figure>
<p>翻译：指定一个从它最后一次接收某个服务实例的心跳包后等待的时间（以秒为单位），如果超过这个时间还不能接收到心跳包，那么eureka将会从他的服务列表中移除该实例，并不再允许向该实例发送流量。设置leaseExpirationDurationInSeconds的值太大的话，可能意味着某个实例不是活着的情况下，流量依然被发送到该实例中。设置的值太小的话，可能会由于临时网络故障导致实例抛弃了流量。这个值至少要比leaseRenewalIntervalInSeconds的值要高，也就是上面提到的lease-renewal-interval-in-seconds。</p>
<h4 id="registry-fetch-interval-seconds"><a href="#registry-fetch-interval-seconds" class="headerlink" title="registry-fetch-interval-seconds"></a>registry-fetch-interval-seconds</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  /**</span><br><span class="line">* Indicates how often(in seconds) to fetch the registry information from the eureka</span><br><span class="line">* server.</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>翻译：指定从eureka抓取注册服务的信息的频率（以秒为单位）</p>
<h4 id="spring-cloud-config-fail-fast"><a href="#spring-cloud-config-fail-fast" class="headerlink" title="spring.cloud.config.fail-fast"></a>spring.cloud.config.fail-fast</h4><p><a href="https://blog.csdn.net/liubenlong007/article/details/87885567">https://blog.csdn.net/liubenlong007/article/details/87885567</a></p>
<h1 id="处理过的问题"><a href="#处理过的问题" class="headerlink" title="处理过的问题"></a>处理过的问题</h1><h4 id="Request-execution-error-endpoint-x3D-DefaultEndpoint-serviceUrl-x3D-’XX’"><a href="#Request-execution-error-endpoint-x3D-DefaultEndpoint-serviceUrl-x3D-’XX’" class="headerlink" title="Request execution error. endpoint&#x3D;DefaultEndpoint{ serviceUrl&#x3D;’XX’}"></a>Request execution error. endpoint&#x3D;DefaultEndpoint{ serviceUrl&#x3D;’XX’}</h4><p>这个报错非常奇葩，我是从网上下的手脚架，运行起来直接报错，后来通过谷歌找到了解决方案，就是在eureka服务的配置文件中加入register-with-eureka和fetch-registry:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 注册中心配置</span><br><span class="line">eureka:</span><br><span class="line">  instance:</span><br><span class="line">    prefer-ip-address: true</span><br><span class="line">    hostname: pig-eureka</span><br><span class="line">  client:</span><br><span class="line">    register-with-eureka: false</span><br><span class="line">    fetch-registry: false</span><br><span class="line">    service-url:</span><br><span class="line">      defaultZone: http://pig:pig@pig-eureka:8761/eureka/</span><br></pre></td></tr></table></figure>
<p>后来再仔细跟一下，发现我是忘记先把eureka注册中心的服务启动了。。。</p>
<h4 id="Cannot-execute-request-on-any-known-server"><a href="#Cannot-execute-request-on-any-known-server" class="headerlink" title="Cannot execute request on any known server"></a>Cannot execute request on any known server</h4><p>确认yml配置文件地址和格式没有问题的话，那么可能是eureka注册中心的服务没有关闭csrf，在eureka注册中心增加WebSecurityConfigurerAdapter，如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableWebSecurity</span><br><span class="line">public class WebSecurityConfig extends WebSecurityConfigurerAdapter &#123;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected void configure(HttpSecurity http) throws Exception &#123;</span><br><span class="line">        http.csrf().disable();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="java-lang-NoClassDefFoundError-com-x2F-netflix-x2F-hystrix-x2F-contrib-x2F-javanica-x2F-aop-x2F-aspectj-x2F-HystrixCommandAspect"><a href="#java-lang-NoClassDefFoundError-com-x2F-netflix-x2F-hystrix-x2F-contrib-x2F-javanica-x2F-aop-x2F-aspectj-x2F-HystrixCommandAspect" class="headerlink" title="java.lang.NoClassDefFoundError: com&#x2F;netflix&#x2F;hystrix&#x2F;contrib&#x2F;javanica&#x2F;aop&#x2F;aspectj&#x2F;HystrixCommandAspect"></a>java.lang.NoClassDefFoundError: com&#x2F;netflix&#x2F;hystrix&#x2F;contrib&#x2F;javanica&#x2F;aop&#x2F;aspectj&#x2F;HystrixCommandAspect</h4><p>需要增加断容器依赖spring-cloud-starter-netflix-hystrix</p>
<h4 id="org-springframework-beans-factory-annotation-Qualifier-value-x3D-webFluxConversionService"><a href="#org-springframework-beans-factory-annotation-Qualifier-value-x3D-webFluxConversionService" class="headerlink" title="@org.springframework.beans.factory.annotation.Qualifier(value&#x3D;webFluxConversionService)}"></a>@org.springframework.beans.factory.annotation.Qualifier(value&#x3D;webFluxConversionService)}</h4><p>如果引入一些第三方的Spring<br>抛出了这个依赖异常，原因是我同时引入依赖：spring-cloud-starter-gateway 和 spring-boot-starter-web。去除了父模块的spring-boot-starter-web依赖即可。</p>
<h4 id="If-you-want-an-embedded-database-H2-HSQL-or-Derby-please-put-it-on-the-classpath"><a href="#If-you-want-an-embedded-database-H2-HSQL-or-Derby-please-put-it-on-the-classpath" class="headerlink" title="If you want an embedded database (H2, HSQL or Derby), please put it on the classpath."></a>If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.</h4><p>如果遇到新建的微服务报错如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">***************************</span><br><span class="line">APPLICATION FAILED TO START</span><br><span class="line">***************************</span><br><span class="line"></span><br><span class="line">Description:</span><br><span class="line"></span><br><span class="line">Failed to configure a DataSource: &#x27;url&#x27; attribute is not specified and no embedded datasource could be configured.</span><br><span class="line"></span><br><span class="line">Reason: Failed to determine a suitable driver class</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Action:</span><br><span class="line"></span><br><span class="line">Consider the following:</span><br><span class="line">	If you want an embedded database (H2, HSQL or Derby), please put it on the classpath.</span><br><span class="line">	If you have database settings to be loaded from a particular profile you may need to activate it (no profiles are currently active).</span><br></pre></td></tr></table></figure>
<p>检查关于数据库的链接拼写，和驱动包依赖，如果都没问题，有可能是因为新的微服务使用了配置中心忘记引用配置中心的客户端pom依赖了，我就是忘记下面这个引用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<p>另外，可能性也会有如下几点：<br>1，yml，properties文件缺失、配置写错等；<br>2，没有在@SpringBootApplication注解的Application的同级包或者子级包下增加配置类也会报这个错;<br>3，也有可能是因为引入了不必要的spring-boot-starter-web模块，这个模块会强制要配置数据源；<br>4，引入了其他依赖到数据源配置的包比如</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;!--mybatis-plus--&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;com.baomidou&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;$&#123;mybatis-plus.version&#125;&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Feign-PathVariable-annotation-was-empty-on-param-0"><a href="#Feign-PathVariable-annotation-was-empty-on-param-0" class="headerlink" title="Feign PathVariable annotation was empty on param 0."></a>Feign PathVariable annotation was empty on param 0.</h4><p>使用Feign的时候,如果参数中带有@PathVariable形式的参数,则要用value&#x3D;””标明对应的参数,否则会抛出IllegalStateException异常</p>
<h4 id="The-bean-‘ngbip-baf-service-FeignClientSpecification’-could-not-be-registered-A-bean-with-that-name-has-already-been-defined-and-overriding-is-disabled"><a href="#The-bean-‘ngbip-baf-service-FeignClientSpecification’-could-not-be-registered-A-bean-with-that-name-has-already-been-defined-and-overriding-is-disabled" class="headerlink" title="The bean ‘ngbip-baf-service.FeignClientSpecification’ could not be registered. A bean with that name has already been defined and overriding is disabled."></a>The bean ‘ngbip-baf-service.FeignClientSpecification’ could not be registered. A bean with that name has already been defined and overriding is disabled.</h4><p>这个原因基本是因为注解了FeignClient的客户端类，同个id的要被重复注册进注册中心才报的错，可以检查一下是否有@FeignClient的id重复，或者pom的依赖重复了导致feign服务注册多次。</p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>SpringCloud</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>SpringCloud</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue系列之表严肃Vue视频教程笔记</title>
    <url>/2019/12/02/Vue%E7%B3%BB%E5%88%97%E4%B9%8B%E8%A1%A8%E4%B8%A5%E8%82%83Vue%E8%A7%86%E9%A2%91%E6%95%99%E7%A8%8B%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>参考自表严肃的视频教程 <a href="https://www.bilibili.com/video/av13450835?p=4">https://www.bilibili.com/video/av13450835?p=4</a></p>
</blockquote>
<h1 id="常用feature"><a href="#常用feature" class="headerlink" title="常用feature"></a>常用feature</h1><h2 id="v-for"><a href="#v-for" class="headerlink" title="v-for"></a>v-for</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;span v-for=&quot;(role) in scope.row.roleList&quot;&gt;</span><br><span class="line">                &lt;el-tag&gt;&#123;&#123;role.roleName&#125;&#125; &lt;/el-tag&gt;</span><br><span class="line">              &lt;/span&gt;</span><br></pre></td></tr></table></figure>
<p>chrome的控制台可以动态直接通过js的api给页面update数据，比如：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/JOPVFM.png"></p>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql系列之性能优化与问题定位</title>
    <url>/2019/12/12/Mysql%E7%B3%BB%E5%88%97%E4%B9%8B%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%8E%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<h1 id="Server-Status-Variables"><a href="#Server-Status-Variables" class="headerlink" title="Server Status Variables"></a>Server Status Variables</h1><h2 id="设置事务自动提交"><a href="#设置事务自动提交" class="headerlink" title="设置事务自动提交"></a>设置事务自动提交</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查看是否开启自动提交事务</span><br><span class="line">SHOW VARIABLES LIKE &#x27;AUTOCOMMIT&#x27;;</span><br><span class="line">select @@AUTOCOMMIT;</span><br></pre></td></tr></table></figure>
<h1 id="设计优化"><a href="#设计优化" class="headerlink" title="设计优化"></a>设计优化</h1><h2 id="tinyint和char-1-性能对比"><a href="#tinyint和char-1-性能对比" class="headerlink" title="tinyint和char(1)性能对比"></a>tinyint和char(1)性能对比</h2><p><a href="https://blog.csdn.net/yzj5208/article/details/81214780?utm_source=blogxgwz6">https://blog.csdn.net/yzj5208/article/details/81214780?utm_source&#x3D;blogxgwz6</a></p>
<h2 id="布尔类型字段的设计"><a href="#布尔类型字段的设计" class="headerlink" title="布尔类型字段的设计"></a>布尔类型字段的设计</h2><p>可以使用bit类型，节约磁盘存储空间。</p>
<h2 id="datetime-和-timestamp-的区别与选择"><a href="#datetime-和-timestamp-的区别与选择" class="headerlink" title="datetime 和 timestamp 的区别与选择"></a>datetime 和 timestamp 的区别与选择</h2><p><a href="https://segmentfault.com/a/1190000017393602">https://segmentfault.com/a/1190000017393602</a></p>
<h1 id="锁表、线程溢出常见处理方法"><a href="#锁表、线程溢出常见处理方法" class="headerlink" title="锁表、线程溢出常见处理方法"></a>锁表、线程溢出常见处理方法</h1><p>查询当前的线程信息，mysql会把当前正在运行的mysql线程信息实时更新到processlist表。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">show processlist; # 查询当前100条；等同于select * from information_schema.processlist;</span><br><span class="line">show full processlist; # 查询全部；</span><br><span class="line"># 查询非睡眠状态的连接</span><br><span class="line">select p.*</span><br><span class="line">from information_schema.processlist p</span><br><span class="line">where p.COMMAND != &#x27;Sleep&#x27;;</span><br><span class="line"># 查询并发最大连接数</span><br><span class="line">show variables like &#x27;%max_connections%&#x27;;</span><br><span class="line"># 查看当前线程连接数量信息 </span><br><span class="line">show status like &#x27;Threads%&#x27;;</span><br></pre></td></tr></table></figure>
<h2 id="慢查询"><a href="#慢查询" class="headerlink" title="慢查询"></a>慢查询</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查找当前正在执行超过1分钟的线程信息</span><br><span class="line">select * from information_schema.processlist where command != &#x27;Sleep&#x27; and time &gt; 60 order by time desc;</span><br><span class="line"># 不要轻易kill，注意看是否是system user或者是maxscale等代理监控的用户</span><br><span class="line"># 确定是慢查询的时候，可以执行kill id的操作</span><br><span class="line"># 命令行查看慢查询</span><br><span class="line">mysql -ureader -pread -e &#x27;show full processlist&#x27; | grep &quot;select &quot;</span><br></pre></td></tr></table></figure>
<p>参考：<a href="https://www.jianshu.com/p/93cae0b3db3b">https://www.jianshu.com/p/93cae0b3db3b</a></p>
<h2 id="事务等待超时一般会抛出异常："><a href="#事务等待超时一般会抛出异常：" class="headerlink" title="事务等待超时一般会抛出异常："></a>事务等待超时一般会抛出异常：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Error updating database.  Cause: com.mysql.cj.jdbc.exceptions.MySQLTransactionRollbackException: Lock wait timeout exceeded; try restarting transaction</span><br></pre></td></tr></table></figure>
<h2 id="设置事务超时时间："><a href="#设置事务超时时间：" class="headerlink" title="设置事务超时时间："></a>设置事务超时时间：</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 查询事务超时变量值</span><br><span class="line">SHOW GLOBAL VARIABLES LIKE &#x27;innodb_lock_wait_timeout&#x27;;</span><br><span class="line"># 设置事务超时时间</span><br><span class="line">SET GLOBAL innodb_lock_wait_timeout=120;</span><br></pre></td></tr></table></figure>
<h2 id="设置线程等待时间"><a href="#设置线程等待时间" class="headerlink" title="设置线程等待时间"></a>设置线程等待时间</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET wait_timeout = 10;</span><br><span class="line">SET global wait_timeout = 10;</span><br><span class="line">show global variables like &#x27;wait_timeout&#x27;;</span><br><span class="line">show variables like &#x27;wait_timeout&#x27;;</span><br></pre></td></tr></table></figure>
<h2 id="事务锁、死锁处理方法"><a href="#事务锁、死锁处理方法" class="headerlink" title="事务锁、死锁处理方法"></a>事务锁、死锁处理方法</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from information_schema.innodb_trx; # 当前运行的所有事务</span><br><span class="line">select * from information_schema.innodb_locks; # 当前出现的锁</span><br><span class="line">select * from information_schema.innodb_lock_waits; # 锁等待的对应关系</span><br></pre></td></tr></table></figure>
<h2 id="查找一直在锁等待的线程"><a href="#查找一直在锁等待的线程" class="headerlink" title="查找一直在锁等待的线程"></a>查找一直在锁等待的线程</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select trx_mysql_thread_id from information_schema.innodb_trx it </span><br><span class="line">JOIN information_schema.INNODB_LOCK_WAITS ilw </span><br><span class="line">on ilw.blocking_trx_id = it.trx_id;</span><br><span class="line"></span><br><span class="line">kill tid;</span><br></pre></td></tr></table></figure>
<h2 id="开启慢查询日志"><a href="#开启慢查询日志" class="headerlink" title="开启慢查询日志"></a>开启慢查询日志</h2><p>参考：<a href="https://www.cnblogs.com/saneri/p/6656161.html" title="标题">https://www.cnblogs.com/saneri/p/6656161.html</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">slow_query_log 慢查询开启状态，ON开启，OFF关闭</span><br><span class="line">slow_query_log_file 慢查询日志存放的位置（这个目录需要MySQL的运行帐号的可写权限，一般设置为MySQL的数据存放目录）</span><br><span class="line">long_query_time 查询超过多少秒才记录</span><br><span class="line">log_queries_not_using_indexes：未使用索引的查询也被记录到慢查询日志中（可选项）</span><br><span class="line">log_output：日志存储方式。log_output=&#x27;FILE&#x27;表示将日志存入文件，默认值是&#x27;FILE&#x27;。log_output=&#x27;TABLE&#x27;表示将日志存入数据库，这样日志信息就会被写入到mysql.slow_log表中。MySQL数据&lt;br&gt;库支持同时两种日志存储方式，配置的时候以逗号隔开即可，如：log_output=&#x27;FILE,TABLE&#x27;。日志记录到系统的专用日志表中，要比记录到文件耗费更多的系统资源，因此对于需要启用慢查询日志，又需&lt;br&gt;要能够获得更高的系统性能，那么建议优先记录到文件。</span><br></pre></td></tr></table></figure>
<h4 id="生产环境的慢查询日志分析命令mysqldumpslow"><a href="#生产环境的慢查询日志分析命令mysqldumpslow" class="headerlink" title="生产环境的慢查询日志分析命令mysqldumpslow"></a>生产环境的慢查询日志分析命令mysqldumpslow</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">比如:</span><br><span class="line">得到返回记录集最多的10个SQL。</span><br><span class="line">mysqldumpslow -s r -t 10 /database/mysql/mysql06_slow.log</span><br><span class="line"> </span><br><span class="line">得到访问次数最多的10个SQL</span><br><span class="line">mysqldumpslow -s c -t 10 /database/mysql/mysql06_slow.log</span><br><span class="line"> </span><br><span class="line">得到按照时间排序的前10条里面含有左连接的查询语句。</span><br><span class="line">mysqldumpslow -s t -t 10 -g “left join” /database/mysql/mysql06_slow.log</span><br><span class="line"> </span><br><span class="line">另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现刷屏的情况。</span><br><span class="line">mysqldumpslow -s r -t 20 /mysqldata/mysql/mysql06-slow.log | more</span><br></pre></td></tr></table></figure>

<h2 id="各种时间的查询"><a href="#各种时间的查询" class="headerlink" title="各种时间的查询"></a>各种时间的查询</h2><p>[参考]<a href="https://www.cnblogs.com/lykbk/p/sdsdssdsqwewewew.html">https://www.cnblogs.com/lykbk/p/sdsdssdsqwewewew.html</a>( “”)</p>
<h1 id="Problem-Solution"><a href="#Problem-Solution" class="headerlink" title="Problem Solution"></a>Problem Solution</h1><h2 id="Access-denied-for-user-‘root‘-’localhost’-using-password-YES"><a href="#Access-denied-for-user-‘root‘-’localhost’-using-password-YES" class="headerlink" title="Access denied for user ‘root‘@’localhost’ (using password: YES)"></a>Access denied for user ‘root‘@’localhost’ (using password: YES)</h2><ul>
<li>Open &amp; Edit &#x2F;etc&#x2F;my.cnf or &#x2F;etc&#x2F;mysql&#x2F;my.cnf, depending on your distro.</li>
<li>Add skip-grant-tables under [mysqld]</li>
<li>Restart Mysql</li>
<li>You should be able to login to mysql now using the below command mysql -u root -p</li>
<li>Run mysql&gt; flush privileges;</li>
<li>Set new password by ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘NewPassword’;</li>
<li>Go back to &#x2F;etc&#x2F;my.cnf and remove&#x2F;comment skip-grant-tables</li>
<li>Restart Mysql</li>
<li>Now you will be able to login with the new password mysql -u root -p</li>
</ul>
<h2 id="You-can’t-specify-target-table-‘label’-for-update-in-FROM-clause"><a href="#You-can’t-specify-target-table-‘label’-for-update-in-FROM-clause" class="headerlink" title="You can’t specify target table ‘label’ for update in FROM clause"></a>You can’t specify target table ‘label’ for update in FROM clause</h2><p>在MySQL中，写SQL语句的时候 ，可能会遇到You can’t specify target table ‘表名’ for update in FROM clause这样的错误，它的意思是说，不能先select出同一表中的某些值，再update这个表(在同一语句中)，即不能依据某字段值做判断再来更新某字段的值。<br>————————————————<br>版权声明：本文为CSDN博主「静远小和尚」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/qq_29672495/article/details/72668008">https://blog.csdn.net/qq_29672495/article/details/72668008</a> </p>
<p>比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update label</span><br><span class="line">set count=(select sum(count)</span><br><span class="line">           from label l</span><br><span class="line">           where (l.label_code = &#x27;Z3&#x27; and l.name = &#x27;科普与知识&#x27;)</span><br><span class="line">              or (l.label_code = &#x27;Z5&#x27; and l.name = &#x27;科技&#x27;))</span><br><span class="line">where id = &#x27;4028e5f47695023c0176950e54561000&#x27;;</span><br></pre></td></tr></table></figure>
<p>可以改成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">update label</span><br><span class="line">set count=(select sum(count)</span><br><span class="line">           from (select count</span><br><span class="line">                 from label l</span><br><span class="line">                 where (l.label_code = &#x27;Z3&#x27; and l.name = &#x27;科普与知识&#x27;)</span><br><span class="line">                    or (l.label_code = &#x27;Z5&#x27; and l.name = &#x27;科技&#x27;)) tmp)</span><br><span class="line">where id = &#x27;4028e5f47695023c0176950e54561000&#x27;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>业界内各种权威、标准、协议</title>
    <url>/2019/12/05/%E4%B8%9A%E7%95%8C%E5%86%85%E5%90%84%E7%A7%8D%E6%9D%83%E5%A8%81%E6%A0%87%E5%87%86/</url>
    <content><![CDATA[<h1 id="ISO-8601"><a href="#ISO-8601" class="headerlink" title="ISO 8601"></a>ISO 8601</h1><p>国际标准化组织的时间和日期的表达方法。</p>
<h1 id="IEEE-754"><a href="#IEEE-754" class="headerlink" title="IEEE 754"></a>IEEE 754</h1><p>对于浮点数的运算，非精确的结果必须优先选择最低有效位为零的，也就是最接近数舍入模式。</p>
<h1 id="cron-expressions"><a href="#cron-expressions" class="headerlink" title="cron expressions"></a>cron expressions</h1><p><a href="http://www.quartz-scheduler.org/documentation/quartz-2.x/tutorials/crontrigger.html" title="cron expressions教程参考">cron expressions教程参考</a></p>
<h1 id="GA-x2F-PRE-x2F-SNAPSHOT等各种版本含义"><a href="#GA-x2F-PRE-x2F-SNAPSHOT等各种版本含义" class="headerlink" title="GA&#x2F;PRE&#x2F;SNAPSHOT等各种版本含义"></a>GA&#x2F;PRE&#x2F;SNAPSHOT等各种版本含义</h1><ul>
<li>GA General Availability,正式发布的版本，官方推荐使用该版本，国外很多项目都是使用GA来表示正式发布版本的</li>
<li>PRE 预览版，主要是用来内部开发人员和测试人员测试使用，因此不建议使用</li>
<li>SNAPSHOT 快照版，可以稳定使用，且该版本会一直进行小量的优化和改进</li>
<li>RC (Release Candidate)：候选版本，几乎就是正式版了</li>
<li>R (RELEASE) 正式版，等价于GA</li>
<li>Alpha 内测版，BUG多，开发人员开发过程中使用，希腊字母α，第一，指最初版</li>
<li>Beta 早期版本，有缺陷，无大BUG，可能加入新功能，进一步开发完善</li>
<li>Gamma 经beta 版，完善修改，成为正式发布的候选版本（Release Candidate）</li>
<li>Build 修正版</li>
<li>Corporation或Enterprise：企业版</li>
<li>Delux：豪华版</li>
<li>DEMO：演示版，有功能限制</li>
<li>Free：免费版</li>
<li>Full：完全版</li>
<li>Final：正式版</li>
<li>Pro(professional)：专业版</li>
<li>Plus：加强版</li>
<li>Retail：零售版</li>
<li>Shareware：共享版，虽然不会要求注册但是一般也有功能限制</li>
<li>SR：修正版</li>
<li>Trial：试用版（一般有时间或者功能限制）</li>
<li>M Milestone build probably not feature complete; should be vaguely stable (i.e. it’s more than just a nightly snapshot) but may still have problems.</li>
<li>LTS（Long Term Support）：长期演进版，Ubuntu会对这一版本的支持时间更长。目前Java也在运用这种方式</li>
</ul>
<h1 id="计算机内存存储数据原理"><a href="#计算机内存存储数据原理" class="headerlink" title="计算机内存存储数据原理"></a>计算机内存存储数据原理</h1><p><a href="https://www.iteye.com/blog/wwty-401713">https://www.iteye.com/blog/wwty-401713</a></p>
<h1 id="服务级别协议（Service-Level-Agreement-x2F-SLA）"><a href="#服务级别协议（Service-Level-Agreement-x2F-SLA）" class="headerlink" title="服务级别协议（Service Level Agreement&#x2F;SLA）"></a>服务级别协议（Service Level Agreement&#x2F;SLA）</h1><h1 id="C-x2F-S与B-x2F-S的区别"><a href="#C-x2F-S与B-x2F-S的区别" class="headerlink" title="C&#x2F;S与B&#x2F;S的区别"></a>C&#x2F;S与B&#x2F;S的区别</h1><blockquote>
<p><a href="https://blog.csdn.net/koudaidai/article/details/7395200">https://blog.csdn.net/koudaidai/article/details/7395200</a></p>
</blockquote>
<p>Client&#x2F;Server是建立在局域网的基础上的，Browser&#x2F;Server是建立在广域网的基础上的。 </p>
<ul>
<li>C&#x2F;S 一般建立在专用的网络上，小范围里的网络环境，局域网之间再通过专门服务器提供连接和数据交换服务。</li>
<li>B&#x2F;S 建立在广域网之上的，不必是专门的网络硬件环境，例如电话上网，租用设备，信息自己管理，有比C&#x2F;S更强的适应范围，一般只要有操作系统和浏览器就行。</li>
</ul>
<h1 id="OSS（Operation-Support-Systems）"><a href="#OSS（Operation-Support-Systems）" class="headerlink" title="OSS（Operation Support Systems）"></a>OSS（Operation Support Systems）</h1><p>运营支撑系统，是电信业务开展和运营时所必需的支撑平台。OSS是电信运营商的一体化、信息资源共享的支持系统，它主要由网络管理、系统管理、计费、营业、账务和客户服务等部分组成，系统间通过统一的信息总线有机整合在一起。</p>
<h1 id="SaaS"><a href="#SaaS" class="headerlink" title="SaaS"></a>SaaS</h1><p>买软件和买服务有着本质区别：<br><a href="https://zhuanlan.zhihu.com/p/27101211">知乎这篇文章讲得很不错</a></p>
<h1 id="SEO（Search-Engine-Optimization）"><a href="#SEO（Search-Engine-Optimization）" class="headerlink" title="SEO（Search Engine Optimization）"></a>SEO（Search Engine Optimization）</h1><p>汉译为搜索引擎优化。是一种方式：利用搜索引擎的规则提高网站在有关搜索引擎内的自然排名。目的是让其在行业内占据领先地位，获得品牌收益。</p>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="JEP-JDK-Enhancement-Proposals-JDK增强提案"><a href="#JEP-JDK-Enhancement-Proposals-JDK增强提案" class="headerlink" title="JEP(JDK Enhancement Proposals)(JDK增强提案)"></a>JEP(JDK Enhancement Proposals)(JDK增强提案)</h2><p><a href="http://openjdk.java.net/jeps/0">http://openjdk.java.net/jeps/0</a></p>
<h2 id="J9"><a href="#J9" class="headerlink" title="J9"></a>J9</h2><h1 id="B-x2F-S结构"><a href="#B-x2F-S结构" class="headerlink" title="B&#x2F;S结构"></a>B&#x2F;S结构</h1><p>B&#x2F;S结构（Browser&#x2F;Server，浏览器&#x2F;服务器模式）。</p>
<h1 id="C-x2F-S结构"><a href="#C-x2F-S结构" class="headerlink" title="C&#x2F;S结构"></a>C&#x2F;S结构</h1><p>C是英文单词“Client”的首字母，即客户端的意思，C&#x2F;S就是“Client&#x2F;Server”的缩写，即“客户端&#x2F;服务器”模式。</p>
<h1 id="面向对象3个基本特征"><a href="#面向对象3个基本特征" class="headerlink" title="面向对象3个基本特征"></a>面向对象3个基本特征</h1><p>继承、封装和多态</p>
<h1 id="每秒查询率（QPS-x2F-Queries-Per-Second）"><a href="#每秒查询率（QPS-x2F-Queries-Per-Second）" class="headerlink" title="每秒查询率（QPS&#x2F;Queries-Per-Second）"></a>每秒查询率（QPS&#x2F;Queries-Per-Second）</h1><p>对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。</p>
<h1 id="每秒事务数字（TPS-x2F-Transactions-Per-Second）"><a href="#每秒事务数字（TPS-x2F-Transactions-Per-Second）" class="headerlink" title="每秒事务数字（TPS&#x2F;Transactions-Per-Second）"></a>每秒事务数字（TPS&#x2F;Transactions-Per-Second）</h1><p>事务数&#x2F;秒。它是软件测试结果的测量单位。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。</p>
<h1 id="响应时间-Response-time-x2F-RT"><a href="#响应时间-Response-time-x2F-RT" class="headerlink" title="响应时间(Response-time&#x2F;RT)"></a>响应时间(Response-time&#x2F;RT)</h1><p>执行一个请求从开始到最后收到响应数据所花费的总体时间,即从客户端发起请求到收到服务器响应结果的时间。</p>
<h1 id="摩尔定律（Moore’s-law）"><a href="#摩尔定律（Moore’s-law）" class="headerlink" title="摩尔定律（Moore’s law）"></a>摩尔定律（Moore’s law）</h1><p>集成电路上可容纳的晶体管数目，约每隔两年便会增加一倍；经常被引用的“18个月”，是由英特尔首席执行官大卫·豪斯（David House）提出：预计18个月会将芯片的性能提高一倍（即更多的晶体管使其更快），是一种以倍数增长的观测。</p>
<h1 id="开发运维（DEVOPS）"><a href="#开发运维（DEVOPS）" class="headerlink" title="开发运维（DEVOPS）"></a>开发运维（DEVOPS）</h1><h2 id="灰度发布"><a href="#灰度发布" class="headerlink" title="灰度发布"></a>灰度发布</h2><h2 id="CI-x2F-CD"><a href="#CI-x2F-CD" class="headerlink" title="CI&#x2F;CD"></a>CI&#x2F;CD</h2><ul>
<li>持续集成（CONTINUOUS INTEGRATION）</li>
<li>持续交付（CONTINUOUS DELIVERY）</li>
</ul>
]]></content>
      <categories>
        <category>标准</category>
      </categories>
      <tags>
        <tag>标准</tag>
      </tags>
  </entry>
  <entry>
    <title>logback</title>
    <url>/2019/12/19/Logback/</url>
    <content><![CDATA[<p>logback当前分成三个模块：logback-core,logback-classic和logback-access。logback-core是其它两个模块的基础模块。</p>
<p>logback-classic是log4j的一个 改良版本。此外logback-classic完整实现SLF4J API使你可以很方便地更换成其它日志系统如log4j或JDK14Logging。</p>
<p>logback-access访问模块与Servlet容器集成提供通过Http来访问日志的功能。</p>
]]></content>
      <categories>
        <category>logback</category>
      </categories>
      <tags>
        <tag>logback</tag>
      </tags>
  </entry>
  <entry>
    <title>Reactor响应式编程阅读源码有感</title>
    <url>/2019/12/13/Reactor%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B%E9%98%85%E8%AF%BB%E6%BA%90%E7%A0%81%E6%9C%89%E6%84%9F/</url>
    <content><![CDATA[<p><a href="https://projectreactor.io/docs/core/release/reference/">官方参考文档</a><br><a href="https://www.baeldung.com/reactor-core">baeldung参考文章</a></p>
<h1 id="Flux"><a href="#Flux" class="headerlink" title="Flux"></a>Flux</h1><p>an Asynchronous Sequence of 0-N Items（是一个异步的处理序列，它有0或者多个条目）<br>官方对Flux的原理解析图解：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/2zMdgN.png"></p>
<p>Spring Gateway的源码中重度依赖Reactor Project，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">return responseFlux.then(chain.filter(exchange));</span><br></pre></td></tr></table></figure>
<p>这句代码的逻辑会这么走：要等到responseFlux被subscribe了之后，chain.filter(exchange)（这是一个Mono），才会被继续流转运行。</p>
<h1 id="Mono"><a href="#Mono" class="headerlink" title="Mono"></a>Mono</h1><h2 id="Mono-just"><a href="#Mono-just" class="headerlink" title="Mono.just"></a>Mono.just</h2><p>I mean that calling Mono.just(System.currentTimeMillis()) will immediately invoke the currentTimeMillis() method and capture the result</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mono&lt;Long&gt; clock = Mono.just(System.currentTimeMillis());</span><br><span class="line">//time == t0</span><br><span class="line"></span><br><span class="line">Thread.sleep(10_000);</span><br><span class="line">//time == t10</span><br><span class="line">clock.block(); //we use block for demonstration purposes, returns t0（代表这个时候获取clock的实际时间依然还是上面第一次调用System.currentTimeMillis()拿到的时间，下面雷同）</span><br><span class="line"></span><br><span class="line">Thread.sleep(7_000);</span><br><span class="line">//time == t17</span><br><span class="line">clock.block(); //we re-subscribe to clock, still returns t0</span><br></pre></td></tr></table></figure>
<h2 id="Mono-defer"><a href="#Mono-defer" class="headerlink" title="Mono.defer"></a>Mono.defer</h2><p>The defer operator is there to make this source lazy, re-evaluating the content of the lambda each time there is a new subscriber:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Mono&lt;Long&gt; clock = Mono.defer(() -&gt; Mono.just(System.currentTimeMillis()));</span><br><span class="line">//time == t0</span><br><span class="line"></span><br><span class="line">Thread.sleep(10_000);</span><br><span class="line">//time == t10</span><br><span class="line">clock.block(); //invoked currentTimeMillis() here and returns t10（这里标识获取到的时间是线程等待了10秒之后的时间，表明defer()这个方法会延时参数里面声明的lambda表达式，在需要的时候再去实际调用计算结果，下面雷同）</span><br><span class="line"></span><br><span class="line">Thread.sleep(7_000);</span><br><span class="line">//time == t17</span><br><span class="line">clock.block(); //invoke currentTimeMillis() once again here and returns t17</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>Reactor</category>
      </categories>
      <tags>
        <tag>Reactor</tag>
      </tags>
  </entry>
  <entry>
    <title>arthas汇总</title>
    <url>/2020/01/07/arthas%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>arthas</category>
      </categories>
      <tags>
        <tag>arthas</tag>
      </tags>
  </entry>
  <entry>
    <title>JWT</title>
    <url>/2020/01/02/JWT/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>JWT</category>
      </categories>
      <tags>
        <tag>JWT</tag>
      </tags>
  </entry>
  <entry>
    <title>Math</title>
    <url>/2020/01/07/Math/</url>
    <content><![CDATA[<h1 id="分解质因数（质因式分解）"><a href="#分解质因数（质因式分解）" class="headerlink" title="分解质因数（质因式分解）"></a>分解质因数（质因式分解）</h1><p><a href="https://baike.baidu.com/item/%E5%88%86%E8%A7%A3%E8%B4%A8%E5%9B%A0%E6%95%B0/2253749?fromtitle=%E8%B4%A8%E5%9B%A0%E6%95%B0%E5%88%86%E8%A7%A3&fromid=10305400&fr=aladdin">参考</a></p>
]]></content>
      <categories>
        <category>Math</category>
      </categories>
      <tags>
        <tag>Math</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker汇总</title>
    <url>/2020/01/17/Docker%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<p><a href="http://www.ruanyifeng.com/blog/2018/02/docker-tutorial.html">参考1</a><br><a href="https://www.jianshu.com/p/ca1623ac7723">参考2</a></p>
<h1 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h1><p><a href="https://www.runoob.com/docker/docker-command-manual.html">命令大全</a></p>
<h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><h3 id="列出所有容器"><a href="#列出所有容器" class="headerlink" title="列出所有容器"></a>列出所有容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker container ls</span><br></pre></td></tr></table></figure>
<h3 id="查看所有容器，包括关闭的"><a href="#查看所有容器，包括关闭的" class="headerlink" title="查看所有容器，包括关闭的"></a>查看所有容器，包括关闭的</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker container ls --all</span><br><span class="line">docker ps -a</span><br></pre></td></tr></table></figure>
<h3 id="删除具体的容器，根据container-id"><a href="#删除具体的容器，根据container-id" class="headerlink" title="删除具体的容器，根据container id"></a>删除具体的容器，根据container id</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker container rm c8faeffaaa62</span><br></pre></td></tr></table></figure>
<h3 id="查看容器IP"><a href="#查看容器IP" class="headerlink" title="查看容器IP"></a>查看容器IP</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect 容器ID | grep IPAddress</span><br></pre></td></tr></table></figure>
<h3 id="启动某个容器"><a href="#启动某个容器" class="headerlink" title="启动某个容器"></a>启动某个容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker restart 1b4671904bfa</span><br></pre></td></tr></table></figure>
<h3 id="查看容器内存使用情况（支持多个同时查）"><a href="#查看容器内存使用情况（支持多个同时查）" class="headerlink" title="查看容器内存使用情况（支持多个同时查）"></a>查看容器内存使用情况（支持多个同时查）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker stats containerName1 containerName2</span><br></pre></td></tr></table></figure>
<h3 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker logs -f 122482b4b37f</span><br></pre></td></tr></table></figure>
<h3 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker exec -it containerName bash</span><br><span class="line">sudo docker attach 44fc0f0582d9</span><br></pre></td></tr></table></figure>
<h3 id="docker限制容器的内存使用"><a href="#docker限制容器的内存使用" class="headerlink" title="docker限制容器的内存使用"></a>docker限制容器的内存使用</h3><p><a href="https://blog.csdn.net/qq_37611270/article/details/97243704">https://blog.csdn.net/qq_37611270&#x2F;article&#x2F;details&#x2F;97243704</a></p>
<h2 id="状态信息"><a href="#状态信息" class="headerlink" title="状态信息"></a>状态信息</h2><h2 id="列出docker-name"><a href="#列出docker-name" class="headerlink" title="列出docker name"></a>列出docker name</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker inspect -f=&#x27;&#123;&#123;.Name&#125;&#125;&#x27; $(sudo docker ps -a -q)</span><br></pre></td></tr></table></figure>
<h3 id="列出docker-ip"><a href="#列出docker-ip" class="headerlink" title="列出docker ip"></a>列出docker ip</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker inspect -f=&#x27;&#123;&#123;.NetworkSettings.IPAddress&#125;&#125;&#x27; $(sudo docker ps -a -q)</span><br></pre></td></tr></table></figure>
<h3 id="列出所有容器对应的名称，端口，及ip"><a href="#列出所有容器对应的名称，端口，及ip" class="headerlink" title="列出所有容器对应的名称，端口，及ip"></a>列出所有容器对应的名称，端口，及ip</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect -f=&#x27;&#123;&#123;.Name&#125;&#125; &#123;&#123;.NetworkSettings.IPAddress&#125;&#125; &#123;&#123;.HostConfig.PortBindings&#125;&#125;&#x27; $(docker ps -aq)</span><br></pre></td></tr></table></figure>
<h3 id="查看状态"><a href="#查看状态" class="headerlink" title="查看状态"></a>查看状态</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl status docker</span><br></pre></td></tr></table></figure>
<h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker inspect 容器id</span><br><span class="line"># 可以查看容器信息  “HostConfig下的Binds 可以看到数据卷绑定  Mounts下Souce和Destination也可以看到数据卷绑定信息”</span><br></pre></td></tr></table></figure>
<h2 id="清理数据"><a href="#清理数据" class="headerlink" title="清理数据"></a>清理数据</h2><p>自动清理空间</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker system prune</span><br></pre></td></tr></table></figure>
<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><p><a href="https://www.cnblogs.com/sablier/p/11605606.html">参考</a><br>目录映射时，容器里面的目录会在容器启动的时候自动创建。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker run -p 3306:3306 --name mysql \</span><br><span class="line">-v /usr/local/docker/mysql/conf:/etc/mysql \</span><br><span class="line">-v /usr/local/docker/mysql/logs:/var/log/mysql \</span><br><span class="line">-v /usr/local/docker/mysql/data:/var/lib/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=raubbhWy \</span><br><span class="line">-d mysql:5.7</span><br></pre></td></tr></table></figure>

<p>进入docker本地连接mysql客户端</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo docker exec -it mysql bash</span><br><span class="line">mysql -uroot -p123456</span><br></pre></td></tr></table></figure>

<h1 id="Fastdfs"><a href="#Fastdfs" class="headerlink" title="Fastdfs"></a>Fastdfs</h1><p><a href="https://hub.docker.com/r/season/fastdfs">season&#x2F;fastdfs</a><br><a href="http://www.zuidaima.com/blog/4653383732808704.htm">参考1</a><br><a href="https://blog.502.li/archives/docker-deploy-fastdfs.html">参考2</a><br><a href="https://v3u.cn/a_id_78">参考3</a></p>
<h1 id="redis"><a href="#redis" class="headerlink" title="redis"></a>redis</h1><p><a href="https://www.runoob.com/docker/docker-install-redis.html">https://www.runoob.com/docker/docker-install-redis.html</a></p>
<h1 id="rabbitmq"><a href="#rabbitmq" class="headerlink" title="rabbitmq"></a>rabbitmq</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker pull rabbitmq:management</span><br><span class="line">docker run -d --hostname my-rabbit --name some-rabbit -p 15555:15672 rabbitmq:management</span><br></pre></td></tr></table></figure>
<p>默认账号密码：guest和guest</p>
<h1 id="docker跑SpringCloud微服务"><a href="#docker跑SpringCloud微服务" class="headerlink" title="docker跑SpringCloud微服务"></a>docker跑SpringCloud微服务</h1><h1 id="dockerfile-maven"><a href="#dockerfile-maven" class="headerlink" title="dockerfile-maven"></a>dockerfile-maven</h1><h1 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h1><p>在Docker中创建镜像最常用的方式，就是使用Dockerfile。Dockerfile是一个Docker镜像的描述文件，我们可以理解成火箭发射的A、B、C、D…的步骤。Dockerfile其内部包含了一条条的指令，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。<br><a href="https://www.runoob.com/docker/docker-dockerfile.html">Dockerfile基础知识</a><br><a href="https://www.cnblogs.com/lingfengblogs/p/11093246.html">Dockerfile命令大全</a></p>
<h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h3><p><a href="https://blog.csdn.net/qq_17639365/article/details/86655177">https://blog.csdn.net/qq_17639365&#x2F;article&#x2F;details&#x2F;86655177</a></p>
<h3 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h3><p><a href="https://www.cnblogs.com/ExMan/p/12017896.html">https://www.cnblogs.com/ExMan/p/12017896.html</a></p>
<ul>
<li>通过docker run命令的-v标识创建的挂载点只能对创建的容器有效。</li>
<li>通过dockerfile的 VOLUME 指令可以在镜像中创建挂载点，这样只要通过该镜像创建的容器都有了挂载点。</li>
<li>还有一个区别是，通过 VOLUME 指令创建的挂载点，无法指定主机上对应的目录，是自动生成的。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#test</span><br><span class="line">FROM ubuntu</span><br><span class="line">MAINTAINER hello1</span><br><span class="line">VOLUME [&quot;/data1&quot;,&quot;/data2&quot;]</span><br></pre></td></tr></table></figure>
上面的dockfile文件通过VOLUME指令指定了两个挂载点 &#x2F;data1 和 &#x2F;data2.</li>
</ul>
<p>我们通过docker inspect 查看通过该dockerfile创建的镜像生成的容器，可以看到如下信息</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;Mounts&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Name&quot;: &quot;d411f6b8f17f4418629d4e5a1ab69679dee369b39e13bb68bed77aa4a0d12d21&quot;,</span><br><span class="line">            &quot;Source&quot;: &quot;/var/lib/docker/volumes/d411f6b8f17f4418629d4e5a1ab69679dee369b39e13bb68bed77aa4a0d12d21/_data&quot;,</span><br><span class="line">            &quot;Destination&quot;: &quot;/data1&quot;,</span><br><span class="line">            &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">            &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;RW&quot;: true</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;Name&quot;: &quot;6d3badcf47c4ac5955deda6f6ae56f4aaf1037a871275f46220c14ebd762fc36&quot;,</span><br><span class="line">            &quot;Source&quot;: &quot;/var/lib/docker/volumes/6d3badcf47c4ac5955deda6f6ae56f4aaf1037a871275f46220c14ebd762fc36/_data&quot;,</span><br><span class="line">            &quot;Destination&quot;: &quot;/data2&quot;,</span><br><span class="line">            &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">            &quot;Mode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;RW&quot;: true</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br></pre></td></tr></table></figure>

<h2 id="apt-get更换国内源解决Dockerfile构建速度过慢"><a href="#apt-get更换国内源解决Dockerfile构建速度过慢" class="headerlink" title="apt-get更换国内源解决Dockerfile构建速度过慢"></a>apt-get更换国内源解决Dockerfile构建速度过慢</h2><p>ubuntu和debian的镜像源都要换</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUN  sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list</span><br><span class="line">RUN  sed -i &#x27;s/deb.debian.org/mirrors.ustc.edu.cn/g&#x27; /etc/apt/sources.list</span><br><span class="line">RUN  apt-get clean</span><br><span class="line">RUN  apt-get update</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FROM ubuntu:20.04</span><br><span class="line">RUN sed -i &#x27;s/ports.ubuntu.com/mirror.tuna.tsinghua.edu.cn/g&#x27; /etc/apt/sources.list</span><br><span class="line">RUN apt-get install vim</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/dakewei/p/12783717.html">https://www.cnblogs.com/dakewei/p/12783717.html</a></p>
<h3 id="163的镜像"><a href="#163的镜像" class="headerlink" title="163的镜像"></a>163的镜像</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#更新apt-get源 使用163的源</span><br><span class="line">RUN mv /etc/apt/sources.list /etc/apt/sources.list.bak &amp;&amp; \</span><br><span class="line">    echo &quot;deb http://mirrors.163.com/debian/ jessie main non-free contrib&quot; &gt;/etc/apt/sources.list &amp;&amp; \</span><br><span class="line">    echo &quot;deb http://mirrors.163.com/debian/ jessie-proposed-updates main non-free contrib&quot; &gt;&gt;/etc/apt/sources.list &amp;&amp; \</span><br><span class="line">    echo &quot;deb-src http://mirrors.163.com/debian/ jessie main non-free contrib&quot; &gt;&gt;/etc/apt/sources.list &amp;&amp; \</span><br><span class="line">    echo &quot;deb-src http://mirrors.163.com/debian/ jessie-proposed-updates main non-free contrib&quot; &gt;&gt;/etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<h1 id="docker-compose"><a href="#docker-compose" class="headerlink" title="docker-compose"></a>docker-compose</h1><p><a href="https://www.jianshu.com/p/90bf0e231e5a">docker-compose.yml文件详解</a><br><a href="https://www.runoob.com/docker/docker-compose.html">基础</a><br><a href="https://www.cnblogs.com/williamjie/p/9103327.html">参考1</a></p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.25.5/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure>
<p>如果从github拉下来安装之后无法执行docker-compose命令的话，可以采用本机电脑下载之后上传到服务器，在chmod修改可执行权限就可以了。</p>
<h2 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h2><h3 id="后台执行"><a href="#后台执行" class="headerlink" title="后台执行"></a>后台执行</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure>

<h2 id="docker-compose中解决depends-on无效问题"><a href="#docker-compose中解决depends-on无效问题" class="headerlink" title="docker-compose中解决depends_on无效问题"></a>docker-compose中解决depends_on无效问题</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RUN apt-get -q update &amp;&amp; apt-get -qy install netcat</span><br><span class="line"># docker-compose.yml 加上下面</span><br><span class="line">command: sh -c &#x27;./wait-for.sh kiwi-microservice-local:5001/actuator/info -- echo kiwi-word-biz already started&#x27;</span><br></pre></td></tr></table></figure>
<p><a href="http://www.zyiz.net/tech/detail-98533.html">http://www.zyiz.net/tech/detail-98533.html</a><br><a href="https://github.com/Eficode/wait-for">https://github.com/Eficode/wait-for</a></p>
<h1 id="Mac上跑docker"><a href="#Mac上跑docker" class="headerlink" title="Mac上跑docker"></a>Mac上跑docker</h1><p><a href="https://www.runoob.com/docker/macos-docker-install.html">https://www.runoob.com/docker/macos-docker-install.html</a></p>
<h1 id="docker-service的配置"><a href="#docker-service的配置" class="headerlink" title="docker.service的配置"></a>docker.service的配置</h1><p><a href="https://www.cnblogs.com/nihaorz/p/12131873.html">https://www.cnblogs.com/nihaorz/p/12131873.html</a></p>
<h1 id="更换国内的镜像"><a href="#更换国内的镜像" class="headerlink" title="更换国内的镜像"></a>更换国内的镜像</h1><p><a href="https://blog.csdn.net/u012081441/article/details/104553145/">https://blog.csdn.net/u012081441/article/details/104553145/</a><br><a href="https://blog.csdn.net/s_lisheng/article/details/79871086">https://blog.csdn.net/s_lisheng&#x2F;article&#x2F;details&#x2F;79871086</a></p>
<h1 id="在docker跑nginx的vue项目"><a href="#在docker跑nginx的vue项目" class="headerlink" title="在docker跑nginx的vue项目"></a>在docker跑nginx的vue项目</h1><p><a href="https://www.jianshu.com/p/422b61100273">https://www.jianshu.com/p/422b61100273</a></p>
<h2 id="nginx80端口被占用修改"><a href="#nginx80端口被占用修改" class="headerlink" title="nginx80端口被占用修改"></a>nginx80端口被占用修改</h2><p><a href="https://jingyan.baidu.com/article/3aed632efb150a701080912f.html">https://jingyan.baidu.com/article/3aed632efb150a701080912f.html</a></p>
<h2 id="验证nginx配置"><a href="#验证nginx配置" class="headerlink" title="验证nginx配置"></a>验证nginx配置</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./sbin/nginx -t</span><br></pre></td></tr></table></figure>
<h2 id="各种配置"><a href="#各种配置" class="headerlink" title="各种配置"></a>各种配置</h2><p><a href="https://www.jqhtml.com/34815.html">https://www.jqhtml.com/34815.html</a></p>
<h1 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker network ls</span><br><span class="line">docker network inspect bridge</span><br></pre></td></tr></table></figure>
<p><a href="https://www.cnblogs.com/chenpython123/p/10823879.html">https://www.cnblogs.com/chenpython123/p/10823879.html</a></p>
<h1 id="Docker根据名称查询容器ID镜像ID并停止删除"><a href="#Docker根据名称查询容器ID镜像ID并停止删除" class="headerlink" title="Docker根据名称查询容器ID镜像ID并停止删除"></a>Docker根据名称查询容器ID镜像ID并停止删除</h1><p><a href="https://blog.csdn.net/zimou5581/article/details/94012682">https://blog.csdn.net/zimou5581/article/details/94012682</a></p>
<h1 id="Problem-Solution"><a href="#Problem-Solution" class="headerlink" title="Problem Solution"></a>Problem Solution</h1><h2 id="bash-vi-command-not-found"><a href="#bash-vi-command-not-found" class="headerlink" title="bash: vi: command not found"></a>bash: vi: command not found</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it &lt;container&gt; bash</span><br><span class="line">apt-get update</span><br><span class="line">apt-get install vim</span><br></pre></td></tr></table></figure>

<h2 id="Error-response-from-daemon-Get-https-registry-1-docker-io-v2-net-x2F-http-TLS-handshake-timeout"><a href="#Error-response-from-daemon-Get-https-registry-1-docker-io-v2-net-x2F-http-TLS-handshake-timeout" class="headerlink" title="Error response from daemon: Get https://registry-1.docker.io/v2/: net&#x2F;http: TLS handshake timeout"></a>Error response from daemon: Get <a href="https://registry-1.docker.io/v2/">https://registry-1.docker.io/v2/</a>: net&#x2F;http: TLS handshake timeout</h2><p><a href="https://blog.csdn.net/BigData_Mining/article/details/87869147">网上的解决方案</a></p>
<h2 id="Current-command-vanished-from-the-unit-file-execution-of-the-command-list-won’t-be-resumed"><a href="#Current-command-vanished-from-the-unit-file-execution-of-the-command-list-won’t-be-resumed" class="headerlink" title="Current command vanished from the unit file, execution of the command list won’t be resumed."></a>Current command vanished from the unit file, execution of the command list won’t be resumed.</h2><p>可能是有docker的相关进程没有杀干净。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -ef|grep docker</span><br><span class="line">kill -9 pid</span><br></pre></td></tr></table></figure>

<h2 id="远程2375连接不上"><a href="#远程2375连接不上" class="headerlink" title="远程2375连接不上"></a>远程2375连接不上</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vi /usr/lib/systemd/system/docker.service</span><br></pre></td></tr></table></figure>
<p>vim进入命令行模式输入?ExecStart，找到如下一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd -H unix://var/run/docker.sock \</span><br></pre></td></tr></table></figure>
<p>在后面加上-H tcp:&#x2F;&#x2F;0.0.0.0:2375</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ExecStart=/usr/bin/dockerd -H fd:// --containerd=/run/containerd/containerd.sock -H tcp://0.0.0.0:2375</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">service docker restart</span><br></pre></td></tr></table></figure>
<p>之后要注意重启之前的容器。</p>
<h2 id="ERROR-Version-in-“-x2F-docker-compose-yml”-is-invalid-You-might-be-seeing-this-error-because-you’re-using-the-wrong-Compose-file-version-Either-specify-a-supported-version-e-g-“2-2”-or-“3-3”"><a href="#ERROR-Version-in-“-x2F-docker-compose-yml”-is-invalid-You-might-be-seeing-this-error-because-you’re-using-the-wrong-Compose-file-version-Either-specify-a-supported-version-e-g-“2-2”-or-“3-3”" class="headerlink" title="ERROR: Version in “.&#x2F;docker-compose.yml” is invalid. You might be seeing this error because you’re using the wrong Compose file version. Either specify a supported version (e.g “2.2” or “3.3”)"></a>ERROR: Version in “.&#x2F;docker-compose.yml” is invalid. You might be seeing this error because you’re using the wrong Compose file version. Either specify a supported version (e.g “2.2” or “3.3”)</h2><p>把docker-compose.yml里面的version改一下，改成2.2或3.3（根据提示改）</p>
<h2 id="docker-启动-nginx-访问不了的问题"><a href="#docker-启动-nginx-访问不了的问题" class="headerlink" title="docker 启动 nginx 访问不了的问题"></a>docker 启动 nginx 访问不了的问题</h2><p>如果容器的nginx服务没有启动</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#  进入容器</span><br><span class="line">/usr/sbin/nginx</span><br><span class="line"># 看下报什么错</span><br></pre></td></tr></table></figure>
<h2 id="vue-config-js设置代理之后，nginx反向代理-404"><a href="#vue-config-js设置代理之后，nginx反向代理-404" class="headerlink" title="vue.config.js设置代理之后，nginx反向代理 404"></a>vue.config.js设置代理之后，nginx反向代理 404</h2><p><a href="https://zhuanlan.zhihu.com/p/60833019">https://zhuanlan.zhihu.com/p/60833019</a><br>&#x2F;etc&#x2F;nginx&#x2F;conf.d&#x2F;default.conf</p>
<p>nginx关键配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">root /usr/share/nginx/html;</span><br><span class="line">index index.html index.htm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /auth &#123;</span><br><span class="line">	proxy_pass http://kiwi-microservice:9991;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /wordBiz &#123;</span><br><span class="line">    proxy_pass http://kiwi-microservice:9991;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">location /code &#123;</span><br><span class="line">    proxy_pass http://kiwi-microservice:9991;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Published-ports-are-discarded-when-using-host-network-mode"><a href="#Published-ports-are-discarded-when-using-host-network-mode" class="headerlink" title="Published ports are discarded when using host network mode"></a>Published ports are discarded when using host network mode</h2><p>host的网络模式不能-p映射端口</p>
<h2 id="OCI-runtime-exec-failed-exec-failed-container-linux-go-349-starting-container-process-caused-“exec-quot-bash-quot-executable-file-not-found-in-PATH”-unknown"><a href="#OCI-runtime-exec-failed-exec-failed-container-linux-go-349-starting-container-process-caused-“exec-quot-bash-quot-executable-file-not-found-in-PATH”-unknown" class="headerlink" title="OCI runtime exec failed: exec failed: container_linux.go:349: starting container process caused “exec: &quot;bash&quot;: executable file not found in $PATH”: unknown"></a>OCI runtime exec failed: exec failed: container_linux.go:349: starting container process caused “exec: &quot;bash&quot;: executable file not found in $PATH”: unknown</h2><p>三种模式选择一种试试：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it 1e33b26152e1 /bin/sh</span><br><span class="line">docker exec -it 1e33b26152e1 bash</span><br><span class="line">docker exec -it 1e33b26152e1 sh</span><br></pre></td></tr></table></figure>

<h2 id="mkdir-can’t-create-directory-‘-x2F-tmp’-File-exists"><a href="#mkdir-can’t-create-directory-‘-x2F-tmp’-File-exists" class="headerlink" title="mkdir: can’t create directory ‘&#x2F;tmp’: File exists"></a>mkdir: can’t create directory ‘&#x2F;tmp’: File exists</h2><p>Dockerfile里面RUN命令创建文件夹的时候注意不要和系统同路径，不然会报错。</p>
<h2 id="openjdk-8-jdk-alpine进入容器"><a href="#openjdk-8-jdk-alpine进入容器" class="headerlink" title="openjdk:8-jdk-alpine进入容器"></a>openjdk:8-jdk-alpine进入容器</h2><p>用传统的<code>docker exec -it ? bash</code>进不去要改成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker exec -it ? /bin/sh</span><br></pre></td></tr></table></figure>
<p><a href="https://stackoverflow.com/questions/40944479/how-to-use-bash-with-an-alpine-based-docker-image/40944512">https://stackoverflow.com/questions/40944479/how-to-use-bash-with-an-alpine-based-docker-image/40944512</a><br>查看其java_home：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">docker-java-home</span><br></pre></td></tr></table></figure>

<h2 id="启动容易报错"><a href="#启动容易报错" class="headerlink" title="启动容易报错"></a>启动容易报错</h2><p>可以通过查看docker状态，看看报错的log：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl status docker -l</span><br></pre></td></tr></table></figure>

<h2 id="jmap等命令在openjdk-8-jdk-alpine不灵"><a href="#jmap等命令在openjdk-8-jdk-alpine不灵" class="headerlink" title="jmap等命令在openjdk:8-jdk-alpine不灵"></a>jmap等命令在openjdk:8-jdk-alpine不灵</h2><h2 id="容器修改了配置启动不来的处理方法"><a href="#容器修改了配置启动不来的处理方法" class="headerlink" title="容器修改了配置启动不来的处理方法"></a>容器修改了配置启动不来的处理方法</h2><p>可以通过<code>docker inspect xxxid</code>查看<code>GraphDriver</code>的容器依赖物理文件目录，进去找到修改过的配置文件改回来</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>jenkins汇总</title>
    <url>/2020/02/18/jenkins%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h1><h2 id="密码保存地方"><a href="#密码保存地方" class="headerlink" title="密码保存地方"></a>密码保存地方</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">This may also be found at: /var/jenkins_home/secrets/initialAdminPassword</span><br></pre></td></tr></table></figure>

<h2 id="插件安装加速"><a href="#插件安装加速" class="headerlink" title="插件安装加速"></a>插件安装加速</h2><h3 id="修改update-center-json地址"><a href="#修改update-center-json地址" class="headerlink" title="修改update-center.json地址"></a>修改update-center.json地址</h3><p>在&#x2F;home&#x2F;jenkins目录找到文件 hudson.model.UpdateCenter.xml（如果没找到就搜索一下文件名）</p>
<p>将原来的<br><code>https://updates.jenkins.io/update-center.json</code><br>改成<br><code>http://mirror.xmission.com/jenkins/updates/update-center.json</code></p>
<p>重启jenkins</p>
<p><a href="http://ip:9090/restart">http://ip:9090/restart</a></p>
<h3 id="修改default-json"><a href="#修改default-json" class="headerlink" title="修改default.json"></a>修改default.json</h3><p>在jenkins安装目录的updates&#x2F;下，先按英文冒号进入命令行模式输入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1,$s/http:\/\/updates.jenkins-ci.org\/download/https:\/\/mirrors.tuna.tsinghua.edu.cn\/jenkins/g</span><br></pre></td></tr></table></figure>
<p>回车之后再次进入命令行模式输入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1,$s/http:\/\/www.google.com/https:\/\/www.baidu.com/g</span><br></pre></td></tr></table></figure>
<p>再回车，保存重启即可。</p>
<p><a href="https://www.cnblogs.com/yoyoketang/p/12115569.html">https://www.cnblogs.com/yoyoketang/p/12115569.html</a></p>
<h2 id="从界面安装插件"><a href="#从界面安装插件" class="headerlink" title="从界面安装插件"></a>从界面安装插件</h2><p><a href="https://www.jianshu.com/p/3b5ebe85c034">https://www.jianshu.com/p/3b5ebe85c034</a></p>
<h2 id="重启Jenkies"><a href="#重启Jenkies" class="headerlink" title="重启Jenkies"></a>重启Jenkies</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/restart</span><br></pre></td></tr></table></figure>

<h2 id="重新加载配置信息"><a href="#重新加载配置信息" class="headerlink" title="重新加载配置信息"></a>重新加载配置信息</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/reload</span><br></pre></td></tr></table></figure>
<h2 id="关闭Jenkins"><a href="#关闭Jenkins" class="headerlink" title="关闭Jenkins"></a>关闭Jenkins</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">http://localhost:8080/exit</span><br></pre></td></tr></table></figure>

<h1 id="jenkins自动部署SpringCloud微服务"><a href="#jenkins自动部署SpringCloud微服务" class="headerlink" title="jenkins自动部署SpringCloud微服务"></a>jenkins自动部署SpringCloud微服务</h1><p><a href="https://blog.csdn.net/sunhuansheng/article/details/100719021">https://blog.csdn.net/sunhuansheng/article/details/100719021</a><br>-更改插件加速<br>-安装maven intergration plugin</p>
]]></content>
      <categories>
        <category>jenkins</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaScript</title>
    <url>/2020/03/29/JavaScript/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h2 id="判断true和false"><a href="#判断true和false" class="headerlink" title="判断true和false"></a>判断true和false</h2><ul>
<li>如果逻辑对象无初始值或者其值为 0、-0、null、””、false、undefined 或者 NaN，那么对象的值为 false。否则，其值为 true（即使当自变量为字符串 “false” 时）！</li>
<li>但是不要想当然的理解为 0 &#x3D;&#x3D; null（结果为false） ，1 &#x3D;&#x3D; “abc”（结果是false）， null &#x3D;&#x3D; undefined （结果为false）</li>
<li>不过 0 &#x3D;&#x3D; false ， 1 &#x3D;&#x3D; true（结果都为true）</li>
</ul>
<h2 id="任意类型的值转换为布尔类型的语法糖"><a href="#任意类型的值转换为布尔类型的语法糖" class="headerlink" title="任意类型的值转换为布尔类型的语法糖"></a>任意类型的值转换为布尔类型的语法糖</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">!!val</span><br></pre></td></tr></table></figure>
<p>一个！是取非 再一个！又取非 相当于把这个数据转换为boolean类型了</p>
<h1 id="JavaScript"><a href="#JavaScript" class="headerlink" title="JavaScript"></a>JavaScript</h1><h2 id="Array-some"><a href="#Array-some" class="headerlink" title="Array.some()"></a>Array.some()</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const array = [1, 2, 3, 4, 5];</span><br><span class="line"></span><br><span class="line">// checks whether an element is even</span><br><span class="line">const even = (element) =&gt; element % 2 === 0;</span><br><span class="line"></span><br><span class="line">console.log(array.some(even));</span><br><span class="line">// expected output: true</span><br></pre></td></tr></table></figure>
<h2 id="沙箱"><a href="#沙箱" class="headerlink" title="沙箱"></a>沙箱</h2><p><a href="https://my.oschina.net/ivweb/blog/872949">参考文章</a></p>
<h2 id="JS判断两个对象内容是否相等"><a href="#JS判断两个对象内容是否相等" class="headerlink" title="JS判断两个对象内容是否相等"></a>JS判断两个对象内容是否相等</h2><p><a href="https://www.jianshu.com/p/7407bd65b15d">https://www.jianshu.com/p/7407bd65b15d</a></p>
<h2 id="自定义sleep"><a href="#自定义sleep" class="headerlink" title="自定义sleep"></a>自定义sleep</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const sleep = function (time) &#123;</span><br><span class="line">  let startTime = new Date().getTime() + time * 1000</span><br><span class="line">  while (new Date().getTime() &lt; startTime) &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断字符包是否包含中文"><a href="#判断字符包是否包含中文" class="headerlink" title="判断字符包是否包含中文"></a>判断字符包是否包含中文</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/.*[\u4e00-\u9fa5]+.*$/.test(str)</span><br></pre></td></tr></table></figure>

<h1 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h1><h2 id="ES5中bind-函数"><a href="#ES5中bind-函数" class="headerlink" title="ES5中bind()函数"></a>ES5中bind()函数</h2><h1 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h1><h2 id="ES6教程"><a href="#ES6教程" class="headerlink" title="ES6教程"></a>ES6教程</h2><p><a href="http://es6.ruanyifeng.com/?search=%E8%A7%A3%E6%9E%84&amp;x=0&amp;y=0">http://es6.ruanyifeng.com/?search=%E8%A7%A3%E6%9E%84&amp;x=0&amp;y=0</a></p>
<h2 id="ES6解构赋值"><a href="#ES6解构赋值" class="headerlink" title="ES6解构赋值"></a>ES6解构赋值</h2><p><a href="http://es6.ruanyifeng.com/?search=%E8%A7%A3%E6%9E%84&amp;x=0&amp;y=0#docs/destructuring#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">http://es6.ruanyifeng.com/?search=%E8%A7%A3%E6%9E%84&amp;x=0&amp;y=0#docs/destructuring#%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC</a></p>
<h2 id="Google-JavaScript-Style-Guide"><a href="#Google-JavaScript-Style-Guide" class="headerlink" title="Google JavaScript Style Guide"></a>Google JavaScript Style Guide</h2><p><a href="https://google.github.io/styleguide/jsguide.html">https://google.github.io/styleguide/jsguide.html</a></p>
<h2 id="let-vs-var"><a href="#let-vs-var" class="headerlink" title="let vs var"></a>let vs var</h2><p>在ES6之前，我们都是用var来声明变量，而且JS只有函数作用域和全局作用域，没有块级作用域，所以{}限定不了var声明变量的访问范围。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  var i = 9;</span><br><span class="line">&#125; </span><br><span class="line">console.log(i);  // 9</span><br></pre></td></tr></table></figure>
<p>ES6新增的let，可以声明块级作用域的变量。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">  let i = 9;     // i变量只在 花括号内有效！！！</span><br><span class="line">&#125; </span><br><span class="line">console.log(i);  // Uncaught ReferenceError: i is not defined</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/bd7f6cf64e41">https://www.jianshu.com/p/bd7f6cf64e41</a></p>
<h2 id="const-vs-var-vs-let"><a href="#const-vs-var-vs-let" class="headerlink" title="const vs var vs let"></a>const vs var vs let</h2><p><a href="https://tylermcginnis.com/var-let-const/">https://tylermcginnis.com/var-let-const/</a><br>简而言之：<br>1、var的作用域是函数级别，默认值是undefined；<br>2、let的作用域是代码块级别，未赋值就引用会抛出ReferenceError<br>3、const的作用域和let一样，但是const相当于是一个常量，赋值之后不能直接修改，不然会抛TypeError，但是如果是其指向的值是对象，那么可以修改对象的子属性，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const person = &#123;</span><br><span class="line">  name: &#x27;Kim Kardashian&#x27;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">person.name = &#x27;Kim Kardashian West&#x27; // ✅</span><br><span class="line"></span><br><span class="line">person = &#123;&#125; // ❌ Assignment to constant variable.</span><br></pre></td></tr></table></figure>
<h2 id="export"><a href="#export" class="headerlink" title="export"></a>export</h2><h4 id="export-vs-export-default"><a href="#export-vs-export-default" class="headerlink" title="export vs export default"></a>export vs export default</h4><p>其中export和export default最大的区别就是export不限变量数 可以一直写，而export default  只输出一次 而且 export出的变量想要使用必须使用{}来盛放，而export default 不需要 只要import任意一个名字来接收对象即可。</p>
<h4 id="export-const"><a href="#export-const" class="headerlink" title="export const"></a>export const</h4><p>export const 可以导出多个对象，import的时候用{}承接。</p>
<h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><h4 id="let-obj-x3D-content-todo"><a href="#let-obj-x3D-content-todo" class="headerlink" title="let obj &#x3D; {}, content; todo"></a>let obj &#x3D; {}, content; todo</h4><h2 id="ES6中import-as-xxx-from-‘xxx’的作用"><a href="#ES6中import-as-xxx-from-‘xxx’的作用" class="headerlink" title="ES6中import * as xxx from ‘xxx’的作用"></a>ES6中import * as xxx from ‘xxx’的作用</h2><p>import * as obj from ‘xx’  这种写法是把所有的输出包裹到obj对象里</p>
<h2 id="BOM（浏览器窗口对象模型）"><a href="#BOM（浏览器窗口对象模型）" class="headerlink" title="BOM（浏览器窗口对象模型）"></a>BOM（浏览器窗口对象模型）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*保存的数据用于浏览器的一次会话（session），当会话结束（通常是窗口关闭），数据被清空*/</span><br><span class="line">window.sessionStorage.setItem(name, JSON.stringify(obj));</span><br><span class="line">/*保存的数据用于浏览器的一次会话（session），当会话结束（通常是窗口关闭），数据被清空*/</span><br><span class="line">window.sessionStorage.setItem(name, JSON.stringify(obj));</span><br></pre></td></tr></table></figure>
<h2 id="Code-specification"><a href="#Code-specification" class="headerlink" title="Code specification"></a>Code specification</h2><table>
<thead>
<tr>
<th>firm</th>
<th>url</th>
</tr>
</thead>
<tbody><tr>
<td>aotu</td>
<td><a href="https://guide.aotu.io/docs/js/code.html">https://guide.aotu.io/docs/js/code.html</a></td>
</tr>
<tr>
<td>腾讯</td>
<td><a href="https://www.kancloud.cn/digest/code-guide/42604">https://www.kancloud.cn/digest/code-guide/42604</a></td>
</tr>
<tr>
<td>alibaba</td>
<td><a href="https://www.cnblogs.com/whitewolf/p/4491447.html?spm=a2c4e.10696291.0.0.5e2f19a4kuyhbl#types">https://www.cnblogs.com/whitewolf/p/4491447.html?spm=a2c4e.10696291.0.0.5e2f19a4kuyhbl#types</a></td>
</tr>
</tbody></table>
<h2 id="es6之扩展运算符…"><a href="#es6之扩展运算符…" class="headerlink" title="es6之扩展运算符…"></a>es6之扩展运算符…</h2><blockquote>
<p>对象中的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中</p>
</blockquote>
<h3 id="变量的扩展"><a href="#变量的扩展" class="headerlink" title="变量的扩展"></a>变量的扩展</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let bar = &#123; a: 1, b: 2 &#125;;</span><br><span class="line">let baz = &#123; ...bar &#125;; // &#123; a: 1, b: 2 &#125;</span><br></pre></td></tr></table></figure>
<p>等同于：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let bar = &#123; a: 1, b: 2 &#125;;</span><br><span class="line">let baz = Object.assign(&#123;&#125;, bar); // &#123; a: 1, b: 2 &#125;</span><br></pre></td></tr></table></figure>
<p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let bar = &#123;a: 1, b: 2&#125;;</span><br><span class="line">let baz = &#123;...bar, ...&#123;a:2, b: 4&#125;&#125;;  // &#123;a: 2, b: 4&#125;</span><br></pre></td></tr></table></figure>
<p><em><strong>引用数据类型时，修改拷贝后的对象会影响到被拷贝的对象：</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let obj1 = &#123; a: 1, b: 2, c: &#123;nickName: &#x27;d&#x27;&#125;&#125;;</span><br><span class="line">let obj2 = &#123; ...obj1&#125;;</span><br><span class="line">obj2.c.nickName = &#x27;d-edited&#x27;;</span><br><span class="line">console.log(obj1); // &#123;a: 1, b: 2, c: &#123;nickName: &#x27;d-edited&#x27;&#125;&#125;</span><br><span class="line">console.log(obj2); // &#123;a: 1, b: 2, c: &#123;nickName: &#x27;d-edited&#x27;&#125;&#125;</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「astonishqft」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https://blog.csdn.net/astonishqft/java/article/details/82899965</span><br></pre></td></tr></table></figure>

<h3 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h3><h2 id="filter-数组过滤"><a href="#filter-数组过滤" class="headerlink" title="filter() 数组过滤"></a>filter() 数组过滤</h2><h3 id="判断数组的每个元素"><a href="#判断数组的每个元素" class="headerlink" title="判断数组的每个元素"></a>判断数组的每个元素</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 判断task.selected是在为true</span><br><span class="line">let newArr = this.list.filter(task =&gt; task.selected)</span><br></pre></td></tr></table></figure>
<h3 id="去掉数组空字符串、undefined、null"><a href="#去掉数组空字符串、undefined、null" class="headerlink" title="去掉数组空字符串、undefined、null"></a>去掉数组空字符串、undefined、null</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let newArr = arr.filter(item =&gt; item)</span><br></pre></td></tr></table></figure>
<h3 id="数组去重"><a href="#数组去重" class="headerlink" title="数组去重"></a>数组去重</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">let newArr = arr.filter((x, index,self)=&gt;self.indexOf(x)===index)</span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var arr  = [1,2,1,&#x27;1&#x27;,null,null,undefined,undefined,NaN,NaN]</span><br><span class="line">let res = Array.from(new Set(arr));</span><br><span class="line">//or</span><br><span class="line">let newArr = [...new Set(arr)]</span><br></pre></td></tr></table></figure>
<h2 id="数组查询返回元素"><a href="#数组查询返回元素" class="headerlink" title="数组查询返回元素"></a>数组查询返回元素</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const result = arr.find(item=&gt;&#123;</span><br><span class="line">	return item.itemCode === itemCode</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h1><h2 id="Promise-all和Promise-race"><a href="#Promise-all和Promise-race" class="headerlink" title="Promise.all和Promise.race"></a>Promise.all和Promise.race</h2><p><a href="https://www.jianshu.com/p/7e60fc1be1b2">https://www.jianshu.com/p/7e60fc1be1b2</a><br>还有最新的Promise.any，不过这个公司的架构中没有引进</p>
<h1 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h1><p>可以增加了一个babel插件，现在支持<br>result &#x3D; 0 ?? result 这种写法</p>
<p>类似  0 || result,<br> || 左侧条件是undefined,null,0<br>?? 左侧条件是undefined,null</p>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系列之TodoItem</title>
    <url>/2020/03/29/Java%E7%B3%BB%E5%88%97%E4%B9%8BTodoItem/</url>
    <content><![CDATA[<h2 id="jad命令-todo"><a href="#jad命令-todo" class="headerlink" title="jad命令 todo"></a>jad命令 todo</h2><h2 id="java-flight-recorder-todo"><a href="#java-flight-recorder-todo" class="headerlink" title="java flight recorder todo"></a>java flight recorder todo</h2><h2 id="arthas-trace-todo"><a href="#arthas-trace-todo" class="headerlink" title="arthas trace todo"></a>arthas trace todo</h2><h2 id="依赖注入jcp标准jsr330-todo"><a href="#依赖注入jcp标准jsr330-todo" class="headerlink" title="依赖注入jcp标准jsr330 todo"></a>依赖注入jcp标准jsr330 todo</h2><h2 id="synchronizedMap-todo"><a href="#synchronizedMap-todo" class="headerlink" title="synchronizedMap todo"></a>synchronizedMap todo</h2><h2 id="JNDI的两种写法-todo"><a href="#JNDI的两种写法-todo" class="headerlink" title="JNDI的两种写法 todo"></a>JNDI的两种写法 todo</h2><h2 id="Throwable和Exception-todo"><a href="#Throwable和Exception-todo" class="headerlink" title="Throwable和Exception todo"></a>Throwable和Exception todo</h2><h2 id="静态常量放类和接口的取舍-todo"><a href="#静态常量放类和接口的取舍-todo" class="headerlink" title="静态常量放类和接口的取舍 todo"></a>静态常量放类和接口的取舍 todo</h2><p>建议常量类，尽管接口能够提供一点点遍历，但是多接口继承的情况下可能会冲突（虽然常量接口不可能会被继承），至于性能方面哪方更强，有待研究。。</p>
<h2 id="Map集合的initialCapacity和load-factor-todo"><a href="#Map集合的initialCapacity和load-factor-todo" class="headerlink" title="Map集合的initialCapacity和load factor todo"></a>Map集合的initialCapacity和load factor todo</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">new HashMap&lt;&gt;(1); // 入参为1的意义何在？</span><br></pre></td></tr></table></figure>
<h2 id="Collectors以及Collectors和Stream的联合用法-todo"><a href="#Collectors以及Collectors和Stream的联合用法-todo" class="headerlink" title="Collectors以及Collectors和Stream的联合用法 todo"></a>Collectors以及Collectors和Stream的联合用法 todo</h2><h2 id="FastList和ArrayList区别-todo"><a href="#FastList和ArrayList区别-todo" class="headerlink" title="FastList和ArrayList区别 todo"></a>FastList和ArrayList区别 todo</h2><h2 id="序列化和反序列化-todo"><a href="#序列化和反序列化-todo" class="headerlink" title="序列化和反序列化 todo"></a>序列化和反序列化 todo</h2><p>序列化原理？<br>如果序列化出去的数据存在redis或者数据库，原来的bean对象做修改，比如增加属性等，再反序列化的时候会不会报错？</p>
<h2 id="有没有java较有知名度的upms-todo"><a href="#有没有java较有知名度的upms-todo" class="headerlink" title="有没有java较有知名度的upms todo"></a>有没有java较有知名度的upms todo</h2><h2 id="只读的Map和List-todo"><a href="#只读的Map和List-todo" class="headerlink" title="只读的Map和List todo"></a>只读的Map和List todo</h2><h2 id="jmap-histo-todo"><a href="#jmap-histo-todo" class="headerlink" title="jmap histo todo"></a>jmap histo todo</h2><h2 id="Java微服务值内存占用高解决方法"><a href="#Java微服务值内存占用高解决方法" class="headerlink" title="Java微服务值内存占用高解决方法"></a>Java微服务值内存占用高解决方法</h2><p>可以从几个方向出发：</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown汇总</title>
    <url>/2020/03/29/Markdown%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><h2 id="标记"><a href="#标记" class="headerlink" title="标记"></a>标记</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">**这是加粗的文字**</span><br><span class="line">*这是倾斜的文字*`</span><br><span class="line">***这是斜体加粗的文字***</span><br><span class="line">~~这是加删除线的文字~~</span><br><span class="line">&gt;这是引用的内容</span><br><span class="line">==背景高亮==</span><br></pre></td></tr></table></figure>
<h2 id="分割线"><a href="#分割线" class="headerlink" title="分割线"></a>分割线</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">----</span><br><span class="line">***</span><br><span class="line">*****</span><br></pre></td></tr></table></figure>
<h2 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">![图片alt](图片地址 &#x27;&#x27;图片title&#x27;&#x27;)</span><br></pre></td></tr></table></figure>
<h2 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">- 列表内容</span><br><span class="line">+ 列表内容</span><br><span class="line">* 列表内容</span><br><span class="line"></span><br><span class="line">注意：- + * 跟内容之间都要有一个空格</span><br></pre></td></tr></table></figure>
<h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 列表内容</span><br><span class="line">2. 列表内容</span><br><span class="line">3. 列表内容</span><br><span class="line"></span><br><span class="line">注意：序号跟内容之间要有空格</span><br></pre></td></tr></table></figure>
<h4 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h4><p>上一级和下一级之间敲三个空格即可</p>
<h2 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h2><h4 id="极简方式"><a href="#极简方式" class="headerlink" title="极简方式"></a>极简方式</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name | 价格 |  数量  </span><br><span class="line">-|-|-</span><br><span class="line">香蕉 | $1 | 5 </span><br><span class="line">苹果 | $1 | 6 </span><br><span class="line">草莓 | $1 | 7 </span><br></pre></td></tr></table></figure>
<p>表格效果：</p>
<table>
<thead>
<tr>
<th>name</th>
<th>价格</th>
<th>数量</th>
</tr>
</thead>
<tbody><tr>
<td>香蕉</td>
<td>$1</td>
<td>5</td>
</tr>
<tr>
<td>苹果</td>
<td>$1</td>
<td>6</td>
</tr>
<tr>
<td>草莓</td>
<td>$1</td>
<td>7</td>
</tr>
</tbody></table>
<h4 id="原生居中写法"><a href="#原生居中写法" class="headerlink" title="原生居中写法"></a>原生居中写法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">name | 111 | 222 | 333 | 444</span><br><span class="line">:-: | :-: | :-: | :-: | :-:</span><br><span class="line">aaa | bbb | ccc | ddd | eee</span><br><span class="line">fff | ggg| hhh | iii | 000</span><br></pre></td></tr></table></figure>
<p>表格效果：</p>
<table>
<thead>
<tr>
<th align="center">name</th>
<th align="center">111</th>
<th align="center">222</th>
<th align="center">333</th>
<th align="center">444</th>
</tr>
</thead>
<tbody><tr>
<td align="center">aaa</td>
<td align="center">bbb</td>
<td align="center">ccc</td>
<td align="center">ddd</td>
<td align="center">eee</td>
</tr>
<tr>
<td align="center">fff</td>
<td align="center">ggg</td>
<td align="center">hhh</td>
<td align="center">iii</td>
<td align="center">000</td>
</tr>
</tbody></table>
<h2 id="行内代码块"><a href="#行内代码块" class="headerlink" title="行内代码块"></a>行内代码块</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">`XXX`</span><br></pre></td></tr></table></figure>

<h2 id="数学公式"><a href="#数学公式" class="headerlink" title="数学公式"></a>数学公式</h2><blockquote>
<p>hexo注意要在主题配置文件_config.yml开启数学公式，关键配置是<code>mathjax</code>，以及要在博客加上配置<code>mathjax: true</code>。<br><a href="https://www.dazhuanlan.com/2019/10/21/5dacaedf4c643/?__cf_chl_jschl_tk__=dbc59d7a95e168226de74bd7fb3f80049375667b-1599913232-0-ATRRQpbKWNHowP0aILxN9t1A-MuQZS0tEBq2UNjUnfkCIMHxl4V7L0r47JKN_4w4V8TIRlaU3dg1sUQfWL2Oy3T3ewydLyGZJYacN1keb9ZQK6qoE79HKmIpXydOUrtI7xlMG3LdCKnhupB7UfIXHduDp3qBsgdib-Tq9wx9gr4fklBx3Bsf4fPA4G5jUu4uXKa1xca88H6t0gBMyhli8_o6CbHJJmN93bQiAWJa2MgApOKLZ147wBgaW2mI0JATcc3_HaPC1x91pKLLoZLIEFRUYrWiPtvt1QnQF2g7zwDDz5CJK0SoFms0PPTVB1Obcw">参考来源</a></p>
</blockquote>
<ul>
<li>行内公式使用<code>$公式XXX$</code>包起来。</li>
<li>行间公式使用<code>$$公式XXX$$</code>包起来。</li>
</ul>
<h3 id="n次方（上标）"><a href="#n次方（上标）" class="headerlink" title="n次方（上标）"></a>n次方（上标）</h3><p>如：x的2次方</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">x^&#123;2&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>行内效果：$x^{2}$</li>
<li>行间效果：$$x^{2}$$</li>
</ul>
<h3 id="下标"><a href="#下标" class="headerlink" title="下标"></a>下标</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">n_&#123;i-1&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>行内效果：$n_{i-1}$</li>
<li>行间效果：$$n_{i-1}$$</li>
</ul>
<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1><h2 id="markdown-here"><a href="#markdown-here" class="headerlink" title="markdown-here"></a>markdown-here</h2><p>谷歌插件，神器，将md一键转富文本！</p>
<blockquote>
<p><a href="https://www.jianshu.com/p/ebe52d2d468f">参考来源1</a></p>
</blockquote>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Flowable汇总</title>
    <url>/2019/12/02/Flowable%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="flowable涉及到的表"><a href="#flowable涉及到的表" class="headerlink" title="flowable涉及到的表"></a>flowable涉及到的表</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ACT_GE_BYTEARRAY	通用的流程定义和流程资源</span><br><span class="line">ACT_GE_PROPERTY	系统相关属性</span><br><span class="line"># 流程历史记录</span><br><span class="line">ACT_HI_ACTINST	历史的流程实例</span><br><span class="line">ACT_HI_ATTACHMENT	历史的流程附件</span><br><span class="line">ACT_HI_COMMENT	历史的说明性信息</span><br><span class="line">ACT_HI_DETAIL	历史的流程运行中的细节信息</span><br><span class="line">ACT_HI_IDENTITYLINK	历史的流程运行过程中用户关系</span><br><span class="line">ACT_HI_PROCINST	历史的流程实例</span><br><span class="line">ACT_HI_TASKINST	历史的任务实例</span><br><span class="line">ACT_HI_VARINST	历史的流程运行中的变量信息</span><br><span class="line"># 用户用户组表</span><br><span class="line">ACT_ID_BYTEARRAY	二进制数据表</span><br><span class="line">ACT_ID_GROUP	用户组信息表</span><br><span class="line">ACT_ID_INFO	用户信息详情表</span><br><span class="line">ACT_ID_MEMBERSHIP	人与组关系表</span><br><span class="line">ACT_ID_PRIV	权限表</span><br><span class="line">ACT_ID_PRIV_MAPPING	用户或组权限关系表</span><br><span class="line">ACT_ID_PROPERTY	属性表</span><br><span class="line">ACT_ID_TOKEN	系统登录日志表</span><br><span class="line">ACT_ID_USER	用户表</span><br><span class="line"># 流程定义表</span><br><span class="line">ACT_RE_DEPLOYMENT	部署单元信息</span><br><span class="line">ACT_RE_MODEL	模型信息</span><br><span class="line">ACT_RE_PROCDEF	已部署的流程定义</span><br><span class="line"># 运行实例表</span><br><span class="line">ACT_RU_DEADLETTER_JOB	正在运行的任务表</span><br><span class="line">ACT_RU_EVENT_SUBSCR	运行时事件</span><br><span class="line">ACT_RU_EXECUTION	运行时流程执行实例</span><br><span class="line">ACT_RU_HISTORY_JOB	历史作业表</span><br><span class="line">ACT_RU_IDENTITYLINK	运行时用户关系信息</span><br><span class="line">ACT_RU_JOB	运行时作业表</span><br><span class="line">ACT_RU_SUSPENDED_JOB	暂停作业表</span><br><span class="line">ACT_RU_TASK	运行时任务表</span><br><span class="line">ACT_RU_TIMER_JOB	定时作业表</span><br><span class="line">ACT_RU_VARIABLE	运行时变量表</span><br><span class="line"># 其他表	</span><br><span class="line">ACT_EVT_LOG	事件日志表</span><br><span class="line">ACT_PROCDEF_INFO	流程定义信息</span><br></pre></td></tr></table></figure>

<h1 id="整合启动flowable-modeler"><a href="#整合启动flowable-modeler" class="headerlink" title="整合启动flowable-modeler"></a>整合启动flowable-modeler</h1><p>官网下载的zip包中将wars里面的flowable-admin.war, flowable-idm.war, flowable-modeler.war and flowable-task.war放到tomcat的webapps目录，解压出来后修改每个war里面对应的properties里面的数据源，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">➜  classes pwd</span><br><span class="line">/Users/zhanshifeng/Documents/ccssoftDocument/flowable/apache-tomcat-7.0.99/webapps/flowable-idm/WEB-INF/classes</span><br><span class="line">➜  classes vi flowable-default.properties</span><br></pre></td></tr></table></figure>
<p>然后启动tomcat访问<a href="http://localhost:8080/flowable-modeler">http://localhost:8080/flowable-modeler</a></p>
<h1 id="Events（事件）"><a href="#Events（事件）" class="headerlink" title="Events（事件）"></a>Events（事件）</h1><p>Events are used to model something that happens during the lifetime of a process. Events are always visualized as a circle. In BPMN 2.0, there exist two main event categories: catching and throwing events.</p>
<p>事件的类别主要有：捕捉事件和投掷事件。</p>
<h2 id="Timer-Event-Definitions（定时器事件定义）"><a href="#Timer-Event-Definitions（定时器事件定义）" class="headerlink" title="Timer Event Definitions（定时器事件定义）"></a>Timer Event Definitions（定时器事件定义）</h2><p>Timer events are events that are triggered by a defined timer. They can be used as start event, intermediate event or boundary event.</p>
<p>定时器事件由某个被预定义的定时器所触发，通常被用作于开始事件、中间事件或边界事件，定时器事件中所以和事件相关的定义或变量值，都必须遵循ISO 8601标准。</p>
<ul>
<li><strong>timeDate</strong> 具体的时间点，当时间点到达，将触发事件。</li>
<li><strong>timeDuration</strong> 每隔一个自定义的时间周期，将触发事件。</li>
<li><strong>timeCycle</strong> 每隔一个自定义的时间周期，将触发事件，触发次数可以差异化，此外，它还具有一个EndDate属性，这个属性代表，当endDate的时间已到达，事件将不被触发，EndDate属性有两种写法，如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;timerEventDefinition&gt;</span><br><span class="line">    &lt;timeCycle flowable:endDate=&quot;2015-02-25T16:42:11+00:00&quot;&gt;R3/PT10H&lt;/timeCycle&gt;</span><br><span class="line">&lt;/timerEventDefinition&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;timerEventDefinition&gt;</span><br><span class="line">    &lt;timeCycle&gt;R3/PT10H/$&#123;EndDate&#125;&lt;/timeCycle&gt;</span><br><span class="line">&lt;/timerEventDefinition&gt;</span><br></pre></td></tr></table></figure>
两种写法都存在同一个定时器事件的时候，Flowable默认采用第一种。</li>
</ul>
<h2 id="Signal-Event-Definitions（信号事件定义）"><a href="#Signal-Event-Definitions（信号事件定义）" class="headerlink" title="Signal Event Definitions（信号事件定义）"></a>Signal Event Definitions（信号事件定义）</h2><p>运行时通过代码抛出信号事件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RuntimeService.signalEventReceived(String signalName);</span><br><span class="line">RuntimeService.signalEventReceived(String signalName, String executionId);</span><br></pre></td></tr></table></figure>
<h4 id="Querying-for-Signal-Event-subscriptions（信号事件订阅查询）"><a href="#Querying-for-Signal-Event-subscriptions（信号事件订阅查询）" class="headerlink" title="Querying for Signal Event subscriptions（信号事件订阅查询）"></a>Querying for Signal Event subscriptions（信号事件订阅查询）</h4><p>查询所有订阅的特定信号事件：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">List&lt;Execution&gt; executions = runtimeService.createExecutionQuery()</span><br><span class="line">      .signalEventSubscriptionName(&quot;alert&quot;)</span><br><span class="line">      .list();</span><br></pre></td></tr></table></figure>
<h4 id="Signal-event-scope（信号事件的作用域）"><a href="#Signal-event-scope（信号事件的作用域）" class="headerlink" title="Signal event scope（信号事件的作用域）"></a>Signal event scope（信号事件的作用域）</h4><p>By default, signals are broadcast process engine wide. This means that you can throw a signal event in a process instance, and other process instances with different process definitions can react on the occurrence of this event.<br>默认，信号事件的作用域是整个广播流程引擎的范围，如果要将作用域限制在某个特定的流程实例以内i，就需要将信号事件绑定在特定的流程定义上。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;signal id=&quot;alertSignal&quot; name=&quot;alert&quot; flowable:scope=&quot;processInstance&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>scope属性值默认是”global”，全局。</p>
<h2 id="Message-Event-Definitions（消息事件定义）"><a href="#Message-Event-Definitions（消息事件定义）" class="headerlink" title="Message Event Definitions（消息事件定义）"></a>Message Event Definitions（消息事件定义）</h2><p>消息事件的定义demo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;definitions id=&quot;definitions&quot;</span><br><span class="line">  xmlns=&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;</span><br><span class="line">  xmlns:flowable=&quot;http://flowable.org/bpmn&quot;</span><br><span class="line">  targetNamespace=&quot;Examples&quot;</span><br><span class="line">  xmlns:tns=&quot;Examples&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;message id=&quot;newInvoice&quot; name=&quot;newInvoiceMessage&quot; /&gt;</span><br><span class="line">  &lt;message id=&quot;payment&quot; name=&quot;paymentMessage&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;process id=&quot;invoiceProcess&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;startEvent id=&quot;messageStart&quot; &gt;</span><br><span class="line">    	&lt;messageEventDefinition messageRef=&quot;newInvoice&quot; /&gt;</span><br><span class="line">    &lt;/startEvent&gt;</span><br><span class="line">    ...</span><br><span class="line">    &lt;intermediateCatchEvent id=&quot;paymentEvt&quot; &gt;</span><br><span class="line">    	&lt;messageEventDefinition messageRef=&quot;payment&quot; /&gt;</span><br><span class="line">    &lt;/intermediateCatchEvent&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/process&gt;</span><br><span class="line"></span><br><span class="line">&lt;/definitions&gt;</span><br></pre></td></tr></table></figure>
<p>As an embeddable process engine, Flowable is not concerned with actually receiving a message. This would be environment dependent and entail platform-specific activities, such as connecting to a JMS (Java Messaging Service) Queue&#x2F;Topic or processing a Webservice or REST request. The reception of messages is therefore something you have to implement as part of the application or infrastructure into which the process engine is embedded.（大概意思是flowable没有局限消息接收的具体实现，这部分由开发者自定义，可以是JMS、消息队列、WebService或者是REST风格的请求）</p>
<p>通过消息来触发启动流程实例可以有如下二个API可供选择：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ProcessInstance startProcessInstanceByMessage(String messageName);</span><br><span class="line">ProcessInstance startProcessInstanceByMessage(String messageName, Map&lt;String, Object&gt; processVariables);</span><br><span class="line">ProcessInstance startProcessInstanceByMessage(String messageName, String businessKey,</span><br><span class="line">    Map&lt;String, Object&gt; processVariables);</span><br></pre></td></tr></table></figure>
<p>If the message needs to be received by an existing process instance, you first have to correlate the message to a specific process instance (see next section) and then trigger the continuation of the waiting execution. The runtime service offers the following methods for triggering an execution based on a message event subscription:(两个方法关联消息去触发继续某个正在等待状态的流程)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void messageEventReceived(String messageName, String executionId);</span><br><span class="line">void messageEventReceived(String messageName, String executionId, HashMap&lt;String, Object&gt; processVariables);</span><br></pre></td></tr></table></figure>
<p>使用ProcessDefinitionQuery来绑定消息订阅查询拿到流程定义ProcessDefinition：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ProcessDefinition processDefinition = repositoryService.createProcessDefinitionQuery()</span><br><span class="line">      .messageEventSubscription(&quot;newCallCenterBooking&quot;)</span><br><span class="line">      .singleResult();</span><br></pre></td></tr></table></figure>
<p>或者使用ExecutionQuery来绑定消息订阅查询特定的执行对象Execution。</p>
<h2 id="Start-Events（开始事件）"><a href="#Start-Events（开始事件）" class="headerlink" title="Start Events（开始事件）"></a>Start Events（开始事件）</h2><p>概念上来说，开始事件总是在等待着捕捉一个触发的发生.<br>开始事件的定义demo：<br>initiator: 指向一个认证的用户id，应该是被纳入IDM范围内的一个用户对象的id。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;startEvent id=&quot;request&quot; flowable:initiator=&quot;initiator&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Timer-Start-Event（定时器开始事件）"><a href="#Timer-Start-Event（定时器开始事件）" class="headerlink" title="Timer Start Event（定时器开始事件）"></a>Timer Start Event（定时器开始事件）</h4><p>XML定义的demo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;startEvent id=&quot;theStart&quot;&gt;</span><br><span class="line">  &lt;timerEventDefinition&gt;</span><br><span class="line">    &lt;timeCycle&gt;R4/2011-03-11T12:13/PT5M&lt;/timeCycle&gt;</span><br><span class="line">  &lt;/timerEventDefinition&gt;</span><br><span class="line">&lt;/startEvent&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Message-Start-Event（消息开始事件）"><a href="#Message-Start-Event（消息开始事件）" class="headerlink" title="Message Start Event（消息开始事件）"></a>Message Start Event（消息开始事件）</h4><p>流程定义引用到消息开始事件的时候：<br>The name of the message start event must be unique across a given process definition. A process definition must not have multiple message start events with the same name. Flowable throws an exception upon deployment of a process definition containing two or more message start events referencing the same message, or if two or more message start events reference messages with the same message name.（消息开始事件在流程定义中必须是唯一的，一个流程定义如果引用多个名字相同的消息开始事件的话，会抛出异常，或者多个消息开始事件被定义成相同的name也会抛出异常；如果流程部署了一个新的版本，那么老旧的版本中的消息订阅将会被移除）</p>
<p>如上文所讲到的，消息事件通过这些API调用来触发：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ProcessInstance startProcessInstanceByMessage(String messageName);</span><br><span class="line">ProcessInstance startProcessInstanceByMessage(String messageName, Map&lt;String, Object&gt; processVariables);</span><br><span class="line">ProcessInstance startProcessInstanceByMessage(String messageName, String businessKey,</span><br><span class="line">    Map&lt;String, Object&lt; processVariables);</span><br></pre></td></tr></table></figure>
<ul>
<li>多个消息开始事件的流程通过runtimeService.startProcessInstanceByMessage(…​)启动</li>
<li>拥有一个空的开始事件可以通过实例id启动流程实例</li>
<li>没有空的开始事件的话通过实例id启动流程会抛异常</li>
</ul>
<p>xml定义demo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;definitions id=&quot;definitions&quot;</span><br><span class="line">  xmlns=&quot;http://www.omg.org/spec/BPMN/20100524/MODEL&quot;</span><br><span class="line">  xmlns:flowable=&quot;http://flowable.org/bpmn&quot;</span><br><span class="line">  targetNamespace=&quot;Examples&quot;</span><br><span class="line">  xmlns:tns=&quot;Examples&quot;&gt;</span><br><span class="line"></span><br><span class="line">  &lt;message id=&quot;newInvoice&quot; name=&quot;newInvoiceMessage&quot; /&gt;</span><br><span class="line"></span><br><span class="line">  &lt;process id=&quot;invoiceProcess&quot;&gt;</span><br><span class="line"></span><br><span class="line">    &lt;startEvent id=&quot;messageStart&quot; &gt;</span><br><span class="line">    	&lt;messageEventDefinition messageRef=&quot;tns:newInvoice&quot; /&gt;</span><br><span class="line">    &lt;/startEvent&gt;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/process&gt;</span><br><span class="line"></span><br><span class="line">&lt;/definitions&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Signal-Start-Event（信号开始事件）"><a href="#Signal-Start-Event（信号开始事件）" class="headerlink" title="Signal Start Event（信号开始事件）"></a>Signal Start Event（信号开始事件）</h4><p>xml定义的配置demo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;signal id=&quot;theSignal&quot; name=&quot;The Signal&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;process id=&quot;processWithSignalStart1&quot;&gt;</span><br><span class="line">  &lt;startEvent id=&quot;theStart&quot;&gt;</span><br><span class="line">    &lt;signalEventDefinition id=&quot;theSignalEventDefinition&quot; signalRef=&quot;theSignal&quot;  /&gt;</span><br><span class="line">  &lt;/startEvent&gt;</span><br><span class="line">  &lt;sequenceFlow id=&quot;flow1&quot; sourceRef=&quot;theStart&quot; targetRef=&quot;theTask&quot; /&gt;</span><br><span class="line">  &lt;userTask id=&quot;theTask&quot; name=&quot;Task in process A&quot; /&gt;</span><br><span class="line">  &lt;sequenceFlow id=&quot;flow2&quot; sourceRef=&quot;theTask&quot; targetRef=&quot;theEnd&quot; /&gt;</span><br><span class="line">  &lt;endEvent id=&quot;theEnd&quot; /&gt;</span><br><span class="line">&lt;/process&gt;</span><br></pre></td></tr></table></figure>
<p>可以通过runtimeService.signalEventReceivedXXX触发。</p>
<h4 id="Error-Start-Even（错误开始事件）"><a href="#Error-Start-Even（错误开始事件）" class="headerlink" title="Error Start Even（错误开始事件）"></a>Error Start Even（错误开始事件）</h4><p>An error start event can be used to trigger an Event Sub-Process. An error start event cannot be used for starting a process instance.（错误开始事件只能用来发出子流程，不能触发整个的流程实例？？）</p>
<h2 id="End-Events（结束事件）"><a href="#End-Events（结束事件）" class="headerlink" title="End Events（结束事件）"></a>End Events（结束事件）</h2><h4 id="None-End-Event（空结束事件）"><a href="#None-End-Event（空结束事件）" class="headerlink" title="None End Event（空结束事件）"></a>None End Event（空结束事件）</h4><p>xml定义demo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;endEvent id=&quot;end&quot; name=&quot;my end event&quot; /&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Error-End-Event（错误结束事件）"><a href="#Error-End-Event（错误结束事件）" class="headerlink" title="Error End Event（错误结束事件）"></a>Error End Event（错误结束事件）</h4><p>xml定义demo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;endEvent id=&quot;myErrorEndEvent&quot;&gt;</span><br><span class="line">  &lt;errorEventDefinition errorRef=&quot;myError&quot; /&gt;</span><br><span class="line">&lt;/endEvent&gt;</span><br></pre></td></tr></table></figure>
<p>具体的错误能够被定义在流程之外，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;error id=&quot;myError&quot; errorCode=&quot;123&quot; /&gt;</span><br><span class="line">...</span><br><span class="line">&lt;process id=&quot;myProcess&quot;&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>errorCode会被用来匹配一个等待被捕捉的边界错误事件，如果匹配不到，那么errorCode会被等同于id来使用，比如下面的二个代码片段作用一样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;error id=&quot;myError&quot; errorCode=&quot;error123&quot; /&gt;</span><br><span class="line">...</span><br><span class="line">&lt;process id=&quot;myProcess&quot;&gt;</span><br><span class="line">...</span><br><span class="line">  &lt;endEvent id=&quot;myErrorEndEvent&quot;&gt;</span><br><span class="line">    &lt;errorEventDefinition errorRef=&quot;myError&quot; /&gt;</span><br><span class="line">  &lt;/endEvent&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;endEvent id=&quot;myErrorEndEvent&quot;&gt;</span><br><span class="line">  &lt;errorEventDefinition errorRef=&quot;error123&quot; /&gt;</span><br><span class="line">&lt;/endEvent&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Terminate-End-Event（终止结束事件）"><a href="#Terminate-End-Event（终止结束事件）" class="headerlink" title="Terminate End Event（终止结束事件）"></a>Terminate End Event（终止结束事件）</h4><p>xml定义demo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;endEvent id=&quot;myEndEvent &gt;</span><br><span class="line">  &lt;terminateEventDefinition flowable:terminateAll=&quot;true&quot;&gt;&lt;/terminateEventDefinition&gt;</span><br><span class="line">&lt;/endEvent&gt;</span><br></pre></td></tr></table></figure>
<p>如果terminateAll为true，会总之所有整个流程以及相关子流程。</p>
<h4 id="Cancel-End-Event（取消结束事件）"><a href="#Cancel-End-Event（取消结束事件）" class="headerlink" title="Cancel End Event（取消结束事件）"></a>Cancel End Event（取消结束事件）</h4><p>xm定义demo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;endEvent id=&quot;myCancelEndEvent&quot;&gt;</span><br><span class="line">  &lt;cancelEventDefinition /&gt;</span><br><span class="line">&lt;/endEvent&gt;</span><br></pre></td></tr></table></figure>
<h2 id="Boundary-Events（边界事件）"><a href="#Boundary-Events（边界事件）" class="headerlink" title="Boundary Events（边界事件）"></a>Boundary Events（边界事件）</h2><p>边界事件的定义规则如下：</p>
<ul>
<li>在流程范围内是唯一的</li>
<li>通过attachedToRef属性附加到一个引用的Activity，但是边界事件和它附着的活动是同一等级的，不是上下级关系？？<br>xml定义demo：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;boundaryEvent id=&quot;myBoundaryEvent&quot; attachedToRef=&quot;theActivity&quot;&gt;</span><br><span class="line">      &lt;XXXEventDefinition/&gt;</span><br><span class="line">&lt;/boundaryEvent&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<h4 id="Timer-Boundary-Event（定时器边界事件）"><a href="#Timer-Boundary-Event（定时器边界事件）" class="headerlink" title="Timer Boundary Event（定时器边界事件）"></a>Timer Boundary Event（定时器边界事件）</h4><p>xml定义demo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;boundaryEvent id=&quot;escalationTimer&quot; cancelActivity=&quot;true&quot; attachedToRef=&quot;firstLineSupport&quot;&gt;</span><br><span class="line">  &lt;timerEventDefinition&gt;</span><br><span class="line">    &lt;timeDuration&gt;PT4H&lt;/timeDuration&gt;</span><br><span class="line">  &lt;/timerEventDefinition&gt;</span><br><span class="line">&lt;/boundaryEvent&gt;</span><br></pre></td></tr></table></figure>
<p>有个关键的不同点是：Non-interrupting 和 Interrupting，前者是不会打断流程原来的活动，后者反之，边界事件默认是会打断的，可以通过cancelActivity属性自定义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;boundaryEvent id=&quot;escalationTimer&quot; cancelActivity=&quot;false&quot; attachedToRef=&quot;firstLineSupport&quot;/&gt;</span><br></pre></td></tr></table></figure>
<p>Note: boundary timer events are only fired when the async executor is enabled (asyncExecutorActivate needs to be set to true in the flowable.cfg.xml, since the async executor is disabled by default).<br>注意要开启异步执行器，flowable默认是关闭该配置的。<br>官方给出的demo（通过定时器边界事件来对Task额外的邮件通知做处理，同时不影响原来Task的继续执行）：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/g6DpP6.png"></p>
<h4 id="Known-issue-with-boundary-events（边界事件已知问题）"><a href="#Known-issue-with-boundary-events（边界事件已知问题）" class="headerlink" title="Known issue with boundary events（边界事件已知问题）"></a>Known issue with boundary events（边界事件已知问题）</h4><p>无论是那种类型的边界事件，都不允许直接并发触发多个外部的序列流程，必须通过并行网关来处理：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/Sk9V5Z.png"></p>
<h4 id="Error-Boundary-Event（错误边界事件）"><a href="#Error-Boundary-Event（错误边界事件）" class="headerlink" title="Error Boundary Event（错误边界事件）"></a>Error Boundary Event（错误边界事件）</h4><p>xml定义demo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;boundaryEvent id=&quot;catchError&quot; attachedToRef=&quot;mySubProcess&quot;&gt;</span><br><span class="line">  &lt;errorEventDefinition errorRef=&quot;myError&quot;/&gt;</span><br><span class="line">&lt;/boundaryEvent&gt;</span><br><span class="line"></span><br><span class="line">&lt;error id=&quot;myError&quot; errorCode=&quot;123&quot; /&gt;</span><br><span class="line">...</span><br><span class="line">&lt;process id=&quot;myProcess&quot;&gt;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ul>
<li>如果errorRef被省略，那么边界错误事件将捕获任何错误事件，如果errorRef指向的error存在，那么将只捕捉对应的error，如果error不存在，那么会将errorRef的值视为对应的error，就像错误结束事件一样。<br>官方给出的demo（）：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/NQoyiB.png"><br>还有官方根据上图demo做的测试类：<a href="https://github.com/flowable/flowable-engine/blob/master/modules/flowable-engine/src/test/java/org/flowable/examples/bpmn/event/error/BoundaryErrorEventTest.java">BoundaryErrorEventTest.java</a></li>
</ul>
<h4 id="Signal-Boundary-Event（信号边界事件）"><a href="#Signal-Boundary-Event（信号边界事件）" class="headerlink" title="Signal Boundary Event（信号边界事件）"></a>Signal Boundary Event（信号边界事件）</h4><p>信号边界事件是不可消耗的，意思是，如果一个信号事件被抛出，那么捕捉这个信号事件的所有流程实例的活动都会被触发，因为信号事件的作用域是全局的，它能够在任何地方被抛出，在任何地方被捕捉。<br>xml定义demo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;boundaryEvent id=&quot;boundary&quot; attachedToRef=&quot;task&quot; cancelActivity=&quot;true&quot;&gt;</span><br><span class="line">    &lt;signalEventDefinition signalRef=&quot;alertSignal&quot;/&gt;</span><br><span class="line">&lt;/boundaryEvent&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Message-Boundary-Event（消息边界事件）"><a href="#Message-Boundary-Event（消息边界事件）" class="headerlink" title="Message Boundary Event（消息边界事件）"></a>Message Boundary Event（消息边界事件）</h4><p>xml定义demo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;boundaryEvent id=&quot;boundary&quot; attachedToRef=&quot;task&quot; cancelActivity=&quot;true&quot;&gt;</span><br><span class="line">    &lt;messageEventDefinition messageRef=&quot;newCustomerMessage&quot;/&gt;</span><br><span class="line">&lt;/boundaryEvent&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Cancel-Boundary-Event（取消边界事件）"><a href="#Cancel-Boundary-Event（取消边界事件）" class="headerlink" title="Cancel Boundary Event（取消边界事件）"></a>Cancel Boundary Event（取消边界事件）</h4><h4 id="compensation-boundary-event（补偿边界事件）"><a href="#compensation-boundary-event（补偿边界事件）" class="headerlink" title="compensation boundary event（补偿边界事件）"></a>compensation boundary event（补偿边界事件）</h4><p>补偿边界事件被定义做一个典型的边界事件，xml定义demo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;boundaryEvent id=&quot;compensateBookHotelEvt&quot; attachedToRef=&quot;bookHotel&quot; &gt;</span><br><span class="line">    &lt;compensateEventDefinition /&gt;</span><br><span class="line">&lt;/boundaryEvent&gt;</span><br><span class="line"></span><br><span class="line">&lt;association associationDirection=&quot;One&quot; id=&quot;a1&quot;</span><br><span class="line">    sourceRef=&quot;compensateBookHotelEvt&quot; targetRef=&quot;undoBookHotel&quot; /&gt;</span><br><span class="line"></span><br><span class="line">&lt;serviceTask id=&quot;undoBookHotel&quot; isForCompensation=&quot;true&quot; flowable:class=&quot;...&quot; /</span><br></pre></td></tr></table></figure>
<ul>
<li>When compensation is triggered, the compensation handler associated with the compensation boundary event is invoked the same number of times the activity it is attached to completed successfully.（当补偿被触发，补偿边界事件绑定的补偿处理器被调用的次数和事件依附在流程活动的次数是一样的）</li>
<li>If a compensation boundary event is attached to an activity with multiple instance characteristics, a compensation event subscription is created for each instance.（如果补偿边界事件被绑定在多个不同的流程实例，那么每个流程实例都将创建一个事件订阅）</li>
<li>If a compensation boundary event is attached to an activity that is contained inside a loop, a compensation event subscription is created each time the activity is executed.（如果事件的绑定逻辑在内部的循环里，那么事件订阅的创建也将跟随着每个循环都创建一次）</li>
<li>If the process instance ends, the subscriptions to compensation events are canceled.（流程实例结束，补偿事件的订阅也将取消）</li>
</ul>
<h2 id="Intermediate-Catching-Events（中间捕捉事件）"><a href="#Intermediate-Catching-Events（中间捕捉事件）" class="headerlink" title="Intermediate Catching Events（中间捕捉事件）"></a>Intermediate Catching Events（中间捕捉事件）</h2><p>所有中间捕捉事件的定义方式，同个流程范围内必须唯一：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;intermediateCatchEvent id=&quot;myIntermediateCatchEvent&quot; &gt;</span><br><span class="line">    &lt;XXXEventDefinition/&gt;</span><br><span class="line">&lt;/intermediateCatchEvent&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Timer-Intermediate-Catching-Event（定时器中间捕捉事件）"><a href="#Timer-Intermediate-Catching-Event（定时器中间捕捉事件）" class="headerlink" title="Timer Intermediate Catching Event（定时器中间捕捉事件）"></a>Timer Intermediate Catching Event（定时器中间捕捉事件）</h4><h4 id="Signal-Intermediate-Catching-Event（信号中间捕捉事件）"><a href="#Signal-Intermediate-Catching-Event（信号中间捕捉事件）" class="headerlink" title="Signal Intermediate Catching Event（信号中间捕捉事件）"></a>Signal Intermediate Catching Event（信号中间捕捉事件）</h4><h4 id="Message-Intermediate-Catching-Event（消息中间捕捉事件）"><a href="#Message-Intermediate-Catching-Event（消息中间捕捉事件）" class="headerlink" title="Message Intermediate Catching Event（消息中间捕捉事件）"></a>Message Intermediate Catching Event（消息中间捕捉事件）</h4><h1 id="Problem-Solution"><a href="#Problem-Solution" class="headerlink" title="Problem Solution"></a>Problem Solution</h1><h2 id="upgrading-flowable-engine-schema-from-6-4-1-1-to-6-5-0-1"><a href="#upgrading-flowable-engine-schema-from-6-4-1-1-to-6-5-0-1" class="headerlink" title="upgrading flowable engine schema from 6.4.1.1 to 6.5.0.1"></a>upgrading flowable engine schema from 6.4.1.1 to 6.5.0.1</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">performing upgrade on engine with resource org/flowable/db/upgrade/flowable.mysql.upgradestep.6411.to.6412.engine.sql</span><br></pre></td></tr></table></figure>
<p>这个报错是因为默认配置的dbSchemaUpgrade是true，这个会在流程初始化的时候去对Flowable版本和数据库存的Flowable版本做比对并做一些初始化的处理，如果要快速启动忽略版本比对问题的话改成false，如果还有问题干脆改成”none”。</p>
]]></content>
      <categories>
        <category>Flowable</category>
      </categories>
      <tags>
        <tag>Flowable</tag>
      </tags>
  </entry>
  <entry>
    <title>股票理财</title>
    <url>/2020/03/29/%E8%82%A1%E7%A5%A8%E7%90%86%E8%B4%A2/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记总结自李哥说理财的股票教程，以及其他网上知识点收集，只是我自己的个人复习笔记。</p>
</blockquote>
<h2 id="经济运作体系"><a href="#经济运作体系" class="headerlink" title="经济运作体系"></a>经济运作体系</h2><p><a href="https://youtu.be/rFV7wdEX-Mo">经济机器是怎样运行的</a></p>
<h2 id="非农时间"><a href="#非农时间" class="headerlink" title="非农时间"></a>非农时间</h2><p>什么是非农，通常说的是美国每月公布的非农业就业人口数据，在金融市场里非农会导致数据的波荡，这个波荡的数据会引起投资者的骚动。<br>非农数据，包括美国非农就业率，非农业就业人数与失业率这三个数值，反映了美国非农业部门的就业状况的数据指标。这三个数据每个月第一个周五北京时间（冬令时：11月–3月）21:30，（夏令时：4月–10月）20:30发布，这些数据来源于美国劳工部劳动统计局。<br>非农分为大非农和小非农之分，大非农一般是在每月第一周的周五，主要是大盘。小非农一般在每月的一周的周三，主要是微盘。大非农的数据波动比较大。<br>简单说来，这两个数据都是直接反应现实的失业和就业情况，我们需要这样理解，如果就业率高失业率低说明美国经济良好，美元走强;反之则美元走弱。所有与美元挂钩的投资，皆会因此而剧烈波动。当我们根据行情做单的时候，要看清楚数据，然后结合相关技术面顺势而为。<br>可以说小非农是非农前的一次预期行情美国非农数据对黄金交易的影响。两者是相互关系的，从小非农指数就可以推测大非农指数，但是想要看得准，那就需要一定的基本功和时间的累积，不是一朝一夕就可以熟练的。</p>
<h3 id="非农数据与黄金的关系"><a href="#非农数据与黄金的关系" class="headerlink" title="非农数据与黄金的关系"></a>非农数据与黄金的关系</h3><blockquote>
<p>非农是官方统计的数据对于一个市场的企业就业情况，从而就可以判断美国的美元经济趋势，大非农是每个月的一周的周五晚八点准时公布，主要是公布美国劳工部公布的一组民间调查的就业率和失业率，也可以判断美国美元趋势。贵金属，黄金，白银，铜，这些全部都是以美元为风向标，美元涨贵金属就跌，美元跌贵金属就涨。 所以能明白美国美元经济是利好利空就能判断黄金的方向了</p>
</blockquote>
<h2 id="股票代码"><a href="#股票代码" class="headerlink" title="股票代码"></a>股票代码</h2><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/499PUR.png"></p>
<h2 id="选股大法"><a href="#选股大法" class="headerlink" title="选股大法"></a>选股大法</h2><ul>
<li>尽量选择ROE比较高，而PE比较低的。</li>
<li>个人理财的核心思想：平衡。</li>
<li>负债率太高的股票要尽量避开。</li>
<li>一般要求企业的现金流为正，更要求净现金流为正。</li>
<li>比如钢铁、煤炭这些原材料行业，还有船舶机械、金融证券都是强周期性行业，低谷时买入，高峰时卖出。（根据行业的周期性）</li>
<li>行业是否有成长性</li>
<li>生存环境是否激烈</li>
<li>经营模式是否简单</li>
<li>竞争分析</li>
<li>财务报表分析</li>
</ul>
<h2 id="股票（公司）指标"><a href="#股票（公司）指标" class="headerlink" title="股票（公司）指标"></a>股票（公司）指标</h2><h3 id="最重要的两个指标"><a href="#最重要的两个指标" class="headerlink" title="最重要的两个指标"></a>最重要的两个指标</h3><p>股市价格常被看作宏观经济的晴雨表，影响股票价格的因素可以有：</p>
<ul>
<li>利率（宏观经济指标）<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/w2x3x5.png"><br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/Sao6RB.png"></li>
<li>通过膨胀（宏观经济指标），但是真正的牛市不应该是超发货币吹出来的一个虚胖的资金牛，应该伴随着实体经济的实质性增长，单纯撒钱可能股市也会涨，但是都是泡沫，一旦发钱速度慢了，不但股市崩盘，实体经济也会产生连锁危机。</li>
</ul>
<h4 id="PE（市盈率）"><a href="#PE（市盈率）" class="headerlink" title="PE（市盈率）"></a>PE（市盈率）</h4><p><em><strong>PE&#x3D;每股市价&#x2F;每股净收益，用来衡量股价是被高估还是低估了。</strong></em><br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/gDif4M.png"><br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/kTXEBi.png"><br><em><strong>PE的简单理解就是需要多少年才能收回我们的投资，10倍市盈率相当于投资的钱10年回本。</strong></em></p>
<h4 id="ROE（净资产收益率）"><a href="#ROE（净资产收益率）" class="headerlink" title="ROE（净资产收益率）"></a>ROE（净资产收益率）</h4><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/NEId1x.png"><br>这也是巴菲特最看重的指标，判断一个公司运营的好坏取决于它的净资产收益率高不高。<br>计算公司为<code>净利润/净资产=净利润/(总资产-总负债)</code><br><em><strong>ROE越高说明一家企业的赚钱能力越强，如果一家公司如果常年的ROE保持在15%以上，就是非常不错的了。</strong></em></p>
<blockquote>
<p>贵州茅台近年来的ROE平均都很高</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/yzNpW3.png"><br><em><strong>ROE高的股票并不一定都涨的好，但是反之一般就会成立。</strong></em></p>
<h3 id="资产负债率"><a href="#资产负债率" class="headerlink" title="资产负债率"></a>资产负债率</h3><p>公司资产的两个来源：</p>
<ul>
<li>股东投入的钱（所有者权益&#x2F;权益资本）。</li>
<li>向银行、金融机构等借的钱（负债&#x2F;债务资本）。</li>
</ul>
<p><code>资产 = 所有者权益 + 负债</code><br>所以企业最佳盈利方式是在权益资本和债务资本之间寻求最佳平衡点。<br>假如一个企业的负债率为60%，就代表这个企业的资产60%是以债务的形式存在。<br>一般企业负债率：40%~60%<br>银行、证券公司、保险公司、房地产公司普遍负债率会高一些：</p>
<ul>
<li>银行：90%+</li>
<li>保险：80%+</li>
</ul>
<p>所以负债率只适合在同行业之间比较，负债率太高的股票要尽量避开。</p>
<h4 id="负债经营的好处"><a href="#负债经营的好处" class="headerlink" title="负债经营的好处"></a>负债经营的好处</h4><ul>
<li>放大经营杠杠</li>
<li>有减税的作用（利息税前抵扣）</li>
</ul>
<h3 id="现金流"><a href="#现金流" class="headerlink" title="现金流"></a>现金流</h3><p>利润好比食物，不吃饭还可以活几天，但是现金流就像是血液一样，大出血的话，可能几分钟都撑不过去。</p>
<h4 id="企业活动"><a href="#企业活动" class="headerlink" title="企业活动"></a>企业活动</h4><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/vXPOJ9.png"><br>每种企业活动都伴随着现金的流入和流出。</p>
<h5 id="净现金流"><a href="#净现金流" class="headerlink" title="净现金流"></a>净现金流</h5><p>一段时间内的企业活动的现金流入和流出的差额叫净现金流。</p>
<p>一般要求企业的现金流为正，更要求净现金流为正。企业可以没有利润，但是不能没有现金流。<br>现行的企业会计制度以<em><strong>权责发生制</strong></em>为基础，可能会出现收入和利润已经体现在财报中了，但是钱不能及时到账，甚至变成坏账，财报可能缺乏实时真实性。</p>
<h3 id="行业分析"><a href="#行业分析" class="headerlink" title="行业分析"></a>行业分析</h3><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/BIJHIz.png"></p>
<h4 id="行业是否有周期性"><a href="#行业是否有周期性" class="headerlink" title="行业是否有周期性"></a>行业是否有周期性</h4><ul>
<li>比如钢铁、煤炭这些原材料行业，还有船舶机械、金融证券都是强周期性行业，低谷时买入，高峰时卖出。</li>
<li>比如食品、家电、娱乐、医药，周期性不是很明显。</li>
</ul>
<h4 id="行业是否有成长性"><a href="#行业是否有成长性" class="headerlink" title="行业是否有成长性"></a>行业是否有成长性</h4><p>如果市场整体饱和，整个行业如法实现以前的高速增长，产能过剩，供过于求，行业生存环境会越来越严峻。</p>
<h4 id="生存环境是否激烈"><a href="#生存环境是否激烈" class="headerlink" title="生存环境是否激烈"></a>生存环境是否激烈</h4><p>恶性竞争可能导致绝大部分企业陷入亏损泥潭，众多品牌混战，打价格战，杀敌一千，自损八百，利润被压缩。</p>
<h4 id="经营模式是否简单"><a href="#经营模式是否简单" class="headerlink" title="经营模式是否简单"></a>经营模式是否简单</h4><p>有些看不懂的复杂生意模式尽量不碰，越复杂，猫腻可能越多，普通人难以摸透。</p>
<h3 id="竞争分析"><a href="#竞争分析" class="headerlink" title="竞争分析"></a>竞争分析</h3><h4 id="企业与客户的关系"><a href="#企业与客户的关系" class="headerlink" title="企业与客户的关系"></a>企业与客户的关系</h4><h5 id="卖方市场（企业竞争力弱）"><a href="#卖方市场（企业竞争力弱）" class="headerlink" title="卖方市场（企业竞争力弱）"></a>卖方市场（企业竞争力弱）</h5><p>计划经济时代就是一个十足的卖方市场，当时的中国经济是长期处于供不应求的状态。</p>
<h5 id="买方市场"><a href="#买方市场" class="headerlink" title="买方市场"></a>买方市场</h5><p>随着中国的市场化改革和生产力的快速提高，今天市场上大部分行业都已经产能过剩了，就变成了典型的买方市场。<br>在买方市场中，卖方一般只能两种手段：</p>
<ul>
<li>通过差异化竞争来获取超额利润。</li>
<li>打折。</li>
</ul>
<h4 id="企业与上游供应商的关系"><a href="#企业与上游供应商的关系" class="headerlink" title="企业与上游供应商的关系"></a>企业与上游供应商的关系</h4><p>这种关系和客户关系有点类似，也有处于”买方”的企业，比如沃尔玛、亚马逊，这种接近于客户端的名下有大量客户资源的公司，其在市场中就扮演着买方的角色，品牌效应强大，对上游供应商更加有话语权，更容易占用上游的资金，延迟货款支付，相当于在上游免息贷款了。</p>
<h4 id="企业是否具有核心竞争力"><a href="#企业是否具有核心竞争力" class="headerlink" title="企业是否具有核心竞争力"></a>企业是否具有核心竞争力</h4><p><em><strong>核心竞争力就是只有我有，别人基本没有的东西，或者只有我才是做得最好的。这就是巴菲特所说的护城河理论，其实就是企业的核心技术。</strong></em><br><em><strong>护城河越深，企业的优势就越明显。</strong></em></p>
<p>护城河可以有：</p>
<ul>
<li>特许经营权（像中国的中石油和中石化，这些个资源垄断型企业）。</li>
<li>多元化发展（适当的多元化是有利于提升企业的整体竞争力，扩大市场空间，但是物极必反，比如乐视）。</li>
</ul>
<h4 id="公司的领导层（这个一般人也了解不到）"><a href="#公司的领导层（这个一般人也了解不到）" class="headerlink" title="公司的领导层（这个一般人也了解不到）"></a>公司的领导层（这个一般人也了解不到）</h4><p>关键判断领导团队、管理团队是否具备以下几个优秀的品质：</p>
<ul>
<li>诚信（把股东的利润放在第一位，而不是高位套现，融资圈钱）</li>
<li>敬业（企业不应该做太多不关紧要的内耗）</li>
<li>社会责任感</li>
</ul>
<h3 id="财务报表"><a href="#财务报表" class="headerlink" title="财务报表"></a>财务报表</h3><p>财报是了解企业的信息窗口，普通投资者能接触到的最有价值的投资材料。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/XA9yLG.png"></p>
<h4 id="资产"><a href="#资产" class="headerlink" title="资产"></a>资产</h4><p>企业能够控制的预期；<br>会给企业带来收益的东西；</p>
<blockquote>
<p>就是钱以及能够产生钱的那些东西。</p>
</blockquote>
<h5 id="流动性资产"><a href="#流动性资产" class="headerlink" title="流动性资产"></a>流动性资产</h5><p>现金或者变现能力较强的资产：货币基金（资金）、应收账款、存货。</p>
<h5 id="非流动性资产"><a href="#非流动性资产" class="headerlink" title="非流动性资产"></a>非流动性资产</h5><p>短期内不打算变现，或者变现能力较差的资产：比如一些固定资产。</p>
<blockquote>
<p>货币基金（资金）多说明企业的经营效益好，可以间接表明该企业的市场竞争力强大。<br>应收账款最好是越少越好，太多的应收账款说明自由资金已被客户过多占用，还可能形成坏账。</p>
</blockquote>
<h2 id="专业名词"><a href="#专业名词" class="headerlink" title="专业名词"></a>专业名词</h2><h3 id="袋鼠市"><a href="#袋鼠市" class="headerlink" title="袋鼠市"></a>袋鼠市</h3><p>袋鼠市场描述的是在一段时间内上下跳跃频繁的市场，没有任何强劲的上升或下降趋势。</p>
<h3 id="窄幅震荡"><a href="#窄幅震荡" class="headerlink" title="窄幅震荡"></a>窄幅震荡</h3><p>上下震荡的幅度都比较小的走势。</p>
<h3 id="宽幅震荡"><a href="#宽幅震荡" class="headerlink" title="宽幅震荡"></a>宽幅震荡</h3><p>上下震荡的幅度都比较大的走势。</p>
<h3 id="IPO"><a href="#IPO" class="headerlink" title="IPO"></a>IPO</h3><p>首次公开募股（Initial Public Offering）是指一家企业第一次将它的股份向公众出售。<br>通常，上市公司的股份是根据相应证监会出具的招股书或登记声明中约定的条款通过经纪商或做市商进行销售。<br>一般来说，一旦首次公开上市完成后，这家公司就可以申请到证券交易所或报价系统挂牌交易。<br>有限责任公司在申请IPO之前，应先变更为股份有限公司。</p>
]]></content>
      <categories>
        <category>理财</category>
      </categories>
      <tags>
        <tag>股票</tag>
        <tag>理财</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring系列之Cache</title>
    <url>/2020/04/02/Spring%E7%B3%BB%E5%88%97%E4%B9%8BCache/</url>
    <content><![CDATA[<h1 id="官方文档"><a href="#官方文档" class="headerlink" title="官方文档"></a>官方文档</h1><p><a href="https://spring.io/guides">Spring All Guides</a><br><a href="https://spring.io/guides/gs/caching/">Caching Data with Spring</a></p>
<h1 id="Problem-Solution"><a href="#Problem-Solution" class="headerlink" title="Problem Solution"></a>Problem Solution</h1><h2 id="SpringBoot中-Cacheable-CacheEvict-CachePut在同一个类中方法调用不起作用"><a href="#SpringBoot中-Cacheable-CacheEvict-CachePut在同一个类中方法调用不起作用" class="headerlink" title="SpringBoot中@Cacheable,@CacheEvict,@CachePut在同一个类中方法调用不起作用"></a>SpringBoot中@Cacheable,@CacheEvict,@CachePut在同一个类中方法调用不起作用</h2><p><a href="https://www.jianshu.com/p/c33ba070028e">https://www.jianshu.com/p/c33ba070028e</a><br><a href="https://www.cnblogs.com/liubey/archive/2018/04/02/spring_cacheable.html">https://www.cnblogs.com/liubey/archive/2018/04/02/spring_cacheable.html</a><br><a href="https://www.cnblogs.com/chanedi/p/4552555.html">https://www.cnblogs.com/chanedi/p/4552555.html</a><br><a href="https://blog.csdn.net/dapinxiaohuo/article/details/52092447">https://blog.csdn.net/dapinxiaohuo/article/details/52092447</a></p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring Cache</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring Cache</tag>
      </tags>
  </entry>
  <entry>
    <title>基金理财</title>
    <url>/2020/03/29/%E5%9F%BA%E9%87%91%E7%90%86%E8%B4%A2/</url>
    <content><![CDATA[<h1 id="踩过的坑"><a href="#踩过的坑" class="headerlink" title="踩过的坑"></a>踩过的坑</h1><h2 id="指数基金的坑"><a href="#指数基金的坑" class="headerlink" title="指数基金的坑"></a>指数基金的坑</h2><p>之前买过几只指数基金，因为没有太多时间去仔细研究，我就从天天基金最近的热销版中挑选了农业、消费、饮食、建筑四个方向的指数，加上受疫情影响，按道理后面应该是利好方向的，所以总共买了6万左右。</p>
<p>然而我忽略了一个投资的定律：</p>
<ul>
<li>别人都纷纷买入了一段时间大涨之后，绝对不能轻易跟投，指不定就已经是山顶了；</li>
<li>别人都纷纷卖出也不是进场的时候，指不定还在半山腰；</li>
</ul>
<h1 id="债券基金"><a href="#债券基金" class="headerlink" title="债券基金"></a>债券基金</h1><h2 id="纯债基金"><a href="#纯债基金" class="headerlink" title="纯债基金"></a>纯债基金</h2><ul>
<li>纯债基金与非纯债基金，力哥建议投资优先考虑纯债基金，在想要投资债券基金的情况下。<ul>
<li>这里要注意的是，纯债基金中是允许投资可转债的，这种从严格意义上来讲是非纯债基金，如果投资范畴定位在百分之百纯债基金的话，那么要抛弃包含可转债的纯债基金。</li>
</ul>
</li>
</ul>
<h2 id="投资技巧"><a href="#投资技巧" class="headerlink" title="投资技巧"></a>投资技巧</h2><ol>
<li>基金基于四四三三的情况下；或者直接在天天基金网选择长时间的范围来排名前三十位的，其网站有长期纯债可选。</li>
<li>剔除投资了可转债的基金。</li>
<li>剔除小公司基金。</li>
<li>剔除基金规模太大的，比如超过20亿。</li>
<li>剔除同一家大型基金公司的非王牌基金。</li>
<li>挑选出综合费率最低的。</li>
<li>选择成立时间相对更长的，基金经理年龄较大，其管理时间较长的。</li>
</ol>
<h2 id="债基收费模式"><a href="#债基收费模式" class="headerlink" title="债基收费模式"></a>债基收费模式</h2><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/qdBMDJ.png"></p>
<h4 id="那种类型更加合算："><a href="#那种类型更加合算：" class="headerlink" title="那种类型更加合算："></a>那种类型更加合算：</h4><ol>
<li>如果只是想试试水，投资几个月也许就取出来了，那么选择不收取申购&#x2F;赎回费用的模式更好。</li>
<li>如果想长期投资，那么可以采取申购&#x2F;赎回的模式。</li>
</ol>
<blockquote>
<p>现在无论是前后端收费，费率听说都被压到很低了，所以前后端也许没有什么区别了，要具体比对。</p>
</blockquote>
<h2 id="定期开放式债券基金（定开债）"><a href="#定期开放式债券基金（定开债）" class="headerlink" title="定期开放式债券基金（定开债）"></a>定期开放式债券基金（定开债）</h2><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/wZowEN.png"></p>
<ul>
<li>定开债相对于普通债基，其封闭阶段，可以让基金经理更有操作空间。</li>
<li>定开债，有可能存在更高杠杠率的情况（普通债基杠杠率不能超过140%，定开债是200%），通过债券A低压给银行，再去申购债券B这种模式，使得风险性增加。<blockquote>
<p>要注意的是，要追求更低风险的情况下，定开债依然要秉承着只选择纯债基的原则，这也是选择债基的原则。</p>
</blockquote>
</li>
</ul>
<h2 id="交易所市场和银行间市场"><a href="#交易所市场和银行间市场" class="headerlink" title="交易所市场和银行间市场"></a>交易所市场和银行间市场</h2><ul>
<li>交易所市场类似股票的二级市场，但是市场流动性和股市不在同一个级别；</li>
<li>银行间市场虽然流动性相对高，但是投资门槛高，老百姓玩不起；</li>
</ul>
<h1 id="混合型基金"><a href="#混合型基金" class="headerlink" title="混合型基金"></a>混合型基金</h1><ul>
<li>偏股混合型基金</li>
<li>平衡混合型基金</li>
<li>灵活配置混合型基金</li>
<li>偏债混合型基金<blockquote>
<p>平衡和灵活配置才是混合型基金的精髓，因为可以做到风险对冲</p>
</blockquote>
</li>
</ul>
<h1 id="股票型基金"><a href="#股票型基金" class="headerlink" title="股票型基金"></a>股票型基金</h1><h2 id="重要指标"><a href="#重要指标" class="headerlink" title="重要指标"></a>重要指标</h2><p>股票配置比例必须高于80%；</p>
<h2 id="投资技巧-1"><a href="#投资技巧-1" class="headerlink" title="投资技巧"></a>投资技巧</h2><h4 id="拼爹"><a href="#拼爹" class="headerlink" title="拼爹"></a>拼爹</h4><p>尽量选择大型的、知名的基金公司</p>
<h4 id="拼人"><a href="#拼人" class="headerlink" title="拼人"></a>拼人</h4><ul>
<li>基金经理，可以有三个考察维度：<ul>
<li>基金经理的基本背景（年龄、学历、履历）<ul>
<li>年龄建议至少在35岁以上；</li>
<li>学历当然无上限；</li>
<li>履历应该选择掌控对应那只基金年份更加久远的；</li>
</ul>
</li>
<li>操盘风格（短线、长线、基金偏好主题）<ul>
<li>基金每个季度都会公布一份基金报告；（在基金公司官网或者天天基金网的基金股票持仓报告中可以看出；或者在天天基金网里面的可以直接查看基金换手率， 不过这个一般每半年才公布一次，换手率50%~200%之间算正常的，超过200%算高的，说明是短线，换手率太高的要小心）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="基金偏好风格"><a href="#基金偏好风格" class="headerlink" title="基金偏好风格"></a>基金偏好风格</h4><p>基金偏好风格依然可以在天天基金网查到相关信息；<br>【晨星投资风格箱】（在晨星中国的官网上可以查到所有股票型基金和混合型基金的风格箱，在天天基金也可以查到）</p>
<h4 id="拼业绩"><a href="#拼业绩" class="headerlink" title="拼业绩"></a>拼业绩</h4><ul>
<li>基金成立的时间要足够久<ul>
<li>挑选成立三年以上的，最好是五年以上的</li>
</ul>
</li>
<li>投资领域的二手货往往比一手货更厚投资价值</li>
<li>基金的长期业绩排名波动不能太大</li>
</ul>
<h4 id="拼规模"><a href="#拼规模" class="headerlink" title="拼规模"></a>拼规模</h4><ul>
<li><p>投资中小盘基金</p>
<ul>
<li>适合挑选10~20亿规模</li>
</ul>
</li>
<li><p>投资大盘基金</p>
<ul>
<li>适合挑选30~100亿规模</li>
</ul>
</li>
</ul>
<p>超过100亿巨无霸基金，力哥建议不要；规模太小的也千万不要碰；</p>
<h4 id="拼成本"><a href="#拼成本" class="headerlink" title="拼成本"></a>拼成本</h4><ul>
<li>建议买管理费小于或者等于1.5%的股基；</li>
<li>现在各大平台的申购费基本都很低了；</li>
<li>赎回费可以考虑阶梯型征收的基金；</li>
</ul>
<h2 id="晨星风格箱"><a href="#晨星风格箱" class="headerlink" title="晨星风格箱"></a>晨星风格箱</h2><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/3nbyuN.png"></p>
<h2 id="股票型基金背后的黑幕【老鼠仓】"><a href="#股票型基金背后的黑幕【老鼠仓】" class="headerlink" title="股票型基金背后的黑幕【老鼠仓】"></a>股票型基金背后的黑幕【老鼠仓】</h2><p>股票型基金的有个臭名昭著的搞老鼠仓黑幕，基金经理利用自己作为业内人士，掌握一手咨询，可以预先自己私下个人名义买入股票，然后用客户在基金里面的大量资金去哄抬自己买入的股票，然后自己的个人仓位得以高抛，私下谋取自己的利益，代价就是广大客户来背锅！<br>而且这种现象基本是比比皆是，大大小小的基金公司做出这种恶劣行为的基本是无处不在，甚至于证券公司，保险公司也如此。</p>
<p><em><strong>最臭名昭著的就是老鼠仓马乐案</strong></em></p>
<h1 id="指数型基金"><a href="#指数型基金" class="headerlink" title="指数型基金"></a>指数型基金</h1><h2 id="何为指数"><a href="#何为指数" class="headerlink" title="何为指数"></a>何为指数</h2><p>简单来说就是一个最直观的指标可以衡量某个集体的整体水平。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/dGm6o6.png"></p>
<h2 id="各国的重要指数"><a href="#各国的重要指数" class="headerlink" title="各国的重要指数"></a>各国的重要指数</h2><p><a href="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/YfAgMV.png"></a></p>
<h2 id="国内的股票指数"><a href="#国内的股票指数" class="headerlink" title="国内的股票指数"></a>国内的股票指数</h2><h4 id="综合指数"><a href="#综合指数" class="headerlink" title="综合指数"></a>综合指数</h4><ul>
<li>上证指数(上证综指)：衡量了上交所的全部股票价格水平。</li>
<li>深证指数（深证综指）：深交所的整体股票价格水平，深交所一般是民营上市公司，偏中小型企业。</li>
</ul>
<h4 id="沪深综合指数缺点"><a href="#沪深综合指数缺点" class="headerlink" title="沪深综合指数缺点"></a>沪深综合指数缺点</h4><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/2GeXrW.png"><br>因为指数采用的是加权平均数，如果某个大盘股的股本极高，那么该股的涨跌对整体指数的影响就会很大，比如中石油这种巨头企业。<br>比如2015股灾，政府救市救市大举买入大盘蓝筹股，这些股票规模大，权重高，很快就把指数拉上来了。</p>
<h4 id="成分指数"><a href="#成分指数" class="headerlink" title="成分指数"></a>成分指数</h4><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/Xc0IE4.png"><br>成分指数的计算中一般只考虑流通股，不考虑非流通股</p>
<h6 id="以前的股市背景"><a href="#以前的股市背景" class="headerlink" title="以前的股市背景"></a>以前的股市背景</h6><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/NhbXns.png"><br>比重大的非流通股确实在上证指数里面的，这就造成了严重的失真，于是成分指数就应运而生。</p>
<h6 id="2005年的股改-支付对价"><a href="#2005年的股改-支付对价" class="headerlink" title="2005年的股改(支付对价)"></a>2005年的股改(支付对价)</h6><p>持有国有股份和法人股的大股东，想把自己手里的股票从非流通变成可流通，被允许卖掉，但是如果被允许都卖掉，造成了供大于求总体估价下跌，那么这样对原本就是可流通的小股民来说是致命打击。<br>于是大股东给出方案，就是送了小部分原本就是非流通的股票（即将要被转为可流通），这样一来，双方都有所获利，也就是支付对价，都是也不能一口气全部股改，于是又有了漫长的非流通股解禁周期（大小非解禁）<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/FBGLyf.png"></p>
<h6 id="规模指数"><a href="#规模指数" class="headerlink" title="规模指数"></a>规模指数</h6><ul>
<li>国证系列指数</li>
<li>巨潮系列指数（巨潮100指数）</li>
<li>申万xx指数</li>
<li>富时中国系列指数（富时中国A50指数）</li>
<li>道琼斯中国88指数</li>
<li>标普中国500指数</li>
</ul>
<h6 id="行业指数"><a href="#行业指数" class="headerlink" title="行业指数"></a>行业指数</h6><p>比如金融指数可细分为：银行指数、券商指数、科技金融指数等等；<br>医药指数可以细分为：生物医药指数、医疗器械指数，中药指数；<br>TMT指数：科技、媒体与通信指数；</p>
<h6 id="风格指数"><a href="#风格指数" class="headerlink" title="风格指数"></a>风格指数</h6><p>按照晨星风格箱的九宫格，可以分为九种不同风格的指数，比如：中小板300成长指数，上证180价值指数（只关注大盘价值股）；</p>
<h6 id="主题指数"><a href="#主题指数" class="headerlink" title="主题指数"></a>主题指数</h6><ul>
<li>上证龙头企业指数（就是把各行业的龙头股给单独挑出来）；</li>
<li>上证红利指数（就是把分红特别多的股票给挑出来）；</li>
<li>上证180治理指数（就是把上证180指数的成分股中把治理很好的股票挑出来）</li>
<li>新思路指数（一带一路）</li>
<li>养老指数</li>
<li>国企改革指数</li>
<li>人工智能指数</li>
</ul>
<h2 id="指数基金的重要指标"><a href="#指数基金的重要指标" class="headerlink" title="指数基金的重要指标"></a>指数基金的重要指标</h2><h4 id="优秀的指数基金"><a href="#优秀的指数基金" class="headerlink" title="优秀的指数基金"></a>优秀的指数基金</h4><p>指数基金的原理是让基金业绩尽可能地去复制指数的走势，所以，最重要的指标是看基金对指数的跟踪误差大不大，跟踪误差越小，该基金就越优秀；</p>
<blockquote>
<p>最终要的选择指数基金原则是选择，跟踪误差最小的基金</p>
</blockquote>
<p>一般跟踪误差都在0.5以内，优秀的可以在0.1%至0.05%以内。</p>
<h2 id="增强型指数基金"><a href="#增强型指数基金" class="headerlink" title="增强型指数基金"></a>增强型指数基金</h2><p>基金经理有权在一定的范围内对投资的股票进行调整.</p>
<h4 id="力哥的建议"><a href="#力哥的建议" class="headerlink" title="力哥的建议"></a>力哥的建议</h4><p>指数基金最大的优点是【便宜】,管理费最贵的是股票基金，毕竟基金经理是主动选股，但是指数基金不需要投入很大的人力在股票的挑选上，只要付指数公司的指数使用费就可以了，经理的活容易干，费率自然就低了。<br>但是增强型指数基金的管理费要比非增强型的高点，比正常的股票型基金的管理费低点。</p>
<p>指数基金一般半年才调一次仓，毕竟指数的成分股一般是不变的，<em><strong>这样有个非常大的好处，可以大大节省交易佣金和印花税，毕竟股票的交易不是免费的，因此股票型基金的换手率太大了其实是很不好的，浪费在交易中间的费用太多了</strong></em></p>
<p>所以，力哥个人一般不建议不纯粹的增强型指数基金，也呼应了之前非纯债基的挑选原则。</p>
<p>指数基因最初的设计理念是为非激进型投资者取得市场的平均投资收益，如果初衷不是不求高收益，就不应该涉足指数基金，直接刚股票或股票型基金即可。【投资就要投纯的】</p>
<h2 id="查询指数的相关资料"><a href="#查询指数的相关资料" class="headerlink" title="查询指数的相关资料"></a>查询指数的相关资料</h2><p>如果是上交所发行的就到上交所官网查询，深交所也同，中证指数也有对应官网。</p>
<h2 id="指数基金的投资标的"><a href="#指数基金的投资标的" class="headerlink" title="指数基金的投资标的"></a>指数基金的投资标的</h2><p>用通俗的话来说就是：”要选择那种把优等生挑选出来的班级”</p>
<h2 id="大数据指数基金"><a href="#大数据指数基金" class="headerlink" title="大数据指数基金"></a>大数据指数基金</h2><h4 id="BAT"><a href="#BAT" class="headerlink" title="BAT"></a>BAT</h4><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/iwvhQm.png"></p>
<h6 id="中证百度百发策略100指数"><a href="#中证百度百发策略100指数" class="headerlink" title="中证百度百发策略100指数"></a>中证百度百发策略100指数</h6><p>百发指数的成分股每个月变动一次，毕竟热点的变化很快，所以也只能跟着快速变化调整成分股。<br>正因为需要这样子快速的变动，所以基金的规模不能太大，俗话说”船小好调头”。</p>
<h6 id="百度和阿里推出的大数据指数基金的区别"><a href="#百度和阿里推出的大数据指数基金的区别" class="headerlink" title="百度和阿里推出的大数据指数基金的区别"></a>百度和阿里推出的大数据指数基金的区别</h6><ul>
<li>百发100属于情绪派</li>
<li>淘金100属于业绩派（基本面派）</li>
</ul>
<h6 id="BA的大数据指数基金实际回报"><a href="#BA的大数据指数基金实际回报" class="headerlink" title="BA的大数据指数基金实际回报"></a>BA的大数据指数基金实际回报</h6><ul>
<li>百发100指数 21%（平局每天也就每年7.7%）</li>
<li>淘金100指数 -17%</li>
</ul>
<hr>
<p>之所以如此亏损的原因有三点：</p>
<ol>
<li>大数据的管理成本比传统的指数基金更高。</li>
<li>每个月一次大换血交易成本太高，特别是在持续的大熊市期间。</li>
<li>投资者纷纷赎回。</li>
</ol>
<h4 id="电脑挑选成分股技巧"><a href="#电脑挑选成分股技巧" class="headerlink" title="电脑挑选成分股技巧"></a>电脑挑选成分股技巧</h4><ul>
<li>剔除涉嫌财务造假的股票</li>
<li>剔除涉嫌市场操纵的股票【特别是被人坐庄的股票，这样子的股票投资风险会很高】</li>
<li>选出价值被低估的股票</li>
</ul>
<h4 id="人脑挑选成分股技巧"><a href="#人脑挑选成分股技巧" class="headerlink" title="人脑挑选成分股技巧"></a>人脑挑选成分股技巧</h4><p>经由上面电脑选择后之后，大数据指数基金还需要人脑进行最后的精选阶段，人脑阶段经理只是踢掉一些个经理认为没有投资价值的股票，不会引进其他股票，而且这个排雷工作是由8个基金专家共同商议决定，8个专家本身和指数基金没有直接明显的利益关系，所以他们的评价会更加客观和全面。</p>
<h6 id="这里和增强型指数基金的区别"><a href="#这里和增强型指数基金的区别" class="headerlink" title="这里和增强型指数基金的区别"></a>这里和增强型指数基金的区别</h6><p>增强型指数基金是经理主观判断把一些个股剔除掉，然后可能会引进其他的成分股。</p>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>大数据指数基金只看股票的好坏，没有其他指标的羁绊。</li>
<li>半年一次成分股的超级大换血。【可以一次换掉几十个成分股，如果本年内原本被低估的股票被炒作起来了，那么就已经不符合大数据指数基金挑选技巧的第三条原则了，可以选择踢掉对应股票，换新的一波低价值股票进来】<ul>
<li>这其实和中国股市板块轮动的特点吻合了，一个板块炒烂了换个板块炒。</li>
</ul>
</li>
<li>不设申购费和赎回费 ，一般收取的是销售服务费（比如每年0.25%），是提前从基金净值里面扣除的，不需要额外的再次支付手续费。</li>
</ul>
<h2 id="ETF基金"><a href="#ETF基金" class="headerlink" title="ETF基金"></a>ETF基金</h2><p>Exchange Traded Funds（上市交易型开放式指数基金）<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/HJOCfM.png"><br>就是说，可以像开放式基金一样在场外的一级市场随时申购速回，也可以像普通的封闭式基金一样在场内的二级市场买卖。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/dAvqJJ.png"><br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/VTVW9J.png"></p>
<h3 id="ETF基金相比传统基金的优点"><a href="#ETF基金相比传统基金的优点" class="headerlink" title="ETF基金相比传统基金的优点"></a>ETF基金相比传统基金的优点</h3><h4 id="资金利用效率最高"><a href="#资金利用效率最高" class="headerlink" title="资金利用效率最高"></a>资金利用效率最高</h4><ul>
<li>申购：ETF基金不是直接拿钱去申购基金的，而是要拿一篮子的股票股申购</li>
<li>赎回：赎回也是一样，赎回的不是钱，而是一篮子对应的股票</li>
</ul>
<p>ETC基金在一级市场并不是买卖行为，而是交换行为，使用股票去换资金，或者用基金去换股票。交换原理如下：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/beYB9B.png"><br>只有在二级市场中才能够买卖。</p>
<h4 id="投资门槛低"><a href="#投资门槛低" class="headerlink" title="投资门槛低"></a>投资门槛低</h4><p>好比如沪深300ETF，普通投资者没有那么大的资金量去分别购买对应份额的300个成分股去兑换沪深300ETF，所以，<em><strong>ETF基金在一级市场的申购赎回更适合机构投资者。</strong></em></p>
<p>所以基金公司一般对参与ETF基金申赎业务的客户一般会有最少200万左右的资金门槛要求。指数ETF的一级市场申赎其实和我们这种捞仔没关系。</p>
<p>但是其二级市场的交易门槛就很低了，最低是以100股来交易，作为捞仔还是搞得起的。</p>
<p><em><strong>ETF基金在二级市场的买卖更加适合普通投资者</strong></em></p>
<p>机构投资者就可以在二级市场中买卖，也可以在一级市场申赎（基金与股票之间的交换）。</p>
<p><em><strong>ETF能够将仓位达到98%、99%，甚至是99.5%以上，而普通的指数基金为了应对投资者的赎回需求，一般仓位只能是90%、92%（这种情况下普通指数基金在熊市时，投资者纷纷赎回的情况下就不得不在低位卖掉股票，造成亏损或者回报折损；而在牛市中，却有可能因为投资者的纷纷申购，基金规模大幅度膨胀，但是却来不及建仓，这样基金的真实涨幅往往会跑输理论的指数涨幅，造成回报大打折扣。）；因此在牛市中，沪深300ETF就一定会比普通的跟踪沪深300指数基金涨得更多</strong></em></p>
<h4 id="管理费率低"><a href="#管理费率低" class="headerlink" title="管理费率低"></a>管理费率低</h4><p>是所有偏股型基金中最低的，投资者在二级市场中买卖ETF基金也是和买股票一样即时成交。普通的开放式指数基金是需要的等待一天才能够申购成功，赎回更是要等待几天钱才能够到账。</p>
<p>ETF的交易还是没有印花税的，一般只需要缴纳从最高千分之三到最低万分一不等。</p>
<h3 id="ETF基金的实战攻略"><a href="#ETF基金的实战攻略" class="headerlink" title="ETF基金的实战攻略"></a>ETF基金的实战攻略</h3><p>ETF基金选择依然要遵循选择规模大、成交量活跃的原则。</p>
<h4 id="套利功能"><a href="#套利功能" class="headerlink" title="套利功能"></a>套利功能</h4><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/0Zm9BH.png"></p>
<ul>
<li>折价（零售价&lt;批发价）</li>
<li>溢价（零售价&gt;批发价）</li>
</ul>
<h5 id="实时参考净值（实时参考估值）"><a href="#实时参考净值（实时参考估值）" class="headerlink" title="实时参考净值（实时参考估值）"></a>实时参考净值（实时参考估值）</h5><p>零售价和批发价的公布时间不是同步的，批发价（一级市场的净值）不是实时公布的，而是每天收盘财务审计之后，才能够给出的确切数值。</p>
<p>所以今天要买或卖ETF参考的基金净值实际上是昨天的，用过时的信息去指导当下的买卖操作，是个危险的事情，因此实时参考净值应运而生（在股市的涨涨跌跌中，后台程序自动模拟计算出基金的当下的最新净值，一般每15秒更新一次）。</p>
<p>天天基金网上就有净值估算、单位净值和累积净值。这个估算值只供估算参考，不是权威的数字。</p>
<h5 id="溢价与折价之间的买卖技巧"><a href="#溢价与折价之间的买卖技巧" class="headerlink" title="溢价与折价之间的买卖技巧"></a>溢价与折价之间的买卖技巧</h5><p><em><strong>知道实时参考净值就知道了该ETF基金当下在二级市场价格是溢价还是折价，如果市场走牛，大量投资者进场买买买，那么就会产生大幅溢价；但是这个时候有一点要注意，如果之后股价没有涨，那么当下的溢价在之后一定会回落的，到之后净值一定会下跌，倒不如在有所预判会回落之际，把基金在高溢价卖掉，美滋滋。</strong></em></p>
<p><em><strong>反过来说，如果当下股市冷冷清清，走熊了，也没杀人愿意买基金，二级市场供大于求，就会产生折价，抓住一些个有这种折价收益的ETF基金给套利套出来，因为在之后的市场回涨时，折价也是会回归的。</strong></em></p>
<h5 id="折溢价信息的查询"><a href="#折溢价信息的查询" class="headerlink" title="折溢价信息的查询"></a>折溢价信息的查询</h5><p>天天基金网根据【净值估算】和二级市场的价格做比较：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/Txgpla.png"></p>
<p>也可以直接在<a href="www.jisilu.cn">集思录</a>，点击ETF基金-&gt;溢价率(升序或降序)，即可直接查看。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/ZIehrl.png"></p>
<h5 id="折溢价指标战略（折价套利、溢价套利）"><a href="#折溢价指标战略（折价套利、溢价套利）" class="headerlink" title="折溢价指标战略（折价套利、溢价套利）"></a>折溢价指标战略（折价套利、溢价套利）</h5><ul>
<li>溢价率&gt;3% 谨慎交易</li>
<li>溢价率&gt;5% 暂停买入</li>
<li>溢价率&gt;10% 建议卖出</li>
<li>折价率&gt;3% 考虑买入</li>
<li>折价率&gt;10% 加速买入</li>
</ul>
<p>一般正常的折溢价率区间是1~2%。<br><em><strong>那些既可以在一级市场交易又可以在二级市场买卖的机构投资者，在溢价的情况下，会选择从一级市场申购大量份额，到二级市场零售卖掉，反之亦然，这种套利行为被大量的机构投资者青睐，这就是为什么ETF基金的折溢价率一般会被很快抹平。</strong></em></p>
<h3 id="ETF基金的优点"><a href="#ETF基金的优点" class="headerlink" title="ETF基金的优点"></a>ETF基金的优点</h3><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/IQW66e.png"></p>
<h3 id="中国A股市场的交易规则"><a href="#中国A股市场的交易规则" class="headerlink" title="中国A股市场的交易规则"></a>中国A股市场的交易规则</h3><p>和股票一样：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/Rjkiz5.png"><br>在开盘之前，ETF基金和股票一样采用【集合竞价模式】。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/6r8Gwv.png"><br>集合竞价规则：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/1qOJUB.png"><br>9点25分之后，就可以看到具体的成交价格和数量了，这种开盘前先集合竞价的目的，就是为了在9点半正式开盘的时候，能够产生一个当天的开盘价，给当天股市的连续竞价确定一个开始的基数。</p>
<h3 id="ETF联接基金"><a href="#ETF联接基金" class="headerlink" title="ETF联接基金"></a>ETF联接基金</h3><p>其实就是专门去买ETF基金的基金，或者叫做ETF基金的影子基金。</p>
<p><em><strong>更加准确地说，ETF联接基金就是普通的开放式基金，可以直接在场外的一级市场申购赎回。</strong></em><br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/TTbwn3.png"><br>百分之10的主动管理可以应对赎回需求。</p>
<p>因为ETF联接基金90%以上投资的ETF基金已经征收过管理费和托管费了，所以是不能够再次征收管理费和托管费的，只有剩下不到10%的主动管理的基金资产才能收取两个费用。</p>
<p>所以，ETF联接基金的持有成本，只比ETF基金高一点点，还是比普通的指数基金低很多。</p>
<h4 id="ETF联接基金的优势"><a href="#ETF联接基金的优势" class="headerlink" title="ETF联接基金的优势"></a>ETF联接基金的优势</h4><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/Rff1ix.png"><br>所以，买普通的沪深300指数基金，不如买沪深300ETF联接基金。</p>
<h4 id="ETF基金-vs-ETF联接基金"><a href="#ETF基金-vs-ETF联接基金" class="headerlink" title="ETF基金 vs ETF联接基金"></a>ETF基金 vs ETF联接基金</h4><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/ogm1hU.png"><br>普通的ETF基金的买卖操作需要和股票一样，要实时跟踪，费时费力，工作学习繁忙的投资者还是得选择ETF联接基金，可以自动设置定投。<br><a href="https://zhuanlan.zhihu.com/p/108820033">知乎大佬分析ETF和ETF联接的区别</a></p>
<blockquote>
<p>买普通的沪深300指数基金，其实不如买其ETF基金</p>
</blockquote>
<h2 id="LOF基金"><a href="#LOF基金" class="headerlink" title="LOF基金"></a>LOF基金</h2><p>和ETF基金一样，全称Listed Open-ended Fund（上市型开放基金）<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/e2dDfW.png"><br>LOF基金本质上就是一个开放式基金，但是它却可以在二级市场上交易，也可以同时在一级市场申购赎回。（二级市场成本更低，可以玩折价溢价的玩法）</p>
<p><em><strong>LOF基金同时具备了ETF基金和ETF连接基金的优点</strong></em></p>
<h3 id="LOF-vs-ETF"><a href="#LOF-vs-ETF" class="headerlink" title="LOF vs ETF"></a>LOF vs ETF</h3><p>ETF是指数基金，而LOF基金可以是指数、股票、混合甚至是债券型等等</p>
<h4 id="基金代码不同"><a href="#基金代码不同" class="headerlink" title="基金代码不同"></a>基金代码不同</h4><p>基金代码开头不一样：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/T9X3SX.png"><br>今天市场上的LOF基金主要都是在深交所上市的。</p>
<h3 id="LOF基金套利实战"><a href="#LOF基金套利实战" class="headerlink" title="LOF基金套利实战"></a>LOF基金套利实战</h3><p>LOF和ETF一样，也可以同时在场外和场内两个市场交易，两个市场会出现价格差，除开手续费之后，如果还有赚头，那就可以实行套利了。</p>
<h4 id="LOF溢价套利"><a href="#LOF溢价套利" class="headerlink" title="LOF溢价套利"></a>LOF溢价套利</h4><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/wbsjQW.png"></p>
<h4 id="LOF折价套利"><a href="#LOF折价套利" class="headerlink" title="LOF折价套利"></a>LOF折价套利</h4><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/1ze3wi.png"></p>
<blockquote>
<p>跨市场的套利流程总共要5个交易日（比如，从天天基金到东方财富之间转托管的方式进行的套利），而直接在证券账户体系内完成的套利体系就更快一些了，只要3个交易日。</p>
</blockquote>
<h2 id="QDII"><a href="#QDII" class="headerlink" title="QDII"></a>QDII</h2><h3 id="QDII-ETF"><a href="#QDII-ETF" class="headerlink" title="QDII-ETF"></a>QDII-ETF</h3><h3 id="QDII-LOF"><a href="#QDII-LOF" class="headerlink" title="QDII-LOF"></a>QDII-LOF</h3><h1 id="Common-Basic-Knowledge"><a href="#Common-Basic-Knowledge" class="headerlink" title="Common Basic Knowledge"></a>Common Basic Knowledge</h1><h2 id="四四三三法则"><a href="#四四三三法则" class="headerlink" title="四四三三法则"></a>四四三三法则</h2><h2 id="基金分红"><a href="#基金分红" class="headerlink" title="基金分红"></a>基金分红</h2><blockquote>
<p>基金的分红与股票的分红是截然不同的</p>
</blockquote>
<ul>
<li>基金不分红留在基金里面，净值不降低，钱依然是申购者的；</li>
<li>股票不分红，那就是对应上市公司自家的，和股民无关；</li>
</ul>
<h4 id="基金分红方式"><a href="#基金分红方式" class="headerlink" title="基金分红方式"></a>基金分红方式</h4><ul>
<li>现金分红；</li>
<li>红利在投资；</li>
</ul>
<h2 id="基金的重要指标"><a href="#基金的重要指标" class="headerlink" title="基金的重要指标"></a>基金的重要指标</h2><ol>
<li>累计净值（平时一般说的净值是单位净值，就是把历次所有分红收益都剔除掉之后当下的净值；一些新基金可能单位净值和累计净值一样，但是老基金分红多次之后，两个值可能相差很大）</li>
<li>单位净值（也就是净值，单位净值&#x3D;（总资产－总负债）&#x2F;基金总份额）</li>
<li>分红与否、基金单位净值高低与基金好坏没有必然联系</li>
</ol>
<h2 id="负相关"><a href="#负相关" class="headerlink" title="负相关"></a>负相关</h2><p>理论上以下关系较大概率是负相关（不排除出现正相关的情况）：</p>
<ul>
<li>股票–债券</li>
<li>股票–房子</li>
<li>存款–债券</li>
<li>美元–黄金</li>
<li>美元–石油</li>
<li>美元–日元</li>
<li>美元–比特币</li>
</ul>
<h2 id="最专业最中立的三家基金评级机构"><a href="#最专业最中立的三家基金评级机构" class="headerlink" title="最专业最中立的三家基金评级机构"></a>最专业最中立的三家基金评级机构</h2><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/DDh3G4.png"></p>
<h2 id="基金业绩评价基准"><a href="#基金业绩评价基准" class="headerlink" title="基金业绩评价基准"></a>基金业绩评价基准</h2><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/ocja4B.png"></p>
<ul>
<li><p>基金KPI</p>
<ul>
<li>根据基金自身特性定制的考核标准</li>
</ul>
</li>
<li><p>β系数 &#x3D; 1 代表基金真实业绩表现和业绩比较基准重合（β系数是对一个基金所承受的系统性风险的量化表达，可以理解为收益弹性有多大）</p>
</li>
<li><p>β系统越高，基金随市场涨跌幅度越大，反之越小</p>
</li>
</ul>
<h2 id="基金公司"><a href="#基金公司" class="headerlink" title="基金公司"></a>基金公司</h2><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/oIJv1r.png"></p>
<blockquote>
<p>只有红框的七家被评为五星公司</p>
</blockquote>
<h2 id="利率"><a href="#利率" class="headerlink" title="利率"></a>利率</h2><p>利率&#x3D;利息÷本金÷时间×100%，如果说年利率的话，就是将公式的时间换成一年<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/771OZU.png"></p>
<h4 id="年化率"><a href="#年化率" class="headerlink" title="年化率"></a>年化率</h4><p>年化收益率&#x3D;（投资内收益&#x2F;本金）&#x2F;（投资天数&#x2F;365）×100%</p>
<h2 id="马克维兹的资产组合理论"><a href="#马克维兹的资产组合理论" class="headerlink" title="马克维兹的资产组合理论"></a>马克维兹的资产组合理论</h2><h2 id="基金的重要选择指标"><a href="#基金的重要选择指标" class="headerlink" title="基金的重要选择指标"></a>基金的重要选择指标</h2><p><em><strong>一般应该要选择三高基金（α系数、R平方还有夏普指数高的）</strong></em></p>
<hr>
<h4 id="β系数"><a href="#β系数" class="headerlink" title="β系数"></a>β系数</h4><ul>
<li>高β策略（高波策略）<ul>
<li>比较适合激进型的投资者</li>
</ul>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/H6JVsQ.png"></p>
<blockquote>
<p>对应的镜像策略是：低β策略，也叫低波策略</p>
</blockquote>
<h4 id="α系数"><a href="#α系数" class="headerlink" title="α系数"></a>α系数</h4><p>代表一个基金的绝对回报或超额收益，通常是基金经理的择时或选股的高超水平获得的<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/O9o50V.png"></p>
<h4 id="基金的真实收益"><a href="#基金的真实收益" class="headerlink" title="基金的真实收益"></a>基金的真实收益</h4><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/KThPuP.png"></p>
<h4 id="夏普指数"><a href="#夏普指数" class="headerlink" title="夏普指数"></a>夏普指数</h4><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/sh2GwL.png"><br>夏普比率是评价基金优劣的最重要的标准化指标，夏普比率越高，基金性价比越高，越值得拥有。</p>
<h4 id="R平方"><a href="#R平方" class="headerlink" title="R平方"></a>R平方</h4><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/i7tQ5j.png"></p>
<h4 id="特雷诺指数"><a href="#特雷诺指数" class="headerlink" title="特雷诺指数"></a>特雷诺指数</h4><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/krld92.png"></p>
<h4 id="一级市场和二级市场的区别"><a href="#一级市场和二级市场的区别" class="headerlink" title="一级市场和二级市场的区别"></a>一级市场和二级市场的区别</h4><p>所谓的一级市场和二级市场，可以说指的是金融市场，交易的是金融产品包括股票、股权，债券、债权，期货、远期协议等等。</p>
<h5 id="一级市场"><a href="#一级市场" class="headerlink" title="一级市场"></a>一级市场</h5><p>也称发行市场或初级市场，是资本需求者将证券首次出售给公众时形成的市场。它是新证券和票据等金融工具的买卖市场。该市场的主要经营者是投资银行、经纪人和证券自营商(在我国这三种业务统一于证券公司)。它们承担政府、公司新发行的证券以及承购或分销股票。</p>
<p>在企业的股权未进入标准化的市场流通之前，都应该属于一级市场的范畴。以股票为例，对于我国A股而言，我们常说的IPO就是在一级市场进行的。对IPO之前企业的投资（例如VC、PE等私募股权投资）一般也称为一级市场投资。这时主要参与通过是机构投资者，投资的机构股权方面有私募基金、投资银行等等。</p>
<p>这时公司股权的溢价很难体现，只能靠公司的盈利体现，而且流通性也很有限。当企业进行一系列的经过一系列流程标准化之后，进入到证券交易场所流通，这时便是进入二级市场了，具体交易标的可以是股票、债券、公募基金等。</p>
<h5 id="二级市场"><a href="#二级市场" class="headerlink" title="二级市场"></a>二级市场</h5><p>是指在证券发行后各种证券在不同的投资者之间买卖流通所形成的市场，又称流通市场或次级市场。比如上海证券交易所和深圳证券交易所就属于二级市场。在二级市场上销售证券的收入属于出售证券的投资者，而不属于发行该证券的公司。</p>
<p>可以说二级市场是变现场所，在企业的股权、债券未实现标准化之前，那么投资银行、私募基金看中未来的升值空间，买下其中一些股权、债权等，到了企事业达到标准化的标准之后，股权成为股票的形式，便可以在二级市场进行交易，所以一级市场有时也叫初级市场，二级市场是一级市场投资得以存在和发展的条件。</p>
<p>如果没有二级市场的存在，证券不具备流通性和溢价，就不会有大量的投资者来参与，一级的投资者就没有“接盘侠”。否则那些投资者就不愿意买这些证券。</p>
<h4 id="场内vs场外"><a href="#场内vs场外" class="headerlink" title="场内vs场外"></a>场内vs场外</h4><p><a href="https://zhuanlan.zhihu.com/p/115616502">知乎大佬的通透解析</a></p>
<h4 id="基金场外转场内（转托管）"><a href="#基金场外转场内（转托管）" class="headerlink" title="基金场外转场内（转托管）"></a>基金场外转场内（转托管）</h4><p><a href="https://xueqiu.com/3586445630/143970093">基金场外转场内（转托管）专题指南2020</a><br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/uFIOx5.png"></p>
<h2 id="未来基金市场的宏观发展"><a href="#未来基金市场的宏观发展" class="headerlink" title="未来基金市场的宏观发展"></a>未来基金市场的宏观发展</h2><p>如果没有灰犀牛出现的情况下，P2P时代的终结之后，中国的基金会迎来相对漫长的一个利好阶段，美国上个世纪经济高速增长了40年后，从80年代开始资产利率就开始降下来了，中国基本上也会是这样子的，所以资产利率降下来也是P2P一类没落终结的一大原因。<br>固定收益利率的降低会导致老百姓的资产向浮动收益类的资产（最典型的就是公募基金）靠拢，比如在美国历史上，1982的公募基金只有3000亿美元，1992已经变成1.64万亿美元了，到了2002年已经到了6.4万亿美元了，由此也可以预见中国基金市场未来的走向。</p>
]]></content>
      <categories>
        <category>理财</category>
      </categories>
      <tags>
        <tag>理财</tag>
        <tag>基金</tag>
      </tags>
  </entry>
  <entry>
    <title>Java系列之JDK&amp;JVM</title>
    <url>/2020/03/31/Java%E7%B3%BB%E5%88%97%E4%B9%8BJDK&amp;JVM/</url>
    <content><![CDATA[<blockquote>
<p>自己总结的思维导图笔记<a href="JVM%EF%BC%88HotSpot%EF%BC%89">JVM（HotSpot）</a><br><a href="https://bugs.openjdk.java.net/projects/JDK/issues">OpenJDK Issues List</a></p>
</blockquote>
<h1 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h1><h2 id="美团Java面试7连问"><a href="#美团Java面试7连问" class="headerlink" title="美团Java面试7连问"></a>美团Java面试7连问</h2><p><a href="https://zhuanlan.zhihu.com/p/114157783">马士兵老师的讲解</a></p>
<h3 id="对象的定位方式"><a href="#对象的定位方式" class="headerlink" title="对象的定位方式"></a>对象的定位方式</h3><h4 id="句柄方式"><a href="#句柄方式" class="headerlink" title="句柄方式"></a>句柄方式</h4><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/QUtvd4.png"></p>
<h4 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h4><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/7BWN68.png"></p>
<h3 id="句柄方式-vs-直接指针"><a href="#句柄方式-vs-直接指针" class="headerlink" title="句柄方式 vs 直接指针"></a>句柄方式 vs 直接指针</h3><p>后者的效率更高，但是当GC挪动对象的时候，前者效率更高。（上图中，前者GC挪动存活对象和清理垃圾对象的时候，t的指针不需要变）</p>
<h3 id="对象怎么分配"><a href="#对象怎么分配" class="headerlink" title="对象怎么分配"></a>对象怎么分配</h3><h3 id="OOP-KLASS模型"><a href="#OOP-KLASS模型" class="headerlink" title="OOP-KLASS模型"></a>OOP-KLASS模型</h3><h2 id="Java三种编译方式：前端编译-JIT编译（即时编译）-AOT编译"><a href="#Java三种编译方式：前端编译-JIT编译（即时编译）-AOT编译" class="headerlink" title="Java三种编译方式：前端编译 JIT编译（即时编译） AOT编译"></a>Java三种编译方式：前端编译 JIT编译（即时编译） AOT编译</h2><p><a href="https://blog.csdn.net/tjiyu/article/details/53748965">https://blog.csdn.net/tjiyu/article/details/53748965</a></p>
<h2 id="java的nio"><a href="#java的nio" class="headerlink" title="java的nio"></a>java的nio</h2><h2 id="Java的AOT、JIT（Just-in-time-x2F-即时编译）"><a href="#Java的AOT、JIT（Just-in-time-x2F-即时编译）" class="headerlink" title="Java的AOT、JIT（Just in time&#x2F;即时编译）"></a>Java的AOT、JIT（Just in time&#x2F;即时编译）</h2><h2 id="Java内存（映像）分析工具（hprof文件分析工具）"><a href="#Java内存（映像）分析工具（hprof文件分析工具）" class="headerlink" title="Java内存（映像）分析工具（hprof文件分析工具）"></a>Java内存（映像）分析工具（hprof文件分析工具）</h2><p><a href="https://youzhixueyuan.com/jvm-performance-analysis-tool.html">https://youzhixueyuan.com/jvm-performance-analysis-tool.html</a><br>目前主流有四大工具：</p>
<ul>
<li>JConsole（JDK自带，功能简单）</li>
<li>VisualVM（JDK自带，功能强大）</li>
<li>JProfiler（商业软件，功能强大）</li>
<li>MAT（基于Eclipse）</li>
</ul>
<h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><h3 id="jar"><a href="#jar" class="headerlink" title="jar"></a>jar</h3><p>list the files in the jar.</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jar -tf xxx.jar</span><br></pre></td></tr></table></figure>
<p>解压jar包：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jar xvf xxx.jar</span><br></pre></td></tr></table></figure>
<h3 id="javap（The-Java-Class-File-Disassembler、Java-class文件反编译程序、分析Class文件字节码的工具）"><a href="#javap（The-Java-Class-File-Disassembler、Java-class文件反编译程序、分析Class文件字节码的工具）" class="headerlink" title="javap（The Java Class File Disassembler、Java class文件反编译程序、分析Class文件字节码的工具）"></a>javap（The Java Class File Disassembler、Java class文件反编译程序、分析Class文件字节码的工具）</h3><p>解压jar包，并反编译class输入到txt文件查看</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">unzip Classes.jar</span><br><span class="line">find . -name &#x27;*.class&#x27; | xargs javap -p &gt; classes.txt</span><br></pre></td></tr></table></figure>
<h3 id="查找命令所在目录"><a href="#查找命令所在目录" class="headerlink" title="查找命令所在目录"></a>查找命令所在目录</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">where java</span><br><span class="line">where javac</span><br><span class="line">where jar</span><br><span class="line">where jvisualvm</span><br><span class="line"># where也可以换成which</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>PTE考试准备</title>
    <url>/2020/03/30/PTE%E8%80%83%E8%AF%95%E5%87%86%E5%A4%87/</url>
    <content><![CDATA[<h1 id="TodoItem"><a href="#TodoItem" class="headerlink" title="TodoItem"></a>TodoItem</h1><h1 id="重要的备忘录"><a href="#重要的备忘录" class="headerlink" title="重要的备忘录"></a>重要的备忘录</h1><h2 id="模拟考网站"><a href="#模拟考网站" class="headerlink" title="模拟考网站"></a>模拟考网站</h2><p><a href="https://ptepractice.com/">https://ptepractice.com</a></p>
<h2 id="官方的在线练习题目"><a href="#官方的在线练习题目" class="headerlink" title="官方的在线练习题目"></a>官方的在线练习题目</h2><p>Scored Practice Tests??</p>
<h2 id="youtube资源"><a href="#youtube资源" class="headerlink" title="youtube资源"></a>youtube资源</h2><p>E2 PTE Academic</p>
<h2 id="英语流利说"><a href="#英语流利说" class="headerlink" title="英语流利说"></a>英语流利说</h2><h2 id="大澳学院-微信公众号"><a href="#大澳学院-微信公众号" class="headerlink" title="大澳学院-微信公众号"></a>大澳学院-微信公众号</h2><h1 id="考试内容"><a href="#考试内容" class="headerlink" title="考试内容"></a>考试内容</h1><p><a href="https://zhuanlan.zhihu.com/p/47240655">参考</a></p>
]]></content>
      <categories>
        <category>PTE</category>
      </categories>
      <tags>
        <tag>PTE</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring系列之SpringWebFlux</title>
    <url>/2020/04/25/Spring%E7%B3%BB%E5%88%97%E4%B9%8BSpringWebFlux/</url>
    <content><![CDATA[<h1 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h1><h2 id="Http请求的总入口"><a href="#Http请求的总入口" class="headerlink" title="Http请求的总入口"></a>Http请求的总入口</h2><p>org.springframework.web.reactive.DispatcherHandler.handle</p>
<h2 id="HandlerFunction-vs-RouterFunction"><a href="#HandlerFunction-vs-RouterFunction" class="headerlink" title="HandlerFunction vs RouterFunction"></a>HandlerFunction vs RouterFunction</h2><p>参考自：<a href="https://www.baeldung.com/spring-5-functional-web">https://www.baeldung.com/spring-5-functional-web</a></p>
<h3 id="HandlerFunction"><a href="#HandlerFunction" class="headerlink" title="HandlerFunction"></a>HandlerFunction</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface HandlerFunction&lt;T extends ServerResponse&gt; &#123;</span><br><span class="line">    Mono&lt;T&gt; handle(ServerRequest request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个接口的实现其实类似servlet，如果和标准的Servlet.service(ServletRequest req, ServletResponse res)比对的话，HandlerFunction返回的是一个响应，而不是将和Servlet一样，将ServerResponse作为参数，这样子几乎没有副作用，而且更方便测试和重用。</p>
<h3 id="RouterFunction"><a href="#RouterFunction" class="headerlink" title="RouterFunction"></a>RouterFunction</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@FunctionalInterface</span><br><span class="line">public interface RouterFunction&lt;T extends ServerResponse&gt; &#123;</span><br><span class="line">    Mono&lt;HandlerFunction&lt;T&gt;&gt; route(ServerRequest request);</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static &lt;T extends ServerResponse&gt; RouterFunction&lt;T&gt; route(</span><br><span class="line">  RequestPredicate predicate,</span><br><span class="line">  HandlerFunction&lt;T&gt; handlerFunction)</span><br></pre></td></tr></table></figure>
<p>通常使用RouterFunctions.route()来绑定路由和HandlerFunction的实现，可以结合WebTestClient来做测试。</p>
<h1 id="Problem-Solution"><a href="#Problem-Solution" class="headerlink" title="Problem Solution"></a>Problem Solution</h1><h2 id="CSRF-Token-has-been-associated-to-this-client"><a href="#CSRF-Token-has-been-associated-to-this-client" class="headerlink" title="CSRF Token has been associated to this client"></a>CSRF Token has been associated to this client</h2><p>今天出现了个奇葩的前端调用SpringGateway网关的错误，网上搜寻了片刻发现没有别人有过和我类似的案例。<br>于是我打算从HttpServlet总入口跟进问题，但是我忘了SpringGateway默认是使用SpringWebFlux的，和SpringMVC没有什么关系了。。。<br>然后全局搜索一下Spring的源码”CSRF Token has been associated to this client”，才意识到要换个入口来跟踪问题。</p>
<p>然而当我把入口换成org.springframework.web.reactive.DispatcherHandler去跟踪发现也不能进入断点，经常一番搜索和研究（因为我对WebFlux基本没用过）<br>发现是WebFlux的安全校验配置没有放开，为了测试我方面，我暂时先这样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@EnableWebFluxSecurity</span><br><span class="line">public class SecurityConfig &#123;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http) &#123;</span><br><span class="line">        return http</span><br><span class="line">                .authorizeExchange()</span><br><span class="line">                .anyExchange()</span><br><span class="line">                .permitAll()</span><br><span class="line">                .and()</span><br><span class="line">                .csrf()</span><br><span class="line">                .disable()</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总结得出：当挖掘源码还不能解决的问题，只能硬着头皮翻遍网上的解决方案，如若还不行就只能去通读官方的文档了，当然，有时间和条件还是要先通读官方文档再来上手。</p>
]]></content>
      <categories>
        <category>Spring</category>
        <category>Spring WebFlux</category>
      </categories>
      <tags>
        <tag>Spring</tag>
        <tag>Spring WebFlux</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之名词</title>
    <url>/2020/04/09/English%E7%B3%BB%E5%88%97%E4%B9%8B%E5%90%8D%E8%AF%8D/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记摘选自张满胜老师的《英语语法新思维初级教程通悟语法第2版》，以及其他网上知识点收集，只是我自己的个人复习笔记，禁止转载，如有侵权，请联系我删除。</p>
</blockquote>
<h1 id="名词"><a href="#名词" class="headerlink" title="名词"></a>名词</h1><h2 id="名词短语"><a href="#名词短语" class="headerlink" title="名词短语"></a>名词短语</h2><p>名词短语是由名词与它的修饰语一起构成的。名词的修饰语与名词的位置关系不外乎两种：一是放在被修饰名词的前面，我们称之为前置定语或定语；二是放在被修饰名词的后面，我们称之为后置定语。<br>一般来讲，名词前面有两种修饰语。其一是限定词，用来限定名词所指的范围，对名词起泛指或特指、定量或不定量等限定修饰作用。<br>其二是形容词，是用来表示名词的性质和特征的。</p>
<h3 id="左二右六公式"><a href="#左二右六公式" class="headerlink" title="左二右六公式"></a>左二右六公式</h3><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/4wFyg3.png"></p>
<h3 id="汉语和英语很大的基本差别"><a href="#汉语和英语很大的基本差别" class="headerlink" title="汉语和英语很大的基本差别"></a>汉语和英语很大的基本差别</h3><p>汉语的定语一律是在名词的前面，而英语的定语有在名词前面的，也有在名词后面的，更多的定语是置于被修饰名词的后面，构成后置定语。</p>
<h2 id="名词的分类"><a href="#名词的分类" class="headerlink" title="名词的分类"></a>名词的分类</h2><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/z9DC7y.png"></p>
<h2 id="不可数名词的规律"><a href="#不可数名词的规律" class="headerlink" title="不可数名词的规律"></a>不可数名词的规律</h2><h3 id="第一组"><a href="#第一组" class="headerlink" title="第一组"></a>第一组</h3><p>对于一些无法分割的名词，我们将其看作一个整体，因而作为不可数名词，没有复数变化（Nouns that have no distinct, separate parts, we look as the whole.）。这样的名词主要是一些物质名词，如：</p>
<ul>
<li>气体：air, fog, oxygen, smoke等。 </li>
<li>液体：beer, blood, coffee, cream, gasoline, honey, juice, milk, oil, tea, water, wine等。</li>
<li>固体：bread, butter, cheese, ice, ice cream, meat, beef （牛肉）, chicken （鸡肉）, fish （鱼肉）, chalk, copper, cotton, glass, gold, iron, paper等。</li>
</ul>
<h3 id="第二组"><a href="#第二组" class="headerlink" title="第二组"></a>第二组</h3><p>一些因其组成部分太小而不易数的名词（nouns that have parts that are too small or insignificant to count）用作不可数名词。也主要是一些物质名词。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/KDwqsP.png"></p>
<h3 id="第三组"><a href="#第三组" class="headerlink" title="第三组"></a>第三组</h3><p>表示总称的名词（nouns that are classes or categories of things）通常不可数。这些名词侧重于表示某类事物的总的概念，而不 是具体的事物。如果要具体指出该总称概念下的具体事物，则要用其他 不同的名词。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/bI6jfs.png"></p>
<h3 id="第四组"><a href="#第四组" class="headerlink" title="第四组"></a>第四组</h3><p>抽象的名词（nouns that are abstractions）一般是不可数的。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/RrA2QT.png"></p>
<h3 id="第五组"><a href="#第五组" class="headerlink" title="第五组"></a>第五组</h3><p>表示研究学科（subjects of study），一般作为不可数名词。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/XGLt37.png"></p>
<h2 id="可数与不可数的“相对论”"><a href="#可数与不可数的“相对论”" class="headerlink" title="可数与不可数的“相对论”"></a>可数与不可数的“相对论”</h2><h3 id="规律一"><a href="#规律一" class="headerlink" title="规律一"></a>规律一</h3><p>对于物质名词或总称的名词，若是表示不同的种类，或者因为特定的意思，或者是液体表示“几杯”或“几瓶”这样的数量，则转化为可数名词。</p>
<h3 id="规律二"><a href="#规律二" class="headerlink" title="规律二"></a>规律二</h3><p>对于抽象名词，若是具体化了，则转化为可数名词。 并且，此时往往伴随着词义上或大或小的改变。比如art（艺术）&#x2F;an art（一项技术，一门特定的艺术）；beauty（美丽）&#x2F;a beauty（一个美人）；youth（青春）&#x2F;a youth（一个年轻人）。</p>
<h3 id="规律三"><a href="#规律三" class="headerlink" title="规律三"></a>规律三</h3><ul>
<li>从更广泛的意义上来说，当一个名词表示抽象的、总称的概念（abstract or generic concept）时，一般作为不可数名词来用。</li>
<li>而当它表示具体的、特定的事物（concrete or particular things）时，则通常用作可数名词。这就是为什么词典中对于某个单词的某一词义，后面标注的既是可数，也是不可数。此时关键要看如何使用这个词义，如果是当作具体的事物来看，则是可数；如果是当作一个概念来看，则是不可数。</li>
</ul>
<h3 id="规律四【自己总结的】"><a href="#规律四【自己总结的】" class="headerlink" title="规律四【自己总结的】"></a>规律四【自己总结的】</h3><p>一些抽象的名词之所以是不可数，那是因为其抽象的概念中包含的成分是不可以被分割出来基数的，好比如：<br>experience（经验），他人可以传授一些经验给我们，但是这些经验是无法去细分来数数说有多少条经验，这个无法数数不是从数字意义上去理解之。<br>而是要从经验要怎么被具体量化的问题，好比如他人给我们的经验中由几句话组成，我们从中抽取任何一句完整的话，这句话依然可以是经验，那么这就是英文思维中的不可数了。<br>同理，advice（建议）也是不可数。反之，比如说chair（椅子）为什么可数，是因为椅子很具体，你单独拆分一个椅子脚不能说它还是椅子。</p>
<h2 id="名词的单数和复数"><a href="#名词的单数和复数" class="headerlink" title="名词的单数和复数"></a>名词的单数和复数</h2><h3 id="只用作复数的名词"><a href="#只用作复数的名词" class="headerlink" title="只用作复数的名词"></a>只用作复数的名词</h3><h4 id="“二合一”的复数名词"><a href="#“二合一”的复数名词" class="headerlink" title="“二合一”的复数名词"></a>“二合一”的复数名词</h4><ol>
<li>工具和仪器<br>glasses、spectacles、binoculars、scales、clippers、forceps、pincers、tongs、tweezers、scissors、shears<br>2、服装<br>jeans、trousers、shorts、trunks、briefs、pants、slacks、pajamas<blockquote>
<p>对于这些名词，要说明数量，我们往往要用pair（如a pair of）表示。</p>
</blockquote>
</li>
</ol>
<h3 id="“单形复义”的名词"><a href="#“单形复义”的名词" class="headerlink" title="“单形复义”的名词"></a>“单形复义”的名词</h3><p>有些名词虽然没有复数的标记，但用作复数，即形式上是单数但是 表达复数的意义。比如：people、cattle、 police、 poultry、livestock。</p>
<p>作为“人们，人民”的意思时，它相当于person的复数形式；但是，如果people用作别的意思，比如当“民族”或“部族”讲时，那就是一个普通名词，有单复数的变化。比如单数要用不定冠词a修饰，即a people（一个民族），复数要在词尾加-s，即peoples。</p>
<ul>
<li>The Chinese are an industrious people. 中华民族是一个勤劳的民族。</li>
<li>the English-speaking peoples 说英语的民族。</li>
</ul>
<h3 id="“the-形容词”——表示一类人的复数名词"><a href="#“the-形容词”——表示一类人的复数名词" class="headerlink" title="“the+形容词”——表示一类人的复数名词"></a>“the+形容词”——表示一类人的复数名词</h3><h3 id="复数专有名词"><a href="#复数专有名词" class="headerlink" title="复数专有名词"></a>复数专有名词</h3><p>在英文中，有些专有名词只用作复数。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/BFHY7l.png"></p>
<h3 id="自我总结"><a href="#自我总结" class="headerlink" title="自我总结"></a>自我总结</h3><p>一个不可数名词在句子中作为单数还是负数主要看的是名词在句子中具体的含义，某些含义要当成单数，某些含义要当成负数。</p>
<h2 id="规则的复数名词"><a href="#规则的复数名词" class="headerlink" title="规则的复数名词"></a>规则的复数名词</h2><h3 id="一般在词尾加-s"><a href="#一般在词尾加-s" class="headerlink" title="一般在词尾加-s"></a>一般在词尾加-s</h3><h3 id="以-s-x-ch-sh结尾的名词加-es"><a href="#以-s-x-ch-sh结尾的名词加-es" class="headerlink" title="以-s, -x, -ch, -sh结尾的名词加-es"></a>以-s, -x, -ch, -sh结尾的名词加-es</h3><p>比如：class&#x2F;classes, box&#x2F;boxes, match&#x2F;matches, bush&#x2F;bushes等。 特别注意：以-ch结尾的名词，若-ch发&#x2F;k&#x2F;音，则加-s，例如： stomach&#x2F;stomachs。</p>
<h3 id="以“辅音字母-y”结尾的名词，变-y为-i，再加-es；而以“元音字母-y”结尾的名词，则加-s"><a href="#以“辅音字母-y”结尾的名词，变-y为-i，再加-es；而以“元音字母-y”结尾的名词，则加-s" class="headerlink" title="以“辅音字母+y”结尾的名词，变-y为-i，再加-es；而以“元音字母 +y”结尾的名词，则加-s"></a>以“辅音字母+y”结尾的名词，变-y为-i，再加-es；而以“元音字母 +y”结尾的名词，则加-s</h3><h3 id="有关以-o结尾的名词"><a href="#有关以-o结尾的名词" class="headerlink" title="有关以-o结尾的名词"></a>有关以-o结尾的名词</h3><p>这类名词的单数变复数稍微有些复杂，因为有的是加-es，有的是 加-s，而有的是加-es或-s均可。</p>
<p>些一般是以“辅音字母+o”结尾的外来词或缩写词加-s。另外还有 以“元音字母+o”结尾的名词变复数也是加-s。</p>
<p>少数名词后加-s或加-es均可：</p>
<ul>
<li>memento&#x2F;memento(e)s（纪念品）</li>
<li>motto&#x2F;motto(e)s（座右铭）</li>
<li>volcano&#x2F;volcano(e)s（火山）</li>
<li>manifesto&#x2F;manifesto(e)s（宣言）</li>
</ul>
<h3 id="有关以-f或-fe结尾的名词"><a href="#有关以-f或-fe结尾的名词" class="headerlink" title="有关以-f或-fe结尾的名词"></a>有关以-f或-fe结尾的名词</h3><ul>
<li>一般变f, fe为v，再加-es。</li>
</ul>
<h4 id="也有直接加-s的"><a href="#也有直接加-s的" class="headerlink" title="也有直接加-s的"></a>也有直接加-s的</h4><p>belief&#x2F;beliefs（信仰） chief&#x2F;chiefs（首领）</p>
<p>cliff&#x2F;cliffs（悬崖） proof&#x2F;proofs（证据） </p>
<p>reef&#x2F;reefs（暗礁） roof&#x2F;roofs（屋顶） </p>
<p>safe&#x2F;safes（保险箱）</p>
<blockquote>
<p>另外要注意：beef（牛肉）&#x2F;beefs（牢骚，抱怨）&#x2F;beeves（肉用牛， &#x3D;beef cattle）</p>
</blockquote>
<h2 id="不规则的复数名词"><a href="#不规则的复数名词" class="headerlink" title="不规则的复数名词"></a>不规则的复数名词</h2><p>最熟悉的应该是man&#x2F;men, woman&#x2F;women以及child&#x2F;children。</p>
<h3 id="以-a结尾的拉丁语名词，词尾变为-ae或-as（少数词）"><a href="#以-a结尾的拉丁语名词，词尾变为-ae或-as（少数词）" class="headerlink" title="以-a结尾的拉丁语名词，词尾变为-ae或-as（少数词）"></a>以-a结尾的拉丁语名词，词尾变为-ae或-as（少数词）</h3><p>alga&#x2F;algae（海藻） alumna&#x2F;alumnae（女校友，女毕业生） antenna&#x2F;antennae&#x2F;antennas（天线） </p>
<p>formula&#x2F;formulae&#x2F;formulas（公 式）larva&#x2F;larvae&#x2F;larvas（幼虫）</p>
<h3 id="以-ex或-ix结尾的拉丁语名词，在词尾直接加-es，或把-ex和-ix变-为-ices"><a href="#以-ex或-ix结尾的拉丁语名词，在词尾直接加-es，或把-ex和-ix变-为-ices" class="headerlink" title="以-ex或-ix结尾的拉丁语名词，在词尾直接加-es，或把-ex和-ix变 为-ices"></a>以-ex或-ix结尾的拉丁语名词，在词尾直接加-es，或把-ex和-ix变 为-ices</h3><p>apex&#x2F;apexes&#x2F;apices（顶点，最高点） appendix&#x2F;appendixes&#x2F;appendices（附录；阑尾） </p>
<p>index&#x2F;indexes&#x2F;indices（索引）</p>
<h3 id="以-is结尾的希腊语名词，变-is为-es"><a href="#以-is结尾的希腊语名词，变-is为-es" class="headerlink" title="以-is结尾的希腊语名词，变-is为-es"></a>以-is结尾的希腊语名词，变-is为-es</h3><p>analysis&#x2F;analyses（分析） basis&#x2F;bases（基础）</p>
<p>crisis&#x2F;crises（危机） diagnosis&#x2F;diagnoses（诊断） </p>
<p>thesis&#x2F;theses（论文）</p>
<h3 id="以-on或-um结尾的名词，变-on或-um为-a，有的可在词尾直接加-s"><a href="#以-on或-um结尾的名词，变-on或-um为-a，有的可在词尾直接加-s" class="headerlink" title="以-on或-um结尾的名词，变-on或-um为-a，有的可在词尾直接加-s"></a>以-on或-um结尾的名词，变-on或-um为-a，有的可在词尾直接加-s</h3><p>bacterium&#x2F;bacteria（细菌） criterion&#x2F;criteria&#x2F;criterions（标准） </p>
<p>datum&#x2F;data（数据） erratum&#x2F;errata（错误，错字勘误表） </p>
<p>medium&#x2F;media&#x2F;mediums（媒介，介质） memorandum&#x2F;memoranda&#x2F;memorandums（备忘录）</p>
<p>phenomenon&#x2F;phenomena（现象）</p>
<h3 id="变-oo-为-ee"><a href="#变-oo-为-ee" class="headerlink" title="变-oo-为-ee-"></a>变-oo-为-ee-</h3><p>foot&#x2F;feet（脚） tooth&#x2F;teeth（牙齿） </p>
<p>goose&#x2F;geese（鹅）</p>
<h3 id="变-ouse为-ice"><a href="#变-ouse为-ice" class="headerlink" title="变-ouse为-ice"></a>变-ouse为-ice</h3><p>mouse&#x2F;mice（老鼠） louse&#x2F;lice（虱子）</p>
<h3 id="以-us结尾的拉丁语名词，变-us为-i，有的可在词尾直接加-es"><a href="#以-us结尾的拉丁语名词，变-us为-i，有的可在词尾直接加-es" class="headerlink" title="以-us结尾的拉丁语名词，变-us为-i，有的可在词尾直接加-es"></a>以-us结尾的拉丁语名词，变-us为-i，有的可在词尾直接加-es</h3><p>alumnus&#x2F;alumni（男校友） bacillus&#x2F;bacilli（杆菌） </p>
<p>cactus&#x2F;cacti&#x2F;cactuses（仙人掌） fungus&#x2F;fungi&#x2F;funguses（真菌） </p>
<p>genius&#x2F;genii&#x2F;geniuses（天才） nucleus&#x2F;nuclei&#x2F;nucleuses（原子核） </p>
<p>stimulus&#x2F;stimuli（刺激物）</p>
<h2 id="复合名词变复数（compound-noun）"><a href="#复合名词变复数（compound-noun）" class="headerlink" title="复合名词变复数（compound noun）"></a>复合名词变复数（compound noun）</h2><h3 id="“man-x2F-woman-名词”构成的复合名词"><a href="#“man-x2F-woman-名词”构成的复合名词" class="headerlink" title="“man&#x2F;woman+名词”构成的复合名词"></a>“man&#x2F;woman+名词”构成的复合名词</h3><p>由“man&#x2F;woman+名词”构成的复合名词，两个词均须变为复数。</p>
<p>man teacher&#x2F;men teachers（男老师） man doctor&#x2F;men doctors（男医 生）</p>
<p>man servant&#x2F;men servants（男仆） woman pilot&#x2F;women pilots（女飞 行员）</p>
<p>woman journalist&#x2F;women journalists（女记者）</p>
<h3 id="以-man-x2F-woman-x2F-child结尾的复合名词"><a href="#以-man-x2F-woman-x2F-child结尾的复合名词" class="headerlink" title="以-man&#x2F;-woman&#x2F;-child结尾的复合名词"></a>以-man&#x2F;-woman&#x2F;-child结尾的复合名词</h3><p>以-man&#x2F;-woman&#x2F;-child结尾的复合名词变复数时，将-man&#x2F;-woman&#x2F;-child变为复数。</p>
<p>fireman&#x2F;firemen（消防员） chairwoman&#x2F;chairwomen（女主席） </p>
<p>horseman&#x2F;horsemen（骑兵） grandchild&#x2F;grandchildren（孙子，孙 女）</p>
<p>policeman&#x2F;policemen（警察） Englishman&#x2F;Englishmen（英国人） </p>
<p>Frenchman&#x2F;Frenchmen（法国人）</p>
<h3 id="“名词-介词或介词短语”构成的复合名词"><a href="#“名词-介词或介词短语”构成的复合名词" class="headerlink" title="“名词+介词或介词短语”构成的复合名词"></a>“名词+介词或介词短语”构成的复合名词</h3><p>“名词+介词或介词短语”构成的复合名词变复数时，将主体名词 （或者说中心名词）变为复数。</p>
<p>comrade-in-arms&#x2F;comrades-in-arms（战友）</p>
<p>passer-by&#x2F;passers-by（过路人） runner-up&#x2F;runners-up（亚军） </p>
<p>looker-on&#x2F;lookers-on（旁观者） mother-in-law&#x2F;mothers-in-law（岳 母，婆婆） </p>
<p>editor-in-chief&#x2F;editors-in-chief（总编辑） bride-to-be&#x2F;brides-to-be（即 将成为新娘的人，准新娘）</p>
<h3 id="由动词短语演变成的复合名词"><a href="#由动词短语演变成的复合名词" class="headerlink" title="由动词短语演变成的复合名词"></a>由动词短语演变成的复合名词</h3><p>由动词短语演变成的复合名词，一般没有主体名词，变复数时在词尾加-s。</p>
<p>forget-me-not&#x2F;forget-me-nots（勿忘我） go-between&#x2F;go-betweens（中间人）</p>
<p>grown-up&#x2F;grown-ups（成年人） take-off&#x2F;take-offs（起飞）</p>
<p>assistant director&#x2F;assistant directors（助理导演） babysitter&#x2F;babysitters（保姆） </p>
<p>breakdown&#x2F;breakdowns（崩溃，衰落） close-up&#x2F;close-ups（特写镜 头）</p>
<p>takeover&#x2F;takeovers（接管） sit-in&#x2F;sit-ins（静坐抗议） </p>
<p>stand-by&#x2F;stand-bys（可以信任的人）</p>
<h3 id="“名词-形容词”构成的复合名词"><a href="#“名词-形容词”构成的复合名词" class="headerlink" title="“名词+形容词”构成的复合名词"></a>“名词+形容词”构成的复合名词</h3><p>“名词+形容词”构成的复合名词变复数时，变名词为复数。</p>
<p>notary public&#x2F;notaries public（公证员） secretary general&#x2F;secretaries general（秘书长） </p>
<p>Attorney General&#x2F;Attorneys General（［美］司法部长，大法官&#x2F; ［英］总检察长） </p>
<p>consul general&#x2F;consuls general（总领事）</p>
<h3 id="单复数同形的名词（零复数名词）"><a href="#单复数同形的名词（零复数名词）" class="headerlink" title="单复数同形的名词（零复数名词）"></a>单复数同形的名词（零复数名词）</h3><p>这些名词没有词形的变化，但既可以用作单数，也可以用作复数。 或者说，这些名词用作单数或复数，词形完全一样，因此这样的名词也 常常被叫作零复数名词。最常见的词是sheep，如：a sheep, two sheep。</p>
<h4 id="动物名称"><a href="#动物名称" class="headerlink" title="动物名称"></a>动物名称</h4><ul>
<li>sheep（绵羊）从来没有sheeps*这个词形。 </li>
<li>deer（鹿）从来没有deers*这个词形。</li>
</ul>
<h4 id="通常用作零复数"><a href="#通常用作零复数" class="headerlink" title="通常用作零复数"></a>通常用作零复数</h4><p>bison（北美野牛）：a bison&#x2F;two bison </p>
<p>grouse（松鸡）：a grouse&#x2F;two grouse</p>
<p>quail（鹌鹑）：a quail&#x2F;two quail </p>
<p>salmon（三文鱼，大马哈鱼）：a salmon&#x2F;two salmon </p>
<p>cod（鳕鱼，也叫作codfish。在英国，满大街的快餐Fish and Chips〈炸鱼和炸薯条〉就是常用这种鱼做的。大家有机会到英国不妨 尝尝就知道了，非常油腻，绝对是增肥食品）：a cod&#x2F;two cod</p>
<h4 id="零复数和规则复数均可"><a href="#零复数和规则复数均可" class="headerlink" title="零复数和规则复数均可"></a>零复数和规则复数均可</h4><p>antelope（羚羊）复数可以是antelope，或者是antelopes。 </p>
<p>reindeer（驯鹿）复数可以是reindeer，或者是reindeers。圣诞节前 夜，帮圣诞老人拉雪橇的就是这种鹿。 </p>
<p>fish（鱼）复数可以是fish，或者是fishes。 </p>
<p>flounder（比目鱼）复数可以是flounder，或者是flounders。 </p>
<p>herring（鲱鱼）复数可以是herring，或者是herrings。还要注意，有 一个常用的俚语red herring（遮眼法，转移注意力的东西），表示提出 不相干的事实或论点，以分散对主题的注意力。 </p>
<p>shrimp（虾）复数可以是shrimp，或者是shrimps。 </p>
<p>对于这些名词，用零复数往往是把那些动物当作整体来看，而采用 规则复数则表示不同的个体及种类。</p>
<h4 id="国籍名称"><a href="#国籍名称" class="headerlink" title="国籍名称"></a>国籍名称</h4><p>以-ese结尾的国籍名词常用零复数。</p>
<p>Chinese（中国人）这是每个中国的英语学习者都应该知道的。“一 个中国人”是one Chinese，“13亿中国人”是1.3 billion Chinese。这里的复 数还是用Chinese，而不是Chineses*。</p>
<p>其他的词还有： Japanese（日本人）：one Japanese&#x2F;ten Japanese Lebanese（黎巴嫩 人）：one Lebanese&#x2F;ten Lebanese Portuguese（葡萄牙人）：one Portuguese&#x2F;ten Portuguese Vietnamese（越南人）：one Vietnamese&#x2F;ten Vietnamese </p>
<p>此外还有： Swiss（瑞士人）：one Swiss&#x2F;ten Swiss British（英国人）：one British&#x2F;ten British</p>
<h4 id="三种没有形式变化的名词"><a href="#三种没有形式变化的名词" class="headerlink" title="三种没有形式变化的名词"></a>三种没有形式变化的名词</h4><ul>
<li>不可数名词，如music，它们没有词形的变化，只能用作单数。</li>
<li>复数可数名词，如people，它们没有词形的变化，只能用作复数。</li>
<li>单复数同形的名词，如sheep，它们没有词形的变化，但既可以用作单数，也可以用作复数。</li>
</ul>
<h3 id="有新词义的复数名词"><a href="#有新词义的复数名词" class="headerlink" title="有新词义的复数名词"></a>有新词义的复数名词</h3><p>在英文中，有些名词在变成复数的时候，词义会有所变化；或者说 当这些名词用于某个特定的意思时，通常用其复数形式。</p>
<ul>
<li>arm（手臂）arms（&#x3D;weapons武器，军事）</li>
<li>custom（风俗） customs（海关）</li>
<li>damage（损坏，损失）damages（赔偿金）</li>
<li>letter（信）letters（文学）</li>
<li>minute（分钟）minutes（会议记录）</li>
<li>spirit（精神）spirits（烈酒）</li>
<li>premise（前提）premises（房屋，营业场所）</li>
<li>security（安全）securities（证券）</li>
<li>line（行）lines（台词）</li>
</ul>
<h2 id="名词的格"><a href="#名词的格" class="headerlink" title="名词的格"></a>名词的格</h2><h3 id="‘s所有格"><a href="#‘s所有格" class="headerlink" title="‘s所有格"></a>‘s所有格</h3><p>首先要明确的是，名词所有格“’s”主要用来表示有生命的名词的所属关系。所以它通常用在姓名、人称、不定代词、集体名词和高等动物等这样的名词后面。</p>
<h3 id="‘s所有格的逻辑语义关系"><a href="#‘s所有格的逻辑语义关系" class="headerlink" title="‘s所有格的逻辑语义关系"></a>‘s所有格的逻辑语义关系</h3><h4 id="所属关系"><a href="#所属关系" class="headerlink" title="所属关系"></a>所属关系</h4><ul>
<li>所谓“所属关系”，就是指某人所拥有的人或物。在以上讨论的例子 中，“’s”主要是用来表示所属关系。</li>
<li>另外，所属关系有时是表示某物属于某一类人，而不是属于具体的 某个人。</li>
</ul>
<p>比如：</p>
<p>the children’s books 儿童读物 women’s wear 女装</p>
<p>Tom and John are men’s names. 汤姆和约翰都是男子名</p>
<p>再比如“学生用书”是：student’s book</p>
<h4 id="主谓关系"><a href="#主谓关系" class="headerlink" title="主谓关系"></a>主谓关系</h4><p>How will Bhutto’s death affect the world?（布托之死将会如何影响世界）</p>
<p>名词短语Bhutto’s death相当于说Bhutto died，表示“布托 死了”，即相当于一个主谓关系。所谓“主谓关系”，是指所有格名词（如 Bhutto）相当于主语，而被修饰的名词（如death）相当于一个谓语。此 时，这个被修饰的名词通常都是由一个动词转化过来的，比如death对应 动词die。</p>
<p>the visitor’s departure &#x3D; the visitor departed 客人的离开</p>
<p>the teacher’s request（此处的request是名词） &#x3D; the teacher requests&#x2F;requested…（此处的request是动词）</p>
<h4 id="动宾关系"><a href="#动宾关系" class="headerlink" title="动宾关系"></a>动宾关系</h4><p>Bhutto’s assassination rocks Pakistan.（布托的遇刺事件震惊了整个巴基斯坦）</p>
<p>所谓“动宾关系”，是指被修饰的名词（如 assassination）相当于一个谓语，且是及物动词（如assassinate）。而所 有格名词（如Bhutto）相当于这个及物动词的宾语。此时，这个被修饰 的名词通常都是由一个动词转化过来的，比如assassination是由动词 assassinate转化而来。</p>
<p>the children’s education &#x3D; (somebody) educated the children</p>
<p>the boy’s punishment &#x3D; (somebody) punished the boy</p>
<h4 id="表示时间或距离"><a href="#表示时间或距离" class="headerlink" title="表示时间或距离"></a>表示时间或距离</h4><p>所有格“’s”用在表示时间的名词后面。</p>
<p>today’s newspaper 今天的报纸      tomorrow’s weather 明天的天气</p>
<p>Each morning, people swarm into the offices and factories of America, seeking a day’s work for a day’s pay. 每天早晨，人们涌进美国的 办公室和工厂，来寻找日薪工作。</p>
<h4 id="表示重量或价值等度量"><a href="#表示重量或价值等度量" class="headerlink" title="表示重量或价值等度量"></a>表示重量或价值等度量</h4><p>two pounds’ weight 两磅重   a ton’s weight 一吨重</p>
<p>two dollars’ worth of sugar 两美元的白糖   ten dollars’ worth of meat 10美元的肉</p>
<h4 id="表示国家、城市、国际组织或地理名词等"><a href="#表示国家、城市、国际组织或地理名词等" class="headerlink" title="表示国家、城市、国际组织或地理名词等"></a>表示国家、城市、国际组织或地理名词等</h4><p>China’s population 中国的人口     China’s industrial development 中国的工业发展</p>
<p>the world’s seven wonders 世界七大奇迹  the earth’s surface 地球的表面 </p>
<p>the sea’s depth 海洋的深度  the moon’s shadow 月球的阴影</p>
<h4 id="用于交通工具及其部件的所属关系"><a href="#用于交通工具及其部件的所属关系" class="headerlink" title="用于交通工具及其部件的所属关系"></a>用于交通工具及其部件的所属关系</h4><p>the car’s exhaust 汽车的排气管     the plane’s engine 飞机的发动机</p>
<h4 id="名词所有格修饰的名词被省去"><a href="#名词所有格修饰的名词被省去" class="headerlink" title="名词所有格修饰的名词被省去"></a>名词所有格修饰的名词被省去</h4><h5 id="避免名词重复"><a href="#避免名词重复" class="headerlink" title="避免名词重复"></a>避免名词重复</h5><p>若名词所有格所修饰的名词已经出现过，则第二次出现 在所有格后面的名词可以省去，以避免重复。</p>
<p>This bike is mine, not Michael’s（&#x3D;Michael’s bike）. 这辆自行车是我的，不是迈克尔的。</p>
<p>I don’t know her name, but I can tell you her husband’s（&#x3D;her husband’s name）. 我不知道她的名字，但是我可以告诉你她丈夫的名字。</p>
<h5 id="表示店铺或教堂"><a href="#表示店铺或教堂" class="headerlink" title="表示店铺或教堂"></a>表示店铺或教堂</h5><p>在一些表示店铺或教堂的名词的所有格后面可省去名词，此时所有格表示相应的场所，且一般要在所有格名词前加定冠词the。</p>
<p>at the baker’s（&#x3D;baker’s shop） 在面包店  at the butcher’s（&#x3D;butcher’s shop） 在肉铺</p>
<p>at the chemist’s（&#x3D;chemist’s store） 在药店  at the florist’s（&#x3D;florist’s shop） 在花店 </p>
<p>at the dentist’s（&#x3D;dentist’s clinic） 在牙医诊所  at the doctor’s（&#x3D;doctor’s clinic） 在医生的诊所</p>
<h5 id="表示某人的住宅"><a href="#表示某人的住宅" class="headerlink" title="表示某人的住宅"></a>表示某人的住宅</h5><p>在人名后的所有格省去名词时，表示某人的住宅。</p>
<p>go to my sister’s（&#x3D;my sister’s home） 去我姐姐家</p>
<h3 id="名词所有格修饰的名词被省去-1"><a href="#名词所有格修饰的名词被省去-1" class="headerlink" title="名词所有格修饰的名词被省去"></a>名词所有格修饰的名词被省去</h3>]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>正则表达式汇总</title>
    <url>/2020/04/06/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<blockquote>
<p>有时候需要通过正则表达式来快速匹配某些字符串筛选结果，但是规则老是忘了，所以记录一下，以便日后使用。</p>
</blockquote>
<h1 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h1><h2 id="行首和行尾"><a href="#行首和行尾" class="headerlink" title="行首和行尾"></a>行首和行尾</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^cat : 验证该行以c开头紧接着是a，然后是t</span><br><span class="line">cat$ : 验证该行以t结尾倒数第二个字符为a倒数第三个字符为c</span><br><span class="line">^cat$: 以c开头接着是a-&gt;t然后是行结束：只有cat三个字母的数据行</span><br><span class="line">^$  : 开头之后马上结束：空白行，不包括任何字符</span><br></pre></td></tr></table></figure>
<p>匹配以- 开头的任何字符串，到以#开头的行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^- .*$</span><br><span class="line">^#.*</span><br></pre></td></tr></table></figure>
<h2 id="匹配包含某个字符串的行"><a href="#匹配包含某个字符串的行" class="headerlink" title="匹配包含某个字符串的行"></a>匹配包含某个字符串的行</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">^(.*)string(.*)\n</span><br></pre></td></tr></table></figure>
<p>string为指定的字符串</p>
]]></content>
      <categories>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>正则表达式</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之限定词（冠词）</title>
    <url>/2020/04/26/English%E7%B3%BB%E5%88%97%E4%B9%8B%E9%99%90%E5%AE%9A%E8%AF%8D-%E5%86%A0%E8%AF%8D/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记摘选自张满胜老师的《英语语法新思维初级教程通悟语法第2版》，以及其他网上知识点收集，只是我自己的个人复习笔记，禁止转载，如有侵权，请联系我删除。</p>
</blockquote>
<h1 id="冠词"><a href="#冠词" class="headerlink" title="冠词"></a>冠词</h1><p>限定词与名词的关系最为密切， 因为它必然是修饰某个名词，以限定名词所指的范围，对名词起泛指或特指、定量或不定量等限定修饰作用。从名词短语（noun phrase）的角度来看，限定词或者是直接放在一个名词的前面来修饰它，构成“限定词+名词”这样的结构（如the teacher），或者是在“限定词+形容词+名词”（如the English teacher）这样的结构中来修饰名词。</p>
<p>限定词包括：<br>冠词：the, an和a； </p>
<p>基数词和序数词：one&#x2F;first, two&#x2F;second, three&#x2F;third等； </p>
<p>指示限定词：this, that, these和those； </p>
<p>物主限定词：my, your, his, her, our和their； </p>
<p>数量限定词：a few, a little, much, many, a lot of, some, any, enough, several, most和all等；</p>
<p>个体限定词：each, every, either, neither和both等； </p>
<p>名词属格：Mary’s, John’s和his father’s等。</p>
<h2 id="特指-vs-泛指"><a href="#特指-vs-泛指" class="headerlink" title="特指 vs 泛指"></a>特指 vs 泛指</h2><ul>
<li><p>所谓泛指，也叫类指，顾名思义，是表示一类事物，或某类事物的总称。</p>
</li>
<li><p>所谓特指，是表示某类事物中的具体的某一个或某一些。</p>
</li>
<li><p>1）The tiger is becoming almost extinct.</p>
</li>
<li><p>2）The tiger is sleeping in the cage.</p>
</li>
</ul>
<p>在例句1）中，想到的是“老虎”这类动物，并不是想到特定的一只老虎。在例句2）中，心里想的是“老虎”这类动物中特定的一只，比如就指眼前所看到的这只老虎。</p>
<p>对于the来说，就是特指和泛指。定冠词主要是表示特指的用法，其次才是表示泛指的用法。但对于不定冠词a&#x2F;an来说，不能表示特指， 主要是用来表示泛指。此外，对于不定冠词，其实还有一个定指&#x2F;不定指的概念（specific or nonspecific reference）。</p>
<h3 id="英语中四种泛指的表达模式"><a href="#英语中四种泛指的表达模式" class="headerlink" title="英语中四种泛指的表达模式"></a>英语中四种泛指的表达模式</h3><p>不可数名词、复数名词和单数名词，这三类名词与英语的冠词有四种不同的搭配使用规则， 从而衍生出四种不同的模式来表示泛指意义。</p>
<p>具体来说就是：</p>
<ul>
<li>不可数名词不加冠词表示泛指；</li>
<li>复数名词不加冠词表示泛指；</li>
<li>单数名词与定冠词the连用可以表示泛指；</li>
<li>单数名词与不定冠词a&#x2F;an连用可以表示泛指。</li>
</ul>
<h4 id="不可数名词不加冠词表示泛指"><a href="#不可数名词不加冠词表示泛指" class="headerlink" title="不可数名词不加冠词表示泛指"></a>不可数名词不加冠词表示泛指</h4><p>不可数名词在表示泛指时，不可与定冠词the连用。如果与the连用，此时不可数名词是表示特指。</p>
<ul>
<li><p>1）I love music, poetry and art. </p>
</li>
<li><p>2）I don’t like the film, but I like the music（of the film）.</p>
</li>
<li><p>在例句1中，music（以及poetry和art）是一个泛指的概念，表示音乐这类艺术形式，因而不能说“I love the music, the poetry and the art.*”。 </p>
</li>
<li><p>在例句2中，the music是特指这部电影的音乐。</p>
</li>
</ul>
<h4 id="复数名词不加冠词表示泛指"><a href="#复数名词不加冠词表示泛指" class="headerlink" title="复数名词不加冠词表示泛指"></a>复数名词不加冠词表示泛指</h4><p>复数名词同不可数名词一样，在表示泛指时，不可与定冠词the连用。如果与the连用，此时复数名词是表示特指。</p>
<ul>
<li><p>1）Books become more and more expensive.</p>
</li>
<li><p>2）Books fill leisure time for many people.</p>
</li>
<li><p>3）Put away the books on your desk. </p>
</li>
<li><p>4）Move the books off that chair and sit down.</p>
</li>
<li><p>在例句1中，该句的意思是泛指一切书都在涨价，即这里的books是表示泛指。</p>
</li>
<li><p>在例句2中，这里的books是泛指一切书，而不是具体指某些书。</p>
</li>
<li><p>在例句3中，这里的books是专指“你桌上的那些书”，所以是特指。</p>
</li>
<li><p>在例句4中，这里的books是专指“椅子上的那些书”，所以是特指。</p>
</li>
</ul>
<h5 id="两种the-复数名词也可以表示泛指"><a href="#两种the-复数名词也可以表示泛指" class="headerlink" title="两种the+复数名词也可以表示泛指"></a>两种the+复数名词也可以表示泛指</h5><h6 id="the-国籍名词"><a href="#the-国籍名词" class="headerlink" title="the+国籍名词"></a>the+国籍名词</h6><p>该结构是指一个国籍的、一个种族的人。</p>
<p>The Chinese are a great people.</p>
<p>Chinese 是单复数同形的名词，这里的the Chinese是表示复数的概念，这从谓语动词are可以看出来。但这里的 he Chinese表示的是“整个中国人或中华民族”，即是一个泛指的概念。<br>不是所有的国籍名词都可以这样用，比如不能说the German are…* 。这样用的国籍名词只限于以-ese、-sh和-ch结尾的词。</p>
<ul>
<li>以 -ese 结尾的国籍名词： Chinese, Japanese</li>
<li>以 -sh 结尾的国籍名词： British, Cornish, Danish, English, Irish, Spanish, Turkish, Welsh </li>
<li>以 -ch 结尾的国籍名词： Dutch, French</li>
</ul>
<h6 id="the-形容词"><a href="#the-形容词" class="headerlink" title="the+形容词"></a>the+形容词</h6><p>“the+形容词”表示一类人，是泛指，相当于在形容词的后面省去了people，所以被看作是复数名词，作主语时，谓语要用复数。<br>The poor are causing the nation’s leaders great concern.<br>这里的the poor是复数的概念，表示“穷人们”这类人，即是一个泛指的概念，而不是专指某些穷人。</p>
<h4 id="单数名词与定冠词the连用可以表示泛指"><a href="#单数名词与定冠词the连用可以表示泛指" class="headerlink" title="单数名词与定冠词the连用可以表示泛指"></a>单数名词与定冠词the连用可以表示泛指</h4><p>定冠词the与单数名词连用时，可以表示泛指。在语气上显得比较正式或文雅，表示一个由典型的样品所代表的那个类别。</p>
<ul>
<li>1）The tiger is becoming almost extinct. </li>
<li>2）Tigers are becoming almost extinct.</li>
</ul>
<p>在例句1中，采用单数名词tiger与the连用表示泛指。所以，对于例句1和例句2，想到的都是“老虎”这类动物，并不是特定的一只只老虎。因此，这两句的译文都一样，表示“老虎几乎要灭绝了”。</p>
<p>正因为“the+单数名词”既可以表示泛指也可以表示特指，所以，在特指还是泛指的理解上有时会出现模棱两可的现象。比如：<br>A: The president is too powerful.<br>B: Which president?<br>A: No, I mean presidents in general.</p>
<h4 id="单数名词与不定冠词-a-x2F-an-连用可以表示泛指"><a href="#单数名词与不定冠词-a-x2F-an-连用可以表示泛指" class="headerlink" title="单数名词与不定冠词 a&#x2F;an 连用可以表示泛指"></a>单数名词与不定冠词 a&#x2F;an 连用可以表示泛指</h4><p>a&#x2F;an+单数可数名词”可以表示泛指，不定冠词a&#x2F;an的泛指用法指的是某一类事物中任何一个具有代表性的成员，所以这里的a&#x2F;an相当于any。</p>
<ul>
<li>1）A tiger is a dangerous animal. </li>
<li>2）The tiger is a dangerous animal. </li>
<li>3）Tigers are dangerous animals.</li>
</ul>
<p>对于这三个例句，想到的都是“老虎”这类动物，而不是特定的一只老虎。</p>
<h5 id="关于a-n-的泛指用法的深入讨论"><a href="#关于a-n-的泛指用法的深入讨论" class="headerlink" title="关于a(n)的泛指用法的深入讨论"></a>关于a(n)的泛指用法的深入讨论</h5><p>A tiger is a dangerous animal.<br>相当于说：<br>Any tiger is a dangerous animal.</p>
<p>a&#x2F;an不能用来表示那些属于整个类别的特性。比如不能说：<br>A tiger is becoming almost extinct. *<br>因为这里的extinct只适于描写整个老虎种群的特性，强调的是“种群”的灭绝，而不适于表示“老虎”这类动物的一般特性。比如可以说“任何一只老虎都具有危险伤人的特性”：<br>Any tiger is a dangerous animal.<br>却不能说“任何一只老虎都具有灭绝的特性”：<br>Any tiger is becoming almost extinct. *<br>不过，对于这种“整个类别”的特性，可以用复数名词或the来泛指，如：<br>The tiger is becoming almost extinct.<br>Tigers are becoming almost extinct.</p>
<h3 id="定冠词-the-的特指用法"><a href="#定冠词-the-的特指用法" class="headerlink" title="定冠词 the 的特指用法"></a>定冠词 the 的特指用法</h3><h4 id="情景-x2F-文化特指（-situational-x2F-cultural-reference-）"><a href="#情景-x2F-文化特指（-situational-x2F-cultural-reference-）" class="headerlink" title="情景&#x2F;文化特指（ situational&#x2F;cultural reference ）"></a>情景&#x2F;文化特指（ situational&#x2F;cultural reference ）</h4><p>在英语中，定冠词 the 有一条用法，是可以表示“著名的”人或事物。比如说到大科学家“爱因斯坦”，我们就要用定冠词 the 这样说：<br>Albert Einstein, the famous physicist<br>阿尔伯特·爱因斯坦，著名的物理学家</p>
<p>但是说到“刘德华”，我们则要区分读者对象了。如果是面向中国国内的读者，我们可以说：<br>Andy Lau, the famous actor</p>
<p>如果是面向世界的读者，我们可能要用不定冠词 a 来这样描述较为妥当：<br>Andy Lau, a famous Chinese actor</p>
<h5 id="一般常识（-general-knowledge-）-x2F-较大情景"><a href="#一般常识（-general-knowledge-）-x2F-较大情景" class="headerlink" title="一般常识（ general knowledge ）&#x2F;较大情景"></a>一般常识（ general knowledge ）&#x2F;较大情景</h5><ul>
<li>the North Pole 北极 </li>
<li>the Equator 赤道 </li>
<li>the earth 地球 </li>
<li>the moon 月亮 </li>
<li>the sky 天空 </li>
<li>the universe 宇宙 </li>
<li>the Renaissance （欧洲14至16世纪的）文艺复兴</li>
</ul>
<h5 id="具体知识（-specific-knowledge-）-x2F-局部情景（-local-use-）"><a href="#具体知识（-specific-knowledge-）-x2F-局部情景（-local-use-）" class="headerlink" title="具体知识（ specific knowledge ） &#x2F; 局部情景（ local use ）"></a>具体知识（ specific knowledge ） &#x2F; 局部情景（ local use ）</h5><p>比如学校里就只有一个图书馆，我们就说：<br>Let’s go to the library.</p>
<h5 id="即时情景用法（-immediate-situation-）"><a href="#即时情景用法（-immediate-situation-）" class="headerlink" title="即时情景用法（ immediate situation ）"></a>即时情景用法（ immediate situation ）</h5><p>A: Where’s the dessert?<br>B: What dessert?<br>C: You were supposed to bring the dessert.<br>B: I didn’t know that. Nobody told me about it. </p>
<h4 id="上下文共指（-textual-co-reference-）"><a href="#上下文共指（-textual-co-reference-）" class="headerlink" title="上下文共指（ textual co-reference ）"></a>上下文共指（ textual co-reference ）</h4><p>上下文共指，就是指听话者或读者可以根据上下文找到所指。它可分为前指（ anaphoric reference ）和后指（ cataphoric reference ）。前指又可分为直接前指（ direct anaphora ）和间接前指（ indirect anaphora ）。</p>
<h5 id="直接前指"><a href="#直接前指" class="headerlink" title="直接前指"></a>直接前指</h5><p>直接前指是指前面提到的某个事物，在后文中再次提到，这样前后两个名词短语是一种共指关系（ co-reference ），指代同一个事物。由于第一次提到的事物通常是不定指的，所以常用不定冠词 a&#x2F;an 来限定。可是一旦那个事物在话语中已经谈到过，就可以把它看作“从上文中已得知的东西”，此后再提到它时就要用定冠词。这就是传统语法书上所说的“第一次提到的单数可数名词前面用不定冠词 a 或 an ，这一名词再次出现时则要用定冠词 the” 。<br>I had a banana and an apple. I ate the banana and gave the apple to Clint.</p>
<h5 id="间接前指-x2F-话题与定冠词-the"><a href="#间接前指-x2F-话题与定冠词-the" class="headerlink" title="间接前指 &#x2F; 话题与定冠词 the"></a>间接前指 &#x2F; 话题与定冠词 the</h5><p>间接前指，表示所指的对象间接地成为听话者知识的一部分。这种知识不是通过上面讨论的那样的直接谈及而获得，而是从已经谈到的事物中推断得到的。<br>John bought a bicycle, but when he rode it one of the wheels came off.<br>约翰买了一辆自行车，可是当他骑上去的时候，有一个轮子掉了下来。</p>
<h5 id="后指-x2F-结构特指"><a href="#后指-x2F-结构特指" class="headerlink" title="后指 &#x2F; 结构特指"></a>后指 &#x2F; 结构特指</h5><p>后指，也叫结构特指（ structural reference ），往往出现在带有后置定语的名词短语中。一般来说，被某个后置定语所修饰的名词的前面要用定冠词 the 。<br>The brick house on the corner is mine.<br>这里的名词短语 brick house 被介词短语 on the corner 修饰，所以有 the 来限定 brick house ，说成 the brick house 。<br>不过，并非所有带有后置定语的名词的前面都得用 the 来限定，比如下面这个句子：<br>What makes us different from women of past decades is our range of choices.<br>这里的名词 women 被介词短语 of pastdecades 修饰，但并没有 the 来限定 women ，变成 the women 。</p>
<p>所以，决定一个名词的前面是否要有 the 来限定，并不完全是看该名词的后面是否有后置定语修饰，主要还是看这个被后置定语修饰的名词是表达一个泛指概念还是特指概念。具体可分成两种情况：</p>
<ul>
<li><p>如果被后置定语修饰的名词是表达一个没有限制的、广泛的、不可预知的人或事物，此时名词的前面依然不用the来限定；</p>
</li>
<li><p>如果被后置定语修饰的名词是表达某个被限定的、特殊的、听者或读者（ listener&#x2F;reader ）很熟悉或与之有关的人或事物，此时名词的前面需要用 the 来限定。</p>
</li>
<li><p>1）What makes us different from women of past decades is our range of choices. </p>
</li>
<li><p>2）The women of the other team all came from London.</p>
</li>
<li><p>在例句1中，这里的 women 说的是普遍的、广泛的“妇女”，是一个泛指概念，因此这里没有the来限定women。</p>
</li>
<li><p>在例句2中，这里的 women 表达的是一个明确的、特殊的妇女群体，是一个特指概念，作为读者的你是熟悉这些 women 的，因此这里有 the 来限定 women。</p>
</li>
</ul>
<h2 id="不定冠词-a-x2F-an-的用法"><a href="#不定冠词-a-x2F-an-的用法" class="headerlink" title="不定冠词 a&#x2F;an 的用法"></a>不定冠词 a&#x2F;an 的用法</h2><p>在三类名词（即单数名词、复数名词和不可数名词）当中，不定冠词仅用于限定单数可数名词。在用法上，当根据说话者和听话者的共有知识不能统一确认所指事物的时候，我们就会用 a&#x2F;an 来修饰一个名词。所以， a&#x2F;an 通常用于所指事物在前面未曾提及并假定说话者或听话者对它还不熟悉的时候。</p>
<p>a&#x2F;an 表示泛指的用法，此用法一般仅限于处在主语位置的“a&#x2F;an+单数名词”。如果“a&#x2F;an+单数名词”是用在表语位置以及宾语位置，则失去了泛指的功能，而表现为其他的意义。</p>
<h3 id="用在补足语中，表示分类，具有描述功能"><a href="#用在补足语中，表示分类，具有描述功能" class="headerlink" title="用在补足语中，表示分类，具有描述功能"></a>用在补足语中，表示分类，具有描述功能</h3><p>单数可数名词在作表语时，通常需要一个冠词。如果用不定冠词 a&#x2F;an ，则具有描述的功能，而没有所指功能。<br>Bill is an engineer.<br>不能说： Bill is engineer. *<br>当然，这里若用the，则表示特指。如：<br>Bill is the engineer who will design the bridge. 比尔是将要设计这座桥的工程师。<br>这里的the engineer不是强调比尔的“工程师”身份，而是强调比尔是完成某项工作的工程师。</p>
<h3 id="用在宾语中，具有所指功能"><a href="#用在宾语中，具有所指功能" class="headerlink" title="用在宾语中，具有所指功能"></a>用在宾语中，具有所指功能</h3><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/UcnS3R.png"></p>
<h3 id="不定冠词-a-x2F-an-与不可数名词"><a href="#不定冠词-a-x2F-an-与不可数名词" class="headerlink" title="不定冠词 a&#x2F;an 与不可数名词"></a>不定冠词 a&#x2F;an 与不可数名词</h3><p>在三类名词（即单数名词、复数名词和不可数名词）当中，不定冠词仅用于限定单数可数名词，不可数名词的前面通常不用 a&#x2F;an 。但是，出于特定的意义表达的需要，就要用 a&#x2F;an 来限定不可数名词。</p>
<h4 id="很多不可数名词与a-x2F-an连用，表示“一种”或“一类”"><a href="#很多不可数名词与a-x2F-an连用，表示“一种”或“一类”" class="headerlink" title="很多不可数名词与a&#x2F;an连用，表示“一种”或“一类”"></a>很多不可数名词与a&#x2F;an连用，表示“一种”或“一类”</h4><p>如果说话者或作者想以某种方式来特指所说的事物，比如通常以关系从句的方式加以限定，或当说话者的意思是“一类”或“一种”的时候，不可数名词前可以用 a&#x2F;an 。<br>A cheese that I like is Camembert.<br>我很喜欢的一种奶酪就是法国卡芒贝尔村产的软质奶酪。</p>
<h4 id="对于饮料类的不可数名词，与a-x2F-an连用时，表示“一杯”"><a href="#对于饮料类的不可数名词，与a-x2F-an连用时，表示“一杯”" class="headerlink" title="对于饮料类的不可数名词，与a&#x2F;an连用时，表示“一杯”"></a>对于饮料类的不可数名词，与a&#x2F;an连用时，表示“一杯”</h4><p>I’d like a beer, please. 我要一杯啤酒。</p>
<h4 id="有些不可数名词，当它们与-a-x2F-an-连用时，会有特别的意思，或者说意思会发生改变"><a href="#有些不可数名词，当它们与-a-x2F-an-连用时，会有特别的意思，或者说意思会发生改变" class="headerlink" title="有些不可数名词，当它们与 a&#x2F;an 连用时，会有特别的意思，或者说意思会发生改变"></a>有些不可数名词，当它们与 a&#x2F;an 连用时，会有特别的意思，或者说意思会发生改变</h4><p>比如 glass 表示“玻璃”这种物质，但 a glass 则表示“一个玻璃杯”。同样， iron 表示“铁”这种物质，但 an iron 表示“一个电熨斗”等等。</p>
<h3 id="不定冠词-a-x2F-an-与数词-one"><a href="#不定冠词-a-x2F-an-与数词-one" class="headerlink" title="不定冠词 a&#x2F;an 与数词 one"></a>不定冠词 a&#x2F;an 与数词 one</h3><p>不定冠词在历史上起源于非重读形式的 one ，在当代英语的许多语境中，不定冠词的这种数词功能仍是非常主要的。所以，在下列并列结构中， one 可作为 a 的强调形式的等同词而替代 a 。</p>
<h4 id="强调数量“一”时用-one"><a href="#强调数量“一”时用-one" class="headerlink" title="强调数量“一”时用 one"></a>强调数量“一”时用 one</h4><p>当我们想加强口吻或引人注意的时候，我们用 one 强调“只有一个 &#x2F; 不超过一个（ one only&#x2F;not more than one ）”的意思，而 a&#x2F;an 则没有这个意思，它显得比较平淡、中性。也就是说， one 比 a&#x2F;an 更强调数量。</p>
<p>Customer: When will they be ready?<br>Assistant: They take a week.<br>Customer: One week, right, thanks very much.</p>
<h4 id="讲故事中用-one"><a href="#讲故事中用-one" class="headerlink" title="讲故事中用 one"></a>讲故事中用 one</h4><p>在讲故事或讲述某种经历时，我们常用 one 来强调人或事物，作为我们将要讲到的一个重要话题。<br>There is one place we go to which is a Mexican restaurant, and they have a happy hour between 5: 30 and 7: 30.<br>有一个地方是我们常去的，那是一家墨西哥餐馆，那里下午 5: 30 至 7: 30 之间饮料特价。</p>
<h4 id="表示类指意义的-a-x2F-an-不能换成-one"><a href="#表示类指意义的-a-x2F-an-不能换成-one" class="headerlink" title="表示类指意义的 a&#x2F;an 不能换成 one"></a>表示类指意义的 a&#x2F;an 不能换成 one</h4><p>我们可以用 a&#x2F;an 表示一类事物，是不定冠词泛指意义的用法。此时，我们就不能用 one 来替换 a&#x2F;an ，否则意思会发生改变。</p>
<ul>
<li><p>1）A shotgun is no good. </p>
</li>
<li><p>2）One shotgun is no good.</p>
</li>
<li><p>在例句1中， a shotgun 是表示类指意义，意思是说“猎枪这种武器”不合适，需要别的武器。</p>
</li>
<li><p>在例句2中， one shotgun 是强调数量，意思是说“一支猎枪”不够，需要两支或更多的猎枪。</p>
</li>
</ul>
<h4 id="表示度量的-a-x2F-an-不能换成-one"><a href="#表示度量的-a-x2F-an-不能换成-one" class="headerlink" title="表示度量的 a&#x2F;an 不能换成 one"></a>表示度量的 a&#x2F;an 不能换成 one</h4><p>我们可以用 a&#x2F;an 来表示度量，以表示价格、速度或比率等概念。这时的 a&#x2F;an 相当于 per （每，每一），不能换成 one 。<br>1 ） The rent is $100 a week.<br>2 ） The rent is $100 one week. *</p>
<p>再比如下列这些表示度量的短语（ measure phrases ）：<br>ten dollars a day 每天 10 美元<br>$5 a kilo 5 美元一千克<br>sixty kilometers an hour 每小时 60 千米<br>four times a day 每天四次</p>
<h4 id="表示数量的固定搭配中的-a-不能换成-one"><a href="#表示数量的固定搭配中的-a-不能换成-one" class="headerlink" title="表示数量的固定搭配中的 a 不能换成 one"></a>表示数量的固定搭配中的 a 不能换成 one</h4><p>各种数量词中也含有不定冠词 a ，此时不能换成 one ，比如： a few, a little, a great many 以及 a large number of 等等。因为这些是固定短语，所以不能把其中的 a 替换成 one ，比如不能说： one few* 或 one little* 等。</p>
<h3 id="不定冠词-a-x2F-an-与-this"><a href="#不定冠词-a-x2F-an-与-this" class="headerlink" title="不定冠词 a&#x2F;an 与 this"></a>不定冠词 a&#x2F;an 与 this</h3><p>在口头叙述中，当说话者想强调某个人、某个地方或某件事，并使他们变得更加生动时，就可以用 this 代替 a 。这个用法在讲笑话时尤为常见。</p>
<h2 id="用-x2F-不用冠词的意义区别（-the-hospital-x2F-hospital-）"><a href="#用-x2F-不用冠词的意义区别（-the-hospital-x2F-hospital-）" class="headerlink" title="用 &#x2F; 不用冠词的意义区别（ the hospital&#x2F;hospital ）"></a>用 &#x2F; 不用冠词的意义区别（ the hospital&#x2F;hospital ）</h2><p>对于表示处所或社会事业机构类的名词（如 prison, church 和 college 等），使用冠词 the ，是强调处所，指的是实际的建筑物或地点；不用冠词 the ，是强调活动，不是指实际的建筑物或地点，而是指与它们相关的社会事业机构。</p>
<h3 id="家居生活类名词"><a href="#家居生活类名词" class="headerlink" title="家居生活类名词"></a>家居生活类名词</h3><p>at table &#x2F; at the table<br>in bed &#x2F; in the bed</p>
<h3 id="处所、建筑物或社会事业机构"><a href="#处所、建筑物或社会事业机构" class="headerlink" title="处所、建筑物或社会事业机构"></a>处所、建筑物或社会事业机构</h3><p>go to hospital （ as patients ） &#x2F; redecorate the hospital<br>go to prison &#x2F; walk around the prison（犯罪入狱&#x2F;绕着这个监狱走）</p>
<h3 id="关于上学（-class-school-college-和-university-等）"><a href="#关于上学（-class-school-college-和-university-等）" class="headerlink" title="关于上学（ class, school, college 和 university 等）"></a>关于上学（ class, school, college 和 university 等）</h3><p>go to school &#x2F; go to the school<br>in school &#x2F; in the school （在校念书&#x2F;在学校里）<br>in class &#x2F; in the class （在上课&#x2F;在这个班级）</p>
<h2 id="其他用冠词的场合"><a href="#其他用冠词的场合" class="headerlink" title="其他用冠词的场合"></a>其他用冠词的场合</h2><h3 id="形容词或副词的最高级、序数词，以及-only-用作形容词后接名词时，它们的前面一般要用-the-。"><a href="#形容词或副词的最高级、序数词，以及-only-用作形容词后接名词时，它们的前面一般要用-the-。" class="headerlink" title="形容词或副词的最高级、序数词，以及 only 用作形容词后接名词时，它们的前面一般要用 the 。"></a>形容词或副词的最高级、序数词，以及 only 用作形容词后接名词时，它们的前面一般要用 the 。</h3><p>the only&#x2F;best way to cope with the problem 解决这个问题的唯一 &#x2F; 最好的方法<br>This is the first time I’ve come to Beijing. 这是我第一次来北京。</p>
<h3 id="在乐器、乐团、合唱团及流行音乐团体前加-the"><a href="#在乐器、乐团、合唱团及流行音乐团体前加-the" class="headerlink" title="在乐器、乐团、合唱团及流行音乐团体前加 the"></a>在乐器、乐团、合唱团及流行音乐团体前加 the</h3><p>the Beatles “甲壳虫”乐队<br>the Philadelphia Orchestra 费城管弦乐队<br>play&#x2F;learn the guitar 弹&#x2F;学吉他<br>learn the piano 学钢琴</p>
<h3 id="定冠词-the-与姓氏连用"><a href="#定冠词-the-与姓氏连用" class="headerlink" title="定冠词 the 与姓氏连用"></a>定冠词 the 与姓氏连用</h3><p>我们可以把定冠词 the 与姓氏连用，然后要在姓氏的后面添加复数 -s 。<br>the Smiths<br>这类短语要表达的意思主要有两种：一是表示夫妇两人（ husband and wife ），二是可以表示一家人，即包括孩子在内（ including children ）。所以， the Smiths 可以表示“史密斯夫妇”，也可以表示“史密斯一家人”。具体的意思可依据上下文而定。</p>
<p>此外，如果是名门望族的姓氏，则除了表示上述两个意思之外，往往还表示整个家族。<br>the Kennedys<br>这个短语虽然可以表示“肯尼迪总统夫妇”或“肯尼迪总统全家人”，但实际上往往是表示“肯尼迪家族”。</p>
<h3 id="表示强调时，会用-the"><a href="#表示强调时，会用-the" class="headerlink" title="表示强调时，会用 the"></a>表示强调时，会用 the</h3><p>（ at the airport check-in desk ）<br>Airline official: How many bags are you checking in?<br>Passenger: Just the one.</p>
<hr>
<p>Receptionist: So it’s just one person then?<br>Customer: No, no, it’s for the two of us.<br>Receptionist: Oh, I’m sorry. Right, two persons.</p>
<h2 id="其他不用冠词的场合"><a href="#其他不用冠词的场合" class="headerlink" title="其他不用冠词的场合"></a>其他不用冠词的场合</h2><h3 id="关于职业、身份或头衔"><a href="#关于职业、身份或头衔" class="headerlink" title="关于职业、身份或头衔"></a>关于职业、身份或头衔</h3><p>I am an English teacher.<br>如果这个头衔是独一无二的，或者说这个职位在一个单位里是唯一的，此时常不用冠词。不过，也可以用 the （既然是独一无二的身份，所以不可能用 a&#x2F;an ）。</p>
<ul>
<li>1）They appointed him Head Librarian.</li>
<li>2）He’s a librarian.</li>
</ul>
<h3 id="关于球类、棋类运动"><a href="#关于球类、棋类运动" class="headerlink" title="关于球类、棋类运动"></a>关于球类、棋类运动</h3><p>play football 踢足球<br>play chess 下棋<br>play tennis 打网球</p>
<h3 id="关于其他限定词与冠词"><a href="#关于其他限定词与冠词" class="headerlink" title="关于其他限定词与冠词"></a>关于其他限定词与冠词</h3><p>所以下面这些表达都是错误的： </p>
<ul>
<li>the my book* </li>
<li>Tom’s the book* </li>
<li>my the money* </li>
<li>our the problems*</li>
</ul>
<p>但是可以这样：</p>
<ul>
<li>the boss’s wife</li>
<li>my brother’s girlfriend</li>
</ul>
<h3 id="特殊名词"><a href="#特殊名词" class="headerlink" title="特殊名词"></a>特殊名词</h3><p>nature ：泛指自然界（动植物及无生命的物质的世界），不加冠词。比如“在大自然中”要说成 in nature ，而不是 in the nature* 。<br>society ：泛指我们在其中生活的这个社会，一般不加冠词。比如“在社会中”要说成 in society ，而不是 in the society* 。<br>Society turns people into criminals and then locks them up.<br>man ：泛指整个人类时，不加冠词。</p>
<h3 id="关于星期"><a href="#关于星期" class="headerlink" title="关于星期"></a>关于星期</h3><p>表示星期几的名词前面一般是不加冠词的，而是直接用介词 on 加上一个星期的名称，即“on+星期名称”。<br>上述不加冠词的星期表达“on+星期名称”所指的具体时间是与真实的说话语境所暗示的某一个时间点有联系的。比如现在的说话时间是在“周三”，那么我们说 on Monday ，就是指刚刚过去的那个“周一”，即“前天”，表示的是一个过去的时间（ past time ）；而我们说 on Friday ，就是指即将到来的那个“周五”，即“后天”，表示的是一个将来的时间（ future time ）。<br>除此以外，“on+星期名称”还可以表示周期性的“星期几”，表示一个规律性的日期，比如 on Monday 可以表示“每逢周一”。在英语中，表示“每逢周几”，我们还可以在星期名词的后面加 -s ，比如 on Mondays 。<br>I have English class on Monday.<br>这里的 on Monday 可以理解成“每周一”，此时也可以用复数，说成 on Mondays 。</p>
<p>综上所述，“on+星期名称”这样的星期表达可以包含两个意思：一是表示一个规律性的日期，意思是“每逢周几”；二是表示过去或将来的某个具体日期（ a specific date ），此时是以说话时间为参照的。</p>
<hr>
<p>加了冠词说 on the Monday 和 on the Thursday ，此时的参照时间不是说话的时间，而是上下文里所确立的某一时间。<br>以上所讨论的是两种定指的星期表达，一个是以说话的时间为参照，另一个是以上下文中特定的时间为参照。既然有定指的星期表达，那么也就有不定指的星期表达，此时用不定冠词a来修饰星期，说成“on a+ 星期名称”。</p>
<ul>
<li><p>1）She left on a Wednesday. </p>
</li>
<li><p>2）She left on Wednesday.</p>
</li>
<li><p>在例句1中， on a Wednesday 表示过去某一个不确定的星期三，与现在的说话时间没有任何联系。</p>
</li>
<li><p>在例句2中， on Wednesday 是以现在的说话时间为参照，表示离说话时间最近的刚刚过去的那个周三，即与现在的说话时间有密切联系。</p>
</li>
</ul>
<h3 id="关于四季"><a href="#关于四季" class="headerlink" title="关于四季"></a>关于四季</h3><p>指一般的四季而不是具体指某年的某一段时间时，通常不加冠词。</p>
<p>in spring （在春天） in summer （在夏天） in autumn （在秋天） in winter （在冬天）</p>
<p>但是，如果指特定的某一年的某个季节时，就要加冠词。比如： </p>
<p>The spring of last year was cold.（去年春天很冷。）</p>
<h3 id="关于昼夜的各段时间"><a href="#关于昼夜的各段时间" class="headerlink" title="关于昼夜的各段时间"></a>关于昼夜的各段时间</h3><ul>
<li>dawn&#x2F;daybreak （黎明 &#x2F; 破晓）</li>
<li>sunrise （日出） sunset （日落）</li>
<li>noon （正午） dusk&#x2F;twilight （黄昏）</li>
<li>night （夜晚） midnight （午夜）</li>
</ul>
<p>以上这些名词尤其是当它们出现在 at, by, after 和 before 之后时，往往不加冠词。<br>at dawn （在黎明时） at daybreak （在破晓时） at sunrise （在日出时） at sunset （在日落时） at noon （在正午时） at dusk&#x2F;twilight （在黄昏时） at night （在夜晚） at midnight （在午夜）</p>
<p>如果是用在其他介词之后，或者是在其他场合，这些名词前则往往要加冠词。<br>watch the dawn （看黎明到来） The sunrise was splendid. （日出很壮观。） We admired the sunset. （我们欣赏了日落。） see nothing in the dusk （在黄昏时什么也没看见） wake up in the night （在夜里醒来） all through the night （整整一夜）</p>
<p>另外，要注意的是，若是表示特定的某一天的某个时间段，往往用不定冠词，并且用介词 on ，此时这些名词的前面通常都会有形容词修饰。<br>on a frosty December night<br>这里的 night 前面有修饰语 frosty 和 December ，表示的是具体的某一天的晚上。此时用了不定冠词 a ，并且用了介词 on 。</p>
<h3 id="关于进餐"><a href="#关于进餐" class="headerlink" title="关于进餐"></a>关于进餐</h3><p>指一般日常惯例的用餐时，通常不加冠词。<br>have rice for dinner 晚餐吃米饭<br>for breakfast&#x2F;lunch （早餐 &#x2F; 午餐吃 …… ） stay for breakfast （留下来吃早餐） before lunch （午餐前） after dinner （晚餐后）<br>但是如果指需要特别提出的某一次用餐，则常用 the 来强调。<br>1 ） Where are we having dinner tonight?<br>2 ） The dinner after his retirement party was quite lavish.</p>
<p>若在三餐名词前有形容词时，则一般加不定冠词，来表示什么样的一餐。<br>We often have a big lunch and a nice dinner.</p>
<h3 id="关于交通工具的名词"><a href="#关于交通工具的名词" class="headerlink" title="关于交通工具的名词"></a>关于交通工具的名词</h3><p>接在 by 之后的交通工具名词，其前面不加冠词。但是这些名词在其他场合要加冠词。</p>
<ul>
<li>by bicycle </li>
<li>take the bicycle</li>
<li>by bus </li>
<li>be on the bus</li>
</ul>
<h3 id="平行结构"><a href="#平行结构" class="headerlink" title="平行结构"></a>平行结构</h3><p>如果两个名词一起放在同一平行结构里，即使是单数可数名词，也通常不加冠词。<br>face to face 面对面；当面 back to back 背对背<br>arm in arm 手挽着手 hand in hand 手牵手<br>eye to eye&#x2F;eyeball to eyeball 面对面地，针锋相对地<br>toe to toe 脚尖挨脚尖，摩肩接踵 shoulder to shoulder&#x2F;side by side 肩并肩地<br>inch by inch 逐渐地，一步一步地 day after day（&#x3D;day by day） 日复一日<br>from person to person 挨个地 from door to door 挨家挨户地<br>from top to toe 从头到脚，完完全全 from father to son 从父到子<br>They talked face to face. 他们面对面地谈话。<br>They talked man to man. 他们坦率地交谈。</p>
<p>这些名词没有冠词是因为它们基本上失去了名词的主要特性，比如它们没有数的变化。不能说： They talked faces to faces. * 它们的前面也不能有修饰语。比如不能说： They talked old man to young man. * 因此，我们不妨把这些短语看成是英语的固定习语。</p>
<h1 id="Other-notes"><a href="#Other-notes" class="headerlink" title="Other notes"></a>Other notes</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Home didn&#x27;t have a flush toilet or refrigerator until Arnie was 14.</span><br></pre></td></tr></table></figure>
<p>这里的refrigerator前面不用加a，是因为or组成的两个名词前面只需要在第一个名词加不定冠词即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Maria Shiver, is an anchor woman on U.S. TV news and niece of assassinated President John F. Kennedy.</span><br></pre></td></tr></table></figure>
<p>同样的道理，这里and修饰的前后两个名词，也只有前者需要加不定冠词。</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>Java Bean Validation Basics</title>
    <url>/2020/04/04/Java-Bean-Validation-Basics/</url>
    <content><![CDATA[<blockquote>
<p>参考来自<a href="http://www.baeldung.com的多篇文章/">www.baeldung.com的多篇文章</a></p>
</blockquote>
<h1 id="Java-Bean-Validation的历史演变"><a href="#Java-Bean-Validation的历史演变" class="headerlink" title="Java Bean Validation的历史演变"></a>Java Bean Validation的历史演变</h1><ul>
<li>原本以为JSR303就已经是够了，后面才发现这只是initial version，也就是Bean Validation 1.0；</li>
<li>后面又推出了JSR349（Bean Validation 1.1）</li>
<li>而最新版本是<a href="https://jcp.org/en/jsr/detail?id=380">JSR380</a>（<a href="https://beanvalidation.org/2.0/">Bean Validation 2.0</a>）</li>
</ul>
<h1 id="依赖包"><a href="#依赖包" class="headerlink" title="依赖包"></a>依赖包</h1><p>在不使用第三方的框架提供的校验功能（比如Spring，Spring默认会引入依赖并对标准做了一些具体的实现）的情况下，想要使用Java Bean Validation的功能需要先引入标准API依赖(这里以2.0版本为准)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.validation&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;validation-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.0.0.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>除了引入标准之外，还要引入标准的实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;6.0.2.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;hibernate-validator-annotation-processor&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;6.0.2.Final&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>这里只是引入的hibernate的validator部分，没有引入持久化的那部分。<br>再引入el表达式的依赖：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;javax.el&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;3.0.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"> </span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;javax.el&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<p>如果没有引入el表达式的依赖可能会报错：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HV000183: Unable to load ‘javax.el.ExpressionFactory&#x27;. Check that you have the EL dependencies on the classpath, or use ParameterMessageInterpolator instead</span><br></pre></td></tr></table></figure>

<h1 id="可以通过Validator对Bean进行数据校验"><a href="#可以通过Validator对Bean进行数据校验" class="headerlink" title="可以通过Validator对Bean进行数据校验"></a>可以通过Validator对Bean进行数据校验</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Test</span><br><span class="line">public void test6() &#123;</span><br><span class="line">    FetchWordResultDTO fetchWordResultDTO = new FetchWordResultDTO();</span><br><span class="line">    ValidatorFactory factory = Validation.buildDefaultValidatorFactory();</span><br><span class="line">    Validator validator = factory.getValidator();</span><br><span class="line">    Set&lt;ConstraintViolation&lt;FetchWordResultDTO&gt;&gt; results = validator.validate(fetchWordResultDTO);</span><br><span class="line">    for (ConstraintViolation&lt;FetchWordResultDTO&gt; result : results) &#123;</span><br><span class="line">        System.out.println(result.getPropertyPath());</span><br><span class="line">        System.out.println(result.getMessage());</span><br><span class="line">        System.out.println(result.getInvalidValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="校验注解"><a href="#校验注解" class="headerlink" title="校验注解"></a>校验注解</h1><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">空检查</span><br><span class="line">@Null       验证对象是否为null</span><br><span class="line">@NotNull    验证对象是否不为null, 无法查检长度为0的字符串</span><br><span class="line">@NotBlank 检查约束字符串是不是Null还有被Trim的长度是否大于0,只对字符串,且会去掉前后空格.</span><br><span class="line">@NotEmpty 检查约束元素是否为NULL或者是EMPTY.</span><br><span class="line"> </span><br><span class="line">Booelan检查</span><br><span class="line">@AssertTrue     验证 Boolean 对象是否为 true  </span><br><span class="line">@AssertFalse    验证 Boolean 对象是否为 false  </span><br><span class="line"> </span><br><span class="line">长度检查</span><br><span class="line">@Size(min=, max=) 验证对象（Array,Collection,Map,String）长度是否在给定的范围之内  </span><br><span class="line">@Length(min=, max=) Validates that the annotated string is between min and max included.</span><br><span class="line"> </span><br><span class="line">日期检查</span><br><span class="line">@Past           验证 Date 和 Calendar 对象是否在当前时间之前  </span><br><span class="line">@Future     验证 Date 和 Calendar 对象是否在当前时间之后  </span><br><span class="line">@Pattern    验证 String 对象是否符合正则表达式的规则</span><br><span class="line">@Past and @PastOrPresent – validate that a date value is in the past or the past including the present; can be applied to date types including those added in Java 8</span><br><span class="line">@Future and @FutureOrPresent – validates that a date value is in the future, or in the future including the present</span><br><span class="line"> </span><br><span class="line">数值检查，建议使用在Stirng,Integer类型，不建议使用在int类型上，因为表单值为“”时无法转换为int，但可以转换为Stirng为&quot;&quot;,Integer为null</span><br><span class="line">@Min            验证 Number 和 String 对象是否大等于指定的值  </span><br><span class="line">@Max            验证 Number 和 String 对象是否小等于指定的值  </span><br><span class="line">@DecimalMax 被标注的值必须不大于约束中指定的最大值. 这个约束的参数是一个通过BigDecimal定义的最大值的字符串表示.小数存在精度</span><br><span class="line">@DecimalMin 被标注的值必须不小于约束中指定的最小值. 这个约束的参数是一个通过BigDecimal定义的最小值的字符串表示.小数存在精度</span><br><span class="line">@Digits     验证 Number 和 String 的构成是否合法  </span><br><span class="line">@Digits(integer=,fraction=) 验证字符串是否是符合指定格式的数字，interger指定整数精度，fraction指定小数精度。</span><br><span class="line">@Positive and @PositiveOrZero – apply to numeric values and validate that they are strictly positive, or positive including 0</span><br><span class="line">@Negative and @NegativeOrZero – apply to numeric values and validate that they are strictly negative, or negative including 0</span><br><span class="line"> </span><br><span class="line">@Range(min=, max=) 检查数字是否介于min和max之间.</span><br><span class="line">@Range(min=10000,max=50000,message=&quot;range.bean.wage&quot;)</span><br><span class="line">private BigDecimal wage;</span><br><span class="line"> </span><br><span class="line">@Valid 递归的对关联对象进行校验, 如果关联对象是个集合或者数组,那么对其中的元素进行递归校验,如果是一个map,则对其中的值部分进行校验.(是否进行递归验证)</span><br><span class="line">@CreditCardNumber信用卡验证</span><br><span class="line">@Email  验证是否是邮件地址，如果为null,不进行验证，算通过验证。</span><br><span class="line">@ScriptAssert(lang= ,script=, alias=)</span><br><span class="line">@URL(protocol=,host=, port=,regexp=, flags=)</span><br><span class="line">// 参考 https://www.cnblogs.com/yangzhilong/p/3724967.html</span><br></pre></td></tr></table></figure>

<h1 id="Validation-in-Spring-Boot"><a href="#Validation-in-Spring-Boot" class="headerlink" title="Validation in Spring Boot"></a>Validation in Spring Boot</h1><h2 id="利用-Valid对数据做优雅的校验"><a href="#利用-Valid对数据做优雅的校验" class="headerlink" title="利用@Valid对数据做优雅的校验"></a>利用@Valid对数据做优雅的校验</h2><p>校验异常会抛出MethodArgumentNotValidException，然后可以Spring的机制定义全局异常处理器。<br>Demo of Controller:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@PostMapping(&quot;/storeFetchWordResult&quot;)</span><br><span class="line">public R storeFetchWordResult(@RequestBody @Valid FetchWordResultDTO fetchWordResultDTO) &#123;</span><br><span class="line">    // do something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>全局异常处理器:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Slf4j</span><br><span class="line">@ControllerAdvice</span><br><span class="line">public class GlobalValidExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line">    @ResponseBody</span><br><span class="line">    @ExceptionHandler(&#123;MethodArgumentNotValidException.class&#125;)</span><br><span class="line">    public R handleValidException(MethodArgumentNotValidException e)&#123;</span><br><span class="line">        //日志记录错误信息</span><br><span class="line">        log.error(Objects.requireNonNull(e.getBindingResult().getFieldError()).getDefaultMessage());</span><br><span class="line">        //将错误信息返回给前台</span><br><span class="line">        return R.failed(CommonConstants.FAIL, Objects.requireNonNull(e.getBindingResult().getFieldError()).getDefaultMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 优化之后的全局异常处理器</span><br><span class="line"></span><br><span class="line">@Slf4j</span><br><span class="line">@RestControllerAdvice</span><br><span class="line">public class GlobalExceptionHandler &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @ExceptionHandler(&#123;MethodArgumentNotValidException.class&#125;)</span><br><span class="line">    @ResponseStatus(HttpStatus.BAD_REQUEST)</span><br><span class="line">    public R handleValidException(MethodArgumentNotValidException e)&#123;</span><br><span class="line">        //日志记录错误信息</span><br><span class="line">        final String errorMessage = EnhancedExceptionUtils.getLogMessage(e);</span><br><span class="line">        log.error(errorMessage);</span><br><span class="line">        //将错误信息返回给前台</span><br><span class="line">        return R.failed(CommonConstants.FAIL, errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>某知名博客文章的全局异常处理器demo（多个字段的错误校验可以更加直观地展示出来）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ResponseStatus(HttpStatus.BAD_REQUEST)</span><br><span class="line">@ExceptionHandler(MethodArgumentNotValidException.class)</span><br><span class="line">public Map&lt;String, String&gt; handleValidationExceptions(</span><br><span class="line">  MethodArgumentNotValidException ex) &#123;</span><br><span class="line">    Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();</span><br><span class="line">    ex.getBindingResult().getAllErrors().forEach((error) -&gt; &#123;</span><br><span class="line">        String fieldName = ((FieldError) error).getField();</span><br><span class="line">        String errorMessage = error.getDefaultMessage();</span><br><span class="line">        errors.put(fieldName, errorMessage);</span><br><span class="line">    &#125;);</span><br><span class="line">    return errors;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Validated-vs-Valid"><a href="#Validated-vs-Valid" class="headerlink" title="@Validated vs @Valid"></a>@Validated vs @Valid</h2><p><a href="https://blog.csdn.net/qq_27680317/article/details/79970590">两者的区别</a><br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/0e8YJB.png"></p>
<h2 id="Validated应用在ctl方法的参数的好处"><a href="#Validated应用在ctl方法的参数的好处" class="headerlink" title="@Validated应用在ctl方法的参数的好处"></a>@Validated应用在ctl方法的参数的好处</h2><p>可以直接在形参上注解：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public ResponseMessage&lt;IPage&lt;PostPhoneInfo&gt;&gt; queryPage(@NotNull Long pageNum, @NotNull Long pageSize, PostPhoneInfo postPhoneInfo) &#123;</span><br><span class="line">    return ResponseMessage.success(postPhoneInfoService.queryPage(pageNum, pageSize, postPhoneInfo));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前我直接想直接采用注解校验入参，不想将校验逻辑带到业务中去，但是使用@Valid无法做到，而Spring封装好的@Validated可以做到。</p>
<h4 id="要注意的地方"><a href="#要注意的地方" class="headerlink" title="要注意的地方"></a>要注意的地方</h4><ul>
<li>校验注解是在方法入参上，则需要在该方法所在的类上添加 @org.springframework.validation.annotation.Validated 注解，在入参前或是在方法上添加启用校验注解都不生效。</li>
<li>如果ctl方法的入参是一个Java Bean承载，那么无需使用@NotNull校验，Spring模式会给一个空实例，@NotNull注解没有意义</li>
<li>使用@Validated分组的时候，比如只需要在某个ctl的方法上指定分组校验时，代码可以这样：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 新增 or 更新</span><br><span class="line"> */</span><br><span class="line">@ApiOperation(notes = &quot;保存单条记录&quot;, value = &quot;保存查询单条记录&quot;)</span><br><span class="line">@PostMapping(&quot;/saveOne&quot;)</span><br><span class="line">@Validated(Default.class)</span><br><span class="line">public ResponseMessage&lt;Void&gt; saveOne(@Valid PostPhoneInfoVO postPhoneInfoVO) &#123;</span><br><span class="line">    postPhoneInfoService.saveOne(postPhoneInfoVO);</span><br><span class="line">    return ResponseMessage.success();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Custom-Validation-MessageSource-in-Spring-Boot"><a href="#Custom-Validation-MessageSource-in-Spring-Boot" class="headerlink" title="Custom Validation MessageSource in Spring Boot"></a>Custom Validation MessageSource in Spring Boot</h2><p>MessageSource是Spring Boot很强大的一个特性，最为明显的是可以用于国际化处理。</p>
<h4 id="一个登陆表单的demo"><a href="#一个登陆表单的demo" class="headerlink" title="一个登陆表单的demo"></a>一个登陆表单的demo</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class LoginForm &#123;</span><br><span class="line"> </span><br><span class="line">    @NotEmpty(message = &quot;&#123;email.notempty&#125;&quot;)</span><br><span class="line">    @Email</span><br><span class="line">    private String email;</span><br><span class="line"> </span><br><span class="line">    @NotNull</span><br><span class="line">    private String password;</span><br><span class="line"> </span><br><span class="line">    // standard getter and setters</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义MessageSource-Bean"><a href="#定义MessageSource-Bean" class="headerlink" title="定义MessageSource Bean"></a>定义MessageSource Bean</h4><p>ReloadableResourceBundleMessageSource是最常用的MessageSource实现类</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public MessageSource messageSource() &#123;</span><br><span class="line">    ReloadableResourceBundleMessageSource messageSource</span><br><span class="line">      = new ReloadableResourceBundleMessageSource();</span><br><span class="line">     </span><br><span class="line">    messageSource.setBasename(&quot;classpath:messages&quot;);</span><br><span class="line">    messageSource.setDefaultEncoding(&quot;UTF-8&quot;);</span><br><span class="line">    return messageSource;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义LocalValidatorFactoryBean来注册上面的MessageSource-Bean"><a href="#定义LocalValidatorFactoryBean来注册上面的MessageSource-Bean" class="headerlink" title="定义LocalValidatorFactoryBean来注册上面的MessageSource Bean"></a>定义LocalValidatorFactoryBean来注册上面的MessageSource Bean</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public LocalValidatorFactoryBean getValidator() &#123;</span><br><span class="line">    LocalValidatorFactoryBean bean = new LocalValidatorFactoryBean();</span><br><span class="line">    bean.setValidationMessageSource(messageSource());</span><br><span class="line">    return bean;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定义国际化配置文件"><a href="#定义国际化配置文件" class="headerlink" title="定义国际化配置文件"></a>定义国际化配置文件</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># messages.properties</span><br><span class="line">email.notempty=Please provide valid email id.</span><br><span class="line"># messages_fr.properties</span><br><span class="line">email.notempty=Veuillez fournir un identifiant de messagerie valide.</span><br></pre></td></tr></table></figure>

<h2 id="Method-Constraints-with-Bean-Validation-2-0"><a href="#Method-Constraints-with-Bean-Validation-2-0" class="headerlink" title="Method Constraints with Bean Validation 2.0"></a>Method Constraints with Bean Validation 2.0</h2><p>这个特性可以用于哪些比较复杂又常用的数据校验，而且校验逻辑是JSR380的注解不能实现的，所以需要自定义校验。</p>
<ul>
<li>Single-parameter Constraints</li>
<li>Cross-Parameter Constraints</li>
<li>return constraints</li>
</ul>
<h4 id="自定义校验注解实现Cross-Parameter-Constraints"><a href="#自定义校验注解实现Cross-Parameter-Constraints" class="headerlink" title="自定义校验注解实现Cross-Parameter Constraints"></a>自定义校验注解实现Cross-Parameter Constraints</h4><p>比如以下Demo：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@ConsistentDateParameters</span><br><span class="line">public void createReservation(LocalDate begin, </span><br><span class="line">  LocalDate end, Customer customer) &#123;</span><br><span class="line">    // ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如要有个业务场景是要求：begin必须比当前时间大，而且end必须比begin大的情况，那么使用JSR380的内置注解就无法实现了，所以要自定义校验注解和注解校验器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Constraint(validatedBy = ConsistentDateParameterValidator.class)</span><br><span class="line">@Target(&#123; METHOD, CONSTRUCTOR &#125;)</span><br><span class="line">@Retention(RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface ConsistentDateParameters &#123;</span><br><span class="line"> </span><br><span class="line">    String message() default</span><br><span class="line">      &quot;End date must be after begin date and both must be in the future&quot;;</span><br><span class="line"> </span><br><span class="line">    Class&lt;?&gt;[] groups() default &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@SupportedValidationTarget(ValidationTarget.PARAMETERS)</span><br><span class="line">public class ConsistentDateParameterValidator </span><br><span class="line">  implements ConstraintValidator&lt;ConsistentDateParameters, Object[]&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public boolean isValid(</span><br><span class="line">      Object[] value, </span><br><span class="line">      ConstraintValidatorContext context) &#123;</span><br><span class="line">         </span><br><span class="line">        if (value[0] == null || value[1] == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        if (!(value[0] instanceof LocalDate) </span><br><span class="line">          || !(value[1] instanceof LocalDate)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(</span><br><span class="line">              &quot;Illegal method signature, expected two parameters of type LocalDate.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        return ((LocalDate) value[0]).isAfter(LocalDate.now()) </span><br><span class="line">          &amp;&amp; ((LocalDate) value[0]).isBefore((LocalDate) value[1]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="自定义返回值的校验注解"><a href="#自定义返回值的校验注解" class="headerlink" title="自定义返回值的校验注解"></a>自定义返回值的校验注解</h4><p>比如要校验某个复杂的对象Reservation：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ReservationManagement &#123;</span><br><span class="line"> </span><br><span class="line">    @ValidReservation</span><br><span class="line">    public Reservation getReservationsById(int id) &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义注解，注意注解的范围可以是构造器CONSTRUCTOR：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Constraint(validatedBy = ValidReservationValidator.class)</span><br><span class="line">@Target(&#123; METHOD, CONSTRUCTOR &#125;)</span><br><span class="line">@Retention(RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">public @interface ValidReservation &#123;</span><br><span class="line">    String message() default &quot;End date must be after begin date &quot;</span><br><span class="line">      + &quot;and both must be in the future, room number must be bigger than 0&quot;;</span><br><span class="line"> </span><br><span class="line">    Class&lt;?&gt;[] groups() default &#123;&#125;;</span><br><span class="line"> </span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>校验器的具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ValidReservationValidator</span><br><span class="line">  implements ConstraintValidator&lt;ValidReservation, Reservation&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    @Override</span><br><span class="line">    public boolean isValid(</span><br><span class="line">      Reservation reservation, ConstraintValidatorContext context) &#123;</span><br><span class="line"> </span><br><span class="line">        if (reservation == null) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        if (!(reservation instanceof Reservation)) &#123;</span><br><span class="line">            throw new IllegalArgumentException(&quot;Illegal method signature, &quot;</span><br><span class="line">            + &quot;expected parameter of type Reservation.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        if (reservation.getBegin() == null</span><br><span class="line">          || reservation.getEnd() == null</span><br><span class="line">          || reservation.getCustomer() == null) &#123;</span><br><span class="line">            return false;</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        return (reservation.getBegin().isAfter(LocalDate.now())</span><br><span class="line">          &amp;&amp; reservation.getBegin().isBefore(reservation.getEnd())</span><br><span class="line">          &amp;&amp; reservation.getRoom() &gt; 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就可以在构造器方法上使用注解了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Reservation &#123;</span><br><span class="line"> </span><br><span class="line">    @ValidReservation</span><br><span class="line">    public Reservation(</span><br><span class="line">      LocalDate begin, </span><br><span class="line">      LocalDate end, </span><br><span class="line">      Customer customer, </span><br><span class="line">      int room) &#123;</span><br><span class="line">        this.begin = begin;</span><br><span class="line">        this.end = end;</span><br><span class="line">        this.customer = customer;</span><br><span class="line">        this.room = room;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    // properties, getters, and setters</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="级联校验-嵌套校验（Cascaded-Validation）"><a href="#级联校验-嵌套校验（Cascaded-Validation）" class="headerlink" title="级联校验 || 嵌套校验（Cascaded Validation）"></a>级联校验 || 嵌套校验（Cascaded Validation）</h4><p>想要校验对象里面的成员属性内部的相关校验，需要再成员属性声明加上@Valid注解，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Reservation &#123;</span><br><span class="line"> </span><br><span class="line">    @Valid</span><br><span class="line">    private Customer customer;</span><br><span class="line">     </span><br><span class="line">    @Positive</span><br><span class="line">    private int room;</span><br><span class="line">     </span><br><span class="line">    // further properties, constructor, getters and setters</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Validating-Container-Elements-with-Bean-Validation-2-0"><a href="#Validating-Container-Elements-with-Bean-Validation-2-0" class="headerlink" title="Validating Container Elements with Bean Validation 2.0"></a>Validating Container Elements with Bean Validation 2.0</h1><h2 id="注意内置的校验还可以用于集合的泛型定义"><a href="#注意内置的校验还可以用于集合的泛型定义" class="headerlink" title="注意内置的校验还可以用于集合的泛型定义"></a>注意内置的校验还可以用于集合的泛型定义</h2><p>比如下面Customer前面的@NotNull：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ReservationManagement &#123;</span><br><span class="line">    @NotNull</span><br><span class="line">    @Size(min = 1)</span><br><span class="line">    public List&lt;@NotNull Customer&gt; getAllCustomers() &#123;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Customer &#123;    </span><br><span class="line">     List&lt;@NotBlank(message=&quot;Address must not be blank&quot;) String&gt; addresses;</span><br><span class="line">     </span><br><span class="line">    // standard getters, setters </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class CustomerMap &#123;</span><br><span class="line">     </span><br><span class="line">    private Map&lt;@Email String, @NotNull Customer&gt; customers;</span><br><span class="line">     </span><br><span class="line">    // standard getters, setters</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Optional-Values"><a href="#Optional-Values" class="headerlink" title="Optional Values"></a>Optional Values</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private Integer age;</span><br><span class="line"> </span><br><span class="line">public Optional&lt;@Min(18) Integer&gt; getAge() &#123;</span><br><span class="line">    return Optional.ofNullable(age);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="非泛型容器的元素（Non-Generic-Container-Elements）"><a href="#非泛型容器的元素（Non-Generic-Container-Elements）" class="headerlink" title="非泛型容器的元素（Non-Generic Container Elements）"></a>非泛型容器的元素（Non-Generic Container Elements）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">@Min(1)</span><br><span class="line">private OptionalInt numberOfOrders;</span><br></pre></td></tr></table></figure>

<h1 id="Problem-Solution"><a href="#Problem-Solution" class="headerlink" title="Problem Solution"></a>Problem Solution</h1><h2 id="HV000030-No-validator-could-be-found-for-type-java-lang-Integer"><a href="#HV000030-No-validator-could-be-found-for-type-java-lang-Integer" class="headerlink" title="HV000030: No validator could be found for type: java.lang.Integer."></a>HV000030: No validator could be found for type: java.lang.Integer.</h2><p><a href="https://blog.csdn.net/xiaobingtao/article/details/41866235">https://blog.csdn.net/xiaobingtao/article/details/41866235</a></p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JSR303</tag>
        <tag>JSR349</tag>
        <tag>JSR380</tag>
        <tag>Java Bean Validation</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring系列之SpringCloud微服务架构</title>
    <url>/2020/04/09/Spring%E7%B3%BB%E5%88%97%E4%B9%8BSpringCloud%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h1 id="公司的微服务模块架构关系"><a href="#公司的微服务模块架构关系" class="headerlink" title="公司的微服务模块架构关系"></a>公司的微服务模块架构关系</h1><h2 id="云原生"><a href="#云原生" class="headerlink" title="云原生"></a>云原生</h2>]]></content>
  </entry>
  <entry>
    <title>CSS备忘录</title>
    <url>/2020/05/01/CSS%E5%A4%87%E5%BF%98%E5%BD%95/</url>
    <content><![CDATA[<h2 id="固定在div的右下角"><a href="#固定在div的右下角" class="headerlink" title="固定在div的右下角"></a>固定在div的右下角</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">position:absolute;</span><br><span class="line">right:5px;</span><br><span class="line">bottom:5px;</span><br></pre></td></tr></table></figure>

<h2 id="下外边框距离（和底部的div拉开距离）"><a href="#下外边框距离（和底部的div拉开距离）" class="headerlink" title="下外边框距离（和底部的div拉开距离）"></a>下外边框距离（和底部的div拉开距离）</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">margin-bottom: 10px</span><br></pre></td></tr></table></figure>

<h2 id="靠边"><a href="#靠边" class="headerlink" title="靠边"></a>靠边</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.pull-right &#123;</span><br><span class="line">  float: right !important;</span><br><span class="line">&#125;</span><br><span class="line">.pull-left &#123;</span><br><span class="line">  float: left !important;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="字体加粗"><a href="#字体加粗" class="headerlink" title="字体加粗"></a>字体加粗</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;b&gt;&lt;/b&gt;</span><br><span class="line">&lt;strong&gt;&lt;/strong&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CSS</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue系列之Vue Router</title>
    <url>/2020/05/01/Vue%E7%B3%BB%E5%88%97%E4%B9%8BVue-Router/</url>
    <content><![CDATA[<h1 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h1><h2 id="的基本使用"><a href="#的基本使用" class="headerlink" title="的基本使用"></a><router-view></router-view>的基本使用</h2><p>假如路由的配置如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export default [&#123;</span><br><span class="line">  path: &#x27;/index&#x27;,</span><br><span class="line">  component: $ =&gt; import(&#x27;@/page/index/Index&#x27;),</span><br><span class="line">  children: [&#123;</span><br><span class="line">    path: &#x27;vocabulary&#x27;,</span><br><span class="line">    component: $ =&gt; import(&#x27;@/page/word/Search&#x27;),</span><br><span class="line">    children: [&#123;</span><br><span class="line">      path: &#x27;detail&#x27;,</span><br><span class="line">      component: $ =&gt; import(&#x27;@/page/word/Detail&#x27;)</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      path: &#x27;starList&#x27;,</span><br><span class="line">      component: $ =&gt; import(&#x27;@/page/word/StarList&#x27;)</span><br><span class="line">    &#125;, &#123;</span><br><span class="line">      path: &#x27;starListDetail&#x27;,</span><br><span class="line">      component: $ =&gt; import(&#x27;@/page/word/StarListDetail&#x27;)</span><br><span class="line">    &#125;]</span><br><span class="line">  &#125;]</span><br><span class="line">&#125;]</span><br></pre></td></tr></table></figure>

<p>vue的依赖关系如下：</p>
<blockquote>
<p>App.vue -&gt; @&#x2F;page&#x2F;index&#x2F;Index.vue -&gt; @&#x2F;page&#x2F;word&#x2F;Search.vue</p>
</blockquote>
<p>App.vue：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div id=&quot;app&quot;&gt;</span><br><span class="line">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<p>@&#x2F;page&#x2F;index&#x2F;Index.vue：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div class=&quot;platform-header&quot;&gt;</span><br><span class="line">        &lt;div&gt;一些固定内容xxx，比如页头，导航栏之类的&lt;div&gt;</span><br><span class="line">        &lt;router-view&gt;&lt;/router-view&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<p>@&#x2F;page&#x2F;word&#x2F;Search.vue：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        某个子组件的具体内容xxx</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>
<p>这时候可以在浏览器访问<a href="http://localhost:8080/#/index/vocabulary%EF%BC%8C%E8%BF%99%E4%B8%AA%E6%97%B6%E5%80%99%E5%B0%B1%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E8%AE%BF%E9%97%AE%E5%88%B0Index%E5%92%8CSearch%E7%BB%84%E4%BB%B6%E7%9A%84%E5%86%85%E5%AE%B9%EF%BC%8C%E6%AD%A4%E5%A4%96%EF%BC%8C%E5%A6%82%E6%9E%9CSearch%E7%9A%84%E7%BB%84%E4%BB%B6%E5%86%85%E5%AE%B9%E6%9C%89%E6%89%80%E5%8F%98%E5%8C%96%EF%BC%8C">http://localhost:8080/#/index/vocabulary，这个时候就可以同时访问到Index和Search组件的内容，此外，如果Search的组件内容有所变化，</a><br>改变路径的节点即可实现浏览器页面不调整的变化，这样用户体验更好跟快。</p>
]]></content>
      <categories>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>原油宝事件简单分析</title>
    <url>/2020/04/26/%E5%8E%9F%E6%B2%B9%E5%AE%9D%E4%BA%8B%E4%BB%B6%E7%AE%80%E5%8D%95%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h2 id="期货交易原理"><a href="#期货交易原理" class="headerlink" title="期货交易原理"></a>期货交易原理</h2><p>期货一般是买方（多方）&lt;&#x3D;&gt;卖方（空方）</p>
<p>双方指定在未来的某个时间一手交钱一手交货，前提是双方签订之日都交保证金（比如这一单的10%）</p>
<h4 id="期货平仓机制"><a href="#期货平仓机制" class="headerlink" title="期货平仓机制"></a>期货平仓机制</h4><p>空方卖给多方按照合约的价格P1和时间的交易过程叫【开仓】</p>
<p>如果出现异常情况不能【开仓】，那么就会启动【平仓】操作：多方把合约还给空方，此时采用另外一个价格P2（该价格随着市场的波动变化）【平仓】，【强制平仓】可以及时止损。</p>
<p>综上所述：</p>
<p>如果P1&lt;P2，多方就赚了，空方亏了，因为多方在过去的时间以低价位拿到货，而在交易时日时，平仓的时候空方要重新拿回来合约要以更高的价格结算；</p>
<p>如果P1&gt;P2，反之，多方亏了，空方赚了。</p>
<h4 id="期货保证金交易制度"><a href="#期货保证金交易制度" class="headerlink" title="期货保证金交易制度"></a>期货保证金交易制度</h4><h5 id="假如油价在拟定合约后上涨的情况"><a href="#假如油价在拟定合约后上涨的情况" class="headerlink" title="假如油价在拟定合约后上涨的情况"></a>假如油价在拟定合约后上涨的情况</h5><p>期货市场的【平仓保证金交易制度】（假如以10%结算）：</p>
<table>
<thead>
<tr>
<th>交易阶段</th>
<th>买方（多方）保证金账户</th>
<th>卖方（空方）保证金账户</th>
<th>输方的资金流入</th>
</tr>
</thead>
<tbody><tr>
<td>期货合约拟定（总价比如20000$）</td>
<td>2000$</td>
<td>2000$</td>
<td>0$</td>
</tr>
<tr>
<td>临近交货时日价格变动之后（假如油价上涨8个点，总价25000）</td>
<td>2500$（从空方划走500$）</td>
<td>2500$（保证金不足，要再充值1500元）</td>
<td>1500$</td>
</tr>
</tbody></table>
<p>如果有一方因为交不起保证金的情况下，交易所就会强行平仓，这样一来，【原本的空方就要变成买房来重新买回来之前的合约，不过是以更高的价位买入，也就是上文提到的P2】</p>
<h5 id="假如油价在拟定合约后下跌的情况"><a href="#假如油价在拟定合约后下跌的情况" class="headerlink" title="假如油价在拟定合约后下跌的情况"></a>假如油价在拟定合约后下跌的情况</h5><p>保证金在下跌的情况，合约签订时计算好的保证金已经交足，所以保证金账户余额里面就一直是充足的，无需追加保证金。【应该是这样】</p>
<p>单看价格下跌，其实如果是直接期货交易完成，对于两方来说是无伤大雅，但是不要忘了，期货是要实货交易的，这就是原油宝问题的致命之处。</p>
<h4 id="原油宝事件的致命问题"><a href="#原油宝事件的致命问题" class="headerlink" title="原油宝事件的致命问题"></a>原油宝事件的致命问题</h4><p>如果说按照合约规定，到期后在一定的短时间内，多方（原油宝客户 约等于 中行）去美国的油库提油，那么问题不大，可惜没有这个如果，中行没有能力在短时间内拿出设备和运载工具去提油！</p>
<p>既然无法真实交易，那么交易所会自动强行平仓，这下麻烦大了，按照当前负油价，那么原油宝客户方一下子从多方变成空方，空方此时卖原油是要倒贴钱的啊！</p>
]]></content>
      <categories>
        <category>理财</category>
      </categories>
      <tags>
        <tag>理财</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue系列之公司前端项目架构</title>
    <url>/2020/05/01/Vue%E7%B3%BB%E5%88%97%E4%B9%8B%E5%85%AC%E5%8F%B8%E5%89%8D%E7%AB%AF%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84/</url>
    <content><![CDATA[<h2 id="babel"><a href="#babel" class="headerlink" title="babel"></a>babel</h2><p>可以在babeljs.cn网站查看es6语法编译前和编译后的区别</p>
<h2 id="webcomponents-org"><a href="#webcomponents-org" class="headerlink" title="webcomponents.org"></a>webcomponents.org</h2><h2 id="vue、vue-router、vuex（全家桶）"><a href="#vue、vue-router、vuex（全家桶）" class="headerlink" title="vue、vue-router、vuex（全家桶）"></a>vue、vue-router、vuex（全家桶）</h2><h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>图片在 youdao note</p>
<h2 id="symbol"><a href="#symbol" class="headerlink" title="symbol()"></a>symbol()</h2><h2 id="element-ui"><a href="#element-ui" class="headerlink" title="element ui"></a>element ui</h2><h2 id="图标库"><a href="#图标库" class="headerlink" title="图标库"></a>图标库</h2><h2 id="mockjs"><a href="#mockjs" class="headerlink" title="mockjs"></a>mockjs</h2><h2 id="lodashjs"><a href="#lodashjs" class="headerlink" title="lodashjs"></a>lodashjs</h2><h2 id="es6"><a href="#es6" class="headerlink" title="es6"></a>es6</h2><p>###import<br>常规import<br>异步import</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">const jquery = import ...</span><br></pre></td></tr></table></figure>
<p>图片在 youdao note</p>
<h2 id="scss"><a href="#scss" class="headerlink" title="scss"></a>scss</h2><h2 id="pug"><a href="#pug" class="headerlink" title="pug"></a>pug</h2><h2 id="unit测试"><a href="#unit测试" class="headerlink" title="unit测试"></a>unit测试</h2><h2 id="e2e端对端测试"><a href="#e2e端对端测试" class="headerlink" title="e2e端对端测试"></a>e2e端对端测试</h2>]]></content>
      <categories>
        <category>Web前端</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title>网上各种讲师技术笔记整合收集</title>
    <url>/2020/05/04/%E7%BD%91%E4%B8%8A%E5%90%84%E7%A7%8D%E8%AE%B2%E5%B8%88%E6%8A%80%E6%9C%AF%E7%AC%94%E8%AE%B0%E6%95%B4%E5%90%88%E6%94%B6%E9%9B%86/</url>
    <content><![CDATA[<h1 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h1><p><a href="https://www.fengorz.me/html/Docker.html">尚硅谷Docker基础笔记</a></p>
<p><a href="https://github.com/coding-by-feng/coding-by-feng.github.io/blob/master/html/docker-in-microservice.pdf">Docker入门与微服务部署-诸葛老师</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>kiwi-microservice项目架构技术记录</title>
    <url>/2020/05/13/kiwi-microservice%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E6%8A%80%E6%9C%AF%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h1 id="运行启动"><a href="#运行启动" class="headerlink" title="运行启动"></a>运行启动</h1><h2 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h2><ul>
<li>项目的maven打包要先去掉根目录（父模块）的pom.xml的modules标签，然后先install根模块(kiwi-microservice)</li>
<li>然后再单独install kiwi-cloud-service模块</li>
<li>最后如果想要一次性用maven命令操作其他所有模块再把modules标签放开注释即可通过根目录的pom.xml来操作子模块</li>
</ul>
]]></content>
      <categories>
        <category>kiwi</category>
      </categories>
      <tags>
        <tag>kiwi</tag>
      </tags>
  </entry>
  <entry>
    <title>linux系列之问题汇总</title>
    <url>/2020/05/14/linux%E7%B3%BB%E5%88%97%E4%B9%8B%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="apt-get国内太慢"><a href="#apt-get国内太慢" class="headerlink" title="apt-get国内太慢"></a>apt-get国内太慢</h2><p>ubuntu和debian的镜像源都要换:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i s@/archive.ubuntu.com/@/mirrors.aliyun.com/@g /etc/apt/sources.list</span><br><span class="line">sed -i &#x27;s/deb.debian.org/mirrors.ustc.edu.cn/g&#x27; /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>还原:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sed -i s@/mirrors.aliyun.com/@/deb.debian.org/@g /etc/apt/sources.list</span><br></pre></td></tr></table></figure>
<p>更换163的镜像:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#更新apt-get源 使用163的源</span><br><span class="line">mv /etc/apt/sources.list /etc/apt/sources.list.bak &amp;&amp; \</span><br><span class="line">    echo &quot;deb http://mirrors.163.com/debian/ jessie main non-free contrib&quot; &gt;/etc/apt/sources.list &amp;&amp; \</span><br><span class="line">    echo &quot;deb http://mirrors.163.com/debian/ jessie-proposed-updates main non-free contrib&quot; &gt;&gt;/etc/apt/sources.list &amp;&amp; \</span><br><span class="line">    echo &quot;deb-src http://mirrors.163.com/debian/ jessie main non-free contrib&quot; &gt;&gt;/etc/apt/sources.list &amp;&amp; \</span><br><span class="line">    echo &quot;deb-src http://mirrors.163.com/debian/ jessie-proposed-updates main non-free contrib&quot; &gt;&gt;/etc/apt/sources.list</span><br></pre></td></tr></table></figure>

<h2 id="apk命令更换源"><a href="#apk命令更换源" class="headerlink" title="apk命令更换源"></a>apk命令更换源</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;http://mirrors.aliyun.com/alpine/v3.8/main&quot; &gt; /etc/apk/repositories \</span><br><span class="line">    &amp;&amp; echo &quot;http://mirrors.aliyun.com/alpine/v3.8/community&quot; &gt;&gt; /etc/apk/repositories \</span><br><span class="line">    &amp;&amp; apk update upgrade \</span><br></pre></td></tr></table></figure>

<h2 id="将命令的返回值赋值给变量（Shell命令）"><a href="#将命令的返回值赋值给变量（Shell命令）" class="headerlink" title="将命令的返回值赋值给变量（Shell命令）"></a>将命令的返回值赋值给变量（Shell命令）</h2><ul>
<li>A&#x3D;<code>ls -la</code> 反引号，运行里面的命令，并把结果返回给变量A</li>
<li>A&#x3D;$(ls -la)等价于反引号</li>
</ul>
<h2 id="linux-shell通过curl获取HTTP请求的状态码"><a href="#linux-shell通过curl获取HTTP请求的状态码" class="headerlink" title="linux shell通过curl获取HTTP请求的状态码"></a>linux shell通过curl获取HTTP请求的状态码</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">curl -I -m 10 -o /dev/null -s -w %&#123;http_code&#125; www.baidu.com</span><br></pre></td></tr></table></figure>

<h2 id="shell获取系统当前时间并格式化"><a href="#shell获取系统当前时间并格式化" class="headerlink" title="shell获取系统当前时间并格式化"></a>shell获取系统当前时间并格式化</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">time=$(date &quot;+%Y-%m-%d %H:%M:%S&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="安装包打包命令"><a href="#安装包打包命令" class="headerlink" title="安装包打包命令"></a>安装包打包命令</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">rpmbuild / dpkg-deb 可以制作 rpm / deb package</span><br></pre></td></tr></table></figure>

<h2 id="命令行特殊字符"><a href="#命令行特殊字符" class="headerlink" title="命令行特殊字符"></a>命令行特殊字符</h2><p>用双引号括起来</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sshpass -p &quot;R.XXXXXXXxxxx;/g4~&quot; ssh root@81.70.99.173</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之数量限定词与个体限定词</title>
    <url>/2020/05/30/English%E7%B3%BB%E5%88%97%E4%B9%8B%E6%95%B0%E9%87%8F%E9%99%90%E5%AE%9A%E8%AF%8D%E4%B8%8E%E4%B8%AA%E4%BD%93%E9%99%90%E5%AE%9A%E8%AF%8D/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之进行时态（将来进行时）</title>
    <url>/2020/06/07/English%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%9B%E8%A1%8C%E6%97%B6%E6%80%81-%E5%B0%86%E6%9D%A5%E8%BF%9B%E8%A1%8C%E6%97%B6/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记摘选自张满胜老师的《英语语法新思维初级教程第2版》，以及其他网上知识点收集，只是我自己的个人复习笔记，禁止转载，如有侵权，请联系我删除。</p>
</blockquote>
<h2 id="典型用法：将来某一特定时刻正在持续的事"><a href="#典型用法：将来某一特定时刻正在持续的事" class="headerlink" title="典型用法：将来某一特定时刻正在持续的事"></a>典型用法：将来某一特定时刻正在持续的事</h2><p><em><strong>将来进行时态的典型用法，就是想象自己或其他人在将来某一特定时刻（at a particular time in future）正在做某事。</strong></em>比如下面的两个朋友在谈论休假的事：<br>A: When do you leave for Hainan?<br>B: Tomorrow. Just think, two days from now I will be lying on the beach in the sun.<br>A: Sounds great!<br>在上文中，说话人B用了will be lying这一动词变化形式，表示想象自己后天就正躺在海滩上的情景，这样的表达很生动。</p>
<p>Don’t telephone me after eight tomorrow—I’ll be having a meeting.<br>明天8点钟以后不要给我打电话，因为那时我正在开会。</p>
<p>Wait until seven o’clock so that they won’t still be eating.<br>等到7点钟再过去吧，这样他们那时就不会还在吃饭了。</p>
<h2 id="口语用法：将来计划好的事"><a href="#口语用法：将来计划好的事" class="headerlink" title="口语用法：将来计划好的事"></a>口语用法：将来计划好的事</h2><p><em><strong>在日常的口语中，我们常用will be doing来谈一个将来计划好的事情。</strong></em><br>Professor Smith will be giving a lecture on American literature tomorrow evening.<br>这里的将来进行时态表示确定好的安排。<br>明晚史密斯教授将会举行有关美国文学的讲座。<br>现在进行时态be doing也可以表示计划好的事。比如上面这个句子也可以说成：<br>Professor Smith is giving a lecture on American literature tomorrow evening. </p>
<blockquote>
<p>此时，两者的区别不是很大。因此，表示将来安排好的事情，两种时态可以换用。</p>
</blockquote>
<p>不过，二者还是有下列两点不同： </p>
<blockquote>
<p>现在进行时只表示最近的将来；而将来进行时既可以表示最近的将来，也可以表示较远的将来。</p>
</blockquote>
<p>I am meeting him tomorrow. 我明天要见他。<br>I will be meeting him tomorrow&#x2F;next year. 我明天&#x2F;明年要见他。</p>
<blockquote>
<p>现在进行时表示最近将来的动作时，必须有确定的表示将来的时间状语；而将来进行时则没有这种限制。</p>
</blockquote>
<p>1） He’s working in this room next Monday.<br>2） He’ll be working in this room.<br>在例句1）中，如果没有表示将来的时间状语next Monday，则该句一般理解成正在进行的活动，表示“他现正在这个房间里工作”。在例句2）中，虽然没有表示将来的时间状语，但依然可以表示将来的活动。</p>
<h2 id="少见用法：表示背景动作——提供另外一个短动作发生的事件背景"><a href="#少见用法：表示背景动作——提供另外一个短动作发生的事件背景" class="headerlink" title="少见用法：表示背景动作——提供另外一个短动作发生的事件背景"></a>少见用法：表示背景动作——提供另外一个短动作发生的事件背景</h2><p>同过去进行时的用法类似，将来进行时可以表示一个背景动作，来描述在这个背景动作下，将会发生的另外一个短暂动作。<br>They probably will be watching TV when we get there.<br>用将来进行时表示一个长的背景动作，比如“看电视”， 而我们“到达”是在他们看电视的过程中的某一将来的时间点发生的动作。主句的进行时表示动作较长，从句的现在时表示将来的某一短动作。<br>等我们一会儿到那里时，他们可能正在看电视。<br>Will your friends be waiting for you at the airport when you arrive?<br>你一会到达机场时，你的朋友们会在那接你吗？</p>
<h2 id="难点用法1：用在疑问句中，表示客气地询问"><a href="#难点用法1：用在疑问句中，表示客气地询问" class="headerlink" title="难点用法1：用在疑问句中，表示客气地询问"></a>难点用法1：用在疑问句中，表示客气地询问</h2><blockquote>
<p>许多美国电影和美国人口语中好像爱用进行时态，但动作又似乎并不是正在进行着，这样的表达有什么特别的意义吗？如在电影 You’ve Got Mail［注：这是由汤姆·汉克斯（Tom Hanks）和梅格·瑞 安（Meg Ryan）主演的一部美国影片，中文译名为《网上情缘》］中， 书店营业员George问Joe付款方式，用的是“How will you be paying for this？”。Joe答Cash。为何不直接用“How will you pay for this？”。这是一种习惯还是一种思维？</p>
</blockquote>
<p>这一问题涉及将来进行时态（如will be paying）的意义及其与一般将来时态（如will pay）的区别。我们注意到，上面的营业员用的是将来进行时态will be paying来询问顾客的付款方式，而不是一般将来时态will pay。<br>这个问题其实引出了“将来进行时态（will be doing）”的一种很有用的用法，即我们用它来“礼貌地询问”，显得比一般将来时will do更委婉客气。这是因为will be doing常表示很客观地询问事实，并不想干涉对方的决定；而will do往往带有各种感情色彩，如请求、命令、指示、质问甚至威胁等等。<br>所以，上述的will be paying就是表示一种客气的询问。我们知道这是发生在书店营业员和顾客之间的对话，店员乔治（George）当然应该要很有礼貌地向顾客提出询问，所以在此场景中他选用了将来进行时“How will you be paying for this?”这一礼貌的询问句式。若他说“How will you pay for this?”则显得比较生硬，不够礼貌，会让顾客感觉对方是在质问自己。<br>will be doing都是出现在服务人员向顾客询问信息的场景中。当然，这种礼貌询问的表达方式不只是出现在公司与客户之间，它同样适用于人与人之间的询问与关心。<br>比如，一位演员在问及导演有关角色的分配时，他是这样礼貌地提问的：<br>Who will I be acting with?<br>这里他同样用了礼貌的提问形式will be acting，表示自己只是在客观地打听事实，而不是要干涉导演的安排，因而这样询问显得委婉礼貌。</p>
<p><em><strong>will be doing用在疑问句中表示客气地询问。但我们也要注意，这并不是说以后我们就不用will do来提问了，而一律用 will be doing代替will do。will do往往带有各种感情色彩，比如表达“请求”，此时我们就得用will do，而一般不用will be doing。</strong></em><br>比如“你能借给我10美元吗？”这句话，一般不说：<br>Will you be lending me ten dollars?*<br>这里的will不是在客观地询问事实，而是表示一种请求，所以，我们要说：<br>Will you lend me ten dollars?<br>如果我们是要客观地询问事实，宜用will be doing来提问； 而若是其他语气，比如请求或命令等，我们则要用will do来提问。</p>
<p>1） Will you be staying in this evening?<br>2） Will you stay in this evening?<br>在例句1）中，用will be doing是表示礼貌地、客观地询问，只是想了解你今晚的打算，并没有干涉的意思。所以我们可译成“今晚你不出去吧？”在例句2）中，用will do，含有感情色彩，如请求、指示或命令。所以这句话可以根据说话者的语气译成“今晚你别出去了，好吗？”（请求），或者“今晚你不要出去了行不行?!”（命令）。</p>
<h2 id="难点用法2：用来表示客观的将来，以避免与表示“意愿”的will-do混淆"><a href="#难点用法2：用来表示客观的将来，以避免与表示“意愿”的will-do混淆" class="headerlink" title="难点用法2：用来表示客观的将来，以避免与表示“意愿”的will do混淆"></a>难点用法2：用来表示客观的将来，以避免与表示“意愿”的will do混淆</h2><p>A: It’s already 10 o’clock. I guess Bob and Amy won’t be coming to the party.<br>B: They called at nine to say that they’d been held up.<br>上面这个对话中的将来进行时态won’t be coming并非像我们通常理解的那样，表示“在将来某一特定的时刻正在做某事”，即并不是进行时态要表达的典型语义。<br>那为什么要用won’t be coming这种较为复杂的形式呢？句中为什么不用更为简单的谓语形式won’t come呢？可不可以用won’t come？两者有何区别？<br>这里涉及情态动词will的意义和用法问题。我们知道，will可以用来表示意愿（willingness）和意图 （intention）等情态语义，所以will do往往表示主观意愿，如will do 有“蓄意为之”的含义，而won’t do则有“不愿意为之”的含义。但将来进行时态will be doing则是表示客观的将来时间，侧重于对将来事件的客观陈述，表示在正常情况下预计要发生的事件，而不表达个人意图。总而言之，will be doing较客观，will do较主观，所以我们用will be doing 来表示客观的将来时间，以避免与表示主观意愿的will do混淆。<br>说话人用won’t be coming是想强调鲍勃和埃米可能是因为其他事情耽误了而“来不了”这一客观事实，而不是主观意愿上的“不愿来”。下文紧接着就说明了他们来不了的原因是they had been held up（他们有事耽误了）。如果说“Bob and Amy won’t come to the party.”。因为won’t do的意思往往相当于refuse to do，表示“拒绝做，不愿意做”。所以，对于这句话，人们一般会理解为“鲍勃和埃米不愿意来参加聚会”。而在原文中，说话人其实是在强调客观将来的时间——“来不了”，而不是“不愿来”。所以，我们看到，这里一个won’t be coming， 一个won’t come，两者的意思大相径庭。<br>A：现在已经10点了，我猜鲍勃和埃米不会来参加聚会了。<br>B：他们9点钟时打过电话，说有事耽误了。</p>
<h2 id="will-be-doing的五种意思"><a href="#will-be-doing的五种意思" class="headerlink" title="will be doing的五种意思"></a>will be doing的五种意思</h2><ol>
<li>想象自己或其他人在将来某一特定的时刻正在做某事； </li>
<li>表示计划好的事； </li>
<li>表示背景动作，提供另外一个短动作发生的事件背景； </li>
<li>用在疑问句中，表示客气的询问。这一用法在口语中尤为常见； </li>
<li>用will be doing来表示客观的将来，以避免与表示“意愿”的will do 混淆。</li>
</ol>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之一般将来时</title>
    <url>/2020/06/06/English%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E8%88%AC%E5%B0%86%E6%9D%A5%E6%97%B6/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记摘选自张满胜老师的《英语语法新思维中级教程通悟语法第2版》，以及其他网上知识点收集，只是我自己的个人复习笔记，禁止转载，如有侵权，请联系我删除。<br>思维导图版本<a href="http://www.xmind.net/m/XReDCR">点击这里</a>（Web版的XMind有一些问题）。</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote>
<p>  从严格意义上来说，英文里是没有“将来时态”的， 而只有现在时态和过去时态这两种时态。</p>
</blockquote>
<p>从时态形式（tense form）的构成上来看。现在时态（present tense）的构成是用动词原形（basic verb form），或遇到单数第三人称主语，谓语动词加-s。过去时态（past tense）的构成则是动词变为过去式（如加-ed或其他特殊变形），对于现在时态和过去时态，都是在谓语动词的词尾上进行变形。但对于将来时态，在动词的词尾却没有任何变形。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/iXKRRi.png"><br>表格中的Tense（时）只有Past（过去时）和Present（现在时），而没有Future（将来时）。通常我们引入一个情态动词will来表示将来时态，但will的引入并不是谓语动词本身的词形变化。正是因为在表示将来时间内发生的事情时，英语谓语动词的词干（stem word）不会发生任何形式的变化，因此“将来时”的说法被看作是不贴切的。<br>表达将来时态，即人们谈论将来要发生的事情时，事实上是采取动词形式变化以外的其他方式来达到这一目的的。具体的方式非常多，比如使用情态动词will和be going to，比如使用现在进行时（be doing）表示将来的动作，以及采用其他的句型结构，如be to do或者be about to do等。从是否成为事实的角度（factual or non-factual）来看。将来的事情与发生在过去或现在的事情是完全不同的，发生在过去或现在的事情都已是确定无疑的，是一个事实（fact）。但谈论将来要发生的事情，就不可能成为一个确定无疑的事实，而只能是表示一种可能性。</p>
<p>It will rain later. 过一会会下雨。<br>我们传统上是把这里的will rain看作是一般将来时态，但实际上这里只是情态动词will表示“推测”或确切地说“预测（prediction）”的一种用法。另外，我们还可以用其他情态动词来表示这种预测，比如说：<br>It may rain later. 过会可能会下雨。<br>It might rain later. 过会或许会下雨。<br>这里的may和might同样可以表示对将来事情的预测，只不过肯定程度是递减的——will比may的把握性大，may比might的把握性大。<br>由此可见，典型的一般将来时will do，在本质上只是情态动词will 的一种用法而已。从这个意义上来说，英语里没有将来时态。</p>
<h2 id="三个概念"><a href="#三个概念" class="headerlink" title="三个概念"></a>三个概念</h2><ul>
<li>预测（prediction）：表示说话人认为将来会发生某件事；</li>
<li>事先计划（future plan）：表示说话人在头脑里已经做出决定将来要做某件事；</li>
<li>意愿（willingness）：表示说话人既不是预计某事将会发生，也不是预先经过考虑决定将做某事，而是在说话的时刻立即做出决断表明他将去做某事。</li>
</ul>
<h2 id="will表示将来——预测"><a href="#will表示将来——预测" class="headerlink" title="will表示将来——预测"></a>will表示将来——预测</h2><p>读者对will应该是非常熟悉的，因为它通常被作为一般将来时态的“代言人”，其最典型的用法就是对未来进行“预测”。<br>I wonder what it will be like in the 21st century. But from the great advances in these past years I assume that we will be entering a new golden age of miracles and wonders. Life will be fantastic in the 21st century.<br>不知道到了21世纪我们的生活会是什么样子。但从近几年巨大的发展来看，我猜想我们一定会进入一个全新的充满奇迹的黄金时代。21世纪的生活一定非常美好。</p>
<h2 id="be-going-to表示将来——预测"><a href="#be-going-to表示将来——预测" class="headerlink" title="be going to表示将来——预测"></a>be going to表示将来——预测</h2><p>Look at those black clouds! It’s going to rain.<br>It’s not going to snow again tomorrow, is it? It was supposed to be warm all week.<br>以上两句话显然都是说话人在对天气情况做出预测，尤其是第一句，说话人是根据目前明显的迹象，即“黑云密布（black clouds）”来做出“要下雨”的预测的。</p>
<h2 id="will和be-going-to的区别"><a href="#will和be-going-to的区别" class="headerlink" title="will和be going to的区别"></a>will和be going to的区别</h2><h3 id="表示“预测”，be-going-to比will有更多的证据支持，而且事件发生的时间更近"><a href="#表示“预测”，be-going-to比will有更多的证据支持，而且事件发生的时间更近" class="headerlink" title="表示“预测”，be going to比will有更多的证据支持，而且事件发生的时间更近"></a>表示“预测”，be going to比will有更多的证据支持，而且事件发生的时间更近</h3><p>由于be going to是一个现在时态的形式（如am&#x2F;is&#x2F;are going to），因此，它所表示的对将来行为的预测往往暗示与“现在”有联系，而且是在说话后不久就将发生的。<br>所以当有现在的证据可以支持预测时，或者说根据目前的明显迹象来推断某件事将要发生时，我们就要用be going to，而不宜用 will。<br>With all of these typos in this resumé, you are not going to make a very good impression.（这份简历上有这么多的打字错误，这样恐怕你不会给对方留下好印象的。）<br>这里的typo即type error的缩写，表示“打字错误”。说话人根据with all of these typos in this resumé这一证据，而预测“你”不会给别人留下好印象。<br>再看这样一幅图：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/DoizHQ.png"><br>这时我们说： She is going to dive into the water. 而不能说： She will dive into the water. *<br>另外，be going to还往往表示当前已有迹象表明说话者无力控制的（uncontrollable）即将发生的行为。比如，如果你不小心失足要掉下去时，你会喊道：<br>Help! I’m going to fall! 不能说： Help! I’ll fall. *</p>
<h3 id="表示“预测”时，will的语气比be-going-to显得正式"><a href="#表示“预测”时，will的语气比be-going-to显得正式" class="headerlink" title="表示“预测”时，will的语气比be going to显得正式"></a>表示“预测”时，will的语气比be going to显得正式</h3><p>will比较正式，be going to更为不正式，常用于私人谈话中， 所以在口语中很常用，而且be going to在口语交流中常被读成be gonna。 比如两个朋友在餐馆里吃饭点菜，一个会对另一个说：I’m gonna have the chicken. 但一会儿侍者过来为他们点菜时，这个人可能会对侍者改口说道：I’ll have the chicken. 这样以保持一定程度的正式性。</p>
<hr>
<p>综上所述，在表示预测时，will 和 be going to有以下两点区别：</p>
<ol>
<li>用be going to特别意指根据目前的明显迹象来推断某件事将要发生（We can use “be going to” for a strong prediction based on present conditions.）；而will则只是表明说话人认为或相信某件事将要发生。 </li>
<li>be going to 通常用来表示说话人预期所说的事件马上或在相当近的将来就要发生；而will所表示的动作发生的时间可近可远。 此外，be going to往往还表示当前已有迹象而且表明说话者无力控制的即将发生的行为</li>
<li>在表示“预测”时，will的语气比be going to显得正式。</li>
</ol>
<h2 id="be-going-to表示“计划”与will表示“意愿”"><a href="#be-going-to表示“计划”与will表示“意愿”" class="headerlink" title="be going to表示“计划”与will表示“意愿”"></a>be going to表示“计划”与will表示“意愿”</h2><p>我们常用它来表示“计划或打算（a plan）”。此时，说话人在头脑里已经做出决定将来要做某件事，并且往往还含有已经为这一行动做了某些准备的意思。又因为只有人才能有主观的思维意识去对将来的行为做出“计划”，因此， be going to的这个用法主要是用于人称主语（person subject），而不可能用于非人称主语（non-person subject）。<br>Close your eyes. I’m going to give you a surprise.</p>
<h3 id="be-going-to表示“计划”，需要用“人”作主语"><a href="#be-going-to表示“计划”，需要用“人”作主语" class="headerlink" title="be going to表示“计划”，需要用“人”作主语"></a>be going to表示“计划”，需要用“人”作主语</h3><p>be going to的这个用法主要是用于人称主语 （person subject），而不可能用于非人称主语（non-person subject）。 但在表示“预测”时，主语可能是人称，也可能是非人称。换句话说，如果是非人称主语，那be going to不会是表示“计划打算”，而是表示“推测”。<br>Look at those black clouds! It’s going to rain.（这里就不可能是说老天“打算”要下一场雨，而是说话人“预测”要下雨。）<br>另一方面，如果是人称主语，那么be going to可能是表示“计划打算”，也可能是表示“预测”。此时，上下文的语境可以帮助我们很容易地区分be going to是表示“计划打算”还是“预测”。比如：<br>A: Look at the time. I’m going to miss my bus.<br>B: Don’t worry. I’ll drive you to the stop. And if the bus has already left, I can get you to your apartment.<br>这里的be going to显然是表示“预测”，而不是表示“计划或打算”，因为不可能是“我打算赶不上公共汽车。”<br>With all of these typos in this resumé, you are not going to make a very good impression.<br>这句话尽管是人称主语，但从上下文来看，be going to在这里是表示“预测”，而不是“计划或打算”，因为原句的意思不是说“你不打算留下好印象”，而是“我认为你可能不会留下好印象”。</p>
<h3 id="be-going-to可以表示“决心”，具有强烈的感情色彩"><a href="#be-going-to可以表示“决心”，具有强烈的感情色彩" class="headerlink" title="be going to可以表示“决心”，具有强烈的感情色彩"></a>be going to可以表示“决心”，具有强烈的感情色彩</h3><p>We’re going to become the world’s leading forwarding company.<br>这句话如果是出自一个公司领导之口，就是表明他要把公司发展壮大的决心，翻译时请注意体会，比如它相当于汉语说“我们一定要成为世界上最大的运输公司”。</p>
<h3 id="will表示“意愿”，一个当机立断的决定"><a href="#will表示“意愿”，一个当机立断的决定" class="headerlink" title="will表示“意愿”，一个当机立断的决定"></a>will表示“意愿”，一个当机立断的决定</h3><p>will可以表示“意愿”的用法。所谓“意愿”，简言之，就是“当机立断（spontaneous decision）”，而不是事先计划好的（unplanned）。具体来说，说话人事先并不知道，而是在得知新的信息之后，在说话的时刻立即做出决断表明他将去做某事，这是一个当机立断的决定。此时，我们只能用will来表达。<br>A: I can’t go out there again.<br>B: You just weren’t ready. Go back out there! Your team needs you.<br>A: I am going to make my team lose if I keep playing.<br>B: No, that is not true. I trust you.<br>A: OK, I’ll give it one more shot, but I’m not sure how good it will be.<br>B: Now you are talking!<br>这里的be going to显然是表示“预测”，而不是“计划”，不是说“我早已计划好故意让我们队输掉比赛”。接下来的“I’ll give it one more shot.”，其中的’ll即是will的缩写，这里的will表示“意愿”，是一个当机立断的决定，因为A本来并不想继续打比赛了，但被B说服了之后而做出决定要再试一次。所以这里他并不是事先计划好的，因而不能说“I’m going to give it one more shot.”*最后一个 will（…but I’m not sure how good it will be.）是表示“预测”，这从主语it也可以看出来，因为表示“意愿”的主语往往都是人称。</p>
<p>A: The telephone is ringing. B: I’ll get it.<br>B要去接电话，既不是他预测要有电话打进来，也不是事先计划好要接这个电话。B是在说话的此刻做出的“要去接电话”这个决定。</p>
<p>A: Oh, no! I’ve spilled coffee on my shirt. B: Just a minute. I’ll get a damp cloth for you.<br>B不可能事先知道A会把衣服弄脏而“打算”给A拿湿布， 所以不能说“I am going to get a damp cloth for you.”* B也不是在“预测”将来的事。</p>
<blockquote>
<p>前面讲过，will表示“预测”时，句子的主语往往是无生命的事物（non-animate subject），与此不同的是，当will表示“意愿”时，句子的主语通常是有生命的“人（animate agent）”，若用“物”作主语则具有拟人的意味，此时说话人往往是在抱怨，而且通常用否定形式的won’t。</p>
</blockquote>
<p>The closet door won’t open. Will you try it?（这个储藏室的门就是打不开，你要试试看吗？）</p>
<blockquote>
<p>will这种表示“意愿”的意义，若用于第二人称（you）的一般 疑问句（Will you?）中，则可以用来提出“请求”</p>
</blockquote>
<p>A: Will you help me to mail these letters? B: I’ll do it.</p>
<blockquote>
<p>关于will的否定</p>
</blockquote>
<p>1） Paul won’t come, because he is too busy. 2） Paul won’t come, because he doesn’t want to.<br>在例句1）中，will作为“推测”的用法，否定词not是重点否定主要的谓语动词come，相当于predict NOT to come。因此，例句1） 我们可译成“我想保罗恐怕来不了，因为他太忙了”。在例句2）中，will 作为“意愿”的用法，否定词not是重点否定情态动词will，相当于NOT willing to come。因此，例句2）我们可译成“保罗不愿意来，因为他不想来。”</p>
<h3 id="比较：will表示“意愿”和be-going-to表示“打算”"><a href="#比较：will表示“意愿”和be-going-to表示“打算”" class="headerlink" title="比较：will表示“意愿”和be going to表示“打算”"></a>比较：will表示“意愿”和be going to表示“打算”</h3><ol>
<li>be going to表示说话人对未来行动的计划或打算，通常是经过事先考虑并含有已经为这一行动做了某些准备的意思。 </li>
<li>will表示意愿，表示在说话的时刻立即做出决定将去做某事，事先并没有经过考虑，更没有为这一活动做出事先的准备。</li>
</ol>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/wWYUg7.png"></p>
<h2 id="现在进行时表示将来"><a href="#现在进行时表示将来" class="headerlink" title="现在进行时表示将来"></a>现在进行时表示将来</h2><p>现在进行时也可以表示对最近的将来做出计划或安排（definite future plans）。下面的例句都是表示将来确定的安排，所以都要用现在进行时：<br>A: The summer holidays are coming soon, Jack. What are your plans?B: Well, Mike, I am taking my girlfriend to Qingdao. She is a beach person, you know.<br>I am flying to Beijing next Monday.（表示机票已买好）我下周一要飞往北京。<br>I am taking a makeup test tomorrow.（表示学校已安排好明天的补考）我明天要参加一次补考。</p>
<p>A: We’re advertising for a new cashier in next week’s Morning Post.<br>B: But you hired a new cashier last week!<br>A: I know, but he isn’t honest.<br>B: But you can’t judge people by their appearance.<br>A: I’m not. I’m judging him by his disappearance!<br>A：我们将在下周的《早报》上登广告，招聘一名新的出纳员。<br>B：可你上周才刚刚聘用了一个出纳员啊！<br>A：我知道，但是他不诚实。<br>B：你不能以一个人的外貌来判断他。<br>A：我没有，我只是根据他的外逃判断他的人品而已！</p>
<h3 id="必须带有表示将来的时间状语"><a href="#必须带有表示将来的时间状语" class="headerlink" title="必须带有表示将来的时间状语"></a>必须带有表示将来的时间状语</h3><p>用现在进行时表示将来的动作，动作发生的时间必须指出或在前文中已经指出，否则就可能会造成现在进行动作与一般将来动作相混淆。<br>A: What are you doing next Sunday? B: I’m not going out. I’m staying at home.<br>B的回答中虽然没有出现具体的将来时间，但因为将来时间next Sunday在上文中已给出，所以B中的现在进行时态是表示将来。</p>
<h3 id="必须是人称主语"><a href="#必须是人称主语" class="headerlink" title="必须是人称主语"></a>必须是人称主语</h3><p>现在进行时表将来的这种用法，通常是表示说话人已计划安排好的活动，如果不是，则不能这样用。例如不能说： It’s raining tomorrow. *<br>因为像rain, snow或storm等这样的活动是人们无法事先计划好的。</p>
<h3 id="与一般现在时表示将来的区别"><a href="#与一般现在时表示将来的区别" class="headerlink" title="与一般现在时表示将来的区别"></a>与一般现在时表示将来的区别</h3><blockquote>
<p>一般现在时要比现在进行时听起来更正式，个人主观色彩要淡些。</p>
</blockquote>
<p>1） I am leaving tonight.<br>2） I leave tonight.<br>在例句1）中，进行时态表达的个人主观色彩要浓些，一 般含有“我自己决定今晚走”的意味。在例句2）中，一般时态更加客 观，比如可能是“公司安排了我出差，给我安排的是今晚动身”。</p>
<p>所以说“Our shop opens next week.”比“Our shop is opening next week.”要好，显得更正式。</p>
<blockquote>
<p>如果是一系列预定的将来的安排，比如旅游行程安排，用进行时 态显得较累赘，而用一般时态则较简洁。</p>
</blockquote>
<p>We leave Beijing at 9: 00 tomorrow morning, arrive in Kunming around 12: 00 and then we tour the World Horti-Expo Garden. 我们明天上 午9点离开北京，大约12点左右抵达昆明，然后就参观世博园。</p>
<h3 id="用be-going-to表示计划与进行时态表示计划的区别"><a href="#用be-going-to表示计划与进行时态表示计划的区别" class="headerlink" title="用be going to表示计划与进行时态表示计划的区别"></a>用be going to表示计划与进行时态表示计划的区别</h3><p>总的来说，be doing表达的将来计划要比be going to的计划更确定 （more definite）。<br>1） I’m taking my holiday in April.<br>2） I’m going to take my holiday in April.<br>在这个场景中，am taking表示比am going to take更确定的 将来计划，可以这样来解释：<br>在例句1）中，说话人已经得到公司批准的假期了（Approval has already been given.）或已经和旅行社订好了行程。所以，我们可以把它 译成比较确定的汉语，比如“我四月份要休假了”。在例句2）中，说话 人只是表达自己的一个打算或想法意图（intention），但目前并没有得 到公司的准假，更没有和旅行社订好行程。这句话相当于汉语说“我打 算四月份休假”，这就没有“我四月份要休假了”听起来确定。<br>be going to do更多的是表达一种不确定的未来计 划，或者说是一种个人的意图或打算，不过这听起来要比hope to do和 would like to do要更为确定些（When we talk about things in the future that are not definite, we use “am going to+verb”. This is more certain than expressions like “hope to…”, “might…” or “would like to…”.）。综合上 述，用be doing谈将来的计划往往比be going to do更确定。</p>
<h2 id="一般现在时表示将来"><a href="#一般现在时表示将来" class="headerlink" title="一般现在时表示将来"></a>一般现在时表示将来</h2><p>A boy was up an apple tree stealing apples. A policeman came along and caught him. He looked up at the boy in the tree and said, “When are you coming down, young man?” “When you go away!” replied the boy.<br>这里when are you coming down中的现在进行时态是表示将来的动作。第二个句子when you go away中的一般现在时态是表示将来的动作，即前面讲过的，在when引导的时间状语从句中，要用一般现在时态替将来时。<br>A: I begin to work at the Swan Laundry on Monday.<br>B: That’s wonderful! But tell me, how do you wash a swan?<br>这里的一般现在时begin表示将来的动作，句中的on Monday是表示将来的时间。<br>A: My daughter gets married at three o’clock in St. Mary’s Church on Saturday.<br>B: How do you feel about it?<br>A: Well, I’m losing a daughter but I am gaining a telephone!</p>
<h2 id="其他表示将来的句型结构"><a href="#其他表示将来的句型结构" class="headerlink" title="其他表示将来的句型结构"></a>其他表示将来的句型结构</h2><h3 id="be-to-do"><a href="#be-to-do" class="headerlink" title="be to do"></a>be to do</h3><blockquote>
<p>表示已安排好要在将来发生的事，是比较正式的用法</p>
</blockquote>
<p>They are to go on a strike on July 8th. 他们定于7月8日举行罢工。<br>She is to be married next month. 她预定在下个月结婚。<br>The Premier is to visit Australia next month. 总理将在下个月对澳 大利亚进行访问。</p>
<blockquote>
<p>表示强烈的命令，相当于must, should，如：父母对孩子、上级对下级或法律条文中的规定等</p>
</blockquote>
<p>You are to finish your homework before you go to play. 你出去玩之前一定要把作业完成了。<br>These tablets are not to be taken orally. 这些药片禁止口服。<br>If it doesn’t rain within the next few weeks, the crops will have to be watered if they are to survive. 以后的几个星期如果还不下雨，则须对庄稼进行灌溉，以便庄稼能够存活。</p>
<h3 id="be-about-to-do"><a href="#be-about-to-do" class="headerlink" title="be about to do"></a>be about to do</h3><p>这一结构用来表示即将发生的动作（比如通常在5分钟之内就会发生），意思是“正要，马上就要”。<br>The train is about to leave. 火车马上就要开了。<br>Jack is holding a fly swatter and staring at a fly on the kitchen table. He is about to swat the fly. 杰克手里正拿着苍蝇拍，眼睛盯着厨房桌上的一只苍蝇。他正要拍 这只苍蝇。</p>
<h3 id="be-on-the-point-x2F-verge-x2F-brink-x2F-eve-of-doing"><a href="#be-on-the-point-x2F-verge-x2F-brink-x2F-eve-of-doing" class="headerlink" title="be on the point&#x2F;verge&#x2F;brink&#x2F;eve of doing"></a>be on the point&#x2F;verge&#x2F;brink&#x2F;eve of doing</h3><p>这一结构与be about to do的意思差不多，但其动作发生的时间比be about to do还要快一些。<br>He was on the point of killing himself when she stepped into his room. 她走进房间时，看见他正要自杀。<br>The child was on the verge of laughing, but he held back. 这孩子差 一点笑出声来，但还是忍住了。</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch汇总</title>
    <url>/2020/05/28/Elasticsearch%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h1 id="Basic-Knowledge"><a href="#Basic-Knowledge" class="headerlink" title="Basic Knowledge"></a>Basic Knowledge</h1><p><a href="https://spring.io/projects/spring-data-elasticsearch#learn">spring-data-elasticsearch官方文档</a></p>
<h2 id="Elasticsearch-Operations"><a href="#Elasticsearch-Operations" class="headerlink" title="Elasticsearch Operations"></a>Elasticsearch Operations</h2><ul>
<li>IndexOperations defines actions on index level like creating or deleting an index.</li>
<li>DocumentOperations defines actions to store, update and retrieve entities based on their id.</li>
<li>SearchOperations define the actions to search for multiple entities using queries</li>
<li>ElasticsearchOperations combines the DocumentOperations and SearchOperations interfaces.</li>
</ul>
<h2 id="Vue浏览器客户端"><a href="#Vue浏览器客户端" class="headerlink" title="Vue浏览器客户端"></a>Vue浏览器客户端</h2><p><a href="https://elasticvue.com/">插件下载</a></p>
<h2 id="查询类型"><a href="#查询类型" class="headerlink" title="查询类型"></a>查询类型</h2><h3 id="term"><a href="#term" class="headerlink" title="term"></a>term</h3><p>term：代表完全匹配，即不进行分词器分析，文档中必须包含整个搜索的词汇</p>
<h2 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PB是数据存储容量的单位，它等于2的50次方个字节，或者在数值上大约等于1000个TB。</span><br></pre></td></tr></table></figure>

<h1 id="Problem-Solution"><a href="#Problem-Solution" class="headerlink" title="Problem Solution"></a>Problem Solution</h1><h2 id="spring-data-elasticsearch-版本冲突问题"><a href="#spring-data-elasticsearch-版本冲突问题" class="headerlink" title="spring-data-elasticsearch 版本冲突问题"></a>spring-data-elasticsearch 版本冲突问题</h2><p>想用spring-data-elasticsearch4.1.1版本发现依赖的springboot版本太低，要升级到2.4才可以，不然即使spring-data-elasticsearch指定高版本也会被自动回退到3.1.10。</p>
]]></content>
      <tags>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之进行时态（现在进行时）</title>
    <url>/2020/06/07/English%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%9B%E8%A1%8C%E6%97%B6%E6%80%81-%E7%8E%B0%E5%9C%A8%E8%BF%9B%E8%A1%8C%E6%97%B6/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记摘选自张满胜老师的《英语语法新思维初级教程第2版》，以及其他网上知识点收集，只是我自己的个人复习笔记，禁止转载，如有侵权，请联系我删除。</p>
</blockquote>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><h3 id="进行时态的构成"><a href="#进行时态的构成" class="headerlink" title="进行时态的构成"></a>进行时态的构成</h3><p>进行时态（continuous tense）的构成是be+doing。注意这里的be动词不是系动词，而是助动词，因而没有“是”的意思。我们可以通过对助动词be的变形来反映人称和时间的变化。<br>就时间的角度而言，有三种不同时间下的进行时态，即现在进行时 （the present continuous tense）、过去进行时（the past continuous tense）和将来进行时（the future continuous tense）。它们的构成分别是：am&#x2F;is&#x2F;are doing, was&#x2F;were doing和will be doing。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/xdr6Ji.png"><br>将来进行时will be doing没有人称和数的变化。这里的助动词be的具体变形，既反映了时间（如动作是发生在现在、过去还是将来），同时也反映了主语人称和数的变化，但表示进行动作的doing始终不变</p>
<h3 id="进行时态的意义"><a href="#进行时态的意义" class="headerlink" title="进行时态的意义"></a>进行时态的意义</h3><p>汉语通常采用语气助词“着”或词组“正在”等来表达。比如“他吃着饭”与“他吃了饭”，我们很容易理解前者是表示正在进行，而后者是表示完成的动作。我们还可以进一步添加具体的时间，如“他正在吃着饭”表示现在进行的动作， 而“他当时在吃着饭”表示过去进行的动作。这很像英文里的进行时态的构成和意义，比如“正在”相当于英文里表示现在时间的is，“着”相当于doing，然后结合具体动词“吃（have）”，于是便有了“He is having dinner.”这样的句子。同理，“当时在”相当于英文里表示过去时间的was，于是便有了“He was having dinner.”。<br>具体来说，进行时是强调在某个特定的（现在、过去或将来）时间点，某项活动正在发生。<br>I am watching CCTV news right now. 我现在正在看中央电视台的新闻。<br>I was watching CCTV news when he arrived yesterday. 他昨天到的时候，我正在看中央电视台的新闻。<br>I will be watching CCTV news at 7:15 pm tomorrow. 明天晚上7点15分，我将会正在看中央电视台的新闻。</p>
<h4 id="直接给出具体的时间"><a href="#直接给出具体的时间" class="headerlink" title="直接给出具体的时间"></a>直接给出具体的时间</h4><p>I am listening to the English program right now. 我现在正在收听英文节目。</p>
<h4 id="通过另一活动表达这一特定时刻"><a href="#通过另一活动表达这一特定时刻" class="headerlink" title="通过另一活动表达这一特定时刻"></a>通过另一活动表达这一特定时刻</h4><p>I will be studying English when you come tomorrow. 你明天来的时候，我将正在学习英语。<br>英文的进行时态be doing表达的意义远不止于“正在发生的活动”这一个意思，要比汉语的“着”所表达的意义多很多。</p>
<h3 id="进行时态的使用语境"><a href="#进行时态的使用语境" class="headerlink" title="进行时态的使用语境"></a>进行时态的使用语境</h3><p>进行时态因为往往强调在说话的时刻某活动正在发生，所以常用进行时态表达生动、具体的场景。而进行时态因为其表现生动，所以在口语中出现的频率远远高于书面语。</p>
<h2 id="现在进行时（不一定正在进行）"><a href="#现在进行时（不一定正在进行）" class="headerlink" title="现在进行时（不一定正在进行）"></a>现在进行时（不一定正在进行）</h2><h3 id="用法一：说话时刻正在进行的动作（action-happening-exactly-now）"><a href="#用法一：说话时刻正在进行的动作（action-happening-exactly-now）" class="headerlink" title="用法一：说话时刻正在进行的动作（action happening exactly now）"></a>用法一：说话时刻正在进行的动作（action happening exactly now）</h3><p>A: May I speak to Clint?<br>B: No, sorry. He is not available now. He is talking on another phone.</p>
<h3 id="用法二：在目前一段时期内持续的一种暂时的情况（action-happening-around-now）"><a href="#用法二：在目前一段时期内持续的一种暂时的情况（action-happening-around-now）" class="headerlink" title="用法二：在目前一段时期内持续的一种暂时的情况（action happening around now）"></a>用法二：在目前一段时期内持续的一种暂时的情况（action happening around now）</h3><p>除了上述表示的action happening exactly now外，现在进行时还常常用来表示action happening around now，也就是说表示现阶段正在持续的活动。这时进行时态表示的是一个一般性的活动，在说话时刻这个动作并不一定正在发生（通常都不在发生），而是在目前一段时期内持续的一种暂时的情况。<br>Jenny: Hello?<br>Frank: Hi, Jenny. What are you doing?<br>Jenny: Oh, hi, Frank. I’m doing my laundry. You?<br>Frank: I’m going to go look for an apartment downtown.<br>Jenny: Really? You aren’t content in the suburbs?<br>Frank: Well, this neighborhood is really booming. It’s not really a suburb any more.<br>Jenny: Yeah, it is getting crowded. Where are you looking for an apartment?<br>Frank: Probably near the train station. I’d like to use public transportation to get around.<br>Jenny: Hmm. I think you’ll be hard pressed to find an affordable place there.<br>Frank: Really? Is the area expensive?<br>Jenny: Yes. And I know while you’re not living in poverty, a college student still can’t afford an apartment by the train station.<br>Frank: Well, OK, thanks for the advice!<br>Jenny: You’re welcome.<br>上面关于“租房”的对话中：<br>Jenny: Yes. And I know while you’re not living in poverty, a college student still can’t afford an apartment by the train station.<br>这里的进行动作are not living并不是强调在说话的时刻正在做什么，而是表示目前短暂的生活情况。<br>朋友知道你正在找工作，关心地问你是否已经找到了：<br>A: Have you found a position yet?<br>B: I’m still checking the papers.<br>比如你为了赶时髦而留长发：<br>Long hair is really in right now. So I’m letting my hair grow.<br>Florence is putting away half her pay each month. Soon, she’ll be able to buy a new car.<br>这里的putting away显然是表示一个现阶段在持续的一般活动。<br>弗洛伦斯现在每月把一半的薪水存起来。我想不久她就能买辆新车了。</p>
<p>因为进行时态的这种用法表示目前的一种短暂的情况，所以它有时含有一种“今昔对比”之意。<br>I am taking the bus to work this week, because my car is in the garage.<br>这里的am taking the bus to work表示“坐公共汽车上班”是暂时的，只是在这个星期内的短暂活动，并且与过去“开车上班”形成了一个今昔对比。</p>
<h3 id="用法三：用于表示“改变”的动词，强调“逐渐变化”的过程"><a href="#用法三：用于表示“改变”的动词，强调“逐渐变化”的过程" class="headerlink" title="用法三：用于表示“改变”的动词，强调“逐渐变化”的过程"></a>用法三：用于表示“改变”的动词，强调“逐渐变化”的过程</h3><p>这种表示action happening around now的进行时态的用法，若是用于表示“改变”的动词，则强调“逐渐变化”的过程。常见的表示“改变”的动词有：change, come, get, become, grow和deteriorate（恶化）等。<br>在上面租房的例子中：<br>Frank: Well, this neighborhood is really booming. It’s not really a suburb any more.<br>Jenny: Yeah, it is getting crowded.<br>这里的booming和getting用于进行时态显然都是表示“逐渐改变”的意思，所以分别译成“越来越繁荣”和“越来越拥挤”。</p>
<p>It’s getting dark. 天渐渐黑了下来。<br>Mom is getting old. 妈妈越来越老了。<br>His health is deteriorating. 他的健康状况日益恶化。<br>My dream is coming true. 我的梦想正一点点地成为现实。</p>
<h3 id="用法四：用于强烈的感情色彩的表达"><a href="#用法四：用于强烈的感情色彩的表达" class="headerlink" title="用法四：用于强烈的感情色彩的表达"></a>用法四：用于强烈的感情色彩的表达</h3><p>Harry: Fine. Fine, but let’s just get one thing straight. I did not go over there that night to make love to you, that is not why I went there. But you looked up at me with these big weepy eyes, “Don’t go home tonight, Harry, hold me a little longer, Harry.” What was I supposed to do?<br>Sally: What are you saying? You took pity on me?<br>Harry: No, I was… （Sally slaps Harry whole-heartedly, then storms out of the kitchen.）<br>这里的进行时态are…saying也并不是强调正在进行的动作，而是为了表达萨莉强烈的愤怒的感情——萨莉觉得自己被侮辱了，以至于第一次把哈里扇去了“五指山”！</p>
<p>Marie: He was shaving and there it was in his briefcase.<br>Sally: What if he came out and saw you looking through his briefcase?<br>Marie: You’re missing the point, I’m telling you what I found. He just spent a hundred and twenty dollars on a new night gown for his wife. I don’t think he’s ever going to leave her.<br>Sally: No one thinks he’s ever going to leave her.<br>Marie: You’re right, you’re right, I know you’re right.<br>这里的进行时态are missing和am telling同样不是为了说明 正在发生的动作，而是为了表达感情色彩。因为前面萨莉说：“他当时要是出来了看到你在翻他的公文包可怎么办啊？”这显然不是玛丽所关心的，所以她用进行时态强调说“You’re missing the point, I’m telling you what I found.”。<br>我们生气时可以这么说：<br>I’m not having this conversation with you.<br>这句话相当于说“I don’t want to talk to you about this.”。<br>我不跟你说了。</p>
<p>You are asking too much! 你的要求太过分了！</p>
<h3 id="用法五：表示将来确定的安排"><a href="#用法五：表示将来确定的安排" class="headerlink" title="用法五：表示将来确定的安排"></a>用法五：表示将来确定的安排</h3><p>现在进行时在口语中还经常用来表示将来的动作（action in the future），此时现在进行时是表示在说话之前就确定的、计划好的将来的安排。<br>在我们用现在进行时态来谈将来确定的安排的时候，如果没有明确的上下文语境来表明将来时间的话，我们往往需要加上明确的表示将来时间的状语，如tomorrow, next year, in June和at Christmas等，以避免与正在进行的动作混淆。<br>We’re eating in a restaurant.<br>这句话往往会被理解成正在发生的动作——“我们现在正在餐馆吃饭”。如果我们给出将来的时间状语，比如tonight，说成“We’re eating in a restaurant tonight. We’ve already booked the table.”（我们今晚要在餐馆吃饭，我们已经订了位置。）<br>A: What are you doing on Saturday night?<br>B: I’m doing some shopping with Jane.</p>
<h4 id="be-going-to表示将来打算的用法。be-doing和be-going-to-do都可以表示将来的计划，它们有何区别呢？"><a href="#be-going-to表示将来打算的用法。be-doing和be-going-to-do都可以表示将来的计划，它们有何区别呢？" class="headerlink" title="be going to表示将来打算的用法。be doing和be going to do都可以表示将来的计划，它们有何区别呢？"></a>be going to表示将来打算的用法。be doing和be going to do都可以表示将来的计划，它们有何区别呢？</h4><p>主要的区别是：<br>现在进行时强调事先已经做好的安排，是比较确定要发生的；而be going to着重表现说话者的计划和意图，并不是确定的安排。<br>Frank and Jenny are getting married? I didn’t even know they were going together.<br>弗兰克和珍妮要结婚了？我连他们俩在谈恋爱都不知道。 这里的进行时态are getting married表明结婚日期已确定。如果说： Frank and Jenny are going to get married. 则表示他们两人打算结婚，并没有确定将来具体的日期。</p>
<p>1） I’m staying at Beijing. 2） I’m going to stay at Beijing.<br>1） 我会待在北京。 2） 我打算待在北京。</p>
<p>再者，对于静态的动词和无生命的主语，不可能使用现在进行时来表示将来。但可以用于be going to，这时表示预测。如不能把belong to 用于进行时态，说成：<br>The red car is belonging to me tomorrow. *<br>但belong to可以用于be going to结构，说成：<br>The red car is going to belong to me tomorrow.<br>这里是表示预测。 明天这辆红色的汽车就将属于我了。</p>
<p>不能说：The tree is falling tomorrow. * 但可以用be going to表示将来的预测，说成：<br>The tree is going to fall tomorrow. 这棵树明天就会倒下了。</p>
<p>当然，若是没有计划或安排可以保证相应的结果会出现，也不能使用现在进行时：<br>We are winning the tennis match next weekend. *<br>因为能否赢得比赛事先无法确定。但我们可以用be going to来表示预测，因而可以说成：<br>We are going to win the tennis match next weekend.<br>这里的be going to表示推测，该句的意思是：我们下周会赢得那场网球比赛的。 这句话还可以解释成：be going to表达“决心”，因此可以理解成： 我们下周一定要赢得那场网球比赛。</p>
<h3 id="用法六：与always等连用，表示多次重复，且含有感情色彩"><a href="#用法六：与always等连用，表示多次重复，且含有感情色彩" class="headerlink" title="用法六：与always等连用，表示多次重复，且含有感情色彩"></a>用法六：与always等连用，表示多次重复，且含有感情色彩</h3><p>现在进行时的感情色彩的表达，还有另外一种用法，就是常与 always, forever, continually和constantly等连用，表示多次重复的行为。 这种反复的行为可以是积极的、让人喜欢的事情。<br>Scott is very generous. He’s always giving his friends gifts and inviting them out for meals. 斯科特为人十分慷慨大方，他总是会送朋友礼物，并请他们吃饭。<br>但也往往表示让说话者厌烦、感觉不合情理或使人不愉快的事，即通常具有负面的、消极的含义。<br>He’s always pulling my leg. 他总是开我的玩笑。<br>He’s continually asking me for money. 他总是向我要钱。</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之完成时态（现在完成时）</title>
    <url>/2020/06/15/English%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AE%8C%E6%88%90%E6%97%B6%E6%80%81-%E7%8E%B0%E5%9C%A8%E5%AE%8C%E6%88%90%E6%97%B6/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记摘选自张满胜老师的《英语语法新思维中级教程通悟语法第2版》，以及其他网上知识点收集，只是我自己的个人复习笔记，禁止转载，如有侵权，请联系我删除。</p>
</blockquote>
<h2 id="完成时态的构成"><a href="#完成时态的构成" class="headerlink" title="完成时态的构成"></a>完成时态的构成</h2><p>完成时态（perfect tense）的构成分为两部分：一是助动词have，二是实义动词的过去分词-ed。具体来说，用助动词have表示“时 （tense）”，以表明动作发生的时间是在过去、现在还是将来；用过去分词来表示动作的“体态（aspect）”，以表明该动作已经完成。用-ed来代替过去分词，于是完成时态的构成是“have+-ed”。<br>以动词work为例，三种完成时态的构成形式如下：<br>现在完成时：have worked<br>过去完成时：had worked<br>将来完成时：will have worked</p>
<h2 id="完成时态的意义"><a href="#完成时态的意义" class="headerlink" title="完成时态的意义"></a>完成时态的意义</h2><p>完成时态的本质思维或者说其核心意义就是用来表示“回顾 （retrospect）”，既然是“回顾”，就必然要涉及两个时间点，即从一个时间点回顾到另外一个时间点，因此完成时态必定涉及前后两个时间。<br>现在完成时就是站在“现在 （present）”的时间角度回顾一个“过去”的事件，是把“过去”和“现在”这两个时间点联系在一起，来表达一个事件。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/mMpFDN.png"><br>过去完成时（past perfect tense）就是站在“过去（past）”的时间角度回顾“更远的过去”的事件，是把“更远的过去”和“过去”联系在一起来表达一个事件。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/NsvuM4.png?token=AFPEEZGDJOY3BIOXWYTR47K645W2W"><br>将来完成时（future perfect tense）则是站在未来的时间角度回顾在此之前发生的事件。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/N4ETrk.png?token=AFPEEZELV4GVMUBSYJQSIOC645XFE"></p>
<hr>
<p>现在完成时态就是站在“现在”回顾“过去”；<br>过去完成时态就是站在“过去”回顾“更远的过去”；<br>将来完成时就是站在未来的时间角度回顾在此之前发生的事件。<br>所以，完成时态表示的就是一个横跨前后两个时间点的事件。</p>
<blockquote>
<p>这个事件是如何把两个时间点联系起来的呢？</p>
</blockquote>
<ol>
<li>一个事件从一个时间点“延续（continue）”到另外一个时间点； </li>
<li>一个事件从一个时间点“重复（repeat）”到另外一个时间点； </li>
<li>一个事件在前一个时间点已经结束，但它的影响“延续”到另外一个时间点。</li>
</ol>
<h1 id="现在完成时"><a href="#现在完成时" class="headerlink" title="现在完成时"></a>现在完成时</h1><blockquote>
<p>一个过去的事件与现在发生联系的方式有上述三种，对应于三种事件：</p>
</blockquote>
<ol>
<li>延续事件（continuous event）：一个过去发生的事件“延续”到现在；</li>
<li>重复事件（repeated event）：一个过去发生的事件“重复”到现在；</li>
<li>单一事件（single event）：一个过去发生的短暂事件没有“延续”或“重复”到现在，但它的影响“延续”到了现在，或者说一个过去发生并结束了的事件对现在仍然有影响。</li>
</ol>
<blockquote>
<p>这三种联系的方式图示如下：</p>
</blockquote>
<ol>
<li>一个事件从过去“延续”到现在：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/gjxp85.png"></li>
<li>一个事件从过去“重复”到现在：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/zFrur5.png?token=AFPEEZEDXWV7D3KSLT5GOHK646ESA"></li>
<li>过去某一短暂动作对现在的影响：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/vU5wum.png?token=AFPEEZGKYNW3UNRE62K4KEK646EVO"></li>
</ol>
<h2 id="回顾性思维"><a href="#回顾性思维" class="headerlink" title="回顾性思维"></a>回顾性思维</h2><p>This has been my life. I have found it worth living, and would gladly live it again if the chance were offered me.<br>罗素用现在完成时总结说：“This has been my life.”。因为他是在回顾自己的一生经历，所以必然要用“现在完成时”这样一个横贯过去与现在的时态来作出“这就是我的一生”这样的结语。若单纯地用一般现在时说成“This is my life.”，那只表明他目前的生活状态——“这就是我现在的生活”，而失去了“回顾过去、纵观一生”的思想内涵。<br>2002年2月21日是美国前总统尼克松秘密访华30周年的纪念日，次日，美国时任总统小布什在中国著名高等学府清华大学发表了演说。<br>小布什作完演讲后，接受了清华大学学生的提问。当有位学生问到有关台湾问题时，小布什作了如下表态：<br>We’ve had many discussions with your leaders, and I’ve reiterated<br>support for the“One China”policy. It’s been my government’s policy for a long period of time, and I haven’t changed it.<br>这里短短的几句话，小布什全部用了现在完成时态，强调自从尼克松总统首次访华及后来的中美建交以来，中美两国之间在不断地交流、交往、增加接触、加强了解，以及美国政府 对“一个中国”政策的一贯支持。<br>我们可以想象，如果小布什用了一般过去时态，说成： The“One China”policy was my government’s policy for a long period of time. （我们美国政府曾经在很长一段时间内坚持了“一个中国”的政策。）<br>这句话的言外之意是，现在美国政府不再坚持这个重要政策了，那么接下来的一句话他就不会说“I haven’t changed it.”，而是要说“I have changed it. （但我现在已经改变了这个政策。）”。</p>
<h2 id="延续事件"><a href="#延续事件" class="headerlink" title="延续事件"></a>延续事件</h2><h3 id="过去的事件“延续”到现在"><a href="#过去的事件“延续”到现在" class="headerlink" title="过去的事件“延续”到现在"></a>过去的事件“延续”到现在</h3><p>所谓“延续事件”，是指“一个开始于过去的动作或状态（action or state）一直延续到现在”，这是现在完成时态最基本、也是最容易理解的意义和用法。<br>An old woman walked out into the middle of the street. The policeman yelled to her,“Don’t you know what it means when I hold up my hand?”The lady said,“Sure I do. I have been a school teacher for 28 years now.”<br>在这个笑话中，那位old woman对警察说的这句话：<br>I have been a school teacher for 28 years now.<br>表示她从事“老师”这个职业是从过去，即28年前开始并且一直延续到了现在，她现在仍然是老师，所以她说28 years now。<br>具体来说就是，如果要表示某一动作或状态 （action or state）从过去开始，并且一直持续（continue）到说话时，而且还可能持续下去，就要采用完成时态形式。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/DYsYK4.png?token=AFPEEZBZDOGFQWJNC2MYE62646N6U"><br>We have been in love for eight years and we are getting married next month. 我们恋爱有八年了，下个月就要结婚了。<br>I have learned English for over ten years now, but I still can’t speak it well.<br>在这句话里，“我”是在10年前开始学习英语的，但这个过去的动作一直延续到了现在，所以用了现在完成时态have learned。</p>
<h3 id="“延续事件”与时间状语的关系"><a href="#“延续事件”与时间状语的关系" class="headerlink" title="“延续事件”与时间状语的关系"></a>“延续事件”与时间状语的关系</h3><h4 id="谓语要表示“延续”"><a href="#谓语要表示“延续”" class="headerlink" title="谓语要表示“延续”"></a>谓语要表示“延续”</h4><p>既然是表示延续思维，句子的谓语动词就要给予配合，即要能够表示延续。具体来说，谓语必须是延续动词，如：learn&#x2F;live，或者是能够表示延续状态的词，如be动词。如果是短暂动 词，则不能表示这种延续思维。比如这些都是错误的：<br>I have fallen in love for eight years. *<br>I have married for over a year. *<br>因为这里的fall in love和marry都是短暂动词，无法与延续性的时间状语（如for eight years, for over a year）连用。要改用表达状态的词，如be in love和be married。注意，这里的married是形容词，所以be married并不是一个被动语态。<br>之所以说“I have fallen in love for eight years. *”这样的句子是错误的，是因为这里的fall in love是一个短暂动作，而短暂动词不能与延续性的时间状语（如for eight years）连用。但这并不是说像fall in love这样的短暂动词不能用于现在完成时态。换句话说，句子错误的原因是fall in love这样的短暂动作与for eight years这样的延续性时间状语有语义上的冲突，而不是fall in love这样的短暂动作与现在完成时态有冲突。<br>“I have fallen in love.”这类句子是完全正确的，短暂动词完全可以用于现在完成时态，只是此时不能和延续性的时间状语连用。</p>
<h4 id="要与“延续性时间状语”连用"><a href="#要与“延续性时间状语”连用" class="headerlink" title="要与“延续性时间状语”连用"></a>要与“延续性时间状语”连用</h4><p>表示延续思维的完成时态除了要有延续性的谓语之外，还必须有延续性的时间状语（durational adverbials），这种表示延续性动作或状态的完成时态一般必须接一个表示“一段时间”的延续性时间状语，以说明某个动作或状态持续到现在有多久了。</p>
<blockquote>
<p> since+时间点或从句</p>
</blockquote>
<p>Since time began, man has lived in fear of fire. 自古以来，人们就生活在对火的恐惧中。</p>
<blockquote>
<p> for+时间段</p>
</blockquote>
<p>Great changes have taken place in Beijing for the past few years. 近几年来，北京发生了巨大的变化。</p>
<blockquote>
<p>“到目前为止”“迄今为止”</p>
</blockquote>
<p>这样的时间短语有：until now，up until now，up to now，up till now 和so far等。请看例句：</p>
<blockquote>
<p>“在最近几个世纪&#x2F;几年&#x2F;几个月以来”</p>
</blockquote>
<p>这样的时间短语有：in the past few years，over the past few years， during the last three months，for the last few centuries，through centuries和 throughout history等。</p>
<p>1） I have lived in China for 3 years.<br>2） I lived in China for 3 years.<br>例句1）表示现在“我”还在中国居住。既然到目前为止已经生活三年了，因此我们可以明确计算出“我”是三年前开始居住在中国的。例句2）则只是说明“我”曾经在中国生活过三年，而且现在已经不住在中国了。这里三年的起止时间，即何时开始在中国居住，何时离开中国，我们都无从知晓。</p>
<h4 id="没有延续性的时间状语，则表示一个“完成了（complete）”的动作"><a href="#没有延续性的时间状语，则表示一个“完成了（complete）”的动作" class="headerlink" title="没有延续性的时间状语，则表示一个“完成了（complete）”的动作"></a>没有延续性的时间状语，则表示一个“完成了（complete）”的动作</h4><p>完成时态要表示延续思维所必须具有的两个条件：<br>（一） 谓语要表示延续；<br>（二） 要有延续性的时间状语。<br>但是如果没有这个延续性的时间状语，句子用完成时态还正确吗？ 若正确，那又是什么意思呢？回答是：若没有延续性的时间状语，可以用完成时态，但表示的是一个在过去已经完成的动作，而没有延续到现在。</p>
<p>John has lived in Paris for ten years.<br>这句话用了现在完成时态，表示John现在还在巴黎生活 （John is still living in Paris now.）。但是如果没有延续性的时间状语而 说成“John has lived in Paris.”，则要理解成“约翰在巴黎生活过”，但现在 他已不住在巴黎了。<br>只有在特殊的上下文语境中，“John has lived in Paris.”这句话才有可能当“延续”讲。比如：<br> A: Where has John lived since he left Beijing?<br> B: He has lived in Paris.<br>这里，B的回答相当于“He has lived in Paris ever since he left Beijing.”。<br> A：约翰离开北京后一直在哪里生活？<br> B：他一直生活在巴黎。</p>
<p>Dr. Findlay was passing one of his patients in the street.“Hello, Mrs. Merton. You haven’t visited me for ages.”“I know, doctor. I’ve been ill.”<br>在这个语境中，虽然没有延续性的时间状语，但这里的完成时have been ill表示“一直在生病”，即表示延续事件。</p>
<p>I have been married for a year. 我结婚已经有一年了。<br>如果将这个句子稍做如下改变：“I have been married.”。<br>即把句末的时间状语for a year去掉，这时这个句子的意思不是“我已经结婚了”，而是“我曾经结过婚”。<br>这句话的言外之意是：“我”现在要么离婚了，要么丧偶了，总之是单身（single）。所以可以说，没有延续性的状语，延续状态顿时变成一个在过去完成的事件，而没有持续到现在。<br>比如当你向外国朋友 介绍自己时说“我已经结婚了”，很多人以为这里有“已经”，那当然得用完成时态，于是就把这句话说成“I have been married. （我结过婚，后来 离婚了。）”。听完这句话，你的外国朋友很可能是对你报以同情地说“I’m sorry to hear it.”。听他这么说，你可能会糊涂了，或者还以为他对你有什么企图呢！其实，要表达“我已经结婚了”，就是I am married. 这一简单的句子。</p>
<h2 id="重复事件"><a href="#重复事件" class="headerlink" title="重复事件"></a>重复事件</h2><h3 id="过去的事件“重复”到现在"><a href="#过去的事件“重复”到现在" class="headerlink" title="过去的事件“重复”到现在"></a>过去的事件“重复”到现在</h3><p>克林顿在2001年1月18日所作的卸任演说：<br>In all the work I have done as president, every decision I have made, every executive action I have taken, every bill I have proposed and signed, I’ve tried to give all Americans the tools and conditions to build the future of our dreams, in a good society, with a strong economy, a cleaner environment, and a freer, safer, more prosperous world. （Selection of President Bill Clinton’s farewell address to the nation on Jan. 18, 2001.）<br>在这里，克林顿不厌其烦地使用完成时态，正是表示在他的八年总统任职期间，他“重复不断”地在have done, have made decisions, have taken action, have proposed and signed bills。比如说“签署法案”，克林顿不可能是一直毫不间断“持续”地（continuously）在签署，这一签就持续了八年，而是表示在八年的总统任职期间，他“多次 重复”签署各种不同的法案。</p>
<p>I’ve been in Canada for six months. I’ve met many new friends.<br>这里的have been是完成时的延续性思维；而我们“结识 （met）”新朋友不是一刻不停地在延续，而是不断重复的一个过程，属于典型的重复性思维。</p>
<p>完成时态表示重复性思维时，句中往往都会有较明显的表示重复概念的词语或语言标示（如复数-s）。比如：<br>I have had so many teachers in my life.<br>…every decision I have made, every executive action I have taken, every bill I have proposed and signed,…<br>I’ve met many new friends. </p>
<p>有时候，句中并没有出现上述这样明确表示重复活动的“语言 标示”，但重复性思维隐含在说话的语境中。这时就要细心体会其中的重复意味，从而正确理解句子的内涵。<br>For us this has been the most perfect way to remember her, and this is how she would want to be remembered.<br>这句话是英国 的威廉王子在纪念母亲戴安娜的音乐会上说的。1997年8月31日，戴安 娜在巴黎出车祸，香消玉殒。2007年7月1日是戴安娜诞辰46周年纪念 日，威廉王子与哈里王子希望用戴安娜喜爱的音乐来纪念她。于是，由 两位王子发起，7月1日当天在英国伦敦温布利体育场（Wembley Stadium）举办“献给戴安娜的音乐会”，借音乐会的形式纪念戴安娜王 妃去世10周年（They organized the event to mark the 10th anniversary of their mother’s death.）。国内媒体在报道这则新闻时是这么翻译的：<br>对我们来说，这是纪念她的最佳方式，这也是她所希望的纪念方式。<br>虽然说这么翻译也未尝不可，但它并没有很好地传达英语原句的意思。这里关键是要理解威廉王子为什么要用完成时态has been，而不是直接说is。<br>自从戴安娜王妃去世后，英国举办过各种活动来纪念她。也就是说，到目前为止，纪念戴安娜的活动已经多次举办过，可以说是从过去到目前为止的重复发生的活动。威廉王子在音乐会现场说的话，显然是在“回顾”过去10年的各种活动，然后得出结论说，这次音乐会“是纪念她的最佳方式”，这正是完成时态“回顾”性思维的体现，并且是表示一个重复到现在的活动，因而他要用完成时态说“For us this has been…”，他用完成时态的另外一个意义还在于，完成时态还表明活动依然可以重复到将来，换句话说，以后一定还会有其他纪念戴安娜王妃的活动，因而也就可能出现比这次音乐会更好的其他纪念方式。<br>因此， 确切地说，这次音乐会是“迄今为止（up until now）”纪念她的最佳方 式，这正是威廉王子用has been所要传达的意义。如果威廉王子用一般现在时态说成“For us this is the most perfect way to remember her,…”，根据一般现在时态的思维特征——表示从过去到现在直至将来的一个永恒 的状态，则意味着这次音乐会作为纪念戴安娜的方式是“前无古人，后无来者”的，是永远无法被超越的了。相信这不是威廉王子所期望的， 所以他要用has been来给这次音乐会精确定位——这是迄今为止纪念她的最佳方式。<br>所以正确的翻译应该是：<br>对我们来说，这是迄今为止纪念她的最佳方式。如果她在天有灵的话，我想这也是她所希望的纪念方式。</p>
<p>2007年10月，卡特在接受英国BBC采访时对时任（2007年10月时）美国副总统切尼（Cheney）也提出了批评。他说切尼是一个好战分子，自己逃避兵役，在过去的10年中却一直强硬地通过军事手段在世界其他地方谋求美国霸权。他说切尼在很多问题上都是错误的，并说他对于美国来说是一场灾难：<br>You know he’s been a disaster for our country. I think he’s been overly persuasive on President George Bush and quite often he’s prevailed.<br>这里的has been并不是表示“重复”意义，而是表示“延续”意义——从切尼担任美国副总统一直到目前说话时为止，所以，我们采用“一直”来对应翻译。同样道理，如果切尼不再担任美国副总统，那么要对他作出如此评论，则应该用一般过去时was了。<br>你们知道，他一直是我们国家的灾难，我想他一直对总统乔治·布什过度诱导，并且经常取得成功。</p>
<p>“重复意义”的完成时态可以看作是“延续事件”完成时态的一个特例，所以，这两种完成时的思维方式是如此密切相关，以至于有时我们很难对二者进行严格的界定区分。 比如：<br>For more than eighty years, scientists have argued over whether life exists on the planet Mars.<br>如果把have argued当作延续性思维来理解，则可译为“80多年以来，科学家们一直在争论火星上是否有生命存在”。强调争论一直在持续，已经持续了80多年。 如果把have argued当作重复性思维来理解，则可译为“80多年以来，就火星上是否有生命存在这一问题，科学家们不断地挑起争论”。 表示争论了一段时间告一段落，若干年后，争论又被再次挑起或被多次挑起。强调80多年当中，“争论”多次被挑起，每一次争论只持续若干年。<br>延续思维：80多年以来，科学家们一直在争论火星上是否有生命存在。<br>重复思维：80多年以来，就火星上是否有生命存在这一问题，科学家们不断地挑起争论。<br>比较模糊的翻译：80多年以来，科学家们一直就火星上是否有生命存在这一问题不断地进行争论。</p>
<p>I have lived in Beijing for 10 years.<br>这句话可以表示“我”一直生活在北京，一刻也没有离开过北京；也可能是表示在北京前后断断续续地生活了10年，中间也离开过北京。此时相当于：<br>I have lived in Beijing on and off for 10 years.<br>我们还可以说：<br>I have lived in Beijing every winter for 10 years.<br>表示“我”每年冬天都回到北京生活，前后已经持续了10年了。这同样是重复与延续兼而有之的活动，相当于这样一条虚线。</p>
<h3 id="“重复事件”与时间状语的关系"><a href="#“重复事件”与时间状语的关系" class="headerlink" title="“重复事件”与时间状语的关系"></a>“重复事件”与时间状语的关系</h3><p> 1） I have called him three times this morning.<br> 2） I called him three times this morning.<br>在例句1）中，既然采用了现在完成时态，而且是表示重复的活动（因为有three times这样的“重复标示”），所以该句强调的是到目前为止的一个时间段内重复的活动，或者说过去的动作called重复到了现在，这里的“现在”显然就是this morning。也就是说，例句1）的说话时间是“今天上午”。而例句1）要表达的意思其实相当于：<br>I have called him three times so far this morning.<br>即表示“我今天上午到目前为止已经给他打过三次电话了”。言外之意是，随着现在的说话时间this morning往将来推移，“我”还可能继续给他打电话，可能打第四次、第五次……。由此可见，这里的“打电话（have called）”具有“将来可重复性（repeatable）”这个特点。<br>相比之下，例句2）与例句1）有很大的不同。既然采用了一般过去时态，则表明事情发生在过去，与现在没有什么联系，因此例句2）的说话时间可能是在“今天下午”或“今天晚上”。进而也就决定了“我”“今天上午”给他打电话的次数仅为三次，没有继续重复的可能性（“我”当然可以继续给他打电话，但已经不属于“今天上午”的活动次数了）。由此可见，这里的“打电话（called）”不具有“将来可重复性（repeatable）”这个特点。<br>1）我今天上午到目前为止已经给他打过三次电话了。<br>2）我今天上午给他打了三次电话。<br>由这个例句所揭示的have called与called在“可重复性”方面的差别可以推而广之，即现在完成时态具有“将来可重复性”，而一般过去时态 不具有“将来可重复性”。这是判断用现在完成时态还是用一般过去时态的重要原则，我称这个原则为“可重复性”原则（Principle of Repeatability）。</p>
<h4 id="可重复原则是现在完成时态的一条根本原则"><a href="#可重复原则是现在完成时态的一条根本原则" class="headerlink" title="可重复原则是现在完成时态的一条根本原则"></a>可重复原则是现在完成时态的一条根本原则</h4><p>His father has been dead for three years.<br>他爸爸去世已经有三年了。<br>但是，对这个句子稍做如下改变： His father has been dead. *<br>这句英文真正的意思是：他爸爸曾经死过。在英文里，这个句子一般被认为是错误的，因为没有使用它的场合——人是不能死而复生的。</p>
<blockquote>
<p>那么“他爸爸已经死了”用英 文该怎么说？</p>
</blockquote>
<p>这句话要看上下文的语境。比如，说到你某位朋友的爸爸，如果你只是要说明他爸爸已经过世了这一事实，只需说“His father is dead.”。<br>但若是你这位朋友的爸爸刚刚去世，你的朋友当然很悲痛伤心、精神恍惚，当别人问你他怎么了，你就可以说是因为“His father has died.”，这里的现在完成时态就是过去发生的事件（比如朋友的父亲去世）对现在有影响（比如你朋友现在悲痛的表现）。<br>所以，对于像“死亡”这样天然不具有重复性的事件，即不能表示来回往复的发生，就不能用现在完成时来表示“过去经历”。同样，人不能返老还童，所以我们不能说： I have been old. *<br>这句话的意思是“我曾经老过”，言外之意是我现在又年轻了。显然，人是不能返老还童的。只能说自己曾经年轻过（I have been young.）。</p>
<h4 id="可重复原则与将来的时间有关"><a href="#可重复原则与将来的时间有关" class="headerlink" title="可重复原则与将来的时间有关"></a>可重复原则与将来的时间有关</h4><p>现在完成时态所表达的动作或状态往往都含有持续或重复到将来某一个时间点的意味，即现在完成时与将来的时间有关，也就是我这里说的“将来可重复性”原则。 现在完成时态可以说是以现在的时间为参照来谈一个可以持续或重复 到将来的事件。<br>1） How many people have entered for the race?<br>2） How many people entered for the race?<br>虽然这两个句子都可以译成“有多少人报名参加这个比赛”，但在英文中，两个句子所使用的语境以及要表达的时间是不同的。<br>在例句1）中，完成时态表达了一个重复活动，真正的含义是“到目前为止有多少人报名参加这个比赛”，相当于“How many people have entered for the race so far?”。其言外之意是，这个比赛还没有开始举行， 是一个将来的活动。说话人关心的是到现在为止报名参加的人数。所以，这正是上面提到的“现在完成时是以现在的时间为参照来谈一个可以持续或重复到将来的事件”。这里是重复到将来的事件——不断有人报名参加，即具有“将来可重复性”。如果比赛已经结束了，成了一个过去的事件，则“（报名enter for）”就已没有“将来可重复性”了，此时我们就不能用现在完成时态，而只能用一般过去时态，这正是例句2）要表达的意思。<br>在例句2）中，用一般过去时态表明这个比赛已经结束了， 而不是一个将来事件。该句真正的意思是“有多少人报名参加了那次比赛”。<br>1）到目前为止，有多少人报名参加这个比赛？<br>2）有多少人报名参加了那次比赛？</p>
<p>Many athletes have entered for the Olympic Games this year.<br>这里用了现在完成时态，表明奥运会还没有举行，这里的“报名”是一个可以重复到将来的活动。</p>
<blockquote>
<p>其实，即使是一个单一的事件而不是一个重复活动，如果使用了现在完成时态，同样与将来时间有关系。</p>
</blockquote>
<p>I have entered for the examination but I don’t want to take it.<br>这个句子用了现在完成时态，表明是将来的事件——考试是在将来举行。<br>这次考试我已经报名了，但我不想考。</p>
<p>A: Have you visited the new exhibit?<br>B: Not yet, but it will be at the student center until June.<br>从B的回答中我们知道这个“展览会（exhibit）”还没有结束，是一个可以持续到将来的事件，因而具备了将来可持续性，所以用了现在完成时态。如果说话人问的是“Did you visit the new exhibit?”， 则表明这个展览会已经撤展结束了，已是一个过去的事件。<br>A：这次新的展览会你去参观了吗？<br>B：还没有去，不是一直在学生中心展览到6月份才结束嘛。</p>
<p>A: I’ve been invited to a dinner party at Janet’s. Do you think I should bring something?<br>B: You could pick up a cake. Chocolate is her favorite.<br>从这个对话的语境中我们知道，这个dinner party还没有举行，是一个将来的事件。不过，“邀请（invite）”现在已经发生了，它的影响会一直持续到现在及未来直到dinner party结束，所以用了现在完成时态。如果用一般过去时说“I was invited to a dinner party at Janet’s.”， 则只表示一个过去的事件，即dinner party已经结束了。<br>A：我受到邀请去珍妮特家参加晚宴，你认为我该带点什么东西去吗？<br>B：你可以买一份蛋糕嘛，巧克力口味的她最喜欢。</p>
<h4 id="可重复性原则与过去时间"><a href="#可重复性原则与过去时间" class="headerlink" title="可重复性原则与过去时间"></a>可重复性原则与过去时间</h4><p>在英文中，确定的过去时间状语（如yesterday和last night）不能用于现在完成时态，这可以用可重复原则来解释。因为过去时间状语表明事件在过去已经完成而无法延续或重复到现在及未来，这就违背了完成时态的将来可重复性原则，故现在完成时不能使用确定的过去时间状语。<br>1） I was absent four times last semester.<br>2） I have been absent twice this semester.<br>在例句1）中，过去时间状语last semester表明“缺课 （absent）”这个事件已经结束，即上学期只有确定的四次缺课。该事件不具有可重复性，所以不能用完成时态。<br>在例句2）中，这学期还没有结束，随着时间的推移还可能有更多次数的“缺课（absent）”。该事件具有未来可重复性，所以要用现在完成时态。<br>1）我上学期逃课四次。<br>2）这学期到目前为止我逃过两次课。</p>
<h4 id="可重复性原则与现在时间"><a href="#可重复性原则与现在时间" class="headerlink" title="可重复性原则与现在时间"></a>可重复性原则与现在时间</h4><p>所谓现在时间，是指诸如today，this week和this year等这样的时间状语。这样的时间状语一般都会用于现在完成时态，如果有特殊的语境信息表明某个事件无法继续延续或重复到现在及将来，就用一般过去时。现在时间可以用于现在完成时态或一般过去时态。<br>1） I haven’t seen him this morning.<br>2） I didn’t see him this morning.<br>例句1）用了现在完成时，而完成时是要与“现在”发生联系的，故例句1）说话的时间是this morning。该事件具有可重复性，随着时间的推移，“我”有可能会见到他。例句2）用的是一般过去时，说明this morning已经成为过去的时间，故例句2）说话的时间是在“今天下午”或“今天晚上”。该事件不具有可重复性，“我今天上午没有见到他”已是确定无疑的事件，不可改变了。</p>
<p>1） I have made five phone calls today.<br>2） I made five phone calls today.<br>这里的例句1）用现在完成时态，则表明“打电话”这个活动还会重复到未来，今天很可能会继续打第六个、第七个电话。而例句2）用一般过去时态，则表明“打电话”这个活动在今天不会再重复了，今天总共就只打了五个电话。<br>想象一下这两个句子不同的使用语境：比如你在一家公司做电话销售员，你的工作就是每天不断地打电话联系你的客户，推销产品。在今天上午10点钟的时候，你和同事交流时说“我今天打了五个电话了”，此时显然你就得用现在完成时态说“I have made five phone calls today.”。而如果你在下午下班后和同事交流时说“我今天打了五个电话”，此时显然你不会再打电话了，所以要说“I made five phone calls today.”。</p>
<h4 id="可重复性原则与一般时间"><a href="#可重复性原则与一般时间" class="headerlink" title="可重复性原则与一般时间"></a>可重复性原则与一般时间</h4><p>一个句子如果出现了具体的过去时间状语，那就不能使用现在完成时态。比如我们不能说：<br>I have gotten up at five o’clock this morning. *<br>但不是只要出现了表示某一时刻的时间状语， 句子就一定不能使用现在完成时态。比如：<br>I have gotten up at five o’clock in the morning.<br>仔细比较以上两句就会发现二者的不同：前一句用了this morning（今天早晨），而在说话的时候，“今天早晨”一定已经成了过去，所以有了这样具体的过去时间状语，就不能用现在完成时态。 但是后一句是用了in the morning（在早晨），而“在早晨”并不是指“今天早晨”。因此，at five o’clock this morning是一个具体的过去时间，但 at five o’clock in the morning并不是指一个具体的过去时间；前者只有一次，但后者可以无数次地重复。所以，具备了这样的“可重复性 （repeatable）”，完全可以用现在完成时态来表达。<br>后一句就是表示到目前为止的一个“重复活动”，是一个典型的现在完成时用法，翻译成“我曾经在早晨五点钟起过床”，说话人这样表达的言外之意是要强调“五点钟”是一个很早的时间，而自己曾经这么早就起床，即表明自己具有早起这样的“过去经历”。类似的我们还可以说：<br> I have gone swimming at 12 at midnight.<br>这句话的意思就是“我曾经在夜里12点去游过泳”，同样表示自己的“重复经历”。当然，我们不能说：<br> I have gone swimming at 12 last night. *</p>
<h4 id="可重复性原则与地点表达"><a href="#可重复性原则与地点表达" class="headerlink" title="可重复性原则与地点表达"></a>可重复性原则与地点表达</h4><p>有时，地点状语起着表明说话时间的作用，因为地点的转化总是伴随着时间的变化。<br>1） In my hometown, I had five jobs.<br>2） In this city, I have had two jobs.<br>在例句1）中，地点状语in my hometown表明“我”现在人不在老家，这个地点状语暗含了过去的时间，所以该句要用一般过去时态，该事件不具有可重复性。在例句2）中，地点状语in this city表明“我”现在人在这个城市，这个地点状语暗含了现在的时间，该句的意思是“到目前为止我做过两份工作”，该事件具有可重复性，所以用现在完成时态。<br>1）我在老家的时候，做过五份不同的工作。<br>2）在这个城市，我到目前为止做过两份不同的工作。</p>
<h4 id="可重复性原则与去世的人的情况"><a href="#可重复性原则与去世的人的情况" class="headerlink" title="可重复性原则与去世的人的情况"></a>可重复性原则与去世的人的情况</h4><p>一般来说，谈到有关去世的人的情况，往往都是无法持续和重复的，即不具有将来可重复性，所以，涉及去世的人的句子通常要用一般过去时态，而不能用现在完成时态。<br>这里举一个关于电影明星的例句。我们知道，美国著名影星玛丽莲·梦露（Marilyn Monroe）已不在人世，所以谈到关于她的情况时，往往要用一般过去时态。而美国人<br>称“大嘴美人”的茱莉亚·罗伯茨（Julia Roberts）现在还活着，所以谈到关于她的情况时，就会用到现在完成时态。比如：<br>1） Marilyn Monroe starred in many movies. She died in 1962.<br>2） Julia Roberts has starred in many American movies.<br>1）玛丽莲·梦露于1962年去世，她生前出演过多部电影。<br>2）茱莉亚·罗伯茨出演过很多美国电影。<br>如果将对茱莉亚·罗伯茨的介绍改为一般过去时态，说成：<br>Julia Roberts starred in many American movies.<br>则会有两种情况：一是等她去世之后这么说，二是她明确宣布退出影坛了。但这两个条件现在都不满足，所以上面这个句子在native speaker听来就显得有点奇怪（sounds odd）。而后一种情况适合日本影星山口百惠（Momoe Yamaguchi），虽然她还活着，但已息影多年，所以要用一般过去时来谈她的从影经历。</p>
<h4 id="可重复性原则与特定语境"><a href="#可重复性原则与特定语境" class="headerlink" title="可重复性原则与特定语境"></a>可重复性原则与特定语境</h4><p>有时，这种“超语言信息”的背景知识并不是一个众所周知的常识，而只是交际双方共有知识（shared knowledge）的一部分，此时到底用现在完成时态还是一般过去时态，则取决于具体语境。如果有语言外的信息决定了某一活动不再延续重复，就要用一般过去时态。比如：<br>1） Have you ever fallen off a horse?<br>2） Did you ever fall off a horse?<br>在例句1）中，用了现在完成时态，意味着“骑马”这个活动没有结束，将来还要骑马，因此fall off a horse这个事件可能重复发生。<br>在例句2）中，用了一般过去时态，意味着“骑马”这项活动不再持续，说话人不再骑马了，因此，fall off a horse这个事件不可能重复发生。<br>1）到目前为止，你骑马从马背上摔下来过吗？<br>2）你以前骑马的时候，从马背上摔下来过吗？</p>
<p>A: Have you ever fallen off a horse?<br>B: Yes, I’ve fallen off quite often.<br>A：到目前为止，你骑马从马背上摔下来过吗？<br>B：是的，我经常从马背上摔下来。</p>
<p>A: Did you ever fall off a horse?<br>B: Yes, I did occasionally.<br>A：你以前骑马的时候，从马背上摔下来过吗？<br>B：摔过，不过只是偶尔摔下来。</p>
<p>由此可见，“可重复性（repeatability）”是现在完成时态的一个重要的思维特征。</p>
<h2 id="单一事件"><a href="#单一事件" class="headerlink" title="单一事件"></a>单一事件</h2><h3 id="何谓“对现在有影响”？"><a href="#何谓“对现在有影响”？" class="headerlink" title="何谓“对现在有影响”？"></a>何谓“对现在有影响”？</h3><p>He’s Just Been to the Zoo<br>When I was waiting in line at the bank, I noticed a woman holding a small child at one of the windows. The boy was eating a roll, which he thrust at the teller. The teller smiled and shook his head.<br>“No, no, dear,”said the boy’s mother, and then, turning to the teller,“I beg your pardon, young man. Please forgive my son. He’s just been to the zoo.”<br>“去动物园”这个事件是发生在过去的，对现在的影响是：小男孩拿自己吃的面包卷去“喂”银行柜员（The little boy thrust the roll at the teller.），他还以为自己在喂一只动物呢！这一“对现在的影响”从完成时的句子“He’s just been to the zoo.”本身是看不出来的。<br>他刚去了动物园<br>那天我在银行排队办事时，看到一位妇女抱着一个小孩站在一个窗口前。小男孩正在吃一个面包卷，并把它往一个柜员面前送。这位营业员微笑着摇了摇头。 “宝贝，别这样，”孩子的母亲说道，然后转过脸对柜员说：“对不起，先生，请原谅这孩子，他刚刚去了动物园。”<br>由此可见，“单一事件”的完成时态是与说话的语境密切相关的，若单独拿出完成时态的句子，我们很难理解其所要表达的真正含义，因为它所要表达的言外之意或潜含在上下文的语境中，或通过上下文的其他句子反映出来。所以，在使用中绝不应死记规则，而要真正理解完成时态的这一用法特点，要融入自己的思维。因为语言表达本质上是一种思维表达，语言只是载体，它的背后是说话人的思维！</p>
<p>She has been to the bank. （她去过那家银行了。）<br>这句话背后的“言外之意”或者说“对现在的影响”是什么？我们只要发挥想象就可以很容易地造出很多不同版本的“对现在的影响”，比如比较直接的影响有：1）为什么她现在有钱花了（She has some money.），因为她去银行取过钱了；2） 她已经把手里的支票存到银行了（The checks are deposited.）。 比较间接的影响有：1）她为什么知道那家银行的地点位置，因为她以前去过（即She has been to the bank.）；2）她为什么现在很高兴，因为她曾去这家银行应聘工作，她刚去过这家银行（即She has been to the bank.）。现在知道自己被录用了，等等。<br>所以，一个完成时的句子若是用在真实的语境中，可能产生多少种“对现在的影响”。</p>
<h3 id="何谓“过去事件”？"><a href="#何谓“过去事件”？" class="headerlink" title="何谓“过去事件”？"></a>何谓“过去事件”？</h3><p>“过去事件”中的这个“过去”应该有离现在较近和较远之分。“单一事件”的完成时既可以表示发生在最近的动作，也可以表示发生在较远的过去的动作，具体情况要看上下文的语境。<br>David has fallen in love, and that’s why he’s becoming excited.<br>这个例句就应该理解为恋爱这个事件是发生在“近的过去（quite recently）”，而且对现在的影响是he’s becoming excited。<br>戴维恋爱了，所以他为什么那么兴奋。<br>有时对于同一个句子，按照“近的过去”与“远的过去”两种意义都可以理解，但两者表达的意思不一样。比如：<br>Have you asked your little brother to do the dishes?<br>首先，这个句子不能译成延续状态，因为我们强调过，表示延续状态的完成时一般必须同时满足两个条件：句子的谓语是延续性动作或状态（continuous action or state）；句子带有延续性的时间状语（durational adverbials）。这里， ask不是延续性动词且句中没有延续性的时间状语，因此这里的完成时态不是表示延续状态，所以不能把它翻译成“一直让你弟弟刷碗”。其实，这个英语句子是有歧义（ambiguous）的。产生歧义的原因是我们既可以把asked作为“近的过去”来理解，也可以作为“远的过去”来理解。歧义是：<br>1）你让你弟弟把碗刷了吗？（近的过去）<br>2）你有没有让你弟弟刷过碗？（远的过去）<br>在句1）中，问话的人一般应该是你的家人，比如说你妈妈。设想这样一个场景：因为正要开饭了，而她找不到干净的碗碟，所以她问你：“你让你弟弟把碗刷了吗？”她现在关心的是有没有干净的餐具可以 用——这就是用现在完成时所要表达的“对现在的影响（current influence）”。在句2）中，问话的人一般不可能是你的家人，应该是你的朋友。设想这样一个场景：你和朋友们正在聊兄弟之间的关系，你告诉你朋友说，你喜欢让你弟弟做各种各样的事情，比如让他为你洗衣服、替你做功课、给你做饭等等，这时候你的一个朋友问你：“那你有没有让你弟弟刷过碗呢？”<br>由此可知，对于“单一事件”的完成时态，虽然该事件发生的过去时间是不确定的，但我们可以大概地区分为“近的过去（near past）”事件和“远的过去（distant past）”事件，因而所表达的意思也不一样。这种时间上的远近是需要借助上下文的语境才能作出区分的，单从完成时态句子本身是无法区分的。因此可以说，“单一事件”的完成时态，若是离开语境，几乎无法理解它所要表达的真正含义。</p>
<h3 id="新闻热点（hot-news）——近的过去"><a href="#新闻热点（hot-news）——近的过去" class="headerlink" title="新闻热点（hot news）——近的过去"></a>新闻热点（hot news）——近的过去</h3><h4 id="所造成的现在结果往往是直接具体或依然清晰可见的"><a href="#所造成的现在结果往往是直接具体或依然清晰可见的" class="headerlink" title="所造成的现在结果往往是直接具体或依然清晰可见的"></a>所造成的现在结果往往是直接具体或依然清晰可见的</h4><h4 id="具有最新热点新闻的效果"><a href="#具有最新热点新闻的效果" class="headerlink" title="具有最新热点新闻的效果"></a>具有最新热点新闻的效果</h4><p>在日常对话中，完成时态的这个用法常常用来提供最新消息。比如某个名人刚刚去世，这往往是个大新闻，这时就会用到现在完成时态。<br>比如：I hear that famous Chinese comedian has died. 我听说那位著名的中国喜剧明星去世了。<br>The President has been assassinated. 总统被暗杀了。<br>但是，如果某个名人的“死亡”不是刚刚发生的，而是离现在的时间比较远了，就要改用一般过去时态了。比如肯尼迪总统是被刺杀的，但因为是很久远的事情了，所以要用一般过去时态来表达：<br>John F. Kennedy was assassinated.</p>
<h4 id="时态搭配：现在完成时-一般过去时"><a href="#时态搭配：现在完成时-一般过去时" class="headerlink" title="时态搭配：现在完成时+一般过去时"></a>时态搭配：现在完成时+一般过去时</h4><p>口语对话中常出现“现在完成时+一般过去 时”的时态搭配使用。此时，我们用“现在完成时”提起一个新闻话题， 用“一般过去时”继续详谈内容。<br>比如，若你要把萨达姆被捕这一新闻告诉你的朋友，你一开始应该用现在完成时，接下去的对话则应改为过去时：<br>A: The former Iraqi President Saddam has been captured.<br>B: Really? When did that happen?<br>A: He was captured Saturday at 8:30 p.m. in a cellar on an isolated farm near Tikrit.<br>A：伊拉克前总统萨达姆被抓了。<br>B：真的？什么时候？<br>A：他是周六晚8:30在提克里特附近一个偏僻的农场的地窖里被捕的。</p>
<h3 id="过去的经历（past-experience）——远的过去"><a href="#过去的经历（past-experience）——远的过去" class="headerlink" title="过去的经历（past experience）——远的过去"></a>过去的经历（past experience）——远的过去</h3><h4 id="表示过去经历的现在完成时"><a href="#表示过去经历的现在完成时" class="headerlink" title="表示过去经历的现在完成时"></a>表示过去经历的现在完成时</h4><p>当谈论一个发生在离现在时间较远的过去的某个事件时，常常含有回顾自己曾经的经历的意味。所以，如果把现在完成时用于指较远的过去的事件，这时的完成时往往用来谈论人们过去的经历或经验（past experience）。<br>1） Have you ever called in sick at work when not ill?<br>2） Have you ever taken office supplies from your company?<br>3） Have you ever taken anything valuable from your company for personal use? 等等。<br>这些问题涉及的时间跨度很长，其中伴有时间副词ever（曾经）来强调这个时间跨度。正如有受访者所言：“‘曾经’是一个很长的时间范畴 （Ever is a long time.）”，它包括从出生以来到目前为止的任何一个过去的时间点，这正是现在完成时态的第三种思维——“单一事件”完成时。所以，上述句子都用了现在完成时态。另外，这里的完成时句子都是表示过去的经历，具有“远的过去”事件的意味。</p>
<h4 id="时态搭配一：现在完成时-一般过去时"><a href="#时态搭配一：现在完成时-一般过去时" class="headerlink" title="时态搭配一：现在完成时+一般过去时"></a>时态搭配一：现在完成时+一般过去时</h4><p>这一时态搭配中的现在完成时也可以用来谈“远的过去”事件，此时用完成时询问对方过去的经历，然后用一般过去时继续详谈这个经历的具体情况。<br>A: Have you seen the film Forrest Gump?（询问对方过去的经历）<br>B: Yes, I have. （现在知道电影的内容）<br>A: When did you see it?（关心看电影的过去的具体时间）<br>B: I saw it last spring. （给出具体时间）<br>A: Did you see it alone?（询问当时的情况）<br>B: No, I saw it with my boyfriend. （提供过去的事实）</p>
<h4 id="时态搭配二：一般过去时-现在完成时"><a href="#时态搭配二：一般过去时-现在完成时" class="headerlink" title="时态搭配二：一般过去时+现在完成时"></a>时态搭配二：一般过去时+现在完成时</h4><p>用一般过去时讲述自己过去的经历，然后用现在完成时探询对方是否有相似的经历，以期望获得更多的理解或共鸣。<br>John: We went down into Juarez and through El Paso, and oh, we had a ball.<br>Louise: Really?<br>John: Yeah. Have you ever been to—have you ever heard of Juarez? Louise: I’ve heard of both of them because my girlfriend’s old boyfriend was stationed in El Paso.<br>John: Well, we went to Juarez…<br>这里约翰在用一般过去时讲述自己在华雷斯的经历， 但在继续讲故事之前，他从过去时态的叙述转到一个现在完成时态的询 问（Have you ever been to—have you ever heard of Juarez?），以此来探询路易斯是否了解华雷斯这个地方。而路易斯在展示自己的有关知识时 也使用了现在完成时（I’ve heard of both of them…），表明自己对华雷斯有所了解。而这个“现在的了解”是因为过去听说过那个地方——即过去的事件对现在有影响。<br>约翰：我们南下去了华雷斯，穿过了整个埃尔帕索市，哦，我们玩得开心极了！<br>路易斯：真的？<br>约翰：是的。对了，你曾经去过——你听说过华雷斯吗？<br>路易斯：这两个地方我都听说过，因为我的女朋友的前男友就是驻扎在埃尔帕索的。<br>约翰：噢，我们去了华雷斯……</p>
<h4 id="时态搭配三：一般现在时-现在完成时"><a href="#时态搭配三：一般现在时-现在完成时" class="headerlink" title="时态搭配三：一般现在时+现在完成时"></a>时态搭配三：一般现在时+现在完成时</h4><p>如果说话人谈到的过去经历是一般常见的经历，而不是指某一次具体的过去的经历，那么他会用一般现在时态，然后接一个现在完成时态，来探寻听话者&#x2F;读者是否有过类似的经历。</p>
<h3 id="“单一事件”与时间状语的关系"><a href="#“单一事件”与时间状语的关系" class="headerlink" title="“单一事件”与时间状语的关系"></a>“单一事件”与时间状语的关系</h3><h4 id="“单一事件”完成时的肯定句不与持续的时间状语连用"><a href="#“单一事件”完成时的肯定句不与持续的时间状语连用" class="headerlink" title="“单一事件”完成时的肯定句不与持续的时间状语连用"></a>“单一事件”完成时的肯定句不与持续的时间状语连用</h4><p>这种完成时态的谓语动词通常是短暂动词，即指动作在短时间或瞬间内就已终止，而不再延续。常见的这类动词有：come，go，leave， kill，die，lose，buy，start，give，marry，join和bring等。因为动作本身无法延续，因此与它连用的时间状语不能是指“一段时间”的，如for a year等。这恰好与“延续事件”的完成时相反——“延续事件”的完成时必须加持续的时间状语，而“单一事件”完成时态不能加持续性的时间状语，<br>I have bought this pair of shoes for a year.  *<br>I have married for over a year.  *<br>I have fallen in love for eight years.  *<br>He has left his hometown for three years.  *</p>
<p>汉语里完全可以说“这部电影我看了有两年了”，但在英语里却不能用现在完成时态这样表达：<br>I have seen the movie for two years. *<br>因为这里句子的谓语动词是短暂性的，不能表示延续，因而不能与 since或for等引导的持续性的时间状语连用。只要把“动作（action）”转 化为“状态（state）”即可，因为状态是可以延续的。<br>比如上面几个错误的句子可以分别改为相应的“状态”：<br>I have had this pair of shoes for a year. 这双鞋我买了有一年了。<br>I have been married for over a year. 我结婚有一年多了。<br>I have been in love for eight years. 我恋爱有八年了。<br>He has been away from his hometown for three years. 他离开家乡有 三年了。<br>若句中的“动作”表达无法转化成“状态”表达，就不能用现在完成时态，而只能改为一般过去时态。比如see没有对应的状态表达，所以上面的例句5只能改成一般过去时：<br>I saw the movie two years ago.<br>这完全能够表达汉语的“这部电影我看了有两年了”这句话的意思。<br>其他句子也可以作同样的时态改变，比如说：<br>I bought this pair of shoes a year ago.<br>I got married over a year ago.<br>He left his hometown three years ago.</p>
<h4 id="“单一事件”完成时的否定句表示状态意义，可与持续的时间状语连用"><a href="#“单一事件”完成时的否定句表示状态意义，可与持续的时间状语连用" class="headerlink" title="“单一事件”完成时的否定句表示状态意义，可与持续的时间状语连用"></a>“单一事件”完成时的否定句表示状态意义，可与持续的时间状语连用</h4><p>短暂性动词的完成时句子若用否定式，表示尚未发生的事情，则可作为一种状态（state），从而可以表示延续。所以，这种否定句就相当于前面介绍过的“延续事件”完成时态。<br>来看下面这个可怜的乞丐：<br>Beggar: Madam, I haven’t seen a piece of meat for weeks.<br>Lady: Mary, please show this poor man the ham we bought just now.<br>乞丐：夫人，我已经好几个星期都没见过一片肉了。 夫人：玛丽，把我们刚才买的那根火腿给他瞧瞧。<br>这位乞丐说“haven’t seen a piece of meat for weeks.”，显然其言外之意是“给我一些肉吃吧”，但那位妇人故意从字面上理解他的意思，所以让玛丽只是给他“看肉”。这里短暂动词see的否定式与延续的时间状语 for weeks连用了。</p>
<h4 id="“单一事件”完成时常与不确定的时间状语连用"><a href="#“单一事件”完成时常与不确定的时间状语连用" class="headerlink" title="“单一事件”完成时常与不确定的时间状语连用"></a>“单一事件”完成时常与不确定的时间状语连用</h4><p>是现在完成时更多的是与过去的不确定的时间搭配使用，如：already （已经），yet （只用在疑问句或否定句中），lately （最近）, just （刚刚，方才），never （从不，从未发生过），ever （曾经）和before （以前）等，而且还可以按照前面讨论的“远近过去”把它们划分为：</p>
<ul>
<li>较远的过去：ever（英文意思是any time between the past and the present，表示“曾经”，一般指较远的过去时间）和before；</li>
<li>较近的过去：yet，already，lately和recently；</li>
<li>更近的过去：just，表示“刚刚”，常与完成时态连用。</li>
</ul>
<p>A: Have you ever been to the Great Wall?<br>B: Yes. I’ve been there many times.<br>或B: Yes. I went there last spring.</p>
<p>Get a hold of yourself! I’ve never seen you so upset before!<br>你要控制一下情绪。我以前从未见你这么生气！</p>
<p>A: Have you found a job yet? 你找到工作了吗？<br>B: No, not yet. 还没有。<br>He hasn’t arrived yet. 他还没到。</p>
<p>在肯定句中，用already代替yet表示“已经”：<br>A: Have you found a job yet? 你找到工作了吗？<br>B: Yes. I’ve found a job already. 是的，我已经找到工作了。<br>He has already arrived. 他已经到了。</p>
<p>A: Would you like something to eat? 你想吃点什么吗？<br>B: No, thanks. I’ve just had dinner. 不了，谢谢。我刚吃过饭。（现在不饿）</p>
<h2 id="“延续事件”“重复事件”与“单一事件”之间的相互关系"><a href="#“延续事件”“重复事件”与“单一事件”之间的相互关系" class="headerlink" title="“延续事件”“重复事件”与“单一事件”之间的相互关系"></a>“延续事件”“重复事件”与“单一事件”之间的相互关系</h2><h3 id="延续事件与单一事件"><a href="#延续事件与单一事件" class="headerlink" title="延续事件与单一事件"></a>延续事件与单一事件</h3><p>这二者的区别和联系主要与能否带有持续的时间状语有关。<br>1） His father has been dead for three years.<br>2） His father has died for three years. *<br>这里例句1）正确，而例句2）错误，因为die表示短暂 动作，不能与持续的时间状语for three years连用。<br>他父亲去世三年了。<br>但要注意的是，短暂动词可以用于现在完成时态。比如：<br>He has married. 他已经结婚了。<br>His father has died. 他父亲已经去世了。<br>一般只能表示单一事件中的“近的过去”事件。<br>延续事件的完成时在没有持续时间状语时不能表示延续，只能表示过去曾经的经历，这正是单一事件中的“远的过去”事件。<br>1） I have been married for a year.<br>2） I have been married.<br>例句1）表示“我结婚已经有一年了”，现在是已婚状 态；例句2）则表示“我结过婚”，而现在是单身。<br>综上所述，延续事件与单一事件的联系是：不带有持续的时间状语的延续事件立即变成了单一事件中的“远的过去”事件——表示过去的经历。</p>
<h3 id="延续事件与重复事件"><a href="#延续事件与重复事件" class="headerlink" title="延续事件与重复事件"></a>延续事件与重复事件</h3><p>1） He has been married for a year.<br>2） He has been married a couple of times.<br>这里的例句1）表示延续事件，而例句2）表示重复事件。<br>1）他结婚有一年了。<br>2）到目前为止他结过两次婚。</p>
<h3 id="重复事件与单一事件"><a href="#重复事件与单一事件" class="headerlink" title="重复事件与单一事件"></a>重复事件与单一事件</h3><h4 id="重复事件与“远的过去”单一事件"><a href="#重复事件与“远的过去”单一事件" class="headerlink" title="重复事件与“远的过去”单一事件"></a>重复事件与“远的过去”单一事件</h4><p>I have been married. 我结过婚。<br>这句话的意思是“我结过婚”，是表示“过去曾经的经历（a past experience）”，是一个“远的过去”单一事件。但它并没有告诉我们“结婚”经历了几次，只是我们知道“结婚”这一事件到目前为止至少发生过 一次（at least one occurrence up to the present）。说“至少发生过一次”其实就潜含了重复的意味，也就是说“结婚”至少有一次，也可能是多次。 因此，我们很容易就能把上面这句变成一个重复事件，即在句末加一个“重复标示”——频度状语（比如three times）说成：<br>I have been married three times. 到目前为止我结过三次婚。<br>这是一个典型的表示重复事件的完成时句子。所以，从表示过去经 历的“单一事件”到“重复事件”，只需迈一小步，即加上一个表示具体次数的频度状语就可以了。<br>另一方面，用现在完成时来谈论过去的经历时，这个经历一定得是具有可重复性的。如果一个活动或状态天然不具有重复性，即不能表示来回往复的发生，就不能用现在完成时来表示“过去的经历”。比如 说“死”，因为人死不能复生，所以不能说： His father has been dead.* 同样，人不能返老还童，所以也不能说： I have been old.*</p>
<h4 id="重复事件与“近的过去”单一事件"><a href="#重复事件与“近的过去”单一事件" class="headerlink" title="重复事件与“近的过去”单一事件"></a>重复事件与“近的过去”单一事件</h4><p>He has been fired.<br>它既可以解释成“远的过去”事件，即表示“过去的经历”： 他被开除过。<br>也可以理解成“近的过去”单一事件： 他被开除了。<br>为了消除歧义和更明确地表达意思，我们可以添加相应的时间状语来加以区分。比如说：<br>He has been fired before. （他以前曾被开除过。）<br>He has just been fired. （他刚被开除了。）</p>
<p>事实上，句子“He has been fired.”存在歧义，这本身就说明了重复事件、“远的过去”单一事件以及“近的过去”单一事件这三者之间是密切相关的。像上面论述的那样，这个句子稍做改变就可以更明确地传达出这三个不同事件的含义。比如通过添加不同的状语three times，before和 just说成：<br>He has been fired three times. （到目前为止，他已经被开除过三次了。——重复事件）<br>He has been fired before. （他以前被开除过。——“远的过去”单一事件）<br>He has just been fired. （他刚刚被开除了。——“近的过去”单一事件）</p>
<h4 id="“动作表达”的完成时态与“状态表达”的一般现在时态"><a href="#“动作表达”的完成时态与“状态表达”的一般现在时态" class="headerlink" title="“动作表达”的完成时态与“状态表达”的一般现在时态"></a>“动作表达”的完成时态与“状态表达”的一般现在时态</h4><p>“动作表达”和“状态表达”的区别往往与现在完成时态有着密切的联系。比如上面关于“结婚”的例子，如果要表达“我结婚有一年了”这样的延续状态时，只能用“状态表达”即be married，而不能用“动作表达”即 married或get married，所以这句中文用英文表达就是：<br>I’ve been married for a year.<br>而不能说：<br>I’ve married for a year. *<br>I’ve got married for a year. *</p>
<p>以“结婚”为例。看到“I have been married.”，要理解成“我结过婚。”但要表示“我已经结婚了”，英文里可以用“动作表达”的完成时态这样说：<br>I have married.<br>也可以用“状态表达”的一般现在时态这样说：<br>I am married.<br>这两句话的语境背景还是稍有不同的：“I am married.”只是很客观地、平静地说明“我已经结婚了”这个事实；而“I have married.”则带有感情色彩，只适用于新婚不久的情况，比如“我”表现出兴奋的样子，见到朋友，满脸幸福地向朋友们宣布“我已经结婚了（I have married.）”。<br>这即是完成时所要表达的“对现在的影响”。这种新婚时的兴奋劲一过，以后再向别人作自我介绍时说“我已经结婚了”，就只能说成“I’m married.”。<br>比如萨达姆刚刚被美军抓住时， 新闻报道就可以用现在完成时态说：<br>Saddam has been captured. 意思相当于“Saddam is captive.”。<br>肯尼迪刚刚被暗杀后，就可以说：<br>Kennedy has been assassinated. 意思相当于“Kennedy is dead.”。<br>但是，随着时间的改变，语境也就变了，“萨达姆被抓”“肯尼迪被杀”离现在都比较久远了，因此，现在就不便说“Saddam has been captured.”和“Kennedy has been assassinated.”，而只能用一般过去时并加上具体的过去时间状语说成“Saddam was captured on 14 Dec. 2003.”和“Kennedy was assassinated on 22 Nov. 1963.”。</p>
<h4 id="“动作表达”的完成时态与“状态表达”的完成时态"><a href="#“动作表达”的完成时态与“状态表达”的完成时态" class="headerlink" title="“动作表达”的完成时态与“状态表达”的完成时态"></a>“动作表达”的完成时态与“状态表达”的完成时态</h4><p>在英语中，“动作表达”的完成时态强调最近发生的事件，而“状态表达”的完成时态强调“较远的过去”经历。<br>His father has died.<br>表示“他爸爸已经死了”，因为has died是“动作表达”，此时通常要理解成最近的事件。而<br>His father has been dead. *<br>这是“状态表达”，强调过去的经历，所以表示“他爸爸曾经死过 （但现在又活过来了）”，显然不通，因此被认为是错句。<br>be married是“状态表达”，所以它的现在完成时态一般表示“曾经的经历”，因此：<br>I have been married. 表示“我曾经结过婚”。<br>但是， 对于不能明确区分是动作还是状态的谓语，则会产生歧义。比如：<br>He has been fired.<br>因为be fired既可以是“动作表达”也可以作为“状态表达”，既可以理解成最近一次动作——“他被开除了”，也可以理解成曾经的经历——“他曾经被开除过”。<br>如果句子的谓语既可以作为动作，也可以作为状态，此时英文就有歧义，区分要靠语境。</p>
<h3 id="完成时态用于最高级句型"><a href="#完成时态用于最高级句型" class="headerlink" title="完成时态用于最高级句型"></a>完成时态用于最高级句型</h3><p>英文常常把现在完成时态用于这样的结构中：<br>“最高级+名词+that从句+现在完成时谓语”<br>This is the most interesting novel that I’ve ever read. 这是我看过的 最有趣的小说。<br>This is the hardest job that I’ve ever done. 这是我做过的最难的工作。</p>
<p>在这个句型结构中，除了用最高级外，还可以用序数词（如 second）来修饰名词。此时，从句的谓语同样要用现在完成时态。<br>This is the first time that I’ve come to Beijing. 这是我第一次来北京。<br>This is the third time that I’ve come to Paris. 这是我第三次来巴黎。</p>
<p><em><strong>在上述句型中，主句的谓语若是一般过去时，比如was（如It was the second&#x2F;best…），that后面的句子的谓语要用过去完成时态。</strong></em>例如：<br>That was the tenth cup of coffee that I had drunk that night. 那是我那天晚上喝的第10杯咖啡。</p>
<h3 id="时间连词since的特殊用法"><a href="#时间连词since的特殊用法" class="headerlink" title="时间连词since的特殊用法"></a>时间连词since的特殊用法</h3><p>I have worked in this company since I left school. 自从毕业离校以来，我就一直在这家公司工作。<br>这个例句中的since作为时间连词，意思是“自从……以来”。与它有关的主句和从句的时态搭配关系是：since后面所接从句的谓语要用一般过去时态，与其搭配的主句谓语则用现在完成时态。<br>It has been three years since I worked in this company.<br>这个句子我们很容易错误地理解为：<br>我在这家公司工作已经有三年了。 *<br>也就是将这句话完全等同于： I have worked in this company for three years now.<br>其实，这句英文真正要表达的意思是：<br>It has been three years since I last worked here in this company. I have NOT worked in this company during the past three years.<br>这句话是要强调“我最后一次在这家公司工作是在三年前”，换句话说，“我过去三年间都没有在这家公司工作”，即“我离开这家公司已经有三年了”。<br>通过比较上述两个since引导的从句的谓语动词left和worked，会发现，left是典型的“短暂动词”，而worked则是“延续动词”。问题就出在动词动作的延续性上，因为since后面接延续性或短暂性动词，用于不同时态，所表达的意义是有区别的。</p>
<h4 id="since-短暂动词"><a href="#since-短暂动词" class="headerlink" title="since+短暂动词"></a>since+短暂动词</h4><p>主句用现在完成时，since后面的从句用一般过去时。<br>I have worked in this company since I have left school.<br>自从毕业离校以来，我就一直在这家公司工作。<br>It has been three years since I have came to China.<br>我来中国已经有三年了。<br>以上这两个例句里的since引导的从句的谓语动词left和came都是典型的短暂动词，而且这些动作都是在过去发生的，所以自然要用一般过去时态。实际上，这里的谓语动词也可以采用现在完成时态，句子的意思不变。比如上面这两个句子也可以这样说：<br>I have worked in this company since I have left school.<br>It has been three years since I have come to China.<br>综上所述，since后面接短暂动词时，用一般过去时态或现在完成时态均可，而且意思一样，都表示从句动作“结束”以来，主句活动在持续。翻译成中文时，句子的意思就按英文字面去理解。比如leave是短暂动词，不论用于一般过去时态（left）还是用于现在完成时态（have left），都表示leave的动作结束后，主句活动work才开始并且一直在持续（即离开学校后就一直在这家公司工作）。</p>
<h4 id="since-延续动词"><a href="#since-延续动词" class="headerlink" title="since+延续动词"></a>since+延续动词</h4><p>当since接延续动词时，用一般过去时态或现在完成时态均可，但意思不一样。若用一般过去时态，则表示从句动作“结束”以来，主句活动在持续；若用现在完成时态，则表示从句动作“开始”以来，主句活动在持续。<br>1） It’s been three years since I worked in this company.<br>2） It’s been three years since I have worked in this company.<br>在例句1）中，worked是延续动词用于一般过去时态，主句时间则是从work这个活动“结束”后开始算起到现在有三年了。<br>在例句2）中，have worked是延续动词用于现在完成时态，主句时间则是从work这个活动“开始”以来算起到现在有三年了。<br>1）我不在这家公司工作有三年了。<br>2）我在这家公司工作有三年了。</p>
<p>It’s two years since I was in this university.<br>这里表示延续状态的动词be用了过去式was，应该是表示从was in this university的状态结束后开始计算时间，所以此句应翻译为：<br>我大学毕业已经有两年了。 而不能按照字面理解为：我上大学已经有两年了。*<br>“我上大学已经有两年了”应该说成“It’s two years since I have been in this university.”。<br>注意：since引导的主句如果单纯表示时间，可以说“It is或has been+时间段+since…”，所以这句话也可以说成“It’s been two years since I have been in this university.”。</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之进行时态（过去进行时）</title>
    <url>/2020/06/07/English%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%9B%E8%A1%8C%E6%97%B6%E6%80%81-%E8%BF%87%E5%8E%BB%E8%BF%9B%E8%A1%8C%E6%97%B6/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记摘选自张满胜老师的《英语语法新思维初级教程第2版》，以及其他网上知识点收集，只是我自己的个人复习笔记，禁止转载，如有侵权，请联系我删除。</p>
</blockquote>
<h2 id="常见用法：用来设置故事的背景"><a href="#常见用法：用来设置故事的背景" class="headerlink" title="常见用法：用来设置故事的背景"></a>常见用法：用来设置故事的背景</h2><p><em><strong>在讲故事时，我们往往会用到过去进行时态（the past continuous tense） was&#x2F;were doing来设置故事发生的过去背景（We often use the past continuous tense to “set the scene” in stories.）这是因为进行时态往往表示一个持续的活动场景，所以用它来铺垫故事的背景，往往会给读者一种身临其境的感觉。</strong></em></p>
<p>It was getting darker. The rain was beating on the windows. The wind was rising. A wood fire was burning on the hearth, and a cat was sleeping in front of it. A girl was playing the piano and was singing softly to herself. Suddenly, there was a knock on the door…<br>上文中就是用了一系列过去进行时（was getting, was beating, was rising, was burning, was sleeping, was playing和 was singing）来进行故事背景的铺垫——屋外是风雨交加的恶劣天气， 而屋内是温馨、舒适和祥和的气氛，这两者形成了鲜明的对比. 然后“传来了敲门声”——这一切都烘托出了一种略带恐怖的氛围。</p>
<p>James Bond was driving through town. It was raining. The wind was blowing hard. Nobody was walking in the streets. Suddenly, Bond saw the killer in a telephone box…<br>上面这种通过描写一系列过去进行的动作来渲染故事背景的过去进行时用法，多见于文学作品中。在日常生活的叙事中，我们更多的是把“过去进行时”和“一般过去时”配合使用（past continuous tense+simple past tense）。此时，过去进行时通常表示一个历时较长的体现“背景”的动作或状态；而一般过去时则表示在此“背景”下发生的一个短暂的动作或状态。简言之，长动作用过去进行时，短动作用一般过去时，以此表示在过去进行时的动作的持续期间，发生了另一个短暂动作。这两个动作之间用when或while连接。</p>
<p>比如我们这样告诉别人自己曾经的“恐怖”经历：<br>I was walking along the street late last night when suddenly I heard footsteps behind me. Somebody was following me. I was frightened and I started to run.<br>这句中的walk表示“一直在走”，显然是长动作，所以要用过去进行时；hear表示“听到了”，显然是短动作，所以用了一般过去时。这里表示在was walking这个持续动作的背景下发生了短暂动作heard。</p>
<h3 id="动作长短的相对性及其与时态的关系"><a href="#动作长短的相对性及其与时态的关系" class="headerlink" title="动作长短的相对性及其与时态的关系"></a>动作长短的相对性及其与时态的关系</h3><p>I was watching TV when the telephone rang.<br>我当时正在看电视， 突然电话铃响了。 在这个句子里，“看电视（watching TV）”可能持续几个小时， 而“电话铃响”可能就持续几秒钟（a few seconds）。但在下面这个句子里：<br>I was walking past the car when it exploded.<br>汽车爆炸时我正好刚走过。在这里，walking past the car可能只持续了几秒钟（a few seconds），而exploded则更短，可能也就几毫秒（a few milliseconds）。<br><em><strong>总之，动作的长短是指具体句子里的两个动作的相对长短。相对短的动作用一般过去时，相对长的动作用过去进行时</strong></em>。若时态用错，句意可能就要发生改变。比如：<br>I was cooking dinner last night when I cut my finger. 我昨晚做晚饭的时候，不小心把手指给切了。<br>I was telephoning Harry when she arrived. 她到的时候，我正在给哈里打电话。<br>若是违反了这一英语思维规律，比如在下面的句子中，我们把短动作cut也用过去进行时，说成：<br>…when I was cutting my finger.<br>那意思就变成“当我在砍手指的时候……”，此时cutting就变成一个长动作了。相信一个正常人是不会说出这样的话的，更不会做出cutting fingers这样的行为。<br>再比如，我们把长动作telephone改用一般过去时，请比较：<br>1） I was telephoning Harry when she arrived.<br>2） I telephoned Harry when she arrived.<br>在例句1）中，telephone是一个延续动作，arrive是短暂 动作。用进行时telephoning是表明在“我”打电话的过程中，她到了，即先telephone，后arrive。在例句2）中，telephone和arrive都用一般过去时，都变成了短暂动作。此时，是表明“我”打电话是发生在她来了之后，即先arrive，后telephone。<br>1） 她到的时候我正在给哈里打电话。<br>2） 她到了之后，我再给哈里打电话。</p>
<h3 id="when和while的区别"><a href="#when和while的区别" class="headerlink" title="when和while的区别"></a>when和while的区别</h3><p><em><strong>我们还看到，过去进行时与一般过去时的这种搭配使用主要由when或while连接，但两者有以下区别：<br>when的后面接短动作，用一般过去时（when+short action, simple past tense），或者接长动作，用过去进行时（when+long action, past continuous tense）； while的后面只能接长动作，用过去进行时（while+long action, past continuous tense）。</strong></em><br>I was walking past the car when it exploded.<br>The car exploded when I was walking past it.<br>The car exploded while I was walking past it.<br>不能说： I was walking past the car while it exploded. *<br>因为这里的exploded是一个短暂动词，不能和while搭配。</p>
<h2 id="少见用法：两个过去同时在持续的动作"><a href="#少见用法：两个过去同时在持续的动作" class="headerlink" title="少见用法：两个过去同时在持续的动作"></a>少见用法：两个过去同时在持续的动作</h2><p>如果句中有两个相对长短的动作，那么长动作用过去进行时，短动作用一般过去时。但是，若句中的两个动作都是较长的动作，则两个动作都用过去进行时，表示两个过去同时在持续的动作。<br>While I was studying in my dorm, my roommates were talking loudly with their friends. 我在宿舍里学习的时候，我的室友在大声地和他们的朋友们说话。<br>While I was studying last night, my wife was watchingTV. 我昨晚学习的时候，我的妻子在看电视。</p>
<h2 id="典型用法：描述一件过去特定时刻正在发生的事情"><a href="#典型用法：描述一件过去特定时刻正在发生的事情" class="headerlink" title="典型用法：描述一件过去特定时刻正在发生的事情"></a>典型用法：描述一件过去特定时刻正在发生的事情</h2><p>过去进行时还可以用来描述一件在过去的特定时刻正在发生的事情，这是各种进行时的典型用法。<br>I was discussing my thesis with my director at this time last night. （特定时刻）</p>
<p>A: What were you doing at 10 o’clock last night?<br>B: I was having dinner with my friends.</p>
<h2 id="口语用法：表示委婉的请求或建议"><a href="#口语用法：表示委婉的请求或建议" class="headerlink" title="口语用法：表示委婉的请求或建议"></a>口语用法：表示委婉的请求或建议</h2><p>在口语表达中，我们还常常用过去进行时来表示委婉的请求或建议，这时并不表示过去时间的动作。这尤其适用于表示态度的动词，如 wonder, hope和think等，这些动词用过去进行时（was wondering）或现在进行时（is wondering），均表示现在的一种愿望或态度，给人一种探询式的、犹豫不决的印象，因而显得很礼貌。</p>
<p>I was wondering if you’d like to lend me your car.<br>I was wondering if you could lend me your car.<br>I was hoping that you’d like to lend me your car.<br>I was thinking that you’d like to lend me your car.<br>我希望你能把车借给我。<br>I hope to borrow your car.<br>I wonder if you can lend me your car.<br>则由于比较直截了当地表达了自己的态度，因而显得欠礼貌。</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之进行时态（思维特征)</title>
    <url>/2020/06/07/English%E7%B3%BB%E5%88%97%E4%B9%8B%E8%BF%9B%E8%A1%8C%E6%97%B6%E6%80%81-%E6%80%9D%E7%BB%B4%E7%89%B9%E5%BE%81/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记摘选自张满胜老师的《英语语法新思维初级教程第2版》，以及其他网上知识点收集，只是我自己的个人复习笔记，禁止转载，如有侵权，请联系我删除。</p>
</blockquote>
<h2 id="进行时态的核心含义"><a href="#进行时态的核心含义" class="headerlink" title="进行时态的核心含义"></a>进行时态的核心含义</h2><ol>
<li>事件具有持续性（ongoing）：进行时态首先表示的是一个事件或活动在某个特定的时间正在持续；</li>
<li>事件具有短暂性（temporary）：即表明事件的持续时间是有限的。如果是无限的，即表达一个长期的、恒久的含义，那么就该用一般现在时态了；</li>
<li>事件未完成（incomplete）：进行体既然强调动作的持续性，那么就表明这个动作还没有结束。</li>
</ol>
<h2 id="进行体动作与一般动作对比"><a href="#进行体动作与一般动作对比" class="headerlink" title="进行体动作与一般动作对比"></a>进行体动作与一般动作对比</h2><h3 id="活动与状态的对比"><a href="#活动与状态的对比" class="headerlink" title="活动与状态的对比"></a>活动与状态的对比</h3><p>进行体表示具体的活动，而一般时态往往与状态有关。<br>1） I am thinking about the answer.<br>2） I think the answer is 144.<br>在例句1）中，进行时态表明think是用于“动态”的意义，相当于consider，此时表示思考活动。在例句2）中，一般时态表明think 是用于“静态”的意义，相当于说have an opinion，此时表示思维状态。</p>
<h3 id="发生在说话那一刻的一个动作与一个习惯的对比"><a href="#发生在说话那一刻的一个动作与一个习惯的对比" class="headerlink" title="发生在说话那一刻的一个动作与一个习惯的对比"></a>发生在说话那一刻的一个动作与一个习惯的对比</h3><p>进行体表示发生在说话时刻的一个动作，而一般时态则表示一个习惯。<br>1） Why are you wearing glasses?<br>2） Why do you wear glasses?<br>在例句1）中，进行时态表示一个当下的具体动作， 即“在说话的时刻，对方正戴着眼镜”。在例句2）中，一般现在时态表示一个习惯动作，即使在说话的时刻，对方没有戴眼镜，也可以说这句话。</p>
<h3 id="具体事件与概括描述的对比"><a href="#具体事件与概括描述的对比" class="headerlink" title="具体事件与概括描述的对比"></a>具体事件与概括描述的对比</h3><p>进行体总是十分具体的，而一般动作可用于概括的叙述。<br>1） Weeds are growing like wildfire（in my garden）.<br>2） Weeds grow like wildfire.<br>在例句1）中，进行时态往往会表达目前所见到的一个具体场景，比如这里说我们家花园里杂草的长势情况。在例句2）中，一般时态通常表示一个一般情形，比如这里是说，一般情况下杂草长得很快，是泛泛地在谈杂草的生长特点，而并没有具体所指。</p>
<h3 id="暂时的事件与长期的状态对比"><a href="#暂时的事件与长期的状态对比" class="headerlink" title="暂时的事件与长期的状态对比"></a>暂时的事件与长期的状态对比</h3><p>进行体表示暂时的事件，而一般时态则往往表示一个长期的状态。<br>1） Joan is singing well.<br>2） Joan sings well.<br>在例句1）中，进行时态表示，在某一特定的场合，也就是在说话的时刻，琼唱歌发挥得很好，或者指她在某一特定的演出中的唱歌表演。说明的是一次具体的演唱活动。在例句2）中，一般现在时态则是强调琼有一副好嗓子，是一种比较永久的属性，相当于一个状态的表达，而不是指具体的演唱活动。</p>
<h3 id="未完成与完成对比"><a href="#未完成与完成对比" class="headerlink" title="未完成与完成对比"></a>未完成与完成对比</h3><p>过去进行时表示动作未完成，一般过去时表示动作已完成。<br>1） He was drowning in the lake, so the lifeguard raced into the water.<br>2） He drowned in the lake.<br>在例句1）中，进行时态表示drown的动作尚未完成，即他当时正在溺水，而并没有死，还在挣扎。所以，才有了下文说the lifeguard raced into the water。在例句2）中，一般过去时态表示一个完成的过去动作，即他溺水且不再挣扎了——溺水身亡了。<br>1） 他当时在湖里溺水了，于是一名救生员立即跳进水里（把他救了起来）。<br>2） 他在湖里淹死了。</p>
<h3 id="事件可变化与不变化的对比"><a href="#事件可变化与不变化的对比" class="headerlink" title="事件可变化与不变化的对比"></a>事件可变化与不变化的对比</h3><p>过去进行时表示事件已经开始进行，并随着时间的推移在继续，因此它允许有变化；而一般过去时把事件看作一个整体，没有变化的余地。<br>1） He was calling Mary when I came in.<br>2） He called Mary when I came in.<br>在例句1）中，“打电话”在先，“我进来”在后。过去进行时表示“打电话”先于“我进来”，并且在“我”进来之后，他可能还在继续打电话，也可能立即结束打电话。即“打电话”这一事件可以有变化。在例句2）中，“我进来”在先，“打电话”在后。一般过去时把“打电话”这一事件作为一个整体，只是说明“他给玛丽打了个电话”，而不能说明这个事件是继续进行的还是立即停止了。</p>
<h2 id="不适于用进行体的情形"><a href="#不适于用进行体的情形" class="headerlink" title="不适于用进行体的情形"></a>不适于用进行体的情形</h2><p>进行时态包含这样两个意义：一是事件的持续性（ongoing），二是事件的短暂性，即有限的持续性。进行时强调的是动作在一段时间里的持续性，因此这一活动必须是连续不断的。如果把动作分割开了看，则违背了进行时态的核心意义——持续性，所以不能用进行时态。我们在下列两种情况下就会把动作分割开：一是谈到在一段时间内做了不同的事情，二是说明某件事发生的次数。因此，这两种情形都不能使用各种进行时态。</p>
<h3 id="不用进行时谈不能在同一时间内同时做的不同事情"><a href="#不用进行时谈不能在同一时间内同时做的不同事情" class="headerlink" title="不用进行时谈不能在同一时间内同时做的不同事情"></a>不用进行时谈不能在同一时间内同时做的不同事情</h3><p>下列两件不同的事情不能用于进行时态：<br>I am painting the room and cooking dinner. *<br>同时在做两件不同的事情，这违背了进行时态的持续性 的特点。而要说：<br>I am painting the room and after that I will cook dinner.<br>我正在粉刷房间，之后我就去做饭。<br>即使是几件同样的事情在同时做，也不能用进行时态。比如我们不能说：<br>Tom was washing three cars. *<br>这个句子给人的感觉是汤姆有三只手，他是用三只手同时在擦洗三辆车，但这显然不符合通常的情况。所以，这个句子听起来很怪，而被认为不正确。 我们应该直接说：<br>Tom was washing cars. 汤姆在洗车。<br>如果要说明具体有几辆车，则要用一般过去时说成：<br>Tom washed three cars. 汤姆洗了三辆车。<br>当然，如果是两个可以同时进行的动作，则两个都可用进行时态表示：<br>She was knitting and listening to the radio.<br>这里的knit和listen虽然是两件不同的事情，但二者可以同时进行，所以可以用于进行时态。<br>她一边编织一边听收音机。</p>
<h3 id="不用进行时谈活动的次数"><a href="#不用进行时谈活动的次数" class="headerlink" title="不用进行时谈活动的次数"></a>不用进行时谈活动的次数</h3><p>当我们说到做一件事情的次数，此时也是把动作割裂开来了，因而与进行时态的“持续性”的特点发生了语义冲突，所以不能用进行时态表达。<br>I was ringing the bell six times. *<br>而可以直接用一般过去时说：<br>I rang the bell six times. 我按了六次铃。</p>
<h2 id="进行时态与动词体"><a href="#进行时态与动词体" class="headerlink" title="进行时态与动词体"></a>进行时态与动词体</h2><blockquote>
<p>根据动词词义的特点，我们可以把动词分为静态动词（stative verb）和动态动词（dynamic verb）。动态动词又可以进一步分为短暂动词（punctual verb）和延续动词（durative verb）。因此，从词义的角度，我们可以把动词分为静态动词、短暂动词和延续动词。</p>
</blockquote>
<h3 id="静态动词"><a href="#静态动词" class="headerlink" title="静态动词"></a>静态动词</h3><p>静态动词与变化无关，它们描述的是一个稳定的状况（situations that are relatively constant over time），这种状况会或长或短地持续下去。一般来说，静态动词可包括下列几类：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/TiW5Nc.png"><br>We understand the questions. 我们理解这些问题。<br>And we know the answers. 而且我们知道答案。<br>We like our English class. 我们喜欢英语课。</p>
<h3 id="短暂动词"><a href="#短暂动词" class="headerlink" title="短暂动词"></a>短暂动词</h3><p>短暂动词往往表示一个不能持续的或持续时间极短的动作（acts which do not extend through time），往往与“时间点（point in time）”有联系。比如kick, hit和smash等。<br>He kicked the ball. 他踢了球。<br>It hit the window. 它（球）打中了窗户。<br>And it smashed the glass. 它（球）把玻璃打碎了。</p>
<h3 id="延续动词"><a href="#延续动词" class="headerlink" title="延续动词"></a>延续动词</h3><p>与短暂动词相对，延续动词表示一个可以持续的活动或过程 （activities or processes），用来描述一个可以延续的场景（describe situations that typically extend through time）。比如run, swim, walk, work, write, become, change, grow和learn等等。</p>
<h3 id="延续状态、短暂动作与延续动作"><a href="#延续状态、短暂动作与延续动作" class="headerlink" title="延续状态、短暂动作与延续动作"></a>延续状态、短暂动作与延续动作</h3><p>从最一般的意义上来说，短暂动词往往与一个场景的改变有联系， 而延续动词则是与一个场景的维持不变相关。借用哲学术语来说，延续动词相当于一个“量变”的过程，是一个状态的维持；而短暂动词则相当于发生了“质变”，是从一种状态变到另一种状态。<br>我们每天的生活中都要经历延续动作与短暂动作的转换。比如我们每天要“上床睡觉”：<br>go to bed 就是一个短暂动作，表示一个状态的改变——人从床下到床上了。 然后我们就“睡着”了：<br>fall asleep 这同样是一个短暂动作，表示一个状态的改变——人从醒着转为睡着了。然后我们就“一直睡着”：<br>be asleep 这两个表达都是延续状态，是维持一直睡着的状态。然后我们早晨“醒来”：<br>学习英语的时态，我们就必须对英语的状态与动作以及短暂动词与 延续动词等的区分要非常敏感（在完成进行时中，我们还需要进行更细致的动词体的区分），只有这样才可能正确地使用时态。</p>
<p>Up! Get up now！ 起来！起床了！<br>Get up, Cousin, we are going to the zoo. 起床了，表弟！我们今天要去动物园！<br>这两个例句中都用get up，就是因为都是表示起床这个“动作”的，而不是表示已经起来的“状态”。</p>
<p>如果要表示起床的“状态”，比如这时你说“我起来了，我已经起床了”，这就是一个状态表达。我们要说成：<br>I’m up. 而不能说成： I get up.*<br>在英文里说“I get up.”*这样的短句是没有意思的，因为我们无法找到一个合适的语境来使用这个句子。没有合适的使用语境的原因就在于，get up表示的是一个短暂动作，只能发生在某一时刻，而不能用于表示延续的状态。但是be up表示状态，就能很好地表示我“起床了”这样 的延续状态。除非get up加上时间状语，这样来表示一个习惯动作。比如说：<br>I often get up very late on Sundays. 我周日常常晚起。</p>
<p>再比如，在汉语里我们常说“我来找某某人”，这里的“我来”该怎么 说呢？此时，同样要注意状态与动作的区分。如果用状态表达，可以说成：<br>I am here to visit Mr. Zhang Mansheng. 我来找张满胜老师。<br>这里的am here就表示“我人现在在这里”的一个状态，所以用的是一般现在时态。但是如果你用了动词come，就不能用一般现在时态说成：<br>I come here to visit Mr. Zhang Mansheng. *<br>因为你“来（come）”这个短暂动作在你说话时已经结束了，所以我们要改用其他时态来表达。我们可以用一般过去时，说成：<br>I came here to visit Mr. Zhang Mansheng. 或者是现在完成时，说成：<br>I’ve come here to visit Mr. Zhang Mansheng.</p>
<p>这时，前台接待人员一般会问你：“你和他约好的吗？”这句话该如何表达呢？<em><strong>我们同样要考虑是用“状态”还是用“动作”，因为这关系到不同时态的使用。</strong></em><br>用“状态”表达，我们要用一般现在时态，说成：<br>Do you have an appointment with him?<br>这里用的是静态动词have。若是用“动作”表达，则要用现在完成时态，说成：<br>Have you made an appointment with him?<br>这里我们用的是动态动词make。</p>
<h3 id="延续动词与进行时态"><a href="#延续动词与进行时态" class="headerlink" title="延续动词与进行时态"></a>延续动词与进行时态</h3><p>延续动词与进行体连用最自然，因为进行体的核心意义是表示“动作有限的延续性”，延续动词也是表示动作的延续性，因此二者在语义上非常吻合。</p>
<h3 id="短暂动词与进行时态"><a href="#短暂动词与进行时态" class="headerlink" title="短暂动词与进行时态"></a>短暂动词与进行时态</h3><p>虽然短暂动词不具有延续性，或者说其延续性较差，这似乎与进行体的核心意义“动作有限的延续性”相矛盾。但是短暂动词可以与进行体连用，不过意思会有所改变。进行体赋予短暂动词“反复 （repetition）”的意义。具体来说，短暂动词用于进行时态，往往表示的是一系列重复的动作，而不是一个单一动作。<br>He is nodding his head in agreement. 他不断地点头表示同意。<br>Henry is kicking the soccer ball around the backyard. 亨利正在后院里踢足球。<br>Someone is coughing. 有人在咳嗽。<br>谓语动词nod, kick和cough都是典型的短暂动词，这里用于进行时态表示的是重复动作，即不断地“点头”、“踢球”和“咳嗽”。</p>
<p>用于进行体的短暂动词也可以表示一个事件的开始。比如：<br>Joe is realizing his mistakes. 乔开始意识到自己的错误。</p>
<p>或者有其他特殊的含义。比如：<br>I am starting the car.<br>这里的短暂动词start用于进行体，我们要朝着动作“延续”性的方向来解释——这句话给人的感觉是这辆汽车很难发动，说话人正试图努力地把它发动起来。<br>我正在发动这辆车。</p>
<h3 id="静态动词与进行时态"><a href="#静态动词与进行时态" class="headerlink" title="静态动词与进行时态"></a>静态动词与进行时态</h3><p>一般来说，静态动词不能用于进行体，原因在于：进行体在语法方面表示一个动作在有限时间内的持续，而静态动词从词汇方面表达的是一种稳定的状态，二者之间存在着基本的语义冲突。<br>比如我们不能说： I am knowing the answer. *<br>因为这里的know就是一个稳定的状态，不是表示一个动作在有限时间内的持续。<br>但是，常见的静态动词在用于进行时态后往往具有特殊的含义。</p>
<h4 id="施动与受动"><a href="#施动与受动" class="headerlink" title="施动与受动"></a>施动与受动</h4><p>我们可以从句子的主语与谓语动作之间的关系，来判断某个动词用于某一特定意义时是否可以用进行时态。谓语动作是主语有意识地发出的，即句子的主语是施动者，此时谓语一般都可以用进行时态。反之，如果主语并非有意识地发出谓语动作，而只是被动的接受者即受动者，此时谓语一般都不能用进行时态。因为进行时态主要只用于有意识的动作。因此在英文中，一些表示无意识的、自发的动作（spontaneous action）的动词，如人们的心理活动（know, understand和believe等）、感情状态（like, love和hate等）以及其他静态动词，均不能用于进行时态。<br>首先，我们来看taste, smell, feel, look和appear这些感官动词。当它们用作系动词时，句子的主语都是受动者，所以不能用进行时态；当它们用作非系动词时，此时句子的主语通常是施动者，所以一般可以用于进行时态。请比较：<br>1） The chef is tasting the soup.<br>2） And it tastes good.</p>
<p>在例句1）中，taste不是系动词，而是一个及物动词，表示“品尝”的动作。此时句子的主语chef是施动者，即有意识地发出taste 这个动作的人，所以可以用于进行时态。在例句2）中，taste是系动词，表示“尝起来”，是一个状态。此时句子的主语it（指the soup）并非施动者，即it并没有发出taste这个动作（只有人才可以taste〈品尝〉），而是受动者，所以这里的taste不能用进行时态，即我们不能说“It is tasting good.”*<br>1） 厨师正在尝这汤的味道。<br>2） 它味道不错。<br>值得注意的是，区分施动者还是受动者并不是根据主语是人还是物，并不是说“人”作句子的主语就一定是施动者，关键还是要看主语是否是“有意识地”发出某个动作。比如：<br>I taste ginger in these spring rolls.（在这些春卷里，我尝到了生姜的味道。）</p>
<blockquote>
<p>这里的主语是I，即人称主语，但I并不是施动者，因为这 里的谓语taste并不是I“有意识”地发出的。怎么知道不是“有意识”的呢？ 这要看taste的意思。这里的taste并不是表示“品尝”这个动作，而是表 示“尝到……的味道”这样的状态。从整个句子的意思来看，“我”并不是 有意识地“品尝”ginger（生姜），而是无意识地“尝到了”生姜的味道。 所以，这里的主语I是一个受动者，因此该句不能用进行时态说成“I am tasting ginger in these spring rolls.”*</p>
</blockquote>
<p>其实我们 区分了taste这个动词三个不同方面的含义。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/XCGH4k.png"><br>在英语中，与“味觉”有关的这三方面含义（即系动词、表示过程的 及物动词和表示结果的及物动词）都集中在taste这个词身上了，相当于 taste“身兼三职”。 在英文中，表示“嗅觉”的三方面含义也是集中在一个词smell身上。<br>1） He is smelling the chicken.<br>2） And it smells nice.<br>3） I smell something burning in the kitchen.<br>在例句1）中，smell不是系动词，而是一个及物动词，表示“闻”的动作。此时句子的主语he是施动者，即有意识地发出smell这个动作，所以可以用于进行时态。在例句2）中，smell是系动词，表示“闻 起来”，是一个状态。此时句子的主语it（指the chicken）并非施动者， 即it并没有发出smell这个动作，而是受动者，所以这里的smell不能用进行时态，即我们不能说“It is smelling nice.”<em>在例句3）中，smell不是系动词，而是一个及物动词，表示“闻到，嗅出”的结果，是一个状态。此时句子的主语I不是施动者，即并非有意识地发出smell这个动作，而是被动地接受了一个结果，所以不能用于进行时态，即我们不能说“I am smelling something burning in the kitchen.”</em></p>
<p>视觉、听觉上也是如此：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/xwrVVY.png"><br>1） I am looking at the picture.<br>2） It looks beautiful.<br>3） I see the picture.</p>
<p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/mvvUbP.png"><br>1） I am listening to the music.<br>2） It sounds nice.<br>3） I hear the music.</p>
<hr>
<p>综上所述，表示人的五官感觉的动词可能有三方面含义： </p>
<ul>
<li>一是系动词； </li>
<li>二是表示结果，此时表示的是一个状态，而不是主语有意识地发出的动作；</li>
<li>三是表示动作的过程，此时是主语有意识的动作。</li>
</ul>
<p>与“味觉”有关的这三方面含义集中在taste一词身上，相当于taste“身兼三职”；<br>与“嗅觉”有关的这三方面含义集中在smell一词身上，相当于smell“身兼三职”；<br>对于“视觉”，用look作系动词和表示动作的过程，用see表示结果；<br>对于“听觉”，用sound作系动词，用hear表示结果，用listen表示动作 的过程；</p>
<p>I am hearing Prof. Smith’s lectures.<br>这里的hear不是“听见”的意思，即不表示结果，否则不能用于进行时态；而是表示主语I有意识地去“参加”某个活动，即主语是施动者，所以可以用于进行时态。该句中的hearing相当于attending，整个句子的意思表示“我目前正在听史密斯教授的课”。这里的进行时态表示“重复性”和“临时性”，即“听课”这一活动可能持续一个学期或一两个月。这里就是hear用于进行时态产生了特殊含义的例证。</p>
<p>1） I am seeing my doctor tomorrow.<br>2） I see what you mean.</p>
<p>在例句1）中，see不是“看见”的意思，即不表示结果，否则不能用于进行时态；而是表示主语I有意识地去“约见”，即主语是施动者，所以可以用于进行时态。这里就是see用于进行时态产生了特殊含义的例证。在例句2）中，see不是“看见”的意思，而是表示“理解，明白”，相当于understand，表示的是一种状态，而非主语I有意识的动作， 所以不能用于进行时态，即不能说“I am seeing what you mean.”*</p>
<h3 id="延续状态（be-adj-）与进行时态"><a href="#延续状态（be-adj-）与进行时态" class="headerlink" title="延续状态（be+adj.）与进行时态"></a>延续状态（be+adj.）与进行时态</h3><p>英语中的延续状态一般都是由be动词接一个形容词或名词构成的。 我们在这里主要讨论形容词的情形。<br>正如动词可以有静态与动态之分一样，英文中的形容词也可分为静态形容词（stative adjective）和动态形容词（dynamic adjective）。 静态形容词：是指某一事物或现象所具有的长时期内难以自然改变的性质特征或状态。英文中的形容词主要是这样的静态形容词，如： tall, red, long, big, beautiful和important等。 动态形容词：是指某一事物或现象所具有的随时可以被改变的性质特征或状态。这些形容词主要是用来描写人的性格特征的，最常用的有：brave, calm, careful, careless, clever, cruel, foolish, friendly, funny, impatient, lazy, kind, naughty, nice, noisy, patient, polite, rude, shy, silly, stubborn和stupid等。<br>静态形容词不能用于进行时态。 动态形容词可以用于进行时态，来描述主语的一个暂时的性质状态或特征，而非其本身所固有的或持久的特征。此时主语是施动者，所以有时表示主语“有意如此”的含义。例如：<br>1） He’s being rude.<br>2） He’s rude.<br>在例句1）中，静态动词be能用于进行时态，即is being， 是因为其后的形容词rude是一个动态形容词，being rude就像一个进行的动作一样，表示主语he在说话时刻的暂时的表现。也许他一般情况下并不“粗鲁（rude）”，只是此时此刻表现得很“粗鲁”，即“粗鲁”并不是他一贯的性格特点。在例句2）中，一般时态is rude则表示主语he惯有的性格特点是“粗鲁”，而不是他说话时刻的行为表现。也许在说话的时刻，他表现得很有礼貌，但我们依然可以说“He is rude.”。而这时他装得很有礼貌的样子，我们就可以说“He is being polite.”。<br>1） 他现在的样子显得很粗鲁。<br>2） 他这人一向很粗鲁。</p>
<p>1） Fred is being silly.<br>2） Fred is silly.<br>在例句1）中，动态形容词silly用于进行时态，表示的是弗雷德在说话时刻的行为表现，意思是“弗雷德现在表现得傻里傻气的”，相当于说“Fred is acting in a silly manner.”。这里的主语Fred是一个施动者。在例句2）中，一般时态is silly则表示主语Fred惯有的性格特点是“傻里傻气的”，而不是说话时刻的行为表现。也许在说话的时刻，他表现得很精明（He may be behaving quite sensibly at the moment of speaking.）。我们依然可以说“Fred is silly.”。这里的主语Fred并不是一个施动者。<br>1） 弗雷德现在正犯傻。<br>2） 弗雷德一向很傻气。</p>
<p>动态形容词用于进行时态往往让表达显得非常生动，给人一个具体的、生动的场景。</p>
<p>The peddler is being rude. 那小贩变得粗鲁起来。<br>She is being careful at this moment. 此刻她正表现得小心翼翼。<br>She was being stupid. Actually she had already known the whole story.当时她在装傻，其实她早已知道了事情的经过。</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之完成进行时（过去完成进行时）</title>
    <url>/2020/07/26/English%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AE%8C%E6%88%90%E8%BF%9B%E8%A1%8C%E6%97%B6-%E8%BF%87%E5%8E%BB%E5%AE%8C%E6%88%90%E8%BF%9B%E8%A1%8C%E6%97%B6/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记摘选自张满胜老师的《英语语法新思维中级教程通悟语法第2版》，以及其他网上知识点收集，只是我自己的个人复习笔记，禁止转载，如有侵权，请联系我删除。</p>
</blockquote>
<p>1） Your eyes are red. You’ve been crying, haven’t you?<br>2） Her eyes were red. It was obvious she had been crying.<br>在例句1）中，由are可以知道，这里说话语境的时间是现在，所以后面用现在完成进行时have been crying来表达一个在“现在”说话时刻之前在延续的事件，即“现在刚刚”结束的事件，<br>在例句2）中，由were可以知道，这里说话语境的时间是过去，此时要表达一个在“过去”说话时刻之前在延续的事件，即“过去刚刚”结束的事件就要用过去完成进行时had been crying。<br>1）你的眼睛红红的，你刚才一直在哭吧?<br>2）她的眼睛当时红红的，很明显，她之前一直在哭。</p>
<h2 id="过去时刻在延续的事件"><a href="#过去时刻在延续的事件" class="headerlink" title="过去时刻在延续的事件"></a>过去时刻在延续的事件</h2><p>过去完成进行时表示开始于过去某个时刻之前的动作持续到过去这一时刻，并继续持续下去。<br>When I arrived in Inner Mongolia, it had been snowing for half a month.<br>这里的arrived确立了过去的坐标时间，然后谈论在此之前发生的一个延续活动“下雪”，所以用过去完成进行时had been snowing。<br>那次在我到内蒙古之前，雪已经下了整整半个月了。</p>
<p>图示如下：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/Ey7gQb.png"><br>类似于现在完成进行时，过去完成进行时的延续事件同样包括长期延续、近期延续、说话时刻在延续以及在说话时刻之前在延续的事件。</p>
<h3 id="过去的长期延续事件"><a href="#过去的长期延续事件" class="headerlink" title="过去的长期延续事件"></a>过去的长期延续事件</h3><p>The police had been looking for the murderer for two years before they caught him.<br>警察抓住这个杀人犯之前，已经找了他两年了。<br>I had been looking for jobs for nearly half a year before I finally got a position in this dot-com company.<br>我找工作找了将近半年，最后得到了一家网络公司的聘用。</p>
<h3 id="过去的近期延续事件"><a href="#过去的近期延续事件" class="headerlink" title="过去的近期延续事件"></a>过去的近期延续事件</h3><p>He looked so tired. I knew he had been studying for the final exams.<br>他当时看起来很累，我知道他一直在忙着准备期末考试。</p>
<h3 id="过去说话时刻在延续的事件"><a href="#过去说话时刻在延续的事件" class="headerlink" title="过去说话时刻在延续的事件"></a>过去说话时刻在延续的事件</h3><p>He told me he had been hunting for a room since noon but with no success.<br>他告诉我，他从中午开始就在找住处，但一直没找到。<br>The plane, which had been waiting on the runway for hours, finally got clearance for taking off.<br>飞机已经在跑道上等了几个小时了，终于获准起飞。</p>
<h3 id="过去刚刚在延续的事件"><a href="#过去刚刚在延续的事件" class="headerlink" title="过去刚刚在延续的事件"></a>过去刚刚在延续的事件</h3><p>Mary’s eyes were red. She had been crying.<br>当时玛丽的眼睛红红的，她刚刚哭过。<br>My face was hot and red because I had been lying in the sun.<br>当时我的脸又红又热，因为我刚刚一直在躺着晒太阳。</p>
<h2 id="在过去时刻重复发生的事件"><a href="#在过去时刻重复发生的事件" class="headerlink" title="在过去时刻重复发生的事件"></a>在过去时刻重复发生的事件</h2><p>I had been trying to get her on the phone. Finally she gave me a call.<br>我当时一直试着打电话找她，最后她给我回了个电话。同样，这里的重复动作不能说出具体的次数。例如不能这样说：<br>I had been trying five times to get her on the phone. Finally she gave me a call. *<br>要表示具体次数，须改为过去完成时：<br>I had tried five times to get her on the phone before she finally gave me a call.<br>我曾打了五次电话去找她，最后她终于给我回了电话。</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之完成时态（将来完成时）</title>
    <url>/2020/07/17/English%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AE%8C%E6%88%90%E6%97%B6%E6%80%81-%E5%B0%86%E6%9D%A5%E5%AE%8C%E6%88%90%E6%97%B6/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记摘选自张满胜老师的《英语语法新思维中级教程通悟语法第2版》，以及其他网上知识点收集，只是我自己的个人复习笔记，禁止转载，如有侵权，请联系我删除。</p>
</blockquote>
<h2 id="将来完成动作的开始时间"><a href="#将来完成动作的开始时间" class="headerlink" title="将来完成动作的开始时间"></a>将来完成动作的开始时间</h2><p>现在完成时是以“现在”作为“坐标时间”，来描述开始于现在之前（即过去）的动作持续到现在。过去完成时是以“过去”作为“坐标时间”，来描述开始于过去之前（即过去的过去）的动作持续到过去。同理，将来完成时是以“将来”作为“坐标时间”，来表示开始于将来之前（可能是过去、现在或将来）的动作持续到将来。但动作开始的时间并不重要，关键是说话人要站在将来的某一时间来谈某一动作的完成情况。</p>
<p>1）“我们”可能是昨天开始考试的，比如说成：<br>We started our exam yesterday and we will have taken five exams by next Friday.<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/wJ930T.png"><br>2）可能是今天开始考试的，比如说成：<br>We have started our exam today and we will have taken five exams by next Friday.<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/gg0Q8h.png"><br>3）也可能是明天才开始考试，比如说成：<br>We will start our exam tomorrow and we will have taken five exams by next Friday.<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/Tgzchk.png"><br>但具体是哪一天开始的并不重要，说话人强调的是他们一共有五门考试。</p>
<h2 id="将来完成时的三种思维用法"><a href="#将来完成时的三种思维用法" class="headerlink" title="将来完成时的三种思维用法"></a>将来完成时的三种思维用法</h2><h3 id="延续事件"><a href="#延续事件" class="headerlink" title="延续事件"></a>延续事件</h3><p>表示在将来某一时刻之前开始的动作，一直延续到该时刻，并可能继续延续下去。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/Tu9fSM.png"><br>(虚线表示这一动作可能开始于现在或过去；虚箭头表示这一动作可能继续延续下去。)</p>
<p>I will have taught English in New Oriental School for five years by the end of next month.<br>到下个月底之前，我在新东方学校教英语的时间将满五年。<br>I will have learned 8,000 words by the end of next year.<br>到明年年底之前，我将学会8,000个单词。</p>
<h3 id="重复事件"><a href="#重复事件" class="headerlink" title="重复事件"></a>重复事件</h3><p>表示在将来的某一时刻之前开始的动作，并在该时刻之前的一段时间内重复发生。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/nHuxiX.png"></p>
<p>By five o’clock this afternoon the spaceship will have traveled eleven times round the world.<br>到今天下午五点钟之前，这艘宇宙飞船就将绕地球飞行11次了。</p>
<h3 id="单一事件"><a href="#单一事件" class="headerlink" title="单一事件"></a>单一事件</h3><p>表示在将来的某一时刻之前开始的动作，到该时刻之前已经完成。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/5zQBX3.png"><br>We will have finished our exam by the end of next week.<br>到下个周末为止，我们将完成考试。<br>By the year 2050, scientists probably will have discovered a cure for cancer.<br>到2050年时，科学家可能会找到治愈癌症的方法。<br>I will graduate in July. I will see you in September. By the time I see you, I will have graduated.<br>我将于7月份毕业，于9月份与你见面，到我见到你的时候，我就已经毕业了。</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>《深入理解Java虚拟机第3版》阅读笔记</title>
    <url>/2020/07/09/%E3%80%8A%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%AC%AC3%E7%89%88%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记总结、摘选自周志明老师的<a href="https://item.jd.com/12607299.html">《深入理解Java虚拟机第3版》</a>，以及其他网上知识点收集，只是我自己的个人复习笔记，禁止转载，如有侵权，请联系我删除。<br>思维导图版本<a href="http://www.xmind.net/m/xcdF8N">点击这里</a></p>
</blockquote>
<h1 id="虚拟机概述"><a href="#虚拟机概述" class="headerlink" title="虚拟机概述"></a>虚拟机概述</h1><h2 id="中间语言翻译（从Java翻译到机器码）"><a href="#中间语言翻译（从Java翻译到机器码）" class="headerlink" title="中间语言翻译（从Java翻译到机器码）"></a>中间语言翻译（从Java翻译到机器码）</h2><blockquote>
<p>从中间语言翻译到机器码</p>
</blockquote>
<h3 id="通过C语言翻译（初JVM）"><a href="#通过C语言翻译（初JVM）" class="headerlink" title="通过C语言翻译（初JVM）"></a>通过C语言翻译（初JVM）</h3><p>通过将字节码class翻译成C语言，比如定义iadd这个字节码是相加的助记符，然后通过c语言来解析字节码中的iadd就是相加，并指向对应的c语言相加的c程序来做实际运算，这样子的话，这个解析字节码的C程序就是所谓的JVM，最简陋效率最低的初代JVM</p>
<h3 id="直接翻译为机器码"><a href="#直接翻译为机器码" class="headerlink" title="直接翻译为机器码"></a>直接翻译为机器码</h3><h4 id="CS-IP"><a href="#CS-IP" class="headerlink" title="CS:IP"></a>CS:IP</h4><p>CS与IPO这是物理CPU内部的两个寄存器。对于一台物理机器而言，这两个寄存器是最重要的寄存器，因为CPU在取指令时便完全依靠这两个寄存器。CS寄存器保存段地址，IP保存偏移地址。CS和IP这两个寄存器的值能够唯一确定内存中的一个地址，CPU在执行机器指令之前，便通过这两个寄存器定位到目标内存位置，并将该位置处的机器指令取出来进行运算。函数跳转的本质其实便是修改CS和IP这两个寄存器的内容，使其指向到目标函数所在内存的首地址，这样CPU便能执行目标函数了。Java虚拟机要想让物理CPU直接执行Java程序所对应的目标机器码，也得修改这两个寄存器才能实现。</p>
<p>在C语言中，能够使用语法糖来修改CS:IP段寄存器，这样C程序就能直接动态执行机器码。<br>既然都能在C语言中直接动态执行机器码了（可以简单理解为：C语言的变量里面可以复制解析出来的机器码，然后直接执行），我们只要将中间语言指令直接翻译为机器码，然后让CS:IP直接指向这段机器码执行，这也是现代JVM最重要的的基本原理之一。</p>
<h3 id="本地编译"><a href="#本地编译" class="headerlink" title="本地编译"></a>本地编译</h3><p>中间语言（Java）与同样属于高级语言的C语言相比，它们实现相同的功能，C语言编译后所生成的机器码，也比中间语言直接翻译成的机器码，在数量上要精简很多，所以单从这个角度来讲，C语言的执行效率当然是要更高一些。<br>中间语言由于其本身不能直接被CPU执行，为了能够被CPU执行，中间语言在完成同样一个功能时，需要准备更多便于自我管理的上下文环境，最后才能执行目标机器指令。准备上下文环境最终也是依靠机器码去实现，因此中间语言最终便生成了更多机器码，当然执行效率就降低了。<br>为了提高性能，JVM提供了一种机制能够将中间语言(字节码)直接编译为本地机器指令。例如安卓和部分JVM所实现的AOT ( ahead of time )特性便是这方面的尝试，但是这种方式并没有减少机器指令的数量级问题。<br>除此之外，JVM的大牛们在JIT (即时编译)、内存分配也进行了大量的优化，使JVM能够对热点代码进行大幅度指令优化，正是由于JVM可以在运行期基于上下文链路进行各种优化，因此优化后的指令质量甚至比C&#x2F;C++编译岀的指令质量更高，以及部分Java程序性能甚至反超C&#x2F;C++程序。如果离开了这些动态优化，Java程序的执行效率是无论如何也提不上去的。</p>
<h2 id="神奇的指令"><a href="#神奇的指令" class="headerlink" title="神奇的指令"></a>神奇的指令</h2><p>Java虚拟机其实是”读不懂”Java代码的，不过也并非所有的虚拟机都不懂得面向对象的语言，JavaScript执行引擎就是个例外一JS脚本不需要编译就能被JS引擎直接执行。<br>Java所谓的中间语言就是Java字节码指令集，指令集一般是计算机硬件才有的东西，而作者却在软件层面定义了一套同样的东西。但是，软件本身不具备执行程序的能力，软件最终还得依靠硬件指令才能完成逻辑计算。因此，一套好的软件指令必须不能超出硬件指令所能表达的计算能力，同时又要对硬件指令进行高度抽象与概括。换言之，如果你定义了一套与硬件指令集完全一模一样的软件指令集，那大家还用你干嘛呀，不如直接用硬件指令得了。</p>
<hr>
<h1 id="Java技术的未来"><a href="#Java技术的未来" class="headerlink" title="Java技术的未来"></a>Java技术的未来</h1><h2 id="无语言倾向"><a href="#无语言倾向" class="headerlink" title="无语言倾向"></a>无语言倾向</h2><h3 id="GraalJVM"><a href="#GraalJVM" class="headerlink" title="GraalJVM"></a>GraalJVM</h3><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/0eyudF.png"></p>
<h3 id="新一代即时编译器"><a href="#新一代即时编译器" class="headerlink" title="新一代即时编译器"></a>新一代即时编译器</h3><p>HotSpot虚拟机中含有两个即使编译器：</p>
<ul>
<li>编译耗时短但是输出代码优化程度较低的客户端编译器（C1）。</li>
<li>编译耗时长但输出代码优化质量较高的服务端编译器（C2）。</li>
</ul>
<p>JDK10之后，HotSpot加入了一个全新的即时编译器，Graal编译器(可以通过相应的JVM参数配置启动，以C2代替者的身份登场，目前还是处于”实验状态”)。<br>Graal能够做比C2更加复杂的优化，如“部分逃逸分析”(Partial Escape Analysis)，也拥有比C2更容易使用激进预测性优化(Aggressive Speculative Optimization)的策略，支持自定义的预测性假设等。</p>
<h3 id="向Native迈进"><a href="#向Native迈进" class="headerlink" title="向Native迈进"></a>向Native迈进</h3><p>最新的基本版本的JDK已经推出跨进程的、可以面向用户程序的类型信息共享(Application Class Data Sharing, AppCDS,允许把加载解析后的类型信息缓存起来，从而提升下次启动速度。</p>
<h4 id="Substrate-VM"><a href="#Substrate-VM" class="headerlink" title="Substrate VM"></a>Substrate VM</h4><p>Substrate VM在内存占用和启动时间比HotSpot强5到50倍：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/UwMq3l.png"><br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/3V5zFm.png"></p>
<h2 id="实战：自己编译JDK"><a href="#实战：自己编译JDK" class="headerlink" title="实战：自己编译JDK"></a>实战：自己编译JDK</h2><h3 id="OpenJDK-vs-OracleJDK"><a href="#OpenJDK-vs-OracleJDK" class="headerlink" title="OpenJDK vs OracleJDK"></a>OpenJDK vs OracleJDK</h3><p>实际上，JDK11之后，两者的公用源码已经占比很高了：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/tCGMw8.png"></p>
<h1 id="自动内存管理"><a href="#自动内存管理" class="headerlink" title="自动内存管理"></a>自动内存管理</h1><h2 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h2><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/LxyOJy.png"></p>
<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器(Program Counter Register)是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。在Java虚拟机的<code>概念模型</code>里，字节解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，它是程序控制流的指示器，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。<br>每个线程都有一个独立的程序计数器，各线程之间的计数器互不影响（因为Java多线程是采用线程轮流切换来实现的，多核处理器中的单个处理器一次只能执行某个线程中的某条指令，切换之后各自的计数器能够恢复到各自接下来的执行位置）。<br>所以，<em><strong>程序计数器是线程私有的。</strong></em></p>
<h3 id="Java虚拟机栈"><a href="#Java虚拟机栈" class="headerlink" title="Java虚拟机栈"></a>Java虚拟机栈</h3><p><em><strong>Java虚拟机栈一样是线程私有的，生命周期与线程相同。</strong></em><br>虚拟机栈描述的是Java方法执行的线程内存模型，每个方法被执行的时候，Java虚拟机都会同步创建一个<code>栈帧(Stack Frame)</code>用于存储局部变量表、操作数栈、动态连接、方法出口等信息。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。<br>广为流传的所谓”堆”和”栈”内存划分说话中的”栈”就是指虚拟机栈，或者是指虚拟机栈中的局部变量表部分。</p>
<h4 id="栈帧？"><a href="#栈帧？" class="headerlink" title="栈帧？"></a>栈帧？</h4><h4 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h4><p>局部变量表存放了编译期可知的各种Java虚拟机基本数据类型(boolean、byte、char、 short、 int、 float、 long、 double) 、对象引用(reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的<code>引用指针</code>，或者叫<code>直接指针</code>；也可能是指向一个代表对象的<code>句柄</code>或者其他与此对象相关的位置)和returnAddress类型(指向了一条字节码指令的地址)<br>这些数据类型在局部变量表中的存储空间以局部变量槽(Slot)来表示，其中64位长度的1ong和double类型的数据会占用两个变量槽，其余的数据类型只占用一个。局部变量表所需的内存空间在编译期间完成分配，当进入一个方法时，这个方法需要在栈帧中分配多大的局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。（“大小”是指变量槽的数量，变量槽占用32个比特还是64个比特由虚拟机决定）。</p>
<h4 id="StackOverFlowError和OutOfMemoryError（Java虚拟机规范）"><a href="#StackOverFlowError和OutOfMemoryError（Java虚拟机规范）" class="headerlink" title="StackOverFlowError和OutOfMemoryError（Java虚拟机规范）"></a>StackOverFlowError和OutOfMemoryError（Java虚拟机规范）</h4><ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将拋出StackOverflowError异常; </li>
<li>如果Java虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会拋出OutOfMemoryError异常。</li>
</ul>
<h4 id="操作数栈？"><a href="#操作数栈？" class="headerlink" title="操作数栈？"></a>操作数栈？</h4><h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>本地方法栈（Native Method Stacks）为虚拟机调用本地方法而服务，就像虚拟机栈服务于Java方法的调用一样。<br>虚拟机可以对本地方法栈自由实现，《Java虚拟机规范》对这没有强制约束（HotSpot将虚拟机栈和本地方法栈合并了）。</p>
<h3 id="Java堆（Heap、GC堆）"><a href="#Java堆（Heap、GC堆）" class="headerlink" title="Java堆（Heap、GC堆）"></a>Java堆（Heap、GC堆）</h3><p>Java堆是虚拟机内存管理中最大的一块（线程共享）。<br>当前主流虚拟机都可以通过参数扩展堆的大小（<code>-Xmx</code>、<code>-Xms</code>），如果内存不足或者堆无法再扩展了，就会抛出OutOfMemoryError。</p>
<h3 id="方法区（”非堆”、Non-Heap）"><a href="#方法区（”非堆”、Non-Heap）" class="headerlink" title="方法区（”非堆”、Non-Heap）"></a>方法区（”非堆”、Non-Heap）</h3><p><em><strong>在JDK 7及之前，HotSpot使用永久代来实现方法区时，而在JDK 8及之后，类变量则会随着Class对象一起存放在Java堆中，这时候<code>类变量在方法区</code>就完全是一种种对逻辑概念的表述了。</strong></em><br>和Java堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的<code>类型信息</code>、<code>常量</code>、<code>静态变量</code>、<code>即时编译器编译后的代码缓存</code>等数据。<br>虽然《Java虚拟机规范》中把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫作“非堆”(Non-Heap) ，目的是与Java堆区分开来。</p>
<h4 id="永久代（Permanent-Generation）的落寞，元空间（Meta-space）的登场"><a href="#永久代（Permanent-Generation）的落寞，元空间（Meta-space）的登场" class="headerlink" title="永久代（Permanent Generation）的落寞，元空间（Meta-space）的登场"></a>永久代（Permanent Generation）的落寞，元空间（Meta-space）的登场</h4><p>Java 8之前，很多人习惯将方法区叫称为”永久代”，因为仅仅只有当时的HotSpot使用永久代来实现方法区，很多其他的虚拟机并不存在永久代的概念，《Java虚拟机规范》也对方法区的实现没有约束，所以方法区不等同于永久代。</p>
<blockquote>
<p>HotSpot使用永久代来实现方法区，实际上导致了Java应用更容易出现内存溢出，其<code>-XX: MaxPermSize</code>可以设置永久代的上限，即使不设置也有默认大小。 而J9和JRockit就没有此类内存限制，除非触碰进程可用内存上限，这个是由系统控制。</p>
</blockquote>
<p>所以到了JDK 6时，HotSpot就逐步放弃永久代，开始采用<code>本地内存（Native Memory）</code>来实现方法区了，到了JDK 8就完全放弃永久代了，改用在本地内存中实现的<code>元空间（Meta-space）</code>，把字符串常量池、静态变量、类型信息等都移到元空间了。<br>垃圾收集器在方法区的回收行为出现得是比较少的，这个区域的内存回收主要是<em><strong>针对常量池的回收和对类型的卸载</strong></em>。</p>
<h4 id="运行时常量池（Runtime-Constant-Pool）"><a href="#运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="运行时常量池（Runtime Constant Pool）"></a>运行时常量池（Runtime Constant Pool）</h4><p>运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池表(Constant Pool Table)，用于存放编译期生成的各种字面量与符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。<br>Java虚拟机对于Class文件每一部分(自然也包括常量池)的格式都有严格规定，如每一个字节用于存储哪种数据都必须符合规范上的要求才会被虚拟机认可、加载和执行，但对于运行时常量池，《Java虚拟机规范》并没有做任何细节的要求。<br>运行时常量池相较于<code>Class文件常量池</code>具有动态性，运行期间可以将新的常量放入运行时常量池中，比如<code>String.intern</code>。<br>因为运行时常量池属于方法区，自然也就受到OutOfMemoryError异常的约束。</p>
<h4 id="直接内存（Direct-Memory）"><a href="#直接内存（Direct-Memory）" class="headerlink" title="直接内存（Direct Memory）"></a>直接内存（Direct Memory）</h4><p>直接内存并不是虚拟机运行时数据区的一部分，也不是《Java虚拟机规范》中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。<br>在JDK 1.4中新加入了NIO (New Input&#x2F;Output)类，引入了一种基于通道(Channel)与缓冲区(Buffer) 的I&#x2F;O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java堆和Native堆中来回复制数据，直接内存当然也是受到物理总内存的约束。</p>
<blockquote>
<p>所以在设置<code>-Xmx</code>等参数时，除了考虑运行时数据区里的各大内存区域，还要考虑到直接内存。 </p>
</blockquote>
<h2 id="垃圾收集器与内存分配策略"><a href="#垃圾收集器与内存分配策略" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h2><h3 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h3><p>对象内存分配的方式（选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有空间压缩整理(Compact) 的能力决定）：</p>
<ul>
<li>指针碰撞（Bump The Pointer）：当使用Serial、ParNew等带压缩整理过程的收集器时（简单高效）。</li>
<li>空闲列表（Free List）：当使用CMS这种基于清除(Sweep)算法的收集器时（较为复杂，实际上，在空闲列表中如果还能够拿到一大块子内存的话，CMS的实现还采用了一种可以继续使用指针碰撞的方式，叫做Linear Allocation Buffer）。</li>
</ul>
<h4 id="并发情况下的内存分配线程安全问题"><a href="#并发情况下的内存分配线程安全问题" class="headerlink" title="并发情况下的内存分配线程安全问题"></a>并发情况下的内存分配线程安全问题</h4><p>并发条件下，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况，解决这个问题的方案：</p>
<ul>
<li>采用CAS配上失败重试的方式保证更新操作的原子性；</li>
<li>把内存分配的动作按照线程划分，在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲(Thread Local Allocation Buffer, TLAB)，线程在各自的本地缓冲区中分配内存，只有本地缓冲区用完了，分配新的缓存区时才需要同步锁定。</li>
</ul>
<p>可以通过<code>-XX: +/-UseTLAB</code>参数来设定使用哪种方案。</p>
<h3 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h3><p>对象在堆内存中的存储布局：</p>
<h4 id="对象头（Header）"><a href="#对象头（Header）" class="headerlink" title="对象头（Header）"></a>对象头（Header）</h4><p>HotSpot对象头包含两类信息：</p>
<ul>
<li>存储对象自身的运行时数据：<code>哈希码（HashCode）</code>、<code>GC分代年龄</code>、<code>锁状态标志</code>、<code>线程持有的锁</code>、<code>偏向线程ID</code>、<code>偏向时间戳</code>等，官方称之为”Mark Word”。<br>MarkWord被设计成一一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机中，如对象未被同步锁锁定的状态下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0，在其他状态(轻量级锁定、重量级锁定、GC标记、可偏向) 下对象的存储内容。如下图：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/YAJQr9.png"></li>
<li>类型指针：即对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。并不是所有的虚拟机实现都必须在对象数据上保留类型指针。</li>
</ul>
<h4 id="实例数据（Instance-Data）"><a href="#实例数据（Instance-Data）" class="headerlink" title="实例数据（Instance Data）"></a>实例数据（Instance Data）</h4><p>这部分是对象真正存储的有效信息，即程序代码里定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录在此。<br>这部分的存储顺序会受到虚拟机分配策略参数<code>-XX: FieldsAllocationStyle</code>参数和字段在Java源码中定义顺序的影响。<br>HotSpot虛拟机默认的分配顺序为longs&#x2F;doubles、ints、 shorts&#x2F;chars、 bytes&#x2F;eooleans、oops(Ordinary Object Pointers, OOPs)，从以上默认的分配策略中可以看到，相同宽度的字段总是被分配到一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。<br>如果HotSpot虛拟机的<code>+XX: CompactPields</code>参数值为true(默认就为true)，那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。</p>
<h4 id="对齐填充（Padding）"><a href="#对齐填充（Padding）" class="headerlink" title="对齐填充（Padding）"></a>对齐填充（Padding）</h4><p>不是一定存在的，只是起到占位符的作用。<br>由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是任何对象的大小都必须是8字节的整数倍。对象头部分已经被精心设计成正好是8字节的倍数(1倍或者2倍)，因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。</p>
<h3 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h3><p>Java程序会通过栈上的reference类型数据来操作堆上的具体对象。</p>
<h4 id="句柄和直接指针两种方式"><a href="#句柄和直接指针两种方式" class="headerlink" title="句柄和直接指针两种方式"></a>句柄和直接指针两种方式</h4><ul>
<li>句柄方式：Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/A1pFdi.png"></li>
<li>直接指针：Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/ycOjxS.png"></li>
</ul>
<blockquote>
<p>使用句柄来访问的最大好处就是reference中存储的是稳定句柄地址，在对象被移动(垃圾收集时移动对象是非常普遍的行为)时只会改变句柄中的实例数据指针，而reference本身不需要被修改。<br>使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。</p>
</blockquote>
<h3 id="实战：OutOfMemoryError异常"><a href="#实战：OutOfMemoryError异常" class="headerlink" title="实战：OutOfMemoryError异常"></a>实战：OutOfMemoryError异常</h3><p>在《Java虚拟机规范》的规定里，除了程序计数器外，虚拟机内存的其他几个运行时区域都有发生OutOfMemoryError (OOM)异常的可能。</p>
<h4 id="Java堆溢出"><a href="#Java堆溢出" class="headerlink" title="Java堆溢出"></a>Java堆溢出</h4><p>要先确认是内存泄露（Memory Leak）还是内存溢出（Memory Overflow）。</p>
<h5 id="Java内存（映像）分析工具（hprof文件分析工具）"><a href="#Java内存（映像）分析工具（hprof文件分析工具）" class="headerlink" title="Java内存（映像）分析工具（hprof文件分析工具）"></a>Java内存（映像）分析工具（hprof文件分析工具）</h5><p>JVM堆转储快照文件（hprof文件）查看分析时，可以指定heapDumpPath：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/export/Domains/rcsv-fm.wd.local/server1/logs</span><br></pre></td></tr></table></figure>
<blockquote>
<p>kill -3 or -9 都不会打heap dump，kill -9 java_pid来不及做任何事情就被干掉了，-3会打印thread dump 但是不是heap dump。</p>
</blockquote>
<p><a href="https://blog.csdn.net/qq_39172525/article/details/80824897">Eclipse Memory Analyzer 分析hprof文件</a></p>
<h5 id="GC-Roots"><a href="#GC-Roots" class="headerlink" title="GC Roots"></a>GC Roots</h5><h4 id="虚拟机栈和本地方法栈溢出"><a href="#虚拟机栈和本地方法栈溢出" class="headerlink" title="虚拟机栈和本地方法栈溢出"></a>虚拟机栈和本地方法栈溢出</h4><p>HotSpot不区分虚拟机栈和本地方法栈，栈容量由<code>-Xss</code>参数设定。</p>
<ul>
<li>1)如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverflowError异常。</li>
<li>2)如果虚拟机的栈内存允许动态扩展，当扩展栈容量无法申请到足够的内存时，将拋出OutOfMemoryError异常 。</li>
</ul>
<p>模拟栈溢出：</p>
<ul>
<li>使用-Xss参数减少栈内存容量。</li>
<li>定义了大量的本地变量，增大此<code>方法帧</code>中<code>本地变量表</code>的长度。</li>
<li>通过不断建立线程的方式，在HotSpot上也是可以产生内存溢出异常的（但是这样产生的内存溢出异常和栈空间是否足够并不存在任何直接的关系，主要取决于操作系统本身的内存使用状态，在这种情况下，给每个线程的栈分配的内存越大，反而越容易产生内存溢出异常）。<br>HotSpot虚拟机提供了参数可以控制Java堆和方法区这两部分的内存的最大值，系统的内存分配需要减去最大堆容量，再减去最大方法区容量，由于程序计数器消耗内存很小，可以忽略掉，如果把直接内存和虚拟机进程本身耗费的内存也去掉的话，剩下的内存就由虚拟机栈和本地方法栈来分配了。因此为每个线程分配到的栈内存越大，可以建立的线程数量自然就越少，建立线程时就越容易把剩下的内存耗尽。</li>
</ul>
<blockquote>
<p>无论是由于栈帧太大还是虚拟机栈容量太小，当新的栈帧内存无法分配的时候，HotSpot 虚拟机抛出的都是StackOverflowError异常。</p>
</blockquote>
<h4 id="方法区和运行时常量池溢出"><a href="#方法区和运行时常量池溢出" class="headerlink" title="方法区和运行时常量池溢出"></a>方法区和运行时常量池溢出</h4><p>在JDK 8以后，永久代便完全退出了历史舞台，元空间作为其替代者登场。在默认设置下，方法区的溢出的溢出已经相对不会那么容易出现了。<br>HotSpot提供了一些参数用于防御元空间溢出问题：<br>-XX: MaxMetaspaceSize: 设置元空间最大值，默认是-1，即不限制，或者说只受限于本地内存大小。<br>-XX: MetaspaceSize: 指定元空间的初始空间大小，以字节为单位，达到该值就会触发垃圾收集进行类型卸载，同时收集器会对该值进行调整:如果释放了大量的空间，就适当降低该值;如果释放了很少的空间，那么在不超过-XX:<br>MaxMetaspaceSize (如果设置了的话)的情况下，适当提高该值。<br>-XX: MinMetaspaceFreeRatio: 作用是在垃圾收集之后控制最小的元空间剩余容量的百分比，可减少因为元空间不足导致的垃圾收集的频率。类似的还有-XX: Max-MetaspaceFreeRatio, 用于控制最大的元空间剩余容量的百分比。</p>
<h4 id="本机直接内存溢出"><a href="#本机直接内存溢出" class="headerlink" title="本机直接内存溢出"></a>本机直接内存溢出</h4><p>直接内存(Direct Memory)的容量大小可通过<code>-XX : MaxDirectMemorySize</code>参数来指定，如果不去指定，则默认与Java堆最大值(由-Xmx指定) 一致。<br>越过了DirectByteBuffer类直接通过反射获取Unsafe实例进行内存分配(Unsafe类的getUnsafe()方法指定只有引导类加载器才会返回实例，体现了设计者希望只有虚拟机标准类库里面的类才能使用Unsafe的功能，在JDK 10时才将Unsafe的部分功能通过VarHandle开放给外部使用)，因为虽然使用DirectByteBuffer分配内存也会拋出内存溢出异常，但它抛出异常时并没有真正向操作系统申请分配内存，而是通过计算得知内存无法分配就会在代码里手动抛出溢出异常，真正申请分配内存的方法是Unsafe:allocateMemory()。</p>
<blockquote>
<p>由直接内存导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见有什么明显的异常情况，如果发现内存溢出之后产生的Dump文件很小，而程序中又直接或间接使用了DirectMemory(典型的间接使用就是NIO)，那就可以考虑重点检查一下直接内存方面的原因了。</p>
</blockquote>
<h1 id="垃圾收集器与内存分配策略-1"><a href="#垃圾收集器与内存分配策略-1" class="headerlink" title="垃圾收集器与内存分配策略"></a>垃圾收集器与内存分配策略</h1><ul>
<li>程序计数器、虚拟机栈、本地方法栈的垃圾回收：<br>这3个区域随线程而生，随线程而灭，栈中的栈帧随着方法的进入和退出而有条不紊地执行着出栈和入栈操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的(尽管在运行期会由即时编译器进行一些优化，但在基于概念模型的讨论里，大体上可以认为是编译期可知的)，因此这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑如何回收的问题，当方法结束或者线程结束时，内存自然就跟随着回收了。</li>
<li>Java堆和方法区的垃圾回收：<br>两个区域则有着很显著的不确定性，一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理。</li>
</ul>
<h2 id="对象已死？"><a href="#对象已死？" class="headerlink" title="对象已死？"></a>对象已死？</h2><blockquote>
<p>垃圾收集器在对Java堆进行回收前，第一件事情就是要确定这些对象之中哪些还“存活”着，哪些已经“死去”(“死去”即不可能再被任何途径使用的对象)了。</p>
</blockquote>
<h3 id="引用计数算法"><a href="#引用计数算法" class="headerlink" title="引用计数算法"></a>引用计数算法</h3><p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一，任何时刻计数器为零的对象就是不可能再被使用的。<br>但是，在Java领域，至少主流的Java虚拟机里面都没有选用引用计数算法来管理内存，主要原因是，这个看似简单的算法有很多例外情况要考虑，必须要配合大量额外处理才能保证正确地工作，譬如单纯的引用计数就很难解决对象之间相互循环引用的问题。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 单纯的引用计数就很难解决对象之间相互循环引用的问题。</span><br><span class="line"> * @Author zhanshifeng</span><br><span class="line"> * @Date 2020/9/8 4:53 PM</span><br><span class="line"> */</span><br><span class="line">public class ReferenceCountingGC &#123;</span><br><span class="line"></span><br><span class="line">    public Object instance;</span><br><span class="line">    private static final int _1MB = 1024 * 1024;</span><br><span class="line">    private byte[] bigSize = new byte[2 * _1MB];</span><br><span class="line"></span><br><span class="line">    public static void testGC() &#123;</span><br><span class="line">        ReferenceCountingGC a = new ReferenceCountingGC();</span><br><span class="line">        ReferenceCountingGC b = new ReferenceCountingGC();</span><br><span class="line">        a.instance = b;</span><br><span class="line">        b.instance = a;</span><br><span class="line">        a = null;</span><br><span class="line">        b = null;</span><br><span class="line"></span><br><span class="line">        // 如果JVM单纯引用计数的话，a和b是不能被回收的，但是实际上是回收了。</span><br><span class="line">        System.gc();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        testGC();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可达性分析算法（Reachability-Analysis）"><a href="#可达性分析算法（Reachability-Analysis）" class="headerlink" title="可达性分析算法（Reachability Analysis）"></a>可达性分析算法（Reachability Analysis）</h3><h4 id="GC-Roots-1"><a href="#GC-Roots-1" class="headerlink" title="GC Roots"></a>GC Roots</h4><p>这个算法的基本思路就是通过一系列称为<code>GCRoots</code>的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程所走过的路径称为“引用链”(Reference Chain)，如果某个对象到GC Roots间没有任何引用链相连，或者用图论的话来说就是从GCRoots到这个对象不可达时，则证明此对象是不可能再被使用的。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/ecAOJD.png"><br>固定可作为GC Roots的对象包括以下几种:</p>
<ul>
<li>在虚拟机栈(栈帧中的本地变量表)中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。</li>
<li>在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量。</li>
<li>在方法区中常量引用的对象，譬如字符串常量池(String Table)里的引用。</li>
<li>在本地方法栈中JNI (即通常所说的Native方法)引用的对象。</li>
<li>Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象(比如NullPointExcepiton、 OutOfMemoryError)等，还有系统类加载器。</li>
<li>所有被同步锁(synchronized关键字) 持有的对象。</li>
<li>反映Java虚拟机内部情况的JMXBean、 JVMTI中注册的回调、本地代码缓存等。</li>
</ul>
<blockquote>
<p>目前最新的几款垃圾收集器无一例外都具备了局部回收的特征，为了避免GCRoots包含过多对象而过度膨胀，它们在实现上也做出了各种优化处理。</p>
</blockquote>
<h3 id="对象的引用？"><a href="#对象的引用？" class="headerlink" title="对象的引用？"></a>对象的引用？</h3><ul>
<li>强引用（Strongly Reference）是最传统的“引用”的定义，是指在程序代码之中普遍存在的引用赋值，即类似“Object obj&#x3D;new Object() ‘这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li>
<li>软引用（Soft Reference）是用来描述一些还有用，但非必须的对象。只被软引用关联着的对象，在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK 1.2版之后提供了SoftReference类来实现软引用。</li>
<li>弱引用（Weak Reference）也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK 1.2版之后提供了WeakReference类来实现弱引用。</li>
<li>虚引用也称为“幽灵引用”或者“幻影引用”（Phantom Reference），它是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。在JDK1.2版之后提供了PhantomReference类来实现虚引用。</li>
</ul>
<h3 id="生存与死亡？"><a href="#生存与死亡？" class="headerlink" title="生存与死亡？"></a>生存与死亡？</h3><p>即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段，要真正宣告一个对象死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记， 随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize(方法。假如对象没有覆盖finalize()方法，或者finalize(方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。如果这个对象被判定为确有必要执行finalize方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致F-Queue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。<br>finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize()中成功拯救自己一只要重新与引用链上的任何一个对象建立关联即可，譬如把自己(this关键字) 赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合，如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</p>
<blockquote>
<p>尽管如此，但是一定要避免使用finalize()，这个方法不确定性太大了，无法保证其被调用的顺序。</p>
</blockquote>
<h3 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h3><p>《Java虚拟机规范》中提到过可以不要求虚拟机在方法区中实现垃圾收集，事实上也确实有未实现或未能完整实现方法区类型卸载的收集器存在(如JDK 11时期的ZGC收集器就不支持类卸载)， 方法区垃圾收集的“性价比”通常也是比较低的:在Java堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常可以回收70%至99%的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回收成果往往远低于此。<br>方法区的垃圾回收两部分内容：</p>
<h4 id="废弃的常量和不再使用的类型"><a href="#废弃的常量和不再使用的类型" class="headerlink" title="废弃的常量和不再使用的类型"></a>废弃的常量和不再使用的类型</h4><p>回收废弃常量与回收Java堆中的对象非常类似。举个常量池中字面量回收的例子，假如一个字符串“java”曾经进入常量池中，但是当前系统又没有任何一个字符串对象的值是“java”,换句话说，已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个字面量。如果在这时发生内存回收，而且垃圾收集器判断确有必要的话，这个“java”常量就将会被系统清理出常量池。<br>常量池中其他类(接口)、方法、字段的符号引用也与此类似。<br>判定一个类型是否属于“不再被使用的类”的条件就比较苛刻了。需要同时满足下面三个条件:</p>
<ul>
<li>该类所有的实例都已经被回收，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
<li>加载该类的类加载器已经被回收。</li>
</ul>
<p>关于对类型进行回收HotSpot虚拟机提供了一些参数做控制：</p>
<ul>
<li>-verbose: class</li>
<li>-XX: +TraceClassLoading</li>
<li>-XX: +TraceClassUnLoading（需要FastDebug版的虚拟机支持）</li>
</ul>
<h2 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h2><p>从如何判定对象消亡的角度出发，垃圾收集算法可以划分为：</p>
<ul>
<li>“引用计数式垃圾收集”(Reference Counting GC)（直接垃圾收集）</li>
<li>“追踪式垃圾收集”(Tracing GC)（间接垃圾收集）</li>
</ul>
<h3 id="分代收集理论"><a href="#分代收集理论" class="headerlink" title="分代收集理论"></a>分代收集理论</h3><ul>
<li>弱分代假说(Weak Generational Hypothesis)：绝大多数对象都是朝生夕灭的。</li>
<li>强分代假说(Strong Generational Hypothesis)：熬过越多次垃圾收集过程的对象就越难以消亡。</li>
</ul>
<p>收集器应该将Java堆划分出不同的区域，然后将回收对象依据其年龄(年龄即对象熬过垃圾收集过程的次数)分配到不同的区域之中存储。显而易见，如果一个区域中大多数对象都是朝生夕灭，难以熬过垃圾收集过程的话，那么把它们集中放在一起，每次回收时只关注如何保留少量存活而不是去标记那些大量将要被回收的对象，就能以较低代价回收到大量的空间;如果剩下的都是难以消亡的对象，那把它们集中放在一块，虚拟机便可以使用较低的频率来回收这个区域，这就同时兼顾了垃圾收集的时间开销和内存的空间有效利用。</p>
<p>在Java堆划分出不同的区域之后，垃圾收集器才可以每次只回收其中某一个或者某些部分的区域。<br>部分收集（Partial GC）类型划分：</p>
<ul>
<li>新生代收集（Minor GC&#x2F;Young GC）：针对Java堆里面新生代的垃圾收集。</li>
<li>老年代收集（Major GC&#x2F;Old GC）：针对Java堆里面老年代的垃圾收集，Major GC有些文献用来代表整堆收集，可能会混淆，目前只有CMS收集器会有单独收集老年代的行为。</li>
<li>混合收集（Mixed GC）：针对Java对里面的整个新生代和部分老年代的垃圾收集，目前只有G1收集器会有这种行为。</li>
</ul>
<p>整堆收集（Full GC）：针对整个Java堆和方法区的垃圾收集。</p>
<p>针对不同的区域安排与里面存储对象存亡特征相匹配的垃圾收集算法：</p>
<ul>
<li>标记-复制算法</li>
<li>标记-清除算法</li>
<li>标记-整理算法</li>
</ul>
<h4 id="新生代与老年代"><a href="#新生代与老年代" class="headerlink" title="新生代与老年代"></a>新生代与老年代</h4><p>现在的商用Java虚拟机里，设计者一般至少会把Java堆划分为新生代(Young Generation)和老年代(Old Generation)两个区域。<br>在新生代中，每次垃圾收集时都发现有大批对象死去，而每次回收后存活的少量对象，将会逐步晋升到老年代中存放。<br>但是存在一个明显的问题：<em><strong>对象不是孤立的，对象之间会存在跨代引用。</strong></em></p>
<p>假如要现在进行一次只局限于新生代区域内的收集(Minor GC)，但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GCRoots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样以。遍历整个老年代所有对象的方案虽然理论上可行，但无疑会为内存回收带来很大的性能负担。因此可以对分代收集理论添加第三条经验法则:</p>
<ul>
<li>跨代引用假说(Intergenerational Reference Hypothesis)<br>跨代引用相对于同代引用来说仅占极少数。这其实是可根据前两条假说逻辑推理得出的隐含推论：存在互相引用关系的两个对象，是应该倾向于同时生存或者同时消亡的。<br>如果某个新生代对象存在跨代引用，由于老年代对象难以消亡，该引用会使得新生代对象在收集时同样得以存活，进而在年龄增长之后晋升到老年代中，这时跨代引用也随即被消除了。<br>依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，只需在新生代上建立一个全局的数据结构(该结构被称为“记忆集”，Remembered Set)， 这个结构把老年代划分成若干小块，标识出老年代的哪块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GCRoots进行扫描。虽然这种方法需要在对象改变引用关系(如将自己或者某个属性赋值)时维护记录数据的正确性，会增加一些运行时 的开销，但比起收集时扫描整个老年代来说仍然是划算的。</li>
</ul>
<h3 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark-Sweep）"></a>标记-清除算法（Mark-Sweep）</h3><p>最基础的垃圾收集算法，算法分为“标记”和“清除”两个阶段:首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。<br>标记-清除算法的缺点：</p>
<ul>
<li>第一个是执行效率不稳定，如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低;</li>
<li>第二个是内存空间的碎片化问题，标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li>
</ul>
<p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/Wkxl6l.png"></p>
<h3 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h3><h4 id="半区复制"><a href="#半区复制" class="headerlink" title="半区复制"></a>半区复制</h4><p>为了解决标记清除算法面对大量可回收对象时执行效率低的问题，有人提出了一种称为“半区复制”(Semispace Copying)的垃圾收集算法，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象，而且每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效，不过其缺陷也显而易见，这种复制回收算法的代价是将可用内存缩小为了原来的一半，另一半等同于空置不用。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/mLYIu0.png"><br>新生代中的对象有98%熬不过第一轮收集。因此并不需要按照1 : 1的比例来划分新生代的内存空间，现在的商用Java虚拟机大多都优先采用了这种收集算法去回收新生代。</p>
<h4 id="Appel式回收"><a href="#Appel式回收" class="headerlink" title="Appel式回收"></a>Appel式回收</h4><p>之后有人继续提出了一种更优化的半区复制分代策略，现在称为“Appel式回收”。HotSpot虛拟机的Serial、ParNew等新生代收集器均采用了这种策略来设计新生代的内存布局”。<br>Appel式回收的具体做法是把新生代分为一块较大的<code>Eden空间</code>和两块较小的<code>Survivor空间</code>，每次分配内存只使用Eden和其中一块Survivor（Survivor From区）。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是8 : 1，也即<em><strong>每次新生代中可用内存空间为整个新生代容量的90%(Eden的80%加上一个Survivor的10%，8:1的总数是10，也就是还有10%用于其他用途，即Survivor To区)，只有一个Survivor空间，即10%的新生代是会被“浪费”的。</strong></em><br>当然，98%的对象可被回收仅仅是“普通场景”下测得的数据，任何人都没有办法百分百保证每次回收都只有不多于10%的对象存活，因此Appel式回收还有一个充当罕见情况的“逃生门”的安全设计，当Survivor空间不足以容纳一次Minor GC之后存活的对象时，就需要依赖其他内存区域(实际上大多就是老年代)进行<code>分配担保(Handle Promotion)</code>。</p>
<blockquote>
<p>这个算法的高效是建立在大部分对象都“朝生夕灭”的特性上的，如果存活对象过多，把这些对象复制到Survivor并维持这些对象引用的正确性就成为一个沉重的负担，因此导致垃圾收集的暂停时间明显变长。</p>
</blockquote>
<h3 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark-Compact）"></a>标记-整理算法（Mark-Compact）</h3><p>标记复制算法在对象存活率较高时就要进行较多的复制操作，效率将会降低。更关键的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法。<br>针对老年代对象的存亡特征，1974年Edward Lueders提出了另外一种有针对性的“标记-整理”(Mark Compact)算法，其中的标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向内存空间一端移动，然后直接清理掉边界以外的内存。<br>标记-清除算法与标记-整理算法的本质差异在于：</p>
<ul>
<li>前者是一种非移动式的回收算法；</li>
<li>而后者是移动式的。</li>
</ul>
<p>移动回收后的存活对象是一项优缺点并存的风险决策。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/xGECtR.png"></p>
<ul>
<li>如果移动存活的对象太多，这将是一笔很大的开销，而且这种移动操作要强制暂停用户的应用程序才能进行（最新的ZGC和Shenandoah收集器使用读屏障(Read Barrier)技术实现了整理过程与用户线程的并发执行）。</li>
<li>如果完全不考虑移动和整理存活对象的话，弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。<br>譬如通过“分区空闲分配链表’’来解决内存分配问题(计算机硬盘存储大文件就不要求物理连续的磁盘空间，能够在碎片化的硬盘上存储和访问就是通过硬盘分区表实现的)。<br>内存的访问是用户程序最频繁的操作，在这个环节上增加了额外的负担，势必会直接影响应用程序的吞吐量。</li>
</ul>
<p>基于以上两点，是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂。从垃圾收集的停顿时间来看，不移动对象停顿时间会更短，甚至可以不需要停顿，但是从整个程序的吞吐量来看，移动对象会更划算。这里的吞吐量的实质是赋值器(Mutator, 可以理解为使用垃圾收集的用户程序)与收集器的效率总和。即使不移动对象会使得收集器的效率提升一些，但因内存分配和访问相比垃圾收集频率要高得多，这部分的耗时增加，总吞吐量仍然是下降的。<br>HotSpot虚拟机里面关注吞吐量的Parallel Scavenge收集器是基于标记整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的，这也从侧面印证这点。<br>另外，还有一种“和稀泥式”解决方案可以不在内存分配和访问上增加太大额外负担，做法是让虚拟机平时多数时间都采用标记清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经大到影响对象分配时，再采用标记-整理算法收集一次，以获得规整的内存空间。</p>
<blockquote>
<p>前面提到的基于标记-清除算法的CMS收集器面临空间碎片过多时采用的就是这种处理办法。</p>
</blockquote>
<h4 id="三色标记法（Tri-color-Marking）"><a href="#三色标记法（Tri-color-Marking）" class="headerlink" title="三色标记法（Tri-color Marking）"></a>三色标记法（Tri-color Marking）</h4><p>白色、黑色、灰色</p>
<h5 id="并发出现对象消失问题"><a href="#并发出现对象消失问题" class="headerlink" title="并发出现对象消失问题"></a>并发出现对象消失问题</h5><p>两种解决方案：增量更新（Incremental Update）、原始快照（Snapshot At The Begging，SATB）。</p>
<h2 id="经典垃圾收集器"><a href="#经典垃圾收集器" class="headerlink" title="经典垃圾收集器"></a>经典垃圾收集器</h2><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/WLBBDC.png"><br>如果两个收集器存在连线，则它们可以搭配使用。<br>上图连线关系不是一成不变的，在JDK 8时将Serial+CMS、ParNew+Serial Old这两个组合声明为废弃(JEP 173)，并在JDK 9中完全取消了这些组合的支持(JEP 214)。</p>
<h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p>这是最古老，最基础的垃圾收集器，只会使用一个处理器单线程去做垃圾收集，而且它在进行垃圾收集期间，会停掉所有的用户工作线程，这是非常糟糕的用户体验。(Stop The World)<br>Serial&#x2F;Serial Old收集器工作流程：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/lqCCw4.png"><br>Serial虽然有上述这么大的弊端，但是历代JVM一直致力于Serial的优化改进，直至如今，Serial依然是HotSpot的默认新生代收集器，因为其在单线程的环境下相较而言简单高效，而且垃圾收集的时间甚至可以缩短到十几、几十毫秒。</p>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>是Serial的多线程并行版本，具体实现和Serial收集器完全一致。<br>ParNew收集器工作流程：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/gh4KtY.png"></p>
<p>JDK5发布时推出了划时代意义的CMS收集器，是HotSpot第一款支持并发的垃圾收集器，其首次实现垃圾收集器与用户线程（基本上）同时工作。<br>ParNew是HotSpot JVM中第一款退役的收集器。</p>
<h4 id="垃圾收集并行-vs-并发"><a href="#垃圾收集并行-vs-并发" class="headerlink" title="垃圾收集并行 vs 并发"></a>垃圾收集并行 vs 并发</h4><ul>
<li>并行(Parallel) ：并行描述的是多条垃圾收集器线程之间的关系，说明同一时间有多条这样的线程在协同工作，通常默认此时用户线程是处于等待状态。</li>
<li>并发(Concurrent) ：并发描述的是垃圾收集器线程与用户线程之间的关系，说明同一时间垃圾收集器线程与用户线程都在运行。由于用户线程并未被冻结，所以程序仍然能响应服务请求，但由于垃圾收集器线程占用了一部分系统资源，此时应用程序的处理的吞吐量将受到一定影响。</li>
</ul>
<h3 id="Parallel-Scavenge收集器（吞吐量优先收集器）"><a href="#Parallel-Scavenge收集器（吞吐量优先收集器）" class="headerlink" title="Parallel Scavenge收集器（吞吐量优先收集器）"></a>Parallel Scavenge收集器（吞吐量优先收集器）</h3><p>这是一款新生代收集器，同样是基于标记-复制算法实现的，也是能够并行收集的多线程收集器。<br>Parallel Scavenge的目标是要达到一个可控的吞吐量。</p>
<h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/9wrqFn.png"><br>高吞吐量可以更好地利用处理器资源，更快完成用户的任务。</p>
<h4 id="Parallel-Scavenge精确控制吞吐量的参数"><a href="#Parallel-Scavenge精确控制吞吐量的参数" class="headerlink" title="Parallel Scavenge精确控制吞吐量的参数"></a>Parallel Scavenge精确控制吞吐量的参数</h4><ul>
<li><code>-XX: MaxGCPauseMills</code>：最大垃圾收集停顿时间（并非越小越好，它与吞吐量是互斥的关系）。<br>这个参数允许的值是一个大于0的毫秒数，收集器将尽力保证内存回收花费的时间不超过用户设定值。不过不要异想天开地认为如果把这个参数的值设置得更小点就能使得系统的垃圾收集速度变得更快，垃圾收集停顿时间缩短是以牺牲吞吐量和新生代空间为代价换取的:系统把新生代调得小-些，收集300MB新生代肯定比收集500MB快，但这也直接导致垃圾收集发生得更频繁，原来10秒收集一次、每次停顿100毫秒，现在变成5秒收集一次、每次停顿70毫秒。停顿时间的确在下降，但吞吐量也降下来了。</li>
<li><code>-XX: GCTimeRatio</code>：直接设置吞吐量大小。<br>这个参数的值则应当是一个大于0小于100的整数，也就是垃圾收集时间占总时间的比率，相当于吞吐量的倒数。譬如把此参数设置为19，那允许的最大垃圾收集时间就占总时间的5%(即1&#x2F;(1+19))，默认值为99，即允许最大1%(即1&#x2F;(1+99))的垃圾收集时间。</li>
<li><code>-XX: +UseAdaptiveSizePolicy</code>：开关参数，开启之后虚拟机会根据当前系统运行情况收集性能监控信息，动态调整其它一些参数以提供最合适的停顿时间或者最大的吞吐量（<code>自适应的调节策略</code>）。</li>
</ul>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用标记-整理算法。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/cQDTyf.png"></p>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，支持多线程并发收集，基于标记-整理算法实现。<br>在注重吞吐量或者处理器资源较为稀缺的场合，可以优先考虑Parallel Scavenge加Parallel Old收集器这个组合。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/83f7lh.png"></p>
<h3 id="CMS收集器（关注停顿时间控制）（如今已经被官方声明为不推荐使用）"><a href="#CMS收集器（关注停顿时间控制）（如今已经被官方声明为不推荐使用）" class="headerlink" title="CMS收集器（关注停顿时间控制）（如今已经被官方声明为不推荐使用）"></a>CMS收集器（关注停顿时间控制）（如今已经被官方声明为不推荐使用）</h3><p>CMS (Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。<br>在较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来良好的交互体验的场景下，CMS收集器就非常符合这类应用的需求。<br>CMS收集器是基于<code>标记-清除算法</code>实现的:</p>
<ul>
<li>初始标记(CMS initial mark)（”Stop The World”）</li>
<li>并发标记(CMS concurrent mark)（可以与用户线程一起工作）</li>
<li>重新标记(CMS remark)（”Stop The World”）</li>
<li>并发清除(CMS concurrent sweep)（可以与用户线程一起工作）</li>
</ul>
<p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/BhG3qR.png"></p>
<h4 id="CMS收集器的弊端"><a href="#CMS收集器的弊端" class="headerlink" title="CMS收集器的弊端"></a>CMS收集器的弊端</h4><ul>
<li>在并发收集的阶段势必会占用用户线程的资源，CMS默认启动的回收线程数是(处理器核心数量+3) &#x2F;4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过25%的处理器运算资源，并且会随着处理器核心数量的增加而下降。但是当处理器核心数量不足四个时，CMS对用户程序的影响就可能变得很大。如果应用本来的处理器负载就很高，还要分出一半的运算能力去执行收集器线程，就可能导致用户程序的执行速度忽然大幅降低。</li>
<li>无法处理<code>浮动垃圾</code>（在标记过程结束之后产生的垃圾），可以通过<code>-XX: CMSInitiatingOccu-pancyFraction</code>参数做一些调整。</li>
<li>标记-清除算法会产生大量空间碎片。</li>
</ul>
<h3 id="Garbage-First收集器（关注停顿时间控制）"><a href="#Garbage-First收集器（关注停顿时间控制）" class="headerlink" title="Garbage First收集器（关注停顿时间控制）"></a>Garbage First收集器（关注停顿时间控制）</h3><p>Garbage First收集器简称G1，到了JDK 8 Update 40之后，被官方称为<code>全功能的垃圾收集器</code>（Fully-Featrued Garbage Collector）。</p>
<ul>
<li>G1作为CMS收集器的替代者和继承人，设计者们希望做出-款能够建立起<code>停顿时间模型</code>(Pause Prediction Model)的收集器（可通过<code>-XX: MaxGCPauseMillis</code>调整，一般停顿时间为200毫秒左右，太短的停顿会造成垃圾回收不充分，最终Full GC）。</li>
<li>G1跳出垃圾收集分代理论，它可以面向堆内存任何部分来组成回收集(Collection Set, - 般简称CSet)进行回收，衡量标准不再是它属于哪个分代，而是哪块内存中存放的垃圾数量最多，回收收益最大，这就是G1收集器的Mixed GC模式。</li>
<li>开创了基于Region的堆内存设计布局，还有一个Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象即可判定为大对象（可以通过参数<code>-XX: G1HeapRegionSize</code>控制），超过了整个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中。</li>
</ul>
<p>G1运作过程：</p>
<ul>
<li>初始标记(Initial Marking)</li>
<li>并发标记(Concurrent Marking)</li>
<li>最终标记(Final Marking) </li>
<li>筛选回收(Live Data Counting and Evacuation)</li>
</ul>
<p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/xgFBnC.png"></p>
<h2 id="低延迟垃圾收集器"><a href="#低延迟垃圾收集器" class="headerlink" title="低延迟垃圾收集器"></a>低延迟垃圾收集器</h2><p>衡量垃圾收集器的三项最重要的指标是，三者共同构成了一个“不可能三角”（一款优秀的收集器通常最多可以同时达成其中的两项）。</p>
<ul>
<li>内存占用(Footprint) </li>
<li>吞吐量(Throughput)</li>
<li>延迟(Latency)</li>
</ul>
<h3 id="Shenandoah收集器"><a href="#Shenandoah收集器" class="headerlink" title="Shenandoah收集器"></a>Shenandoah收集器</h3><p>Shenandoah收集器不是”亲儿子”，在OracleJDK12 中目前还未支持，其后面版本JDK是否支持有待考证。<br>这个项目的目标是实现-种能在任何堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的垃圾收集器，该目标意味着相比CMS和G1，Shenandoah不仅要进行并发的垃圾标记，还要并发地进行对象清理后的整理动作。<br>Shenandoah和G1有三个明显的不同之处：</p>
<ul>
<li>支持并发的整理算法，G1的回收阶段是可以多线程并行的，但却不能与用户线程并发；</li>
<li>Shenandoah (目前)是默认不使用分代收集的，换言之，不会有专门的新生代Region或者老年代Region的存在；</li>
<li>Shenandoah摒弃 了在G1中耗费大量内存和计算资源去维护的记忆集，改用名为“连接矩阵”(ConnectionMatrix)的全局数据结构来记录跨Region的引用关系，降低了处理跨代指针时的记忆集维护消耗，也降低了<code>伪共享问题</code>的发生概率。</li>
</ul>
<h3 id="ZGC收集器（Z-Garbage-Collector）"><a href="#ZGC收集器（Z-Garbage-Collector）" class="headerlink" title="ZGC收集器（Z Garbage Collector）"></a>ZGC收集器（Z Garbage Collector）</h3><p>ZGC是一款在JDK 11中新加入的具有实验性质的低延迟垃圾收集器。<br>ZGC和Shenandoah的目标是高度相似的，都希望在尽可能对吞吐量影响不太大的前提下，实现在任意堆内存大小下都可以把垃圾收集的停顿时间限制在十毫秒以内的低延迟。<br>ZGC完全成熟之后，将会成为服务端、大内存、低延迟应用的首选收集器的有力竞争者。</p>
<h2 id="选择合适的垃圾收集器"><a href="#选择合适的垃圾收集器" class="headerlink" title="选择合适的垃圾收集器"></a>选择合适的垃圾收集器</h2><h3 id="Epsilon收集器"><a href="#Epsilon收集器" class="headerlink" title="Epsilon收集器"></a>Epsilon收集器</h3><p>从JDK 10开始，为了隔离垃圾收集器与Java虚拟机解释、编译、监控等子系统的关系,RedHat提出了垃圾收集器的统一接口，即JEP 304提案，Epsilon是这个接口的有效性验证和参考实现，同时也用于需要剥离垃圾收集器影响的性能测试和压力测试。<br>近年来大型系统从传统单体应用向微服务化、无服务化方向发展的趋势已越发明显，Java在这方面比起Golang等后起之秀来确实有一些先天不足，使用率正渐渐下降。传统Java有着内存占用较大，在容器中启动时间长，即时编译需要缓慢优化等特点，这对大型应用来说并不是什么太大的问题，但对短时间、小规模的服务形式就有诸多不适。为了应对新的技术潮流，最近几个版本的JDK逐渐加入了提前编译、面向应用的类数据共享等支持。Epsilon也是有着类似的目标，如果客户应用只要运行数分钟甚至数秒，只要Java虚拟机能正确分配内存，在堆耗尽之前就会退出，那显然运行负载极小、没有任何回收行为的Epsilon便是很恰当的选择。</p>
<h3 id="收集器的权衡"><a href="#收集器的权衡" class="headerlink" title="收集器的权衡"></a>收集器的权衡</h3><p>选择合适的垃圾收集器的因素主要有三个：</p>
<ul>
<li>应用程序的关注点：<ul>
<li>吞吐量（如果是数据分析、科学计算类的任务、异步实时性追求不高的后台任务，目标是能尽快算出更多的结果，那吞吐量就是主要关注点）。 </li>
<li>停顿时间（如果是SLA应用、服务影响时间要求高的应用、抢购服务等，那停顿时间直接影响服务质量，严重的甚至会导致事务超时，这样延迟就是主要关注点）。</li>
<li>内存占用（如果是客户端应用或者嵌入式应用、内存资源紧张的机器，那垃圾收集的内存占用则是不可忽视的）。</li>
</ul>
</li>
<li>运行应用的基础设施：<ul>
<li>硬件规格，要涉及的系统架构是x86-32&#x2F;64、SPARC还是ARM&#x2F;Aarch64;</li>
<li>处理器的数量多少，分配内存的大小;</li>
<li>选择的操作系统是Linux、Solaris 还是Windows等。</li>
</ul>
</li>
<li>使用JDK的发行商是什么?<ul>
<li>版本号是多少?是ZingJDK&#x2F;Zulu、OracleJDK、Open-DK、OpenJ9抑或是其他公司的发行版?</li>
<li>该JDK对应了《Java虚拟机规范》的哪个版本?</li>
</ul>
</li>
</ul>
<h3 id="虚拟机和垃圾收集器日志"><a href="#虚拟机和垃圾收集器日志" class="headerlink" title="虚拟机和垃圾收集器日志"></a>虚拟机和垃圾收集器日志</h3><ul>
<li>在JDK 9以前，HotSpot并没有提供统一的日志处理框架，虚拟机各个功能模块的日志开关分布在不同的参数上，日志级别、循环日志大小、输出格式、重定向等设置在不同功能上都要单独解决。</li>
<li>直到JDK9,HotSpot所有功能的日志都收归到了“-Xlog”参数上，这个参数的能力也相应被极大拓展了:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Xlog[:[selector][:[output][:[decorators][:output-options]]]]</span><br></pre></td></tr></table></figure>
<img src="https://gitee.com/fengorz/oss/raw/master/uPic/ieuLlX.png"><blockquote>
<p>参数详细用法可以参考周志明老师的书或者官方文档。</p>
</blockquote>
</li>
</ul>
<h2 id="内存分配和策略回收"><a href="#内存分配和策略回收" class="headerlink" title="内存分配和策略回收"></a>内存分配和策略回收</h2><p>Java技术体系的自动内存管理，最根本的目标是自动化地解决两个问题：</p>
<ul>
<li>自动给对象分配内存；</li>
<li>自动回收分配给对象的内存。</li>
</ul>
<h3 id="对象优先分配在Eden空间"><a href="#对象优先分配在Eden空间" class="headerlink" title="对象优先分配在Eden空间"></a>对象优先分配在Eden空间</h3><p>对象优先分配在Eden空间，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。<br>HotSpot虚拟机提供了<code>-XX: +PrintGCDetails</code>这个收集器日志参数。</p>
<blockquote>
<p>BOILERPLATE:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 测试对象优先分配在Eden空间</span><br><span class="line"> *</span><br><span class="line"> * -verbose:gc</span><br><span class="line"> * -Xms20M</span><br><span class="line"> * -Xmx20M</span><br><span class="line"> * -Xmn10M</span><br><span class="line"> * -XX:+PrintGCDetails</span><br><span class="line"> * -XX:SurvivorRatio=8</span><br><span class="line"> *</span><br><span class="line"> * 限制Java大小为20MB，不可扩展，10MB分配给Minor，剩下10MB给Major</span><br><span class="line"> * Minor所在Eden空间与Survivor From空间的默认比率是8:1（Minor GC时存活对象从Eden移步到Survivor From时）</span><br><span class="line"> *</span><br><span class="line"> * @Author zhanshifeng</span><br><span class="line"> * @Date 2020/9/24 4:16 PM</span><br><span class="line"> */</span><br><span class="line">public class PrioritizedEdenAllocation &#123;</span><br><span class="line">    private final static int _1MB = 1024 * 1024;</span><br><span class="line"></span><br><span class="line">    public static void test() &#123;</span><br><span class="line">        byte[] allocation1 = new byte[2 * _1MB];</span><br><span class="line">        byte[] allocation2 = new byte[2 * _1MB];</span><br><span class="line">        byte[] allocation3 = new byte[2 * _1MB];</span><br><span class="line">        /**</span><br><span class="line">         * -Xmn给到Minor只有10MB，这个时候，上面已经消耗掉6个MB了，</span><br><span class="line">         * 剩下的4MB不足以分配给4MB大小的allocation4，</span><br><span class="line">         * 故Eden空间不足，出现一次Minor GC。</span><br><span class="line">         * GC期间虚拟机又发现已有的三个2MB大小的对象全部无法放入Survivor From空间(Survivor From空间只有1MB大小)</span><br><span class="line">         * 于是触发分配担保机制(Handle Promotion)，allocation1、allocation2、allocation3被转移到Major</span><br><span class="line">         * 最后allocation4被成功分配达到Eden，此时Survivor空闲</span><br><span class="line">         */</span><br><span class="line">        byte[] allocation4 = new byte[4 * _1MB]; // GC</span><br><span class="line"></span><br><span class="line">        // Heap</span><br><span class="line">        // PSYoungGen total 9216K, used 7988K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">        // eden space 8192K, 97% used [0x00000007bf600000,0x00000007bfdcd1a0,0x00000007bfe00000)</span><br><span class="line">        // from space 1024K, 0% used [0x00000007bff00000,0x00000007bff00000,0x00000007c0000000)</span><br><span class="line">        // to   space 1024K, 0% used [0x00000007bfe00000,0x00000007bfe00000,0x00000007bff00000)</span><br><span class="line">        // ParOldGen       total 10240K, used 4096K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">        // 实际上这里的GC之后的老年代的10MB只使用到4MB，应该是Minor GC只回收了前面连个对象就足以分配allocation4了，所以没有回收第三个对象</span><br><span class="line">        // object space 10240K, 40% used [0x00000007bec00000,0x00000007bf000010,0x00000007bf600000)</span><br><span class="line">        // Metaspace       used 3050K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">        // class space    used 333K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        test();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h3><p>大对象就是指需要大量连续内存空间的Java对象，最典型的大对象便是那种很长的字符串，或者元素数量很庞大的数组。<br>比遇到大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，我们写程序的时候应注意避免。<br>在Java虚拟机中要避免大对象的原因是，在分配空间时，它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置好它们，而当复制对象时，大对象就意味着高额的内存复制开销。HotSpot虚拟机提供了<code>-XX:PretenureSizeThreshold</code>参数， 指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 其他参数同上</span><br><span class="line"> * -XX:+UseSerialGC（下面参数在Parallel Scavenge不支持）</span><br><span class="line"> * -XX:PretenureSizeThreshold=3145728</span><br><span class="line"> */</span><br><span class="line">public static void testPretenureSizeThreshold()&#123;</span><br><span class="line">    byte[] allocation4 = new byte[4 * _1MB]; // 直接分配到老年代了</span><br><span class="line"></span><br><span class="line">    // Heap</span><br><span class="line">    // def new generation   total 9216K, used 1844K [0x00000007bec00000, 0x00000007bf600000, 0x00000007bf600000)</span><br><span class="line">    // eden space 8192K,  22% used [0x00000007bec00000, 0x00000007bedcd170, 0x00000007bf400000)</span><br><span class="line">    // from space 1024K,   0% used [0x00000007bf400000, 0x00000007bf400000, 0x00000007bf500000)</span><br><span class="line">    // to   space 1024K,   0% used [0x00000007bf500000, 0x00000007bf500000, 0x00000007bf600000)</span><br><span class="line">    // tenured generation   total 10240K, used 4096K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">    // 下面这行可以看到老年代被占用。</span><br><span class="line">    // the space 10240K,  40% used [0x00000007bf600000, 0x00000007bfa00010, 0x00000007bfa00200, 0x00000007c0000000)</span><br><span class="line">    // Metaspace       used 2981K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">    // class space    used 328K, capacity 388K, committed 512K, reserved 1048576K</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个对象年龄(Age)计数器，存储在对象头中。对象通常在Eden区里诞生，如果经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象年龄设为1岁。<br>对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度(默认为15)，就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数<code>-XX:MaxTenuringThreshold</code>设置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 其他参数同上</span><br><span class="line"> * -XX:MaxTenuringThreshold=1</span><br><span class="line"> * -XX:+PrintTenuringDistribution</span><br><span class="line"> */</span><br><span class="line">public static void testTenuringThreshold() &#123;</span><br><span class="line">    byte[] allocation1 = new byte[_1MB / 4];</span><br><span class="line">    byte[] allocation2 = new byte[4 * _1MB];</span><br><span class="line">    byte[] allocation3 = new byte[4 * _1MB]; // Eden控件这个时候不足4MB，进行第一次MinorGC，将allocation1移到Survivor From空间，将allocation2移到Major</span><br><span class="line">    System.out.println(&quot;------------&quot;);</span><br><span class="line">    allocation3 = null; </span><br><span class="line">    allocation3 = new byte[4 * _1MB]; // 手动第二次GC，allocation1年龄是2，进入Major</span><br><span class="line">    System.out.println(&quot;------------&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="动态对象年龄判定"><a href="#动态对象年龄判定" class="headerlink" title="动态对象年龄判定"></a>动态对象年龄判定</h3><p>如果在Survivor空间中的一批相同年龄的对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到-XX:MaxTenuringThreshold中要求的年龄。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 其他参数同上</span><br><span class="line"> * -XX:MaxTenuringThreshold=15</span><br><span class="line"> * -XX:+PrintTenuringDistribution</span><br><span class="line"> */</span><br><span class="line">public static void testTenuringThreshold2() &#123;</span><br><span class="line">    byte[] allocation1 = new byte[_1MB / 4];</span><br><span class="line">    byte[] allocation2 = new byte[_1MB / 4]; // allocation1、allocation2加起来大于survivor空间的一半</span><br><span class="line">    byte[] allocation3 = new byte[4 * _1MB];</span><br><span class="line">    byte[] allocation4 = new byte[4 * _1MB]; // Eden空间不足，第一次GC，allocation1、allocation2直接进入Major，而非Survivor</span><br><span class="line">    System.out.println(&quot;------------&quot;);</span><br><span class="line">    allocation4 = null;</span><br><span class="line">    allocation4 = new byte[4 * _1MB];</span><br><span class="line">    System.out.println(&quot;------------&quot;);// 手动第二次GC，allocation3也进入Major，所以tenured generation占用48%</span><br><span class="line">    // tenured generation   total 10240K, used 4967K [0x00000007bf600000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">    // the space 10240K,  48% used [0x00000007bf600000, 0x00000007bfad9f80, 0x00000007bfada000, 0x00000007c0000000)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h3><p>在发生MinorGC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这次Minor GC可以确保是安全的。如果不成立，则虛拟机会先查看-XX: HandlePromotionFailure参数的设置值是否允许担保失败(Handle Promotion Failure) ，如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，就会进行Minor GC（这是一个<em><strong>冒险</strong></em>行为）。<br>JDK 6 Update24之前还会做多一层判断：</p>
<ul>
<li>如果大于，将尝试进行一次Minor GC,尽管这次Minor GC是有风险的;</li>
<li>如果小于，或者-XX:HandlePromotionFailure设置不允许冒险，那这时就要改为进行一次Full GC。</li>
</ul>
<h4 id="冒险"><a href="#冒险" class="headerlink" title="冒险"></a>冒险</h4><p>新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在MinorGC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），需要老年代进行分配担保，把Survivor无法容纳的对象直接送入老年代，这与生活中信用贷款担保类似。老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，但一共有多少对象会在这次回收中活下来在实际完成内存回收之前是无法明确知道的，所以<em><strong>只能取之前每一次回收晋升到老年代对象容量的平均大小作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。</strong></em><br>取历史平均值来比较其实仍然是一种赌概率的解决办法，如果赌输了（Minor GC失败），那就只能Full GC，</p>
<h2 id="各个JDK版本使用的默认GC收集器"><a href="#各个JDK版本使用的默认GC收集器" class="headerlink" title="各个JDK版本使用的默认GC收集器"></a>各个JDK版本使用的默认GC收集器</h2><p>JDK default garbage collectors：</p>
<ul>
<li>Java 7：Parallel GC</li>
<li>Java 8：Parallel GC</li>
<li>Java 9：G1 GC</li>
<li>Java 10：G1 GC</li>
</ul>
<h1 id="虚拟机性能监控、故障处理工具"><a href="#虚拟机性能监控、故障处理工具" class="headerlink" title="虚拟机性能监控、故障处理工具"></a>虚拟机性能监控、故障处理工具</h1><h2 id="基础故障处理工具（命令行）"><a href="#基础故障处理工具（命令行）" class="headerlink" title="基础故障处理工具（命令行）"></a>基础故障处理工具（命令行）</h2><h3 id="jps"><a href="#jps" class="headerlink" title="jps"></a>jps</h3><ul>
<li>类似Unix的ps命令，可以列出正在运行的虚拟机进程，并显示虚拟机执行主类(Main Class，main()函数所在的类)名称以及这些进程的本地虚拟机唯一ID (LVMID， Local Virtual Machine Identifier) 。</li>
<li>对于本地虚拟机进程来说，LVMID与操作系统的进程ID(PID, Process Identifier)是一致的，使用Windows的任务管理器或者UNIX的ps命令也可以查询到虚拟机进程的LVMID，但如果同时启动了多个虚拟机进程，无法根据进程名称定位时，那就必须依赖jps命令显示主类的功能才能区分了。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/Ypeo0b.png"></li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./jps -l</span><br><span class="line">21618 me.fengorz.kiwi.gateway.GatewayApplication</span><br><span class="line">21443 me.fengorz.kiwi.eureka.EurekaApplication</span><br><span class="line">21624 me.fengorz.kiwi.auth.AuthApplication</span><br><span class="line">21609 me.fengorz.kiwi.admin.UpmsApplication</span><br><span class="line">21642 /Users/zhanshifeng/Documents/myDocument/idea-project/microservice-kiwi/kiwi-common/kiwi-common-sdk/target/surefire/surefirebooter5682934295796544847.jar</span><br><span class="line">5005</span><br><span class="line">21645 sun.tools.jps.Jps</span><br><span class="line">21438 me.fengorz.kiwi.config.ConfigApplication</span><br><span class="line">21631 org.codehaus.classworlds.Launcher</span><br><span class="line">21359</span><br></pre></td></tr></table></figure>
<h3 id="jstatd"><a href="#jstatd" class="headerlink" title="jstatd"></a>jstatd</h3><p>需要远程主机提供RMI支持，JDK中提供了jstatd工具可以很方便地建立远程RMI服务器。<br><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/windows/jstatd.html#:~:text=Description,registry%20on%20the%20local%20host.">官方文档</a></p>
<h3 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h3><p>jstat (JVM Statistics Monitoring Tool)是用于监视虚拟机各种运行状态信息的命令行工具。它可以显示本地或者远程虚拟机进程中的类加载、内存、垃圾收集、即时编译等运行时数据。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/vKxXCM.png"></p>
<p><a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html">JDK 8的jstat官方手册</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># 每250秒查询一次进程21443的垃圾收集情况，一共查询20次</span><br><span class="line">./jstat -gc 21443 250 20</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./jstat -gcutil 21443</span><br><span class="line">  S0     S1     E      O      M     CCS    YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line"> 67.19   0.00  77.24  71.45  94.54  92.87     74    0.164     2    0.092    0.256</span><br><span class="line"># S0、S1表示Survivor0、Survivor1</span><br><span class="line"># E表示新生代Eden区，已经使用了77.24%</span><br><span class="line"># O表示老年代</span><br><span class="line"># M表示Meta Space（元空间）</span><br><span class="line"># CCS：Compressed class space utilization as a percentage.（压缩类空间利用率百分比）</span><br><span class="line"># YGC表示发生Minor GC（Young GC）的次数</span><br><span class="line"># YGCT: Young generation garbage collection time.（YGC的总耗时）</span><br><span class="line"># FGC表示Full GC次数</span><br><span class="line"># FGCT表示FGC总耗时</span><br><span class="line"># GCT表示所有GC总耗时</span><br></pre></td></tr></table></figure>
<h3 id="jinfo（Java配置信息工具）"><a href="#jinfo（Java配置信息工具）" class="headerlink" title="jinfo（Java配置信息工具）"></a>jinfo（Java配置信息工具）</h3><p>jinfo (Configuration Info for Java)的作用是实时查看和调整虚拟机各项参数（只能对可在运行时修改的参数生效）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Usage:</span><br><span class="line">    jinfo &lt;option&gt; &lt;pid&gt;</span><br><span class="line">       (to connect to a running process)</span><br><span class="line"></span><br><span class="line">where &lt;option&gt; is one of:</span><br><span class="line">    -flag &lt;name&gt;         to print the value of the named VM flag</span><br><span class="line">    -flag [+|-]&lt;name&gt;    to enable or disable the named VM flag</span><br><span class="line">    -flag &lt;name&gt;=&lt;value&gt; to set the named VM flag to the given value</span><br><span class="line">    -h | -help           to print this help message</span><br></pre></td></tr></table></figure>
<h3 id="jmap（Java内存映射工具）"><a href="#jmap（Java内存映射工具）" class="headerlink" title="jmap（Java内存映射工具）"></a>jmap（Java内存映射工具）</h3><p>jmap (Memory Map for Java)命令用于生成堆转储快照(般称为heapdump或dump文件)。<br>也可以使用参数<code>-XX:+HeapDumpOnOutOfMemoryError</code>“暴力”拿到hump文件。</p>
<h4 id="jmap的其他作用"><a href="#jmap的其他作用" class="headerlink" title="jmap的其他作用"></a>jmap的其他作用</h4><p>还可以查询finalize执行队列、Java堆和方法区的详细信息，如空间使用率、当前用的是哪种收集器等。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/5CDON2.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">jmap -dump:format=b,file=test.bin pid</span><br></pre></td></tr></table></figure>
<h3 id="jhat（虚拟机堆转储快照分析工具）"><a href="#jhat（虚拟机堆转储快照分析工具）" class="headerlink" title="jhat（虚拟机堆转储快照分析工具）"></a>jhat（虚拟机堆转储快照分析工具）</h3><p>jhat（JVM Heap Analysis Tool）命令可以与jmap搭配使用，来分析jmap生成的堆转储快照。jhat内置了一个微型的HTTP&#x2F;Web服务器，生成堆转储快照的分析结果后，可以在浏览器中查看。<br>不过一般不会在部署应用程序的服务器上直接分析堆转储快照，即使可以这样做，也会尽量将堆转储快照文件复制到其他机器上进行分析。</p>
<h3 id="jstack：Java堆跟踪工具"><a href="#jstack：Java堆跟踪工具" class="headerlink" title="jstack：Java堆跟踪工具"></a>jstack：Java堆跟踪工具</h3><p>jstack (Stack Trace for Java)命令用于生成虚拟机当前时刻的线程快照(一般称为threaddump或者javacore文件)。<br>线程快照就是当前虚拟机内每一条线程<code>正在执行的方法堆栈的集合</code>，生成线程快照的目的通常是定位线程出现长时间停顿的原因，如<code>线程间死锁</code>、<code>死循环</code>、<code>请求外部资源导致的长时间挂起</code>等，都是导致线程长时间停顿的常见原因。线程出现停顿时通过jstack来查看各个线程的调用堆栈，就可以获知没有响应的线程到底在后台做些什么事情，或者等待着什么资源。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/jcikU1.png"><br>通过<code>java.lang.Thread</code>的getAllStackTraces()获取虚拟机所有线程的StackTraceElement对象，也可以查看线程状况。</p>
<h2 id="可视化故障处理工具"><a href="#可视化故障处理工具" class="headerlink" title="可视化故障处理工具"></a>可视化故障处理工具</h2><ul>
<li>JConsole（最古老）</li>
<li>JHSDB（JDK 9之后才正式提供）</li>
<li>VisualVM</li>
<li>Java Mission Control（JMC）</li>
</ul>
<h3 id="JHSDB（基于服务性代理的调试工具）"><a href="#JHSDB（基于服务性代理的调试工具）" class="headerlink" title="JHSDB（基于服务性代理的调试工具）"></a>JHSDB（基于服务性代理的调试工具）</h3><p>JHSDB比老工具更好用、更强大，是一款基于服务性代理(Serviceability Agent, SA)实现的进程外调试工具。服务性代理是HotSpot虚拟机中一组用于映射Java虚拟机运行信息的、主要基于Java数据结构为参照物进行设计，把这些C++的数据抽象出Java模型对象，相当于HotSpot的C++代码的一个镜像。通过服务性代理的API,可以在一个独立的Java虚拟机的进程里分析其他HotSpot虚拟机的内部数据，或者从HotSpot虚拟机进程内存中dump出来的转储快照里还原出它的运行状态细节。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Description 测试JHSDB故障分析工具</span><br><span class="line"> * @Author zhanshifeng</span><br><span class="line"> * @Date 2020/9/26 10:11 AM</span><br><span class="line"> */</span><br><span class="line">public class JHSDBTest &#123;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * taticObj随着Test的类型信息存放在方法区；</span><br><span class="line">     * instanceObj随着Test的对象实例存放在Java堆；</span><br><span class="line">     * localObj则是存放在foo方法栈帧的局部变量表中。</span><br><span class="line">     */</span><br><span class="line">    static class Test &#123;</span><br><span class="line">        static ObjectHolder staticObj = new ObjectHolder();</span><br><span class="line">        ObjectHolder instanceObj = new ObjectHolder();</span><br><span class="line"></span><br><span class="line">        void foo() &#123;</span><br><span class="line">            ObjectHolder localObj = new ObjectHolder();</span><br><span class="line">            System.out.println(&quot;done&quot;);// 打断点</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class ObjectHolder &#123;&#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * VM Options:</span><br><span class="line">     * -Xmx10m</span><br><span class="line">     * -XX:+UseSerialGC</span><br><span class="line">     * -XX:-UseCompressedOops</span><br><span class="line">     *</span><br><span class="line">     * @param args</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Test test = new JHSDBTest.Test();</span><br><span class="line">        test.foo();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * ./jps -l</span><br><span class="line">     * 6019 me.fengorz.jvm.jhsdb.JHSDBTest</span><br><span class="line">     *</span><br><span class="line">     * ./jhsdb hsdb -pid 6019</span><br><span class="line">     *</span><br><span class="line">     * 通过Tools-&gt;Heep Parameters复制Eden里面对象实例的内存地址</span><br><span class="line">     * scanoops 0x0000000124c00000 0x0000000124e9ee58 0x0000000124eb0000</span><br><span class="line">     * 可以追寻到以下结果：</span><br><span class="line">     * 0x0000000115c93d00 me/fengorz/jvm/jhsdb/JHSDBTest$Test</span><br><span class="line">     * 0x0000000115c93cf0 me/fengorz/jvm/jhsdb/JHSDBTest$ObjectHolder</span><br><span class="line">     * 0x0000000115c93d18 me/fengorz/jvm/jhsdb/JHSDBTest$ObjectHolder</span><br><span class="line">     * 0x0000000115c93d28 me/fengorz/jvm/jhsdb/JHSDBTest$ObjectHolder</span><br><span class="line">     *</span><br><span class="line">     * 通过Tools-&gt;Inspector确认三个实例地址存放的具体内容</span><br><span class="line">     * _metadata._klass: InstanceKlass for me/fengorz/jvm/jhsdb/JHSDBTest$ObjectHolder</span><br><span class="line">     * _super: InstanceKlass for java/lang/Object</span><br><span class="line">     * _layout_helper: 16</span><br><span class="line">     * _access_flags: 538968096</span><br><span class="line">     * _subklass: null</span><br><span class="line">     * _next_sibling: InstanceKlass for me/fengorz/jvm/jhsdb/JHSDBTest$Test</span><br><span class="line">     * _vtable_len: 5</span><br><span class="line">     * _array_klasses: null</span><br><span class="line">     * _nonstatic_field_size: 0</span><br><span class="line">     * _static_field_size: 0</span><br><span class="line">     * _static_oop_field_count: 0</span><br><span class="line">     * _nonstatic_oop_map_size: 0</span><br><span class="line">     * _is_marked_dependent: 0</span><br><span class="line">     * _init_state: 4</span><br><span class="line">     * _itable_len: 2</span><br><span class="line">     */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据Inspector的结果可以得到对象头和指向对象元数据的指针，里面包括了：</p>
<ul>
<li>Java类型的名字、继承关系、实现接口关系</li>
<li>字段信息、方法信息、运行时常量池的指针、内嵌的虚方法表(vtable) 以及接口方法表(itable) 等。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hsdb&gt; revptrs 0x0000000115c93cf0</span><br><span class="line">null</span><br><span class="line">Oop for java/lang/Class @ 0x0000000115c92288</span><br></pre></td></tr></table></figure>
<p>通过Inspector查看<code>0x0000000115c92288</code>地址对应的对象实例具体内容：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/f7me0O.png"><br>至此，可以看出上面内存地址的<code>0x0000000115c93cf0</code>对象实例，被内存地址为<code>0x0000000115c92288</code>的实例对象所引用，这就正好对照了Test类里面声明了静态的ObjectHolder类型的变量staticObj。<br>继续跟踪第二个对象实例内存地址在哪里被引用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hsdb&gt; revptrs 0x0000000115c93d18</span><br><span class="line">Oop for me/fengorz/jvm/jhsdb/JHSDBTest$Test @ 0x0000000115c93d00</span><br></pre></td></tr></table></figure>
<p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/hkJyDV.png"><br>可以看出：内存地址为<code>0x0000000115c93d18</code>的实例被内存地址为<code>0x0000000115c93d00</code>的实例所引用，这就对照了上面代码的这句：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ObjectHolder instanceObj = new ObjectHolder();</span><br></pre></td></tr></table></figure>
<p>跟踪第三个内存地址时出现null：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hsdb&gt; revptrs 0x0000000115c93d28</span><br><span class="line">null</span><br></pre></td></tr></table></figure>
<p>这是因为第三个对象实例是方法栈里面产生的：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void foo() &#123;</span><br><span class="line">   ObjectHolder localObj = new ObjectHolder();</span><br><span class="line">   System.out.println(&quot;done&quot;);// 打断点</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>revptrs不支持跟踪栈上的指针引用，可以换成在Java Threads窗口选中main线程，然后打开上面的Stack Memory for main：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/yBkGU4.png"></p>
<h3 id="JConsole（Java监视与管理控制台）"><a href="#JConsole（Java监视与管理控制台）" class="headerlink" title="JConsole（Java监视与管理控制台）"></a>JConsole（Java监视与管理控制台）</h3><p>JConsole (Java Monitoring and Management Console)是一款基于JMX (JavaManagement Extensions)的可视化监视、管理工具。它的主要功能是通过JMX的MBean (Managed Bean)对系统进行信息收集和参数动态调整。<br>其Memory标签相当于可视化的jstat命令，Threads标签相当于可视化的jstack命令。<br>Threads标签使用测试代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ThreadTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void createBusyThread() &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            while (true) &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;testBusyThread&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private final static Object lock = new Object();</span><br><span class="line"></span><br><span class="line">    public static void createLockThread() &#123;</span><br><span class="line">        new Thread(() -&gt; &#123;</span><br><span class="line">            synchronized (lock) &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    lock.wait();</span><br><span class="line">                &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, &quot;testLockThread&quot;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class SyncAdd implements Runnable &#123;</span><br><span class="line">        int a, b;</span><br><span class="line"></span><br><span class="line">        public SyncAdd(int a, int b) &#123;</span><br><span class="line">            this.a = a;</span><br><span class="line">            this.b = b;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            synchronized (Integer.valueOf(a)) &#123;</span><br><span class="line">                synchronized (Integer.valueOf(b)) &#123;</span><br><span class="line">                    System.out.println(a + b);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 为了做实验的机器资源安全，可以加上限制：</span><br><span class="line">     * -Xms500m</span><br><span class="line">     * -Xmx500m</span><br><span class="line">     *</span><br><span class="line">     * @param args</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        // BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));</span><br><span class="line">        // reader.readLine();</span><br><span class="line">        // createBusyThread();</span><br><span class="line">        // reader.readLine();</span><br><span class="line">        // createLockThread();</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; 500; i++) &#123;</span><br><span class="line">            new Thread(new SyncAdd(1, 2)).start();</span><br><span class="line">            new Thread(new SyncAdd(2, 1)).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Name: testBusyThread</span><br><span class="line">     * State: RUNNABLE</span><br><span class="line">     * Total blocked: 0  Total waited: 0</span><br><span class="line">     *</span><br><span class="line">     * Stack trace:</span><br><span class="line">     * app//me.fengorz.jvm.jconsole.ThreadTest.lambda$createBusyThread$0(ThreadTest.java:15)</span><br><span class="line">     * app//me.fengorz.jvm.jconsole.ThreadTest$$Lambda$96/0x000000080019b840.run(Unknown Source)</span><br><span class="line">     * java.base@11.0.8/java.lang.Thread.run(Thread.java:834)</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Name: testLockThread</span><br><span class="line">     * State: WAITING on java.lang.Object@b847d8d</span><br><span class="line">     * Total blocked: 0  Total waited: 1</span><br><span class="line">     *</span><br><span class="line">     * Stack trace:</span><br><span class="line">     * java.base@11.0.8/java.lang.Object.wait(Native Method)</span><br><span class="line">     * java.base@11.0.8/java.lang.Object.wait(Object.java:328)</span><br><span class="line">     * app//me.fengorz.jvm.jconsole.ThreadTest.lambda$createLockThread$1(ThreadTest.java:27)</span><br><span class="line">     * app//me.fengorz.jvm.jconsole.ThreadTest$$Lambda$97/0x000000080019cc40.run(Unknown Source)</span><br><span class="line">     * java.base@11.0.8/java.lang.Thread.run(Thread.java:834)</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 太多SyncAdd线程产生死锁之后可以点击JConsole的Detect Deadlock探测死锁。</span><br><span class="line">     *</span><br><span class="line">     * Name: Thread-45</span><br><span class="line">     * State: BLOCKED on java.lang.Integer@2f98ef2a owned by: Thread-48</span><br><span class="line">     * Total blocked: 2  Total waited: 0</span><br><span class="line">     *</span><br><span class="line">     * Stack trace:</span><br><span class="line">     * app//me.fengorz.jvm.jconsole.ThreadTest$SyncAdd.run(ThreadTest.java:45)</span><br><span class="line">     *    - locked java.lang.Integer@d0dcf29</span><br><span class="line">     * java.base@11.0.8/java.lang.Thread.run(Thread.java:834)</span><br><span class="line">     *</span><br><span class="line">     * ----------------</span><br><span class="line">     *</span><br><span class="line">     * Name: Thread-48</span><br><span class="line">     * State: BLOCKED on java.lang.Integer@d0dcf29 owned by: Thread-45</span><br><span class="line">     * Total blocked: 2  Total waited: 0</span><br><span class="line">     *</span><br><span class="line">     * Stack trace:</span><br><span class="line">     * app//me.fengorz.jvm.jconsole.ThreadTest$SyncAdd.run(ThreadTest.java:45)</span><br><span class="line">     *    - locked java.lang.Integer@2f98ef2a</span><br><span class="line">     * java.base@11.0.8/java.lang.Thread.run(Thread.java:834)</span><br><span class="line">     *</span><br><span class="line">     * 可以发现两个线程在相互等待锁的释放：</span><br><span class="line">     * State: BLOCKED on java.lang.Integer@2f98ef2a owned by: Thread-48</span><br><span class="line">     * State: BLOCKED on java.lang.Integer@d0dcf29 owned by: Thread-45</span><br><span class="line">     */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="VisualVM（多合-故障处理工具）"><a href="#VisualVM（多合-故障处理工具）" class="headerlink" title="VisualVM（多合-故障处理工具）"></a>VisualVM（多合-故障处理工具）</h3><p>VisualVM (A1l-in-One Java Troubleshooting Tool)是功能最强大的运行监视和故障处理程序之一，曾经在很长一段时间内是Oracle官方主力发展的虚拟机故障处理工具。VisualVM的功能有：</p>
<ul>
<li>显示虚拟机进程以及进程的配置、环境信息(jps、jinfo)。</li>
<li>监视应用程序的处理器、垃圾收jstack)。</li>
<li>dump以及分析堆转储快照(jmap、jhat)。</li>
<li>方法级的程序运行性能分析，找出被调用最多、运行时间最长的方法。</li>
<li>离线程序快照:收集程序的运行时配置、线程dump、 内存dump等信息建立一个快照，可以将快照发送开发者处进行Bug反馈。</li>
<li>其他插件带来的无限可能性。</li>
</ul>
<h3 id="Java-Mission-Control（可持续在线的监控工具）"><a href="#Java-Mission-Control（可持续在线的监控工具）" class="headerlink" title="Java Mission Control（可持续在线的监控工具）"></a>Java Mission Control（可持续在线的监控工具）</h3><p>Oracle Java SE Advanced &amp; Suite（Advanced是” Advanced Monitoring &amp; Management of Java in the Enterprise” ）与普通Oracle Java SE在功能上的主要差别是前者包含了一系列的监控、管理工具，譬如用于企业JRE定制管理的AMC (Java Advanced Management Console)控制台、JUT (Java Usage Tracker)跟踪系统，用于持续收集数据的JFR(Java Flight Recorder)飞行记录仪和用于监控Java虚拟机的JMC (Java Mission Control)。这些功能全部都是需要商业授权才能在生产环境中使用，但根据Oracle Binary Code协议，在个人开发环境中，允许免费使用JMC和JFR。<br>JMC的作用：</p>
<ul>
<li>作为JMX控制台，显示来自虚拟机MBean提供的数据;</li>
<li>另一方面作为JFR的分析工具，展示来自JFR的数据。</li>
</ul>
<h4 id="JFR"><a href="#JFR" class="headerlink" title="JFR"></a>JFR</h4><p>JFR是一套内建在HotSpot虚拟机里面的监控和基于事件的信息搜集框架，与其他的监控工具(如JProfiling)相比，Oracle特别强调它“可持续在线”(Always-On)的特性。JFR在生产环境中对吞吐量的影响一般不会高于1% (甚至号称是Zero Performance Overhead)，而且JFR监控过程的开始、停止都是完全可动态的，即不需要重启应用。<br>JFR包含以下几类信息：</p>
<ul>
<li>一般信息：关于虚拟机、操作系统和记录的一般信息。</li>
<li>内存：关于内存管理和垃圾收集的信息。</li>
<li>代码：关于方法、异常错误、编译和类加载的信息。</li>
<li>线程：关于应用程序中线程和锁的信息。</li>
<li>I&#x2F;O：关于文件和套接字输入、输出的信息。</li>
<li>系统：关于正在运行Java虚拟机的系统、进程和环境变量的信息。</li>
<li>事件：关于记录中的事件类型的信息，可以根据线程或堆栈跟踪，按照日志或图形的格式查看。</li>
</ul>
<p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/Qal5eB.png"></p>
<h4 id="被监控端启动参数"><a href="#被监控端启动参数" class="headerlink" title="被监控端启动参数"></a>被监控端启动参数</h4><blockquote>
<p><a href="https://docs.oracle.com/javase/9/management/java-discovery-protocol.htm#JSMGM-GUID-4FE44ECD-E1A7-42CE-9AD8-A2E582C55C43">Java Discovery Protocol (JDP)</a></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Dcom.sun.management.jmxremote.port=9999</span><br><span class="line">-Dcom.sun.management.jmxremote.ssl=false</span><br><span class="line">-Dcom.sun.management.jmxremote.authenticate=false</span><br><span class="line">-XX:+UnlockCommercialFeatures </span><br><span class="line">-XX:+FlightRecorder</span><br></pre></td></tr></table></figure>
<p>下面这个应该是向内网的安装JMC的机器广播自动发现的通知（Multicast address to send autodiscovery packets）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Dcom.sun.management.jdp.address=224.0.23.178</span><br></pre></td></tr></table></figure>

<h2 id="HotSpot虚拟机插件及工具"><a href="#HotSpot虚拟机插件及工具" class="headerlink" title="HotSpot虚拟机插件及工具"></a>HotSpot虚拟机插件及工具</h2><h3 id="HSDIS（JIT生成代码反编译）"><a href="#HSDIS（JIT生成代码反编译）" class="headerlink" title="HSDIS（JIT生成代码反编译）"></a>HSDIS（JIT生成代码反编译）</h3><p>HSDIS插件的作用是让HotSpot的<code>-XX:+PrintAssembly</code>指令调用它来把即时编译器动态生成的本地代码还原为汇编代码输出，同时还会自动产生大量非常有价值的注释，这样我们就可以通过输出的汇编代码来从最本质的角度分析问题。<br>JITWatch是HSDIS经常搭配使用的可视化的编译日志分析工具，为便于在JITWatch中读取，可以使用以下参数把日志输出到logfile文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-XX:+UnlockDiagnosticVMOptions</span><br><span class="line">-XX:+TraceClassLoading</span><br><span class="line">-XX:+LogCompilation</span><br><span class="line">-XX:LogFile=/tmp/logfile.log</span><br><span class="line">-XX:+PrintAssembly</span><br><span class="line">-XX:+TraceClassLoading</span><br></pre></td></tr></table></figure>

<h1 id="调优案例分析与实战"><a href="#调优案例分析与实战" class="headerlink" title="调优案例分析与实战"></a>调优案例分析与实战</h1><h2 id="大内存硬件上的程序部署策略"><a href="#大内存硬件上的程序部署策略" class="headerlink" title="大内存硬件上的程序部署策略"></a>大内存硬件上的程序部署策略</h2><p>目前单体应用在较大内存的硬件上主要的部署方式有两种：</p>
<h3 id="通过一个单独的Java虚拟机实例来管理大量的Java堆内存"><a href="#通过一个单独的Java虚拟机实例来管理大量的Java堆内存" class="headerlink" title="通过一个单独的Java虚拟机实例来管理大量的Java堆内存"></a>通过一个单独的Java虚拟机实例来管理大量的Java堆内存</h3><p>对于用户交互性强、对停顿时间敏感、内存又较大的系统，并不是一定要使用Shenandoah、ZGC这些明确以控制延迟为目标的垃圾收集器才能解决问题(当然这是最值得考虑的方案)。<br>使用Parallel Scavenge&#x2F;Old收集器，并且给Java虚拟机分配较大的堆内存也是有很多运行得很成功的案例的，但前提是必须把应用的Full GC频率控制得足够低，至少要低到不会在用户使用过程中发生，譬如十几个小时乃至一整天都不出现一次Full GC,这样可以通过在服务器空闲时执行定时任务的方式触发Full GC，甚至是自动重启应用服务器来保持内存可用空间在一个稳定的水平。<br>控制Full GC频率的关键是老年代的相对稳定，这主要取决于应用中绝大多数对象能否符合“朝生夕灭”的原则，即大多数对象的生存时间不应当太长，尤其是不能有成批量的、长生存时间的大对象产生，这样才能保障老年代空间的稳定。<br>在许多网站和B&#x2F;S形式的应用里，多数对象的生存周期都应该是请求级或者页面级的，会话级和全局级的长生命对象相对较少。<br>使用单个Java虚拟机实例来管理大内存，还需要考虑下面可能面临的问题：</p>
<ul>
<li>ZGC和Shenandoah这种低延迟的最好解决方案目前尚未完全成熟（在任意堆内存大小下都能很好地做到低延迟GC）。</li>
<li>大内存的情况下，64位虚拟机的性能测试结果普遍略低于相同版本的32位虚拟机。</li>
<li>必须保证应用程序足够稳定，因为这种大型单体应用要是发生了堆内存溢出，几乎无法产生堆转储快照（要产生十几GB乃至更大的快照文件），哪怕成功生成了快照也难以进行分析。如果确实出了问题要进行诊断，可能就必须应用JMC这种能够在生产环境中进行的运维工具。</li>
<li>在64位虚拟机中消耗的内存一般比32位虚拟机要大，这是由于指针膨胀，以及数据类型对齐补白等因素导致的，可以开启（默认即开启）压缩指针功能来缓解。</li>
</ul>
<h3 id="同时使用若干个Java虚拟机，建立逻辑集群来利用硬件资源"><a href="#同时使用若干个Java虚拟机，建立逻辑集群来利用硬件资源" class="headerlink" title="同时使用若干个Java虚拟机，建立逻辑集群来利用硬件资源"></a>同时使用若干个Java虚拟机，建立逻辑集群来利用硬件资源</h3><p>在一台物理机器上建立逻辑集群的目的仅仅是尽可能利用硬件资源，并不是要按职责、按领域做应用拆分，也不需要考虑状态保留、热转移之类的高可用性需求，不需要保证每个虚拟机进程有绝对准确的均衡负载，因此使用无Session复制的亲合式集群是一个相当合适的选择。<br>比如使用均衡器按一定的规则算法 (譬如根据Session ID&#x2F;Token ID分配)将一个固定的用户请求（或者某种类别的请求）永远分配到一个固定的集群节点进行处理即可，这样程序开发阶段就几乎不必为集群环境做任何特别的考虑。<br>逻辑集群方案可能会遇到的问题：</p>
<ul>
<li>节点竞争全局的资源，最典型的就是磁盘竞争，各个节点如果同时访问某个磁盘文件的话（尤其是并发写操作容易出现问题），很容易导致I&#x2F;O异常。</li>
<li>很难最高效率地利用某些资源池，譬如连接池，一般都是在各个节点建立自己独立的连接池，这样有可能导致一些节点的连接池已经满了，而另外一些节点仍有较多空余。尽管可以使用集中式的JNDI来解决，但这个方案有一定复杂性并且可能带来额外的性能代价。</li>
<li>如果使用32位Java虛拟机作为集群节点的话，各个节点仍然不可避免地受到32位的内存限制，在32位Windows平台中每个进程只能使用2GB的内存，考虑到堆以外的内存开销，堆最多一般只能开到1.5GB。在某些Linux或UNIX系统（如Solaris）中，可以提升到3GB乃至接近4GB的内存，但32位中仍然受最高4GB（2的32次幂）内存的限制。</li>
</ul>
<h2 id="堆外内存导致的内存溢出"><a href="#堆外内存导致的内存溢出" class="headerlink" title="堆外内存导致的内存溢出"></a>堆外内存导致的内存溢出</h2><p>直接内存占用太多资源也会导致溢出错误，在进行GC时，虚拟机虽然会对直接内存进行回收，但是直接内存却不能像新生代、老年代那样，发现空间不足了就主动通知收集器进行垃圾回收，它只能等待老年代满后Full GC出现后，“顺便”帮它清理掉内存的废弃对象。否则就不得不一直等到抛出内存溢出异常时，先捕获到异常，再在Catch块里面通过System.gc()命令来触发垃圾收集。<br>但如果Java虚拟机再打开了<code>-XX:+DisableExplicitGC</code>开关，禁止了人工触发垃圾收集的话，那就只能眼睁睁看着堆中还有许多空闲内存，自己却不得不抛出内存溢出异常了。</p>
<h2 id="外部命令导致系统缓慢（比如Shell脚本）"><a href="#外部命令导致系统缓慢（比如Shell脚本）" class="headerlink" title="外部命令导致系统缓慢（比如Shell脚本）"></a>外部命令导致系统缓慢（比如Shell脚本）</h2><h2 id="不合适的数据结构导致内存占用过大"><a href="#不合适的数据结构导致内存占用过大" class="headerlink" title="不合适的数据结构导致内存占用过大"></a>不合适的数据结构导致内存占用过大</h2><p>如果存在加载过量的资源到堆内存，比如要加载某个超大的文件资源到HashMap，有时候是非常危险的事情。</p>
<h1 id="虚拟机执行子系统"><a href="#虚拟机执行子系统" class="headerlink" title="虚拟机执行子系统"></a>虚拟机执行子系统</h1><h2 id="Class类文件结构"><a href="#Class类文件结构" class="headerlink" title="Class类文件结构"></a>Class类文件结构</h2><p>根据《Java虚拟机规范》的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”。</p>
<h3 id="无符号数"><a href="#无符号数" class="headerlink" title="无符号数"></a>无符号数</h3><p>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</p>
<h3 id="表"><a href="#表" class="headerlink" title="表"></a>表</h3><p>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表，这张表由以下图示的数据项按严格顺序排列构成。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/Bi0qtp.png"></p>
<h3 id="魔数与Class文件的版本"><a href="#魔数与Class文件的版本" class="headerlink" title="魔数与Class文件的版本"></a>魔数与Class文件的版本</h3><p>每个Class文件的头4个字节被称为魔数(Magic Number)，它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。使用魔数而不是扩展名来进行识别主要是基于安全考虑，因为文件扩展名可以随意改动。<br>紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号(Minor Version)，第7和第8个字节是主版本号(Major Version)。<br>Java的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1，高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件。</p>
<h3 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h3><p>紧接着主、次版本号之后的是常量池入口，由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值(constant_pool_count，计数从1开始，所以代表的真实常量数要减一)。<br>常量池中主要存放两大类常量:字面量(Literal)和符号引用(Symbolic References)。</p>
<h4 id="字面量（Literal）"><a href="#字面量（Literal）" class="headerlink" title="字面量（Literal）"></a>字面量（Literal）</h4><p>字面量比较接近于Java语言层面的常量概念，如文本字符串、被声明为final的常量值等。</p>
<h4 id="符号引用（Symbolic-References）"><a href="#符号引用（Symbolic-References）" class="headerlink" title="符号引用（Symbolic References）"></a>符号引用（Symbolic References）</h4><p>符号引用主要包括下面几类常量（编译层面）：</p>
<ul>
<li>被模块导出或者开放的包（Package）</li>
<li>类和接口的全限定名（Fully Qualified Name）</li>
<li>字段的名称和描述符（Descriptor）</li>
<li>方法的名称和描述符</li>
<li>方法句柄和方法类型（Method Handle、 Method Type、 Invoke Dynamic）</li>
<li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li>
</ul>
<p>Java代码在进行Javac编译的时候，在Class文件中不会保存各个方法、字段最终在内存中的布局信息，这些字段、方法的符号引用不经过虚拟机在运行期转换的话是无法得到真正的内存入口地址，也就无法直接被虚拟机使用的。<br>当虚拟机做类加载时，将会从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。截至JDK 13，常量表中分别有17种不同类型的常量。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/ALeJ6i.png"><br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/up775P.png"></p>
<p>CONSTANT_Class_info型常量的结构：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/w3K0KQ.png"></p>
<ul>
<li>tag是标志位，它用于区分常量类型；</li>
<li>name_index是常量池的索引值。</li>
</ul>
<p>CONSTANT_Utf8_info型常量的结构：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/KFeRHX.png"></p>
<ul>
<li>tag是标志位；</li>
<li>length值代表字符串长度是多少字节；</li>
<li>bytes是长度为length字节的连续数据，是一个使用UTF-8缩略编码表示的字符串。</li>
</ul>
<p><em><strong>由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，所以其最大长度也就是Java中方法、字段名的最大长度。而这里的最大长度就是length的最大值，既u2类型能表达的最大值65535。所以Java程序中如果定义了超过64KB英文字符的变量或方法名，即使规则和全部字符都是合法的，也会无法编译。</strong></em></p>
<p>剩余常量池的其他17种数据类型结构：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/7GAD7B.png"><br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/67k136.png"><br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/VH2Na3.png"></p>
<h3 id="访问标志"><a href="#访问标志" class="headerlink" title="访问标志"></a>访问标志</h3><p>在常量池结束之后，紧接着的2个字节代表访问标志(access_flags)，这个标志用于识别一些类或者接口层次的访问信息，其16个标志位目前只用了9个，剩下的暂时都是归零：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/bucTRC.png"></p>
<h3 id="类索引、父类索引与接口索引集合（Class文件中由这三项数据来确定该类型的继承关系）"><a href="#类索引、父类索引与接口索引集合（Class文件中由这三项数据来确定该类型的继承关系）" class="headerlink" title="类索引、父类索引与接口索引集合（Class文件中由这三项数据来确定该类型的继承关系）"></a>类索引、父类索引与接口索引集合（Class文件中由这三项数据来确定该类型的继承关系）</h3><ul>
<li><p>类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，它们各自指向一个CONSTANT_Class_info类型的常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。<br>由于Java语言不允许多重继承，父类索引只有一个，除了java.lang.Object之外，所以Java类的父类索引都不为0。</p>
</li>
<li><p>接口索引集合是一组u2类型的数据的集合，被实现的接口将按implements关键字后的接口顺序从左到右排列在接口索引集合中。<br>其入口的第一项u2类型的数据为接口计数器（interfaces_count），表示索引表的容量，如果该类没有实现任何接口，则该计数器值为0。</p>
</li>
</ul>
<h3 id="字段表集合"><a href="#字段表集合" class="headerlink" title="字段表集合"></a>字段表集合</h3><p>字段表（field_info）用于描述接口或者类中声明的变量。Java语言中的“字段”（Field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。<br>字段表中包含了各种修饰符，各个修饰符都是布尔值，要么有某个修饰符，要么没有，很适合使用标志位来表示。而字段叫做什么名字、字段被定义为什么数据类型，只能引用常量池中的常量来描述。</p>
<h4 id="字段表结构"><a href="#字段表结构" class="headerlink" title="字段表结构"></a>字段表结构</h4><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/ldCh7K.png"><br>字段修饰符存放在access_flags中：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/CjBL3G.png"><br>跟随access_flags标志的是两项索引值（常量池项的引用，分别代表着字段的简单名称以及字段和方法的描述符）：</p>
<ul>
<li>name_index；存放全限定名和简单名称；</li>
<li>descriptor_index：用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/2VuQTj.png"><br>对于数组类型，使用前置的”[“字符来描述，如一个定义为<code>java.lang.String[][]</code>类型的二维数组将被记录成<code>[[Ljava/lang/String;</code>，一个整型数组<code>int[]</code>将被记录成<code>[I</code>。<br>对于方法的描述，按照先参数列表、后返回值的顺序，参数列表按照参数的严格顺序放在一组小括号<code>()</code>之内。如方法<code>void inc()</code>的描述符为<code>()V</code>，方法<code>java.lang.String toString()</code>的描述符为<code>()Ljava/lang/String;</code>，方法<code>int indexOf(char[]source, int sourceOffset, int sourceCount，char[]target, int targetOffset，int targetCount, int fromIndex)</code>的描述符为<code>([CII[CII)I</code>。</li>
</ul>
<p>字段表集合中不会列出从父类或者父接口中继承而来的字段，但有可能出现原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，编译器就会自动添加指向外部类实例的字段。另外，在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于Class文件格式来讲，只要两个字段的描述符不是完全相同，那字段重名就是合法的。</p>
<h3 id="方法表集合"><a href="#方法表集合" class="headerlink" title="方法表集合"></a>方法表集合</h3><p>方法表的结构如同字段表一样，依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）。<br>方法表结构：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/wlHrvV.png"><br>方法访问标志：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/0t8tqx.png"><br>方法里的Java代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为<code>Code</code>的属性里面，属性表作为Class文件格式中最具扩展性的一种数据项目。<br>如果子类没有重写父类方法，一般就只有最常见的类构造器<code>&lt;clinit&gt;()</code>方法和实例构造器<code>&lt;init&gt;()</code>方法。<br>在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名。<br>特征签名是指方法中各个参数在常量池中的字段符号引用的集合，也正是因为返回值不会包含在特征签名之中，所以Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的。但是在Class文件格式之中，特征签名的范围要更大一些，只要描述符不是完全一致的两个方法就可以共存。</p>
<h3 id="属性表集合"><a href="#属性表集合" class="headerlink" title="属性表集合"></a>属性表集合</h3><p>Class文件、字段表、方法表都可以携带自己的属性表集合。<br>虚拟机规范预定义的属性：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/S3F8ul.png"><br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/sL31G5.png"><br>属性表结构：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/OJqB3A.png"></p>
<h4 id="Code属性"><a href="#Code属性" class="headerlink" title="Code属性"></a>Code属性</h4><p>Java程序方法体里面的代码经过Javac编译器处理之后，最终变为字节码指令存储在Code属性内。Code属性出现在方法表的属性集合之中，接口或者抽象类中的方法就不存在Code属性。<br>Code属性表的结构：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/6340QL.png"></p>
<ul>
<li>attribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，此常量值固定为<code>&quot;Code&quot;</code>，它代表了该属性的属性名称。</li>
<li>attribute_length指示了属性值的长度，由于属性名称索引与属性长度一共为6个字节，所以属性值的长度固定为整个属性表长度减去6个字节。</li>
<li>max_stack代表了<code>操作数栈（Operand Stack）</code>深度的最大值。在方法执行的任意时刻，操作数栈都不会超过这个深度。虚拟机运行的时候需要根据这个值来分配<code>栈帧（Stack Frame）</code>中的操作栈深度。</li>
<li>max_locals代表了局部变量表所需的存储空间。其单位是<code>变量槽（Slot）</code>，变量槽是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、 float、 int、 short、 boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用一个变量槽，而double和long这两种64位的数据类型则需要两个变量槽，方法参数（包括<code>this</code>、<code>super</code>这种内置的参数）、显式异常处理程序的参数（Exception Handler Parameter,就是try-catch语句中catch块中所定义的异常）、方法体中定义的局部变量都需要依赖局部变量表来存放。<br><em><strong>操作数栈和局部变量表直接决定该方法的栈帧所耗费的内存，不必要的操作数栈深度和变量槽数量会造成内存的浪费。</strong></em><br><em><strong>Java虚拟机的做法是将局部变量表中的变量槽进行重用，当代码执行超出一个局部变量的作用域时，这个局部变量所占的变量槽可以被其他局部变量所使用，Javac编译器会根据变量的作用域来分配变量槽给各个变量使用，根据同时生存的最大局部变量数量和类型计算出max_locals的大小。</strong></em></li>
<li>code_length和code用来存储Java源程序编译后生成的字节码指令。<br>code_length代表字节码长度，code是用于存储字节码指令的一系列字节流。既然叫字节码指令，那顾名思义每个指令就是一个u1类型的单字节，当虚拟机读取到code中的一个字节码时，就可以对应找出这个字节码代表的是什么指令，并且可以知道这条指令后面是否需要跟随参数，以及后续的参数应当如何解析。我们知道一个u1数据类型的取值范围为0x00<del>0xFF，对应十进制的0</del>255,也就是一共可以表达256条指令。目前，《Java虚 拟机规范》已经定义了其中约200条编码值对应的指令含义。<br>关于code_length, 《Java虚拟机规范》中明确限制了一个方法不允许超过65535条字节码指令，即它实际只使用了u2的长度，如果超过这个限制，Javac编译器就会拒绝编译。</li>
</ul>
<p>Java程序可分为：</p>
<ul>
<li>方法体的代码（Code属性）；</li>
<li>元数据（Metadata，包括类、方法、字段的定义及其他信息）。</li>
</ul>
<h5 id="异常表（try-catch-finally）（在Code属性中并不是必须存在的）"><a href="#异常表（try-catch-finally）（在Code属性中并不是必须存在的）" class="headerlink" title="异常表（try-catch-finally）（在Code属性中并不是必须存在的）"></a>异常表（try-catch-finally）（在Code属性中并不是必须存在的）</h5><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/MFoY0i.png"><br>如果当字节码从第start_pc行到第end_pc行之间(不含第end_pc行)出现了类型为catch_type或者其子类的异常(catch_type为指向一个CONSTANT_Class_info型常量的索引)，则转到第handler_pc行继续处理。当catch_type的值为0时，代表任意异常情况都需要转到handler_pc处进行处理。<br>《Java虚拟机规范》中明确要求Java语言的编译器应当选择使用异常表而不是通过跳转指令来实现Java异常及finally处理机制。</p>
<h4 id="Exceptions属性"><a href="#Exceptions属性" class="headerlink" title="Exceptions属性"></a>Exceptions属性</h4><p>Exceptions属性的作用是列举出方法中可能拋出的受查异常（Checked Excepitons），也就是方法描述时在throws关键字后面列举的异常。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/7pKUvH.png"><br>number_of_exceptions项表示方法可能抛出number_of_exceptions种受查异常，每种受查异常使用一个exception_index_table项表示;<br>exception_index_table是一个指向常量池中CONSTANT_Class_info型常量的索引，代表了该受查异常的类型。</p>
<blockquote>
<p>BOILERPLATE:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package me.fengorz.jvm.clazz;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 测试分析Class字节码</span><br><span class="line"> *</span><br><span class="line"> * @Author zhanshifeng</span><br><span class="line"> * @Date 2020/10/7 12:39 PM</span><br><span class="line"> */</span><br><span class="line">public class TestClass &#123;</span><br><span class="line"></span><br><span class="line">    private int m;</span><br><span class="line"></span><br><span class="line">    private int inc() &#123;</span><br><span class="line">        return m + 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用javap输出常量表（JDK 8编译的class）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ javap -v TestClass</span><br><span class="line">Warning: File ./TestClass.class does not contain class TestClass</span><br><span class="line">Classfile /Users/zhanshifeng/IdeaProjects/leetcode-practice/out/production/leetcode-practice/me/fengorz/jvm/clazz/TestClass.class</span><br><span class="line">  Last modified Oct 7, 2020; size 395 bytes</span><br><span class="line">  MD5 checksum acbed0d4b1041fe8c4a659f1f3dbb206</span><br><span class="line">  Compiled from &quot;TestClass.java&quot;</span><br><span class="line">public class me.fengorz.jvm.clazz.TestClass</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER   // 这里可以发现两个标志位为真：类声明为public，JDK 1.2之后的ACC_SUPER都必须为真，所以flags的值等于0x0001|0x0020=0x0021</span><br><span class="line">  this_class: #3                          // me/fengorz/jvm/clazz/TestClass     这里的类索引通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串：&quot;me/fengorz/jvm/clazz/TestClass&quot;</span><br><span class="line">  super_class: #4                         // java/lang/Object   父类索引，原理和类索引一样。</span><br><span class="line">  interfaces: 0, fields: 1, methods: 2, attributes: 1   // 接口索引集合大小为0 // 字段计数器fields为1，代表类中有1个字段 // 方法计数器methods为2，代表类中有2个方法 // 属性表数量1个</span><br><span class="line">Constant pool:                            // 常量池开始</span><br><span class="line">   #1 = Methodref          #4.#18         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V CONSTANT_Methodref_info类型常量，即inc方法的符号引用</span><br><span class="line">   #2 = Fieldref           #3.#19         // me/fengorz/jvm/clazz/TestClass.m:I</span><br><span class="line">   #3 = Class              #20            // me/fengorz/jvm/clazz/TestClass     &quot;#3&quot;被上面this_class引用</span><br><span class="line">   #4 = Class              #21            // java/lang/Object   &quot;#4&quot;被上面super_class引用</span><br><span class="line">   #5 = Utf8               m              // CONSTANT_Utf8_info型常量用来描述字段m的名字</span><br><span class="line">   #6 = Utf8               I              // 声明字段数据类型为int</span><br><span class="line">   #7 = Utf8               &lt;init&gt;         // 编译器添加的实例构造器</span><br><span class="line">   #8 = Utf8               ()V            // 代表空参数返回void的inc方法</span><br><span class="line">   #9 = Utf8               Code           // inc方法的&quot;Code&quot;属性，说明此属性是方法具体的字节码指令</span><br><span class="line">  #10 = Utf8               LineNumberTable</span><br><span class="line">  #11 = Utf8               LocalVariableTable</span><br><span class="line">  #12 = Utf8               this</span><br><span class="line">  #13 = Utf8               Lme/fengorz/jvm/clazz/TestClass;</span><br><span class="line">  #14 = Utf8               inc</span><br><span class="line">  #15 = Utf8               ()I</span><br><span class="line">  #16 = Utf8               SourceFile</span><br><span class="line">  #17 = Utf8               TestClass.java</span><br><span class="line">  #18 = NameAndType        #7:#8          // &quot;&lt;init&gt;&quot;:()V       </span><br><span class="line">  #19 = NameAndType        #5:#6          // m:I                // 对应字段m的名字和类型</span><br><span class="line">  #20 = Utf8               me/fengorz/jvm/clazz/TestClass</span><br><span class="line">  #21 = Utf8               java/lang/Object</span><br><span class="line">&#123;</span><br><span class="line">  public me.fengorz.jvm.clazz.TestClass();</span><br><span class="line">    descriptor: ()V                             </span><br><span class="line">    flags: (0x0001) ACC_PUBLIC      // 标志位，方法声明为public</span><br><span class="line">    Code:</span><br><span class="line">      // 操作数栈深度1，本地（局部）变量表容量1（这个实际上是隐藏的this关键字），</span><br><span class="line">      // 这里args_size之所以为1，是因为局部变量表中至少会存在一个指向当前对象实例的局部变量this，</span><br><span class="line">      // 局部变量表中也会预留出第一个变量槽位来存放对象实例的引用，所以实例方法参数大小值从1开始</span><br><span class="line">      stack=1, locals=1, args_size=1    </span><br><span class="line">         0: aload_0                     // aload_0指令是将第0个变量槽中为reference类型的本地变量推到操作数栈顶</span><br><span class="line"></span><br><span class="line">         // 具体的方法调用，invokespecial，这条指令的作用是以栈顶的reference类型的数据所指向的对象作为方法接收者，</span><br><span class="line">         // 调用此对象的实例构造器方法、private方法或者它的父类的方法。这个方法有一个u2类型的参数说明具体调用哪个方法，</span><br><span class="line">         // 它指向常量池中的一个CONSTANT_Methodref_info类型常量，即此方法的符号引用。</span><br><span class="line">         1: invokespecial #1            // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V      </span><br><span class="line">         4: return                      // inc方法的返回</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 9: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   Lme/fengorz/jvm/clazz/TestClass;</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;TestClass.java&quot;</span><br></pre></td></tr></table></figure>

<h2 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h2><p>字节码指令集可算是一种具有鲜明特点、优势和劣势均很突出的指令集架构，顾名思义字节码长度只能是一个字节（即0~255），这意味着指令集的操作码总数不能够超过256条；<br>虚拟机在处理那些超过一个字节的数据时，不得不在运行时从字节中重建出具体数据的结构，譬如要将一个16位长度的无符号整数使用两个无符号字节存储起来（假设将它们命名为byte1和byte2），那它们的值应该是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(byte1 &lt;&lt; 8) | byte2</span><br></pre></td></tr></table></figure>
<p>放弃操作数长度对齐，可以节省大量的填充和间隔符号。</p>
<blockquote>
<p>Java虚拟机解析器伪代码：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do &#123;</span><br><span class="line">    自动计算PC寄存器的值加1;</span><br><span class="line">    根据Pc寄存器指示的位置，从字节码流中取出操作码;</span><br><span class="line">    if (字节码存在操作数) 从字节码流中取出操作数;</span><br><span class="line">        执行操作码所定义的操作;</span><br><span class="line">    &#125; while (字节码流长度&gt; 0);</span><br></pre></td></tr></table></figure>
<h3 id="字节码与数据类型"><a href="#字节码与数据类型" class="headerlink" title="字节码与数据类型"></a>字节码与数据类型</h3><p>大多数指令都包含其操作所对应的数据类型信息：</p>
<ul>
<li><code>iload</code>指令用于从局部变量表中加载int型的数据到操作数栈中；</li>
<li><code>fload</code>指令加载的则是float类型的数据。</li>
</ul>
<p>操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：</p>
<ul>
<li>i代表对int类型的数据操作；</li>
<li>l代表long；</li>
<li>s代表short；</li>
<li>b代表byte；</li>
<li>c代表char；</li>
<li>f代表float；</li>
<li>d代表double；</li>
<li>a代表reference；</li>
<li><code>arraylength</code>指令，它没有代表数据类型的特殊字符，但操作数永远只能是一个数组类型的对象。</li>
<li>有些事与数据类型无关的指令（比如<code>goto</code>）。</li>
</ul>
<p><em><strong>大部分指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展（Sign-Extend）为相应的int类型数据，将boolean和char类型数据零位扩展（Zero-Extend）为相应的int类型数据。与之类似，在处理boolean、byte、 short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。因此，大多数对于boolean、byte、 short和char类型数据的操作，实际上都是使用相应的对int类型作为运算类型（Computational Type）来进行的。</strong></em></p>
<h3 id="不同类型的字节码指令"><a href="#不同类型的字节码指令" class="headerlink" title="不同类型的字节码指令"></a>不同类型的字节码指令</h3><h4 id="加载和存储指令"><a href="#加载和存储指令" class="headerlink" title="加载和存储指令"></a>加载和存储指令</h4><p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输，这类指令包括：</p>
<ul>
<li>将一个局部变量加载到操作栈；</li>
<li>将一个数值从操作数栈存储到局部变量表；</li>
<li>将一个常量加载到操作数栈；</li>
<li>扩充局部变量表的访问索引的指令.</li>
</ul>
<h4 id="运算指令"><a href="#运算指令" class="headerlink" title="运算指令"></a>运算指令</h4><p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。</p>
<h4 id="类型转换指令"><a href="#类型转换指令" class="headerlink" title="类型转换指令"></a>类型转换指令</h4><p>类型转换指令可以将两种不同的数值类型相互转换，这些转换操作一般用于实现用户代码中的显式类型转换操作，或者用来处理字节码指令集中数据类型相关指令无法与数据类型对应的问题。</p>
<h4 id="对象创建与访问指令"><a href="#对象创建与访问指令" class="headerlink" title="对象创建与访问指令"></a>对象创建与访问指令</h4><h4 id="操作数栈管理指令"><a href="#操作数栈管理指令" class="headerlink" title="操作数栈管理指令"></a>操作数栈管理指令</h4><h4 id="控制转移指令"><a href="#控制转移指令" class="headerlink" title="控制转移指令"></a>控制转移指令</h4><h4 id="方法调用和返回指令"><a href="#方法调用和返回指令" class="headerlink" title="方法调用和返回指令"></a>方法调用和返回指令</h4><h4 id="异常处理指令"><a href="#异常处理指令" class="headerlink" title="异常处理指令"></a>异常处理指令</h4><h4 id="同步指令"><a href="#同步指令" class="headerlink" title="同步指令"></a>同步指令</h4><p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor, 更常见的是直接将它称为“锁”）来实现的。<br>方法级的同步是隐式的，无须通过字节码指令来控制，它实现在方法调用和返回操作之中。<br>当方法调用时，调用指令将会检查方法的ACC_ SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程就要求先成功持有管程，然后才能执行方法，最后当方法完成（无论是正常完成还是非正常完成）时释放管程。<br>在方法执行期间，其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法边界之外时自动释放。</p>
<h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><h2 id="类的生命周期"><a href="#类的生命周期" class="headerlink" title="类的生命周期"></a>类的生命周期</h2><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/5TyrOh.png"></p>
<h2 id="类的加载时机"><a href="#类的加载时机" class="headerlink" title="类的加载时机"></a>类的加载时机</h2><p>以下这些情况，如果类型没有进行过初始化，则需要先触发其初始化阶段，这种引用称为对一个类型进行主动引用：</p>
<ul>
<li>使用new关键字实例化对象的时候；</li>
<li>读取或设置一个类型的静态字段（被final修饰、 已在编译期把结果放入常量池的静态字段除外）的时候；</li>
<li>调用一个类型的静态方法的时候；</li>
<li>使用java.lang.reflect包的方法对类型进行反射调用的时候；</li>
<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化;</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main方法的那个类），虚拟机会先初始化这个主类;</li>
<li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang .invoke MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>
<li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ul>
<p>除此之外，其他引用类型的方式都不会触发初始化，称为被动引用。</p>
<h3 id="被动引用"><a href="#被动引用" class="headerlink" title="被动引用"></a>被动引用</h3><ul>
<li>通过子类引用父类的静态字段，不会导致子类初始化；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SuperClass &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;super class init!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static int value = 666;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class SubClass extends SuperClass &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;sub class init!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ClassLoadTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(SubClass.value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * super class init!</span><br><span class="line">     * 666</span><br><span class="line">     */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通过数组定义来引用类，不会触及此类的初始化；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ClassLoadTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SuperClass[] arr = new SuperClass[10];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 并没有输出 super class init!</span><br><span class="line">     */</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>常量在编译阶段会存入调用类的常量池中，本质上没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化；</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Constant &#123;</span><br><span class="line">    static &#123;</span><br><span class="line">        System.out.println(&quot;constant init!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final String HELLO_WORLD = &quot;hello world!&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class ClassLoadTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(Constant.HELLO_WORLD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * 并没有输出 &quot;constant init!&quot;</span><br><span class="line">     */</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<ul>
<li>当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</li>
</ul>
<h2 id="类的加载过程"><a href="#类的加载过程" class="headerlink" title="类的加载过程"></a>类的加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>在加载阶段，Java虚拟机需要完成以下三件事情:</p>
<ul>
<li>通过一个类的全限定名来获取定义此类的二进制字节流，字节流来源可以有：<ul>
<li>从ZIP压缩包中读取，这很常见，最终成为日后JAR、EAR、 WAR格式的基础。</li>
<li>从网络中获取。</li>
<li>运行时计算生成，这种场景使用得最多的就是动态代理技术，在java.lang.refect.Proxy中，就是用了ProxyGenerator .generateProxyClass()来为特定接口生成形式为“*$Proxy”的代理类的二进制字节流。</li>
<li>从数据库中读取，这种场景相对少见些。</li>
<li>可以从加密文件中获取，这是典型的防Class文件被反编译的保护措施，通过加载时解密Class文件来保障程序运行逻辑不被窥探。</li>
</ul>
</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>
<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>
</ul>
<h4 id="类的加载"><a href="#类的加载" class="headerlink" title="类的加载"></a>类的加载</h4><p>加载阶段可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的findClass或loadClass方法）。</p>
<h4 id="数组的加载"><a href="#数组的加载" class="headerlink" title="数组的加载"></a>数组的加载</h4><p>与类加载不一致，待记录。</p>
<p>加载阶段结束后，Java虚拟机外部的二进制字节流就按照虚拟机所设定的格式存储在方法区之中了，《Java虚拟机规范》未规定此区域的具体数据结构。类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。</p>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><ul>
<li>文件格式验证（这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，后面的三个验证阶段全部是基于方法区的存储结构上进行的）。</li>
<li>元数据验证。</li>
<li>字节码验证（这阶段就要对类的方法体(Class文件中的Code属性)进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为）。</li>
<li>符号引用验证（符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验,通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源）。<ul>
<li>如果无法通过符号引用验证，Java虚拟机将会拋出一个<code>java.lang.IncompatibleClassChangeError</code>的子类异常，典型的如：<code>java.lang.IlelalAccessError</code>、<code>java.lang.NoSuchFieldError</code>、<code>java.lang.NoSuchMethodError</code>等。</li>
</ul>
</li>
</ul>
<p><em><strong>如果程序运行的全部代码（包括自已编写的、第三方包中的、从外部加载的、动态生成的等所有代码）都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用<code>-Xverify: none</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</strong></em></p>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量）分配内存并设置类变量初始值的阶段，从概念上讲，这些变量所使用的内存都应当在方法区中进行分配。<br><em><strong>这时候进行内存分配的仅包括类变量，而不包括实例变量，实例变量将会在对象实例化时随着对象一起起分配在Java堆中。</strong></em><br>如果是赋值了的基本类型静态变量的情况下（也就是默认是预置为基础类型的<code>零值</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static int value = 123;</span><br></pre></td></tr></table></figure>
<p>在准备阶段期间其是不会被预置为123的值的，123的赋值操作将在后面的<code>初始化阶段</code>中进行。<br>基本类型的零值：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/2yFTP5.png"><br>***如果变量被声明为final static，也就是类变量进常量池的字段属性表中的ConstantValue属性时，那么其在准备阶段会被初始化为具体指定的值，如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public static final int value = 123;</span><br></pre></td></tr></table></figure>

<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是Java虚拟机将常量池内的符号引用替换为直接引用的过程，也就是将对类引用、接口引用、方法引用、对象变量引用等赋值为其具体的实例引用。</p>
<ul>
<li>符号引用（Symbolic References）<ul>
<li>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。各种虚拟机实现的内存布局可以各不相同，但是它们能接受的符号引用必须都是一致的，因为符号引用的字面量形式明确定义在《Java虚拟机规范》的Class文件格式中。</li>
</ul>
</li>
<li>直接引用（Direct References）<ul>
<li>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。虚拟机到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它，这个《Java虚拟机规范》没有具体约束。</li>
</ul>
</li>
</ul>
<p>一般来说，一个符号引用之前已经被成功解析过，那么后续的引用解析请求就应当一直能够成功；如果第一次解析失败了，其他指令对这个符号的解析请求也应该收到相同的异常，哪怕这个请求的符号在后来已成功加载进Java虚拟机内存之中。</p>
<h4 id="类或接口的解析"><a href="#类或接口的解析" class="headerlink" title="类或接口的解析"></a>类或接口的解析</h4><p>假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，其解析过程如下（出现任何异常，解析将失败）：</p>
<ul>
<li>如果C不是数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。</li>
<li>如果C是数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似是<code>[Ljava/lang/Integer</code>，那将会按照第一点的规则加载数组元素类型，接着由虚拟机生成一个代表该数组维度和元素的数组对象。</li>
<li>此时C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出<code>java.lang.IlegalAccessError</code>异常。<ul>
<li>JDK 9引入模块化之后，即使是public类型也不能肆无忌惮地访问了。</li>
</ul>
</li>
</ul>
<h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h4><p>解析一个未被解析过的字段符号引用，首先将会对字段表内class_index项中索引的CONSTANT__Class_info符号引用进行解析，如果解析成功，那么假设这个字段所属的类或接口用C表示，《Java虚拟机规范》要求按照如下步骤对C进行后续字段的搜索：</p>
<ul>
<li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用。</li>
<li>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用。</li>
<li>否则，如果C不是java.lang.Object的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用。</li>
<li>否则，查找失败，抛出java.lang.NoSuchFieldError异常。</li>
<li>同样的，找到成功的话，还要对字段的访问权限进行校验。</li>
</ul>
<h4 id="方法解析"><a href="#方法解析" class="headerlink" title="方法解析"></a>方法解析</h4><p>需要先解析出方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，那么假设用C表示这个类，接下来虚拟机对方法的解析和字段解析类似，同样也是自下而上的解析，如果解析成功也需要进行权限验证。</p>
<ul>
<li>由于Class文件格式中类的方法和接口的方法符号引用的常量类型定义是分开的，如果在类的方法表中发现class_index中索引的C是个接口的话，那就直接抛出java.lang .IncompatibleClassChangeError异常。</li>
<li>在类C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用。</li>
<li>否则，在类C实现的接口列表及它们的父接口之中递归查找是否有简单名称和描述符都与目标相匹配的方法，如果存在匹配的方法，说明类C是一个抽象类，这时候查找结束，抛出java.lang.AbstractMethodError异常。</li>
<li>如果还没有找到，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li>
</ul>
<h4 id="接口方法解析"><a href="#接口方法解析" class="headerlink" title="接口方法解析"></a>接口方法解析</h4><p>接口方法也是需要先解析出接口方法表的class_index项中索引的方法所属的类或接口的符号引用，如果解析成功，依然用C表示这个接口，接下来虚拟机将会<br>按照如下步骤进行后续的接口方法搜索:</p>
<ul>
<li>如果在接口方法表中发现class_index中的索引C是个类而不是接口，那么就直接抛出java.lang .IncompatibleClassChangeError异常。</li>
<li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在接口C的父接口中递归查找，直到java.lang.Object类（接口方法的查找范围也会包括Object类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>如果接口有多继承的父接口，则返回其中一个符合的直接引用，查找结束（有些虚拟机的实现会拒绝这种不确定性）。</li>
<li>如果还没有找到，宣告方法查找失败，抛出java.lang.NoSuchMethodError异常。</li>
</ul>
<p>JDK 9之后增加了接口的静态私有方法、模块化访问约束。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>初始化阶段就是执行类构造器<code>&lt;clinit&gt;()</code>方法的过程。<code>&lt;clinit&gt;()</code>并不是程序员在Java代码中直接编写的方法，它由Javac编译器自动生成。</p>
<h4 id="lt-clinit-gt-方法"><a href="#lt-clinit-gt-方法" class="headerlink" title="&lt;clinit&gt;()方法"></a><code>&lt;clinit&gt;()</code>方法</h4><ul>
<li><code>&lt;clinit&gt;()</code>方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}块）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序决定的，静态语句块中只能访问到定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块可以赋值，但是不能访问。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static &#123;</span><br><span class="line">    test = 2;</span><br><span class="line">    System.out.println(test);// 这句编译不通过</span><br><span class="line">&#125;</span><br><span class="line">static int test = 1;</span><br></pre></td></tr></table></figure></li>
<li>父类的<code>&lt;clinit&gt;()</code>方法比子类的先执行，也就意味着父类中定义的静态语句块要优先于子类的变量赋值操作。<ul>
<li>因此在Java虚拟机中第一个被执行的<code>&lt;clinit&gt;()</code>方法的类型肯定是java.lang.Object。</li>
</ul>
</li>
<li>没有静态语句块与静态变量的赋值操作的类或接口，可以不生成<code>&lt;clinit&gt;()</code>。接口与类不同，只有当父接口中定义的变量被使用时，父接口才会调用<code>&lt;clinit&gt;()</code>。此外，接口的实现类在初始化时也一样不会执行接口的<code>&lt;clinit&gt;()</code>方法。</li>
<li><code>&lt;clinit&gt;()</code>方法是线程安全的，所以其里面有很耗时的初始化操作，当多个线程同时去初始化其类时，会造成线程阻塞。这也就是为什么有些资源配置加载逻辑会放到类的静态代码块来完成。</li>
</ul>
<h2 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h2><h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>两个完全相等的类必须是同一个类加载器加载的，”相等”包含了：<br>类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括了使用instanceof关键字做对象所属关系判定等各种情况。<br>分别使用自定义实现类加载器<code>new ClassLoader()</code>与虚拟机默认加载器所加载的同个类的实例去做instanceof会出现不匹配的结果。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>只存在两种类加载器：</p>
<ul>
<li>启动类加载器（Bootstrap ClassLoader），这个类加载器使用C++语言实现，是虚拟机自身的一部分。</li>
<li>由Java语言实现，并且全都继承自抽象类<code>java.lang.ClassLoader</code>。</li>
</ul>
<p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/S3pc4X.png"><br>双亲委派模型的工作过程是:如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去完成加载。<br>双亲委派的具体按照loadClass()方法的逻辑去调用父加载器加载，如果父类加载失败，会自动调用自己的findClass(方法来完成加载，这样既不影响用户按照自己的意愿去加载类，又可以保证新写出来的类加载器是符合双亲委派规则的。</p>
<h3 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h3><h4 id="OSGi"><a href="#OSGi" class="headerlink" title="OSGi"></a>OSGi</h4><p>OSGi实现模块化热部署的关键是它自定义的类加载器机制的实现，每一个程序模块(OSGi中称为Bundle)都有一个自己的类加载器，当需要更换一个Bundle时，就把Bundle连同类加载器一起换掉以实现代码的热替换。在OSGi环境下，类加载器不再双亲委派模型推荐的树状结构，而是进一步发展为更加复杂的网状结构。<br>《深入理解OSGi：Equinox原理、应用于最佳实践》这本书有对其进行详尽讲解。</p>
<h2 id="Java模块化（待记录）"><a href="#Java模块化（待记录）" class="headerlink" title="Java模块化（待记录）"></a>Java模块化（待记录）</h2><h1 id="虚拟机字节码执行引擎"><a href="#虚拟机字节码执行引擎" class="headerlink" title="虚拟机字节码执行引擎"></a>虚拟机字节码执行引擎</h1><h2 id="运行时栈帧结构"><a href="#运行时栈帧结构" class="headerlink" title="运行时栈帧结构"></a>运行时栈帧结构</h2><p>Java虚拟机以方法作为最基本的执行单元，<code>栈帧（Stack Frame）</code>则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素。<br>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译Java程序源码的时候，栈帧中需要多大的局部变量表,需要多深的操作数栈就已经被分析计算出来，并且写入到方法表的Code属性之中。<br>同一时刻、同一条线程里面，在调用堆栈的所有方法都同时处于执行状态。 而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的，其被称为<code>当前栈帧（Current Stack Frame）</code>，与这个栈帧所关联的方法被称为<code>当前方法（Current Method)</code>。执行引擎所运行的所有字节码指令都只针对当前栈帧进行操作。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/7VakEo.png"></p>
<h3 id="局部变量表-1"><a href="#局部变量表-1" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表（Local Variables Table）是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。在Java程序被编译为Class文件时，就在方法的Code属性的max_locals数据项中确定了该方法所需分配的局部变量表的最大容量，局部变量表的容量以变量槽（Variable Slot）为最小单位，一个变量槽可以存放一个32位以内的数据类型。<br><em><strong>对于double和long类型的变量其存在于两个连续的变量槽，由于变量表是线程私有数据，所以是线程安全的。</strong></em><br>当一个方法被调用时，Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递。如果执行的是实例方法（没有被static修饰的方法），那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数。其余参数则按照参数表顺序排列，占用剩下的局部变量槽，参数表分配完毕后，再根据方法体内部定义的变量顺序和作用域分配其余的变量槽。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void test1() &#123;</span><br><span class="line">    byte[] placeholder = new byte[1024 * 1024];</span><br><span class="line">    // 这里操作GC，是不会回收placeholder，因为此时placeholder还在作用域之内</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void test2() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        byte[] placeholder = new byte[1024 * 1024];</span><br><span class="line">    &#125;</span><br><span class="line">    // 这里操作GC，依然不会回收placeholder</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void test3() &#123;</span><br><span class="line">    &#123;</span><br><span class="line">        byte[] placeholder = new byte[1024 * 1024];</span><br><span class="line">    &#125;</span><br><span class="line">    int a = 0;</span><br><span class="line">    // 这里操作GC，这次placeholder真的被回收了</span><br><span class="line">    // 上面两个例子placeholder所占用的变量槽没有被复用，而这里的被复用了，老的placeholder对象实例失去引用自然会被回收</span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果遇到一个方法，其后面的代码是较耗时的操作，而前面又定义了占用大量内存但实际上已经不会再使用的变量，手动将其设置为null，把变量对应的局部变量槽清空，会加快GC的生效，尽快将内存腾出来（不过在经过编译优化过之后，null赋值这种语句很大可能会被当做无效代码优化掉，所以并不一定要固定遵循这个规则写代码）。<br>局部变量表的变量不存在类变量那样的<code>准备阶段</code>（一次在准备阶段，赋予系统初始值；另外一次在初始化阶段，赋予程序员定义的初始值）。<br>局部变量必须赋予初始值才能使用，不存在像类变量那样的基础类型默认初始值。</p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈的最大深度也在编译的时候被写入到Code属性的max_stacks数据项之中。操作数栈的每个元素都可以是包括long和double在内的任意Java数据类型。32位数据类型所占的栈容量为1, 64位数据类型所占的栈容量为2。</p>
<blockquote>
<p>栈帧之间的数据共享（比如方法之间的调用）：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/zoG4oq.png"></p>
</blockquote>
<h3 id="动态连接"><a href="#动态连接" class="headerlink" title="动态连接"></a>动态连接</h3><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接（Dynamic Linking）。</p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：</p>
<ul>
<li>恢复上层方法的局部变量表和操作数栈</li>
<li>把返回值（如果有的话）压入调用者栈帧的操作数栈中</li>
<li>调整PC计数器的值以指向方法调用指令后面的一条指令等。</li>
</ul>
<h2 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h2><p>一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（也就是之前说的直接引用）。这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法调用过程变得相对复杂，某些调用需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。</p>
<h3 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h3><p>承接前面关于方法调用的话题，所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用。<br>这种解析能够成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。换句话说，调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。这类方法的调用被称为解析（Resolution）。<br>可以在解析阶段中确定唯一的调用版本，Java语言里符合这个条件的方法共有静态方法、私有方法、实例构造器、父类方法4种，再加上被final修饰的方法调用，这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为“非虚方法”（Non-Virtual Method），与之相反，其他方法就被称为“虚方法”（Virtual Method）。<br>解析调用一定是个静态的过程，在编译期间就完全确定，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用，不必延迟到运行期再去完成。</p>
<h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><h4 id="静态分派"><a href="#静态分派" class="headerlink" title="静态分派"></a>静态分派</h4><p>虚拟机（或者准确地说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Description 静态分派Demo</span><br><span class="line"> * @Author zhanshifeng</span><br><span class="line"> * @Date 2020/10/16 8:16 PM</span><br><span class="line"> */</span><br><span class="line">public class StaticDispath &#123;</span><br><span class="line"></span><br><span class="line">    static abstract class Human &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Man extends Human &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    static class Woman extends Human &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello(Human mankind) &#123;</span><br><span class="line">        System.out.println(&quot;hello, mankind!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello(Man man) &#123;</span><br><span class="line">        System.out.println(&quot;hello, man!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void sayHello(Woman woman) &#123;</span><br><span class="line">        System.out.println(&quot;hello, woman!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * Human可理解过man或者woman的静态类型，静态类型在编译器就可知</span><br><span class="line">     * man和woman还具备了一个实际类型，或者叫运行时类型，这要在运行器才能得知</span><br><span class="line">     *</span><br><span class="line">     * @param args</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        Human man = new Man();</span><br><span class="line">        Human woman = new Woman();</span><br><span class="line">        StaticDispath staticDispath = new StaticDispath();</span><br><span class="line">        staticDispath.sayHello(man);</span><br><span class="line">        staticDispath.sayHello(woman);</span><br><span class="line"></span><br><span class="line">        // 实际类型变化，要运行时才能得知</span><br><span class="line">        Human mankind = (new Random()).nextBoolean() ? new Man() : new Woman();</span><br><span class="line">        // 静态类型变化，编译器即可得知</span><br><span class="line">        staticDispath.sayHello((Man) mankind);</span><br><span class="line">        staticDispath.sayHello((Woman) mankind);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     * hello, mankind!</span><br><span class="line">     * hello, mankind!</span><br><span class="line">     */</span><br></pre></td></tr></table></figure>
<p>重载的规则中，将在继承关系中从下往上开始搜索，越接上层的优先级越低，最后才是多态的重载。</p>
<h4 id="动态分派"><a href="#动态分派" class="headerlink" title="动态分派"></a>动态分派</h4><p>虚方法的查找过程：</p>
<ul>
<li>找到操作数栈顶的第一个元素所指向的对象的实际类型，记作C。</li>
<li>如果在类型C中找到与常量中的描述符和简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；不通过则返回java.lang.IlegalAccessError异常。</li>
<li>否则，按照继承关系从下往上依次对C的各个父类进行第二步的搜索和验证过程。</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常。</li>
</ul>
<h2 id="动态类型语言的支持"><a href="#动态类型语言的支持" class="headerlink" title="动态类型语言的支持"></a>动态类型语言的支持</h2><h3 id="动态类型语言"><a href="#动态类型语言" class="headerlink" title="动态类型语言"></a>动态类型语言</h3><p>动态类型语言的关键特征是它的类型检查的主体过程是在运行期而不是编译期进行的，满足这个特征的语言有很多，常用的包括：<br>APL、Clojure、 Erlang、 Groovy、 JavaScript、 Lisp、 Lua、 PHP、Prolog、 Python、Ruby、Smalltalk、 Tcl, 等等。<br>在编译期就进行类型检查过程的语言，譬如C++和Java等就是最常用的静态类型语言。</p>
<h3 id="invokedynamic指令"><a href="#invokedynamic指令" class="headerlink" title="invokedynamic指令"></a>invokedynamic指令</h3><p>某种意义上可以说invokedynamic指令与MethodHandle机制的作用是一样的，都是为了解决原有4条“invoke*”指令方法分派规则完全固化在虚拟机之中的问题，把如何查找目标方法的决定权从虚拟机转嫁到具体用户代码之中，让Coder有更高的自由度。<br>每一处含有invokedynamic指令的位置都被称作<code>动态调用点（Dynamically-Computed Call Site）</code>，这条指令的第一个参数不再是代表方法符号引用的CONSTANT_Methodref_info常量，而是CONSTANT_InvokeDynamic_info常量，从这个新常量中可以得到3项信息：</p>
<ul>
<li>引导方法（Bootstrap Method，该方法存放在BootstrapMethods属性中）</li>
<li>方法类型（MethodType）</li>
<li>名称</li>
</ul>
<p>引导方法是有固定的参数，并且返回值规定是java.lang invoke.CallSite对象，这个对象代表了真正要执行的目标方法调用。根据CONSTANT_InvokeDynamic_info常量中提供的信息，虚拟机可以找到并且执行引导方法，从而获得一个CallSite对象，最终调用到要执行的目标方法上。</p>
<h2 id="基于栈的字节码解释执行引擎"><a href="#基于栈的字节码解释执行引擎" class="headerlink" title="基于栈的字节码解释执行引擎"></a>基于栈的字节码解释执行引擎</h2><h3 id="基于栈的指令集与基于寄存器的指令集"><a href="#基于栈的指令集与基于寄存器的指令集" class="headerlink" title="基于栈的指令集与基于寄存器的指令集"></a>基于栈的指令集与基于寄存器的指令集</h3><p>Javac编译器输出的字节码指令流，基本上是一种基于栈的指令集架构（Instruction Set Architecture, ISA），字节码指令流里面的指令大部分都是零地址指令，它们依赖操作数栈进行工作。<br>与之相对的另外一套常用的指令集架构是基于寄存器的指令集，最典型的就是x86的二地址指令集，也就是现在主流PC机中物理硬件直接支持的指令集架构，这些指令依赖寄存器进行工作。</p>
<h3 id="基于栈的解释器执行过程"><a href="#基于栈的解释器执行过程" class="headerlink" title="基于栈的解释器执行过程"></a>基于栈的解释器执行过程</h3><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/wekX6w.png"><br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/YwTNOP.png"></p>
<h2 id="三种编译"><a href="#三种编译" class="headerlink" title="三种编译"></a>三种编译</h2><ul>
<li>前端编译器（叫“编译器的前端”更准确一些）把*.java文件转变成*.class文件的过程。<ul>
<li>JDK的Javac、Eclipse JDT中的增量式编译器（ECJ）</li>
</ul>
</li>
<li>Java虚拟机的即时编译器（常称JIT编译器，Just In Time Compiler）运行期把字节码转变成本地机器码的过程。<ul>
<li>HotSpot虚拟机的C1、C2编译器，Graal编译器</li>
</ul>
</li>
<li>使用静态的提前编译器（常称AOT编译器&#x2F;Ahead Of Time Compiler、后端编译）直接把程序编译成与目标机器指令集相关的二进制代码的过程。<ul>
<li>JDK的Jaotc、GNU Compiler for the Java（GCJ）、Excelsior JET</li>
</ul>
</li>
</ul>
<h3 id="三种编译器与解释器的搭配模式"><a href="#三种编译器与解释器的搭配模式" class="headerlink" title="三种编译器与解释器的搭配模式"></a>三种编译器与解释器的搭配模式</h3><ul>
<li>混合模式（Mixed Mode）：HotSpot默认的方案，JVM采取解释器和其中一个编译器直接配合的运行模式，编译器根据自身的版本以及宿主机器的硬件性能自动选择。</li>
<li>解释模式（Interpreted Mode）：通过<code>-Xint</code>参数开启，该模式初始化启动虚拟机时间快，更适合客户端应用。</li>
<li>编译模式（Compiled Mode）：通过<code>-Xcomp</code>参数开启，该模式需要更长的预热时间，在服务器资源充足的情况下，更适合服务端应用。</li>
</ul>
<h2 id="后端编译与优化"><a href="#后端编译与优化" class="headerlink" title="后端编译与优化"></a>后端编译与优化</h2><p>如果我们把字节码看作是程序语言的一种中间表示形式（Intermediate Representation, IR）的话，那编译器无论在何时、在何种状态下把Class文件转换成与本地基础设施（硬件指令集、操作系统）相关的二进制机器码，它都可以视为整个编译过程的后端。</p>
<h3 id="热点代码"><a href="#热点代码" class="headerlink" title="热点代码"></a>热点代码</h3><p>热点探测判定方式：</p>
<ul>
<li>基于采样的热点探测（Sample Based Hot Spot Code Detection）。采用这种方法的虚拟机会周期性地检查各个线程的调用栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。基于采样的热点探测的好处是实现简单高。</li>
<li>基于计数器的热点探测（Counter Based Hot Spot Code Detection）。采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法”。这种统计方法实现起来要麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。但是它的统计结果相对来说更加精确严谨。</li>
</ul>
<h4 id="热点探测"><a href="#热点探测" class="headerlink" title="热点探测"></a>热点探测</h4><ul>
<li>基于采样的热点探测（Sample Based Hot Spot Code Detection）。采用这种方法的虚拟机会周期性地检查各个线程的调用栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是“热点方法”。基于采样的热点探测的好处是实现简单高效，还可以很容易地获取方法调用关系（将调用堆栈展开即可)，缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因素的影响而扰乱热点探测。</li>
<li>基于计数器的热点探测（Counter Based Hot Spot Code Detection）。采用这种方法的虚拟机会为每个方法（甚至是代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是“热点方法”。这种统计方法实现起来要麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系。但是它的统计结果相对来说更加精确严谨。</li>
</ul>
<p>HotSpot为每个方法准备了两类计数器：</p>
<ul>
<li>方法调用计数器(Invocation Counter)</li>
<li>回边计数器(Back Edge Counter,“回边”的意思就是指在循环边界往回跳转)。</li>
</ul>
<p>当虚拟机运行参数确定的前提下，这两个计数器都有一个明确的阈值，计数器阈值一旦溢出，就会触发即时编译。</p>
<h5 id="方法调用计数器"><a href="#方法调用计数器" class="headerlink" title="方法调用计数器"></a>方法调用计数器</h5><p>在默认设置下，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间之内方法被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那该方法的调用计数器就会被减少一半，这个过程被称为方法调用计数器热度的衰减(Counter Decay)，而这段时间就称为此方法统计的半衰周期(Counter Half Life Time)，进行热度衰减的动作是在虚拟机进行垃圾收集时顺便进行的，可以使用虚拟机参数<code>-XX: -UseCounterDecay</code>来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样只要系统运行时间足够长，程序中绝大部分方法都会被编译成本地代码。另外还可以使用<code>-XX: CounterHalfLifeTime</code>参数设置半衰周期的时间，单位是秒。</p>
<blockquote>
<p>方法调用计数器触发即使编译：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/TzOuPi.png"></p>
</blockquote>
<h5 id="回边计数器"><a href="#回边计数器" class="headerlink" title="回边计数器"></a>回边计数器</h5><p>回边计数器的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令就称为“回边(Back Edge)”。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/A8ukA9.png"></p>
<h1 id="高效并发"><a href="#高效并发" class="headerlink" title="高效并发"></a>高效并发</h1><h2 id="Java内存模型与线程"><a href="#Java内存模型与线程" class="headerlink" title="Java内存模型与线程"></a>Java内存模型与线程</h2><p>衡量一个服务性能的高低好坏，每秒事务处理数（Transactions Per Second, TPS）是重要的指标之一，它代表着一秒内<br>服务端平均能响应的请求总数，而TPS值 与程序的并发能力又有非常密切的关系。<br>对于计算量相同的任务，程序线程并发协调得越有条不紊，效率自然就会越高;</p>
<h3 id="硬件的效率与一致性"><a href="#硬件的效率与一致性" class="headerlink" title="硬件的效率与一致性"></a>硬件的效率与一致性</h3><p>“让计算机并发执行若干个运算任务”与“更充分地利用计算机处理器的效能”之间的一个重要的复杂性来源于绝大多数的运算任务都不可能只靠处理器“计算”就能完成。处理器至少要与内存交互，如读取运算数据、存储运算结果等。<br>由于计算机的存储设备与处理器的运算速度有着几个数量级的差距，所以现代计算机系统都不得不加入一层或多层读写速度尽可能接近处理器运算速度的高速缓存（Cache）来作为内存与处理器之间的缓冲：<br>将运算需要使用的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。</p>
<p>基于高速缓存的存储交互很好地解决了处理器与内存速度之间的矛盾，但是它引入了一个新的问题：缓存一致性（Cache Coherence）。<br>在多核处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存（Main Memory），这种系统称为共享内存多核系统（Shared Memory Multiprocessors System）<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/qAaDqo.png"><br>除了增加高速缓存之外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入代码进行乱序执行(Out-Of-Order Execution)优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但并不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此如果存在一个计算任务依赖另外一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱序执行优化类似，Java虚拟机的即时编译器中也有指令重排序（Instruction Reorder）优化。</p>
<h3 id="Java内存模型（Java-Memory-Model、JMM）"><a href="#Java内存模型（Java-Memory-Model、JMM）" class="headerlink" title="Java内存模型（Java Memory Model、JMM）"></a>Java内存模型（Java Memory Model、JMM）</h3><p>Java内存模型的主要目的是定义程序中各种变量的访问规则，即关注在虚拟机中把变量值存储到内存和从内存中取出变量值这样的底层细节。此处的变量与Java编程中所说的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，自然就不会存在竞争问题。</p>
<h4 id="主内存和工作内存"><a href="#主内存和工作内存" class="headerlink" title="主内存和工作内存"></a>主内存和工作内存</h4><p>Java内存模型规定了所有的变量都存储在主内存（Main Memory）中，每条线程还有自己的工作内存（Working Memory，可与前面讲的处理器高速缓存类比），线程的工作内存中保存了被该线程使用的变量的主内存副本，线程对变量的所有操作（读取、赋值等）都必须在工作内存中进行，而不能直接读写主内存中的数据。不同的线程之间也无法直接访问对方工作内存中的变量，线程间变量值的传递均需要通过主内存来完成。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/f0BuJZ.png"><br>主内存直接对应于物理硬件的内存，而为了获取更好的运行速度，虚拟机可能会让工作内存优先存储于寄存器和高速缓存中，因为程序运行时主要访问的是工作内存。</p>
<h4 id="内存间的交互操作（最新的JSR-133已经被抛弃的操作-x2F-Deprecated-x2F-JSR-133已将其由8种简化为4种）"><a href="#内存间的交互操作（最新的JSR-133已经被抛弃的操作-x2F-Deprecated-x2F-JSR-133已将其由8种简化为4种）" class="headerlink" title="内存间的交互操作（最新的JSR-133已经被抛弃的操作&#x2F;Deprecated&#x2F;JSR-133已将其由8种简化为4种）"></a>内存间的交互操作（最新的JSR-133已经被抛弃的操作&#x2F;Deprecated&#x2F;JSR-133已将其由8种简化为4种）</h4><p>Java内存模型中定义了以下8种操作来完成主内存与工作内存之间具体的交互协议，每一种操作都是原子的、不可再分的：</p>
<ul>
<li>lock (锁定) ：作用于主内存的变量，它把一个变量标识为一条线程独占的状态。</li>
<li>unlock（解锁）：作用于主内存的变量，它把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。</li>
<li>read（读取）: 作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的load动作使用。</li>
<li>load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。</li>
<li>use（使用）：作用于工作内存的变量，它把工作内存中一个变量的值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。</li>
<li>assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。</li>
<li>store（存储）：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的write操作使用。</li>
<li>write（写入）：作用于主内存的变量，它把store操作从工作内存中得到的变量的值放入主内存的变量中。</li>
</ul>
<p>Java内存模型还规定了在执行上述8种基本操作时必须满足一些规则：</p>
<ul>
<li>不允许read和load、 store和write操作之一单独出现，即不允许一个变量从主内存读取了但工作内存不接受，或者工作内存发起回写了但主内存不接受的情况。</li>
<li>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后必须把该变化同步回主内存。</li>
<li>不允许一个线程没有发生过任何assign操作就把数据从线程的工作内存同步回主内存中。</li>
<li>一个新的变量只能在主内存中“诞生”，不允许在工作内存中直接使用一个未被初始化(load或assign)的变量，换句话说就是对一个变量实施use、store操作之前，必须先执行assign和load操作。</li>
<li>一个变量在同一个时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，多次执行lock后，只有执行相同次数的unlock操作，变量才会被解锁。</li>
<li>对一个变量执行lock操作，那将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行load或assign操作以初始化变量的值。</li>
<li>一个变量事先没有被lock操作锁定，那就不允许对它执行unlock操作，也不允许去unlock一个被其他线程锁定的变量。</li>
<li>对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、write操作）。</li>
</ul>
<h4 id="volatile型变量的特殊规则"><a href="#volatile型变量的特殊规则" class="headerlink" title="volatile型变量的特殊规则"></a>volatile型变量的特殊规则</h4><p>当一个变量被定义成volatile之后，它将具备两项特性：</p>
<h5 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h5><p>保证此变量对所有线程的可见性，这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。而普通变量并不能做到这一点，普通变量的值在线程间传递时均需要通过主内存来完成。<br><em><strong>基于volatile变量的运算在并发下不一定是线程安全的，volatile变量在各个线程的工作内存中是不存在一致性问题的， 但是Java里面的运算操作符并非原子操作，这导致volatile变量的运算在并发下一样是不安全的。</strong></em></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @Description 基于volatile的可见性存在的高并发线程不安全问题测试</span><br><span class="line"> * @Author zhanshifeng</span><br><span class="line"> * @Date 2020/10/21 11:12 AM</span><br><span class="line"> */</span><br><span class="line">public class VolatileTest &#123;</span><br><span class="line"></span><br><span class="line">    public static volatile int race = 0;</span><br><span class="line"></span><br><span class="line">    public static void increase() &#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static final int THREADS_COUNT = 100;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        /**</span><br><span class="line">         * IDEA默认main主方法会开启两个线程</span><br><span class="line">         * java.lang.ThreadGroup[name=main,maxpri=10]</span><br><span class="line">         *     Thread[main,5,main]</span><br><span class="line">         *     Thread[Monitor Ctrl-Break,5,main]</span><br><span class="line">         */</span><br><span class="line">        Thread.currentThread().getThreadGroup().list();</span><br><span class="line">        Thread[] threads = new Thread[THREADS_COUNT];</span><br><span class="line">        for (int i = 0; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] = new Thread(() -&gt; &#123;</span><br><span class="line">                for (int j = 0; j &lt; 10000; j++) &#123;</span><br><span class="line">                    increase();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        for (Thread thread : threads) &#123;</span><br><span class="line">            thread.start();</span><br><span class="line">        &#125;</span><br><span class="line">        while (Thread.activeCount() &gt; 2) &#123;</span><br><span class="line">            Thread.yield();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *   public static void increase();</span><br><span class="line">     *     descriptor: ()V</span><br><span class="line">     *     flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">     *     Code:</span><br><span class="line">     *       stack=2, locals=0, args_size=0</span><br><span class="line">     *          // 当getstatic指令把race的值取到操作栈顶时，volatile关键字保证了race的值在此时是正确的</span><br><span class="line">     *          0: getstatic     #2                  // Field race:I</span><br><span class="line">     *          //  但是在执行iconst_1、iadd这些指令的时候，其他线程可能已经把race的值改变了，而操作栈顶的值就变成了过期的数据</span><br><span class="line">     *          3: iconst_1</span><br><span class="line">     *          4: iadd</span><br><span class="line">     *          // 所以putstatic指令执行后就可能把较小的race值同步回主内存之中。</span><br><span class="line">     *          5: putstatic     #2                  // Field race:I</span><br><span class="line">     *          8: return</span><br><span class="line">     *       LineNumberTable:</span><br><span class="line">     *         line 13: 0</span><br><span class="line">     *         line 14: 8</span><br><span class="line">     */</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码计算完之后结果是随机的，可见volatile只能保证变量可见性，在实际开发使用中，还是要依赖锁机制来写代码。</p>
<blockquote>
<p>如果在对某个变量是处于分别多线程单一修改和分别多线程读取的情况，这个时候适合使用volatile修饰变量</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">volatile boolean isShutdown;</span><br><span class="line">public void shutdown() &#123;</span><br><span class="line">    this.isShutdown = true;</span><br><span class="line">&#125;</span><br><span class="line">public void run() &#123;</span><br><span class="line">    while (isShutdown) &#123;</span><br><span class="line">        // do something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="指令重排序"><a href="#指令重排序" class="headerlink" title="指令重排序"></a>指令重排序</h5><p>使用volatile变量的另外一个作用是禁止指令重排序优化，普通的变量仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。<br>这就是Java内存模型中描述的所谓“线程内表现为串行的语义”（Within-Thread As-If-Serial Semantics）。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/iGuv6y.png"><br>如果定义initialized变量时没有使用volatile修饰，就可能会由于指令重排序的优化，导致位于线程A中最后一条代码“initialized&#x3D;true”被提前执行（机器级别的优化）。<br>在volatile修饰的变量做运算前，底层编译层汇编后，在赋值操作后，会多了一个内存屏障（Memory Barrier或Memory Fence），指重排序时不能把后面的指令重排序到内存屏障之前的位置，这个就能够保证其他线程读取变量值时的一致性。<br>从硬件架构上讲，指令重排序是指处理器采用了允许将多条指令不按程序规定的顺序分开发送给各个相应的电路单元进行处理，同时保证其计算结果的正确性。</p>
<blockquote>
<p>volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢上一点，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。<br>不过即便如此，大多数场景下volatile的总开销仍然要比锁来得更低。我们在volatile与锁中选择的唯一判断依据仅仅是volatile的语义能否满足使用场景的需求。</p>
</blockquote>
<h5 id="使用底层规则"><a href="#使用底层规则" class="headerlink" title="使用底层规则"></a>使用底层规则</h5><p>假定T表示一个线程，V分别表示volatile型变量，那么在进行read、load、use、assign、store和write操作时需要满足如下规则:</p>
<ul>
<li>只有当线程T对变量V执行的前一个动作是load的时候，线程T才能对变量V执行use动作；并且，只有当线程T对变量V执行的后一个动作是use的时候，线程T才能对变量V执行load动作。线程T对变量V的use动作可以认为是和线程T对变量V的load、read动作相关联的，必须连续且一起出现（作用于工作内存中，每次使用V前都必须先从主内存刷新最新的值，用于保证能看见其他线程对变量V所做的修改，这里将这个子规则简称为规则R）。</li>
<li>只有当线程T对变量V执行的前一个动作是assign的时候，线程T才能对变量V执行store动作；并且，只有当线程T对变量V执行的后一个动作是store的时候，线程T才能对变量V执行assign动作。线程T对变量V的assign动作可以认为是和线程T对变量V的store、write动作相关联的，必须连续且一起出现（同样遵循子规则R）。</li>
</ul>
<h4 id="针对long和double型变量的特殊规则（64位数据类型）"><a href="#针对long和double型变量的特殊规则（64位数据类型）" class="headerlink" title="针对long和double型变量的特殊规则（64位数据类型）"></a>针对long和double型变量的特殊规则（64位数据类型）</h4><p>如果有多个线程共享并未声明为volatile的long或double类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既不是原值，也不是其他线程修改值的代表了“半个变量’的数值（不过实际上出现的情况极其罕见）。<br>JDK 9起，HotSpot增加了一个实验性的参数<code>-XX: +AlwaysAtomicAccesses</code> （这是JEP 188对Java内存模型更新的一部分内容）来约束虚拟机对所有数据类型进行原子性的访问。</p>
<h4 id="原子性、可见性与有序性"><a href="#原子性、可见性与有序性" class="headerlink" title="原子性、可见性与有序性"></a>原子性、可见性与有序性</h4><h5 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h5><p>synchronized块实际上会被编译成为两种指令：monitorenter和monitorexit来确保操作原子性。</p>
<h5 id="可见性（Visibility）"><a href="#可见性（Visibility）" class="headerlink" title="可见性（Visibility）"></a>可见性（Visibility）</h5><p>可见性就是指当一个线程修改了共享变量的值时，其他线程能够立即得知这个修改，volatile、synchronized和final关键字都可以实现可见性。</p>
<ul>
<li>同步块的可见性是由“对一个变量执行unlock操作之前，必须先把此变量同步回主内存中（执行store、 write操作）”这条规则获得的。</li>
<li>final关键字的可见性是指：<br>被final修饰的字段在构造器中一旦被初始化完成，并且构造器没有把“this”的引用传递出去（this引用逃逸是一件很危险的事情，其他线程有可能通过这个引用访问到“初始化了一半”的对象），那么在其他线程中就能看见final字段的值。</li>
</ul>
<h5 id="有序性（Ordering）"><a href="#有序性（Ordering）" class="headerlink" title="有序性（Ordering）"></a>有序性（Ordering）</h5><h4 id="先行发生规则"><a href="#先行发生规则" class="headerlink" title="先行发生规则"></a>先行发生规则</h4><p>Java语言提供了volatile和synchronized两个关键字来保证线程之间操作的有序性，volatile关键字本身就包含了禁止指令重排序的语义，而synchronized则是由”一个变量在同一个时刻只允许一条线程对其进行lock操作”这条规则获得的，这个规则决定了持有同一个锁的两个同步块只能串行地进入。<br>一个操作“时间上的先发生”不代表这个操作会是“先行发生”，反之也是。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 同个线程中进行以下操作</span><br><span class="line">int i = 1;</span><br><span class="line">int j = 2;</span><br></pre></td></tr></table></figure>
<p>两条赋值语句在同一个线程之中，根据程序次序规则，“int i&#x3D;1”的操作先行发生于“int j&#x3D;2”，但是“int j&#x3D;2”的代码完全可能先被处理器执行，这并不影响先行发生原则的正确性，因为我们在这条线程之中没有办法感知到这一点。</p>
<h3 id="Java与线程"><a href="#Java与线程" class="headerlink" title="Java与线程"></a>Java与线程</h3><h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><p>线程是比进程更轻量级的调度执行单位，线程的引入，可以把一个进程的资源分配和执行调度分开，各个线程既可以共享进程资源（内存地址、文件I&#x2F;O等），又可以独立调度。<br>实现线程主要有三种方式：</p>
<ul>
<li>使用内核线程实现(1: 1实现)</li>
<li>使用用户线程实现(1: N实现)</li>
<li>使用用户线程加轻量级进程混合实现(N: M实现)</li>
</ul>
<h5 id="内核线程实现"><a href="#内核线程实现" class="headerlink" title="内核线程实现"></a>内核线程实现</h5><p>内核线程(Kernel-Level Thread，KLT)就是直接由操作系统内核(Kernel)支持的线程，这种线程由内核来完成线程切换，内核通过操纵调度器(Scheduler)对线程进行调度，并负责将线程的任务映射到各个处理器上。每个内核线程可以视为内核的一个分身，这样操作系统就有能力同时处理多件事情，支持多线程的内核就称为多线程内核(Multi-Threads Kernel)。<br>程序一般不会直接使用内核线程，而是使用内核线程的一种高级接口–轻量级进程（Light Weight Process, LWP），轻量级进程就是我们通常意义上所讲的线程，由于每个轻量级进程都由一个内核线程支持，因此只有先支持内核线程，才能有轻量级进程。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/lu7hFR.png"><br>轻量级进程也具有它的局限性：</p>
<ul>
<li>由于是基于内核线程实现的，所以各种线程操作，如创建、析构及同步，都需要进行系统调用。而系统调用的代价相对较高，需要在用户态(User Mode)和内核态(Kernel Mode)中来回切换。</li>
<li>每个轻量级进程都需要有一个内核线程的支持，因此轻量级进程要消耗一定的内核资源(如内核线程的栈空间)，因此一个系统支持轻量级进程的数量是有限的。</li>
</ul>
<h5 id="用户线程实现（User-Thread，UT）"><a href="#用户线程实现（User-Thread，UT）" class="headerlink" title="用户线程实现（User Thread，UT）"></a>用户线程实现（User Thread，UT）</h5><p>用户线程指的是完全建立在用户空间的线程库上，系统内核不能感知到用户线程的存在及如何实现的。用户线程的建立、同步、销毁和调度完全在用户态中完成，不需要内核的帮助。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/3Vd0km.png"><br>如果程序实现得当，这种线程不需要切换到内核态，因此操作可以是非常快速且低消耗的，也能够支持规模更大的线程数量，部分高性能数据库中的多线程就是由用户线程实现的。<br>但是用户线程实现方式也是优劣分明的，由于操作系统只把处理器资源分配到进程,那诸如“阻塞如何处理”“多处理器系统中如何将线程映射到其他处理器上”这类问题解决起来将会异常困难，甚至有些是不可能实现的。<br>Java语言曾经使用过用户线程，但后来还是放弃了，近些年倾向于高并发的编程语言又普遍支持用户线程，如Golang、Erlang等。</p>
<h5 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h5><p>这种实现方式既存在用户线程，也存在轻量级进程。用户线程还是完全建立在用户空间中，因此用户线程的创建、切换、析构等操作依然廉价，并且可以支持大规模的用户线程并发。而操作系统支持的轻量级进程则作为用户线程和内核线程之间的桥梁，这样可以使用内核提供的线程调度功能及处理器映射，并且用户线程的系统调用要通过轻量级进程来完成，这大大降低了整个进程被完全阻塞的风险。他们之间是多对多的关系。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/NUce76.png"></p>
<h5 id="Java线程的实现"><a href="#Java线程的实现" class="headerlink" title="Java线程的实现"></a>Java线程的实现</h5><p>“主流”商用Java虚拟机的线程模型普遍都使用基于操作系统原生线程模型来实现，即采用1: 1的线程模型。<br>每一个Java线程都是直接映射到操作系统原生线程来实现的，而且中间没有额外的间接结构，虚拟机是不会去干涉线程调度的（可以设置线程优先级给操作系统提供调度建议），全权交给底下的操作系统去处理，所以何时冻结或唤醒线程、该给线程分配多少处理器执行时间等，都是操作系统完成的。</p>
<h6 id="Java线程的调度"><a href="#Java线程的调度" class="headerlink" title="Java线程的调度"></a>Java线程的调度</h6><p>线程调度是指系统为线程分配处理器使用权的过程，调度主要方式有两种：</p>
<ul>
<li>协同式（Cooperative Threads Scheduling）线程调度：<br>这种方式的线程要把自己的事情干完后才会进行线程切换，切换操作对线程自己是可知的，所以一般没有什么线程同步的问题。Lua语言中的“协同例程”就是这类实现。<br>它的坏处也很明显：线程执行时间不可控制，甚至如果一个线程的代码编写有问题，一直不告知系统进行线程切换，那么程序就会一直阻塞在那里。</li>
<li>抢占式（Preemptive Threads-Scheduling）线程调度（Java的实现方式）：<br>这种方式的线程将由系统来分配执行时间，线程的切换不由线程本身来决定。譬如在Java中，有Thread:yield()方法可以主动让出执行时间，但是不能想要主动获取执行权限。<br>这种设计不会有一个线程导致整个进程甚至整个系统阻塞的问题，虽然说Java线程调度是系统自动完成的，但是我们仍然可以“建议”操作系统给某些线程多分配一点执行时间，另外的一些线程则可以少分配一点（通过设置线程优先级）。<br>在两个线程同时处于Ready状态时，优先级越高的线程越容易被系统选择执行，但是线程优先级不是一项稳定的调借手段，存在不确定性。<br>Java语言一共设置了10个级别的线程优先级（Thread.MIN_PRIORITY至Thread.MAX_PRIORITY），但Windows中就只有七种优先级，因此在Windows下设置线程优先级为1和2、3和4、6和7、8和9的效果是完全相同的。<br>Java线程优先级与Windows线程优先级的对应关系：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/E9AsBW.png"><br>优先级可能会被系统自行改变。例如在Windows系统中存在一个叫“优先级推进器”的功能(Priority Boosting,当然它可以被关掉)，大致作用是当系统发现一个线程被执行得特别频繁时，可能会越过线程优先级去为它分配执行时间，从而减少因为线程频繁切换而带来的性能损耗。</li>
</ul>
<h6 id="状态切换"><a href="#状态切换" class="headerlink" title="状态切换"></a>状态切换</h6><p>Java定义了6种线程状态，在任意一个时间点中，一个线程只能有且只有其中的一种状态，并且可以通过特定的方法在不同状态之间转换。</p>
<ul>
<li>新建(New)：创建后尚未启动的线程处于这种状态。</li>
<li>运行(Runnable)：包括操作系统线程状态中的Running和Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着操作系统为它分配执行时间。</li>
<li>无限期等待(Waiting)：处于这种状态的线程不会被分配处理器执行时间，它们要等待被其他线程显式唤醒。以下方法会让线程陷入无限期的等待状态：<ul>
<li>没有设置Timeout参数的Object::wait()；</li>
<li>没有设置Timeout参数的Thread::join()；</li>
<li>LockSupport::park()方法；</li>
</ul>
</li>
<li>限期等待(TimedWaiting)：处于这种状态的线程也不会被分配处理器执行时间，不过无须等待被其他线程显式唤醒，在一定时间之后它们会由系统自动唤醒。以下方法会让线程进入限期等待状态：<ul>
<li>Thread::sleep()方法；</li>
<li>设置了Timeout参数的Object::wait()方法；</li>
<li>设置了Timeout参数的Thread:join()方法；</li>
<li>LockSupport:parkNanos()方法；</li>
<li>LockSupport::parkUntil()方法；</li>
</ul>
</li>
<li>阻塞(Blocked)：线程被阻塞了，“阻塞状态”与“等待状态”的区别是“阻塞状态”在等待着获取到一个排它锁，这个事件将在另外一个线程放弃这个锁的时候发生；而“等待状态”则是在等待一段时间或者唤醒动作的发生。在程序等待进入同步区域的时候，线程将进入这种状态。</li>
<li>结束(Terminated)：已终止线程的线程状态，线程已经结束执行。</li>
</ul>
<p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/ySGBse.png"></p>
<h3 id="Java与协程"><a href="#Java与协程" class="headerlink" title="Java与协程"></a>Java与协程</h3><p>对于有栈协程OpenJDK 在2018年创建了Loom项目，这是Java用来应对，根据目前公开的信息，如无意外，日后该项目为Java语言引入的、与现在线程模型平行的新并发编程机制中应该也会采用“纤程”这个名字。<br>Loom团队在JVMLS 2018大会上公布了他们对Jetty基于纤程改造后的测试结果，同样在5000QPS的压力下，以容量为400的线程池的传统模式和每个请求配以一个纤程的新并发处理模式进行对比，前者的请求响应延迟在10000至20000毫秒之间，而后者的延迟普遍在200毫秒以下。</p>
<h2 id="线程安全与锁优化"><a href="#线程安全与锁优化" class="headerlink" title="线程安全与锁优化"></a>线程安全与锁优化</h2><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>当多个线程同时访问一个对象时，如果不用考虑这些线程在运行时环境下的调度和交替执行，也不需要进行额外的同步，或者在调用方进行任何其他的协调操作，调用这个对象的行为都可以获得正确的结果，那就称这个对象是线程安全的。<br>各种多线程操作共享数据可以分为五类。</p>
<h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><p>Java语言中，如果多线程共享的数据是基本数据类型，那么只要在定义时使用final关键字修饰它就可以保证它是不可变的。如果共享数据是一个对象，由于Java语言目前暂时还没有提供值类型的支持，那就需要对象自行保证其行为不会对其状态产生任何影响才行。<br>比如java.lang.String类的对象实例，它是典型的不可变对象，用户调用它的substring()、replace()和concat()这些方法都不会影响它原来的值，只会返回一个新构造的字符串对象。<br>保证对象行为不影响自己状态的途径有很多种，最简单的一种就是把对象里面带有状态的变量都声明为final,这样在构造函数结束之后，它就是不可变的。<br>在Java类库API中符合不可变要求的类型，除了String之外，常用的还有枚举类型及java.lang.Number的部分子类，如Long和Double等包装类型、BigInteger和BigDecimal等大数据类型。但同为Number子类型的原子类AtomicInteger和AtomicLong则是可变的。</p>
<h4 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全"></a>绝对线程安全</h4><p>一个类要达到“不管运行时环境如何，调用者都不需要任何额外的同步措施”可能需要付出非常高昂的，甚至不切实际的代价。在JavaAPI中标注自己是线程安全的类，大多数都不是绝对的线程安全。<br>比如常用的Vector、Collections.synchronizedCollection()这些在调用端不通过某些同步处理，有时候也会出现线程不安全的情况，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 如果有其他多个线程在同时调用vector的remove()、和add()，这个时候用以下的for可能会出现数组下标越界异常</span><br><span class="line">for(int i = 0; i &lt; vector.size(); i++)&#123;</span><br><span class="line">    vector.get(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h4><p>在Java中，大部分线程安全的类都是这种类型。</p>
<h4 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h4><p>平常说一个类不是线程安全的，通常就是指这种情况。</p>
<h4 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立"></a>线程对立</h4><p>一个线程对立的例子是Thread类的suspend()和resume()方法。如果有两个线程同时持有一个线程对象，一个尝试去中断线程，一个尝试去恢复线程，在并发进行的情况下，无论调用时是否进行了同步，目标线程都存在死锁风险。假如suspend()中断的线程就是即将要执行resume()的那个线程，那就肯定要产生死锁了。也正是这个原因，suspend()和resume()方法都已经被声明废弃了。</p>
<h3 id="线程安全实现的方法"><a href="#线程安全实现的方法" class="headerlink" title="线程安全实现的方法"></a>线程安全实现的方法</h3><h4 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h4><h5 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h5><p>互斥是实现同步的一种手段，临界区(Critical Section)、互斥量(Mutex)和信号量(Semaphore)都是常见的互斥实现方式。<br>在执行monitorenter指令时，首先要去尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经持有了那个对象的锁，就把锁的计数器的值增加一， 而在执行monitorexit指 令时会将锁计数器的值减一。一旦计数器的值为零，锁随即就被释放了。如果获取对象锁失败，那当前线程就应当被阻塞等待，直到请求锁定的对象被持有它的线程释放为止。<br>使用synchronized要注意的地方：</p>
<ul>
<li>被synchronized修饰的同步块对同一条线程来说是可重入的。这意味着同一线程反复进入同步块也不会出现自己把自己锁死的情况。</li>
<li>被synchronized修饰的同步块在持有锁的线程执行完毕并释放锁之前，会无条件地阻塞后面其他线程的进入。这意味着无法像处理某些数据库中的锁那样，强制已获取锁的线程释放锁;也无法强制正在等待锁的线程中断等待或超时退出。</li>
</ul>
<p>如果要阻塞或唤醒一条线程，则需要操作系统来帮忙完成，这就不可避免地陷入用户态到核心态的转换中，进行这种状态转换需要耗费很多的处理器时间。尤其是对于代码特别简单的同步块（譬如被synchronized修饰的getter()或setter()方法），状态转换消耗的时间甚至会比用户代码本身执行的时间还要长，因此才说，synchronized是Java语言中一个重量级的操作，必要的情况下才使用这种操作。</p>
<h5 id="可重入锁（ReentrantLock）"><a href="#可重入锁（ReentrantLock）" class="headerlink" title="可重入锁（ReentrantLock）"></a>可重入锁（ReentrantLock）</h5><p>ReentrantLock与synchronized相比增加了一些高级功能，主要有以下三项：</p>
<ul>
<li>等待可中断：是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。可中断特性对处理执行时间非常长的同步块很有帮助。</li>
<li>公平锁：是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有机会获得锁。synchronized中的锁是非公平的，ReentrantLock在默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。不过一旦使用了公平锁，将会导致ReentrantLock的性能急剧下降，会明显影响吞吐量。</li>
<li>锁绑定多个条件：是指一个ReentrantLock对象可以同时绑定多个Condition对象。在synchronized中，锁对象的wait()跟它的notify()或者notifyAll()方法配合可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外添加一个锁；而ReentrantLock则无须这样做，多次调用newCondition()方法即可。</li>
</ul>
<h4 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h4><p>互斥同步面临的主要问题是进行线程阻塞和唤醒所带来的性能开销，因此这种同步也被称为阻塞同步(Blocking Synchronization)。从解决问题的方式上看，互斥同步属于一种悲观的并发策略，其总是认为只要不去做正确的同步措施(例如加锁)，那就肯定会出现问题，无论共享的数据是否真的会出现竞争，它都会进行加锁，这将会导致用户态到核心态转换、维护锁计数器和检查是否有被阻塞的线程需要被唤醒等开销。<br>基于冲突检测的乐观并发策略，通俗地说就是不管风险，先进行操作，如果没有其他线程争用共享数据，那操作就直接成功了；如果共享的数据的确被争用，产生了冲突，那再进行其他的补偿措施，最常用的补偿措施是不断地重试，直到出现没有竞争的共享数据为止。这种乐观并发策略的实现不再需要把线程阻塞挂起，因此这种同步操作被称为非阻塞同步(Non-Blocking Synchronization)，使用这种措施的代码也常被称为无锁(Lock-Free)编程，或者叫乐观锁。</p>
<h5 id="CAS指令"><a href="#CAS指令" class="headerlink" title="CAS指令"></a>CAS指令</h5><p>非阻塞同步得益于现代处理器<code>比较并交换（Compare-and-Swap）</code>指令的诞生。<br>CAS指令需要有三个操作数，分别是内存位置(在Java中可以简单地理解为变量的内存地址，用V表示)、旧的预期值(用A表示)和准备设置的新值(用B表示)。CAS指令执行时，当且仅当V符合A时，处理器才会用B更新V的值，否则它就不执行更新。但是，不管是否更新了V的值，都会返回V的旧值，上述的处理过程是一个原子操作，执行期间不会被其他线程中断。<br><em><strong>直到JDK 9之后，Java类库才在VarHandle类里开放了面向用户程序使用的CAS操作。</strong></em></p>
<h5 id="CAS操作的”ABA问题”"><a href="#CAS操作的”ABA问题”" class="headerlink" title="CAS操作的”ABA问题”"></a>CAS操作的”ABA问题”</h5><p>如果一个变量V初次读取的时候是A值，并且在准备赋值的时候检查到它仍然为A值，那就能说明它的值没有被其他线程改变过了吗?<br>这是不能的，因为如果在这段期间它的值曾经被改成B，后来又被改回为A，那CAS操作就会误认为它从来没有被改变过。这个漏洞称为CAS操作的“ABA问题”。</p>
<h4 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h4><h5 id="可重入代码（Reentrant-Code）"><a href="#可重入代码（Reentrant-Code）" class="headerlink" title="可重入代码（Reentrant Code）"></a>可重入代码（Reentrant Code）</h5><p>可重入代码有一些共同的特征，例如，不依赖全局变量、存储在堆上的数据和公用的系统资源，用到的状态量都由参数中传入，不调用非可重入的方法等。<br>如果一个方法的返回结果是可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足可重入性的要求（比如常见的静态工具类的常用方法）。</p>
<h5 id="线程本地存储（Thread-Local-Storage）"><a href="#线程本地存储（Thread-Local-Storage）" class="headerlink" title="线程本地存储（Thread Local Storage）"></a>线程本地存储（Thread Local Storage）</h5><p>把共享数据的可见范围限制在同一个线程之内，就无须同步也能保证线程之间不出现数据争用的问题。<br>比如大部分使用消费队列的架构模式（如“生产者-消费者”模式）都会将产品的消费过程限制在一个线程中消费完，其中最重要的一种应用实例就是经典Web交互模型中的“一个请求对应一个服务器线程”（Thread-per-Request）的处理方式，<br>可以通过java.lang.ThreadLocal类来实现线程本地存储的功能。每个线程的Thread对象中都有一个ThreadLocalMap对象，这个对象存储了以ThreadLocal.threadLocalHashCode为键，以本地线程变量为值的K-V值对，<br>ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，每一个ThreadLocal对象都包含了一个独一无二的threadLocalHashCode值，使用这个值就可以在线程K-V值对中找回对应的本地线程变量。</p>
<h3 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h3><h4 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h4><p>互斥同步对性能最大的影响是阻塞的实现，挂起线程和恢复线程的操作都需要转入内核态中完成，共享数据的锁定状态只会持续很短的一段时间，很多时候为了这段时间去挂起和恢复线程并不值得。<br>当后面的线程暂时获取不到锁时，可以让后面请求锁的那个线程“稍等一会”，但不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只须让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。<br>自旋等待本身虽然避免了线程切换的开销，但它是要占用处理器时间的，所以如果锁被占用的时间很短，自旋等待的效果就会非常好，反之如果锁被占用的时间很长，那么自旋的线程只会白白消耗处理器资源。<br>因此自旋等待的时间必须有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程。自旋次数的默认值是十次，可以使用参数<code>-XX:PreBlockSpin</code>来自行更改。</p>
<p>在JDK 6中对自旋锁的优化，引入了自适应的自旋。自适应意味着自旋的时间不再是固定的了，而是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定的。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行中，那么虚拟机就会认为这次自旋也很有可能再次成功，进而允许自旋等待持续相对更长的时间，比如持续100次忙循环。另一方面，如果对于某个锁，自旋很少成功获得过锁，那在以后要获取这个锁时将有可能直接省略掉自旋过程，以避免浪费处理器资源。有了自适应自旋，随着程序运行时间的增长及性能监控信息的不断完善。</p>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>锁消除是指虚拟机即时编译器在运行时，对一些代码要求同步，但是对被检测到不可能存在共享数据竞争的锁进行消除。锁消除的主要判定依据来源于<code>逃逸分析</code>的数据支持，如果判断到一段代码中 ，在堆上的所有数据都不会逃逸出去被其他线程访问到，那就可以把它们当作栈上数据对待，认为它们是线程私有的，同步加锁自然就无须再进行。</p>
<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>原则上，推荐将同步块的作用范围限制得尽量小，只在共享数据的实际作用域中才进行同步，这样是为了使得需要同步的操作数量尽可能变少，即使存在锁竞争，等待锁的线程也能尽可能快地拿到锁。<br>大多数情况下，上面的原则都是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体之中的，那么同样的代码存在某些阶段或一部分场景没有过多的线程竞争（甚至完全没有的情况），那么频繁地进行互斥同步操作也会导致不必要的性能损耗。<br><em><strong>虚拟机探测到有这样零碎的操作都对同一个对象加锁，会把加锁同步的范围扩展(粗化)到整个操作序列的外部。</strong></em></p>
<h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>HotSpot虚拟机的对象头（Object Header）分为两部分：</p>
<ul>
<li>第一部分用于存储对象自身的运行时数据，如哈希码（HashCode)、GC分代年龄（Generational GC Age）等。这部分数据的长度在32位和64位的Java虚拟机中分别会占用32个或64个比特，官方称它为“Mark Word”。这部分是实现轻量级锁和偏向锁的关键。</li>
<li>另外一部分用于存储指向方法区对象类型数据的指针，如果是数组对象，还会有一个额外的部分用于存储数组长度。</li>
</ul>
<p><code>Mark Word</code>被设计成非固定的动态数据结构，以便在极小的空间内存储尽量多的信息。它会根据对象的状态复用自己的存储空间，32位HotSpot兑现头的”Mark Word”详细结构图：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/Xwt8ri.png"></p>
<h5 id="轻量级锁的工作过程"><a href="#轻量级锁的工作过程" class="headerlink" title="轻量级锁的工作过程"></a>轻量级锁的工作过程</h5><p>在代码即将进入同步块的时候，如果此同步对象没有被锁定（锁标志位为“01”状态），虚拟机首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝(官方为这份拷贝加了一个Displaced前缀，即Displaced Mark Word)， 这时候线程堆栈与对象头的状态：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/a4LgyJ.png"><br>然后，虚拟机将使用CAS操作尝试把对象的<code>Mark Word</code>更新为指向<code>Lock Record</code>的指针。如果这个更新动作成功了，即代表该线程拥有了这个对象的锁，并且对象Mark Word的锁标志位(Mark Word的最后两个比特)将转变为“00”，表示此对象处于轻量级锁定状态。这时候线程堆栈与对象头的状态如图：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/77CEBw.png"><br>如果这个更新操作失败了，那就意味着至少存在一条线程与当前线程竞争获取该对象的锁。虚拟机首先会检查对象的<code>Mark Word</code>是否指向当前线程的栈帧，如果是，说明当前线程已经拥有了这个对象的锁，那直接进入同步块继续执行就可以了，否则就说明这个锁对象已经被其他线程抢占了。如果出现两条以上的线程争用同一个锁的情况，那轻量级锁就不再有效，必须要膨胀为重量级锁，锁标志的状态值变为“10”，此时<code>Mark Word</code>中存储的就是指向重量级锁(互斥量)的指针，后面等待锁的线程也必须进入阻塞状态。</p>
<h5 id="轻量级锁的解锁过程"><a href="#轻量级锁的解锁过程" class="headerlink" title="轻量级锁的解锁过程"></a>轻量级锁的解锁过程</h5><p>解锁过程也同样是通过CAS操作来进行的，如果对象的<code>Mark Word</code>仍然指向线程的锁记录，那就用CAS操作把对象当前的<code>Mark Word</code>和线程中复制的<code>Displaced Mark Word</code>替换回来。假如能够成功替换，那整个同步过程就顺利完成了；如果替换失败，则说明有其他线程尝试过获取该锁，就要在释放锁的同时，唤醒被挂起的线程。</p>
<h5 id="轻量级锁-vs-重量级锁"><a href="#轻量级锁-vs-重量级锁" class="headerlink" title="轻量级锁 vs 重量级锁"></a>轻量级锁 vs 重量级锁</h5><p>轻量级锁能提升程序同步性能的依据是<code>对于绝大部分的锁，在整个同步周期内都是不存在竞争的</code>这一经验法则。如果没有竞争，轻量级锁便通过CAS操作成功避免了使用互斥量的开销；但如果确实存在锁竞争，除了互斥量的本身开销外，还额外发生了CAS操作的开销。</p>
<h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>如果说轻量级锁是在无竞争的情况下使用CAS操作去消除同步使用的互斥量，那偏向锁就是在无竞争的情况下把整个同步都消除掉，连CAS操作都不去做了。<br>“偏”的意思是这个锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁一直没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。</p>
<blockquote>
<p>偏向锁启用参数<code>-XX: +UseBiasedLocking</code>。</p>
</blockquote>
<p>当锁对象第一次被线程获取的时候，虚拟机将会把对象头中的标志位设置为“01”、把偏向模式设置为“1”，表示进入偏向模式。同时使用CAS操作把获取到这个锁的线程的ID记录在对象的Mark Word之中。如果CAS操作成功，持有偏向锁的线程以后每次进入这个锁相关的同步块时，虚拟机都可以不再进行任何同步操作(例如加锁、解锁及对Mark Word的更新操作等）。</p>
<p>一旦出现另外一个线程去尝试获取这个锁的情况，偏向模式就马上宣告结束。根据锁对象目前是否处于被锁定的状态决定是否撤销偏向（偏向模式设置为“0”），撤销后标志位恢复到未锁定（标志位为“01”） 或轻量级锁定（标志位为“00”）的状态，后续的同步操作就按照轻量级锁那样去执行。偏向锁、轻量级锁的状态转化及对象<code>Mark Word</code>的关系如图：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/EC1S58.png"></p>
<h5 id="偏向锁与哈希码的冲突之处"><a href="#偏向锁与哈希码的冲突之处" class="headerlink" title="偏向锁与哈希码的冲突之处"></a>偏向锁与哈希码的冲突之处</h5><p>一个对象如果计算过哈希码，就应该一直保持该值不变（强烈推荐但不强制，因为用户可以重载hashCode()方法按自己的意愿返回哈希码），否则很多依赖对象哈希码的API都可能存在出错风险。而作为绝大多数对象哈希码来源的Object::hashCode()方法，返回的是对象的一致性哈希码(Identity Hash Code)，这个值是能强制保证不变的，它通过在对象头中存储计算结果来保证第<br>一次计算之后，再次调用该方法取到的哈希码值永远不会再发生改变。</p>
<p>当对象进入偏向状态的时候，<code>Mark Word</code>大部分的空间（23个比特）都用于存储持有锁的线程ID了，这部分空间占用了原有存储对象哈希码的位置。</p>
<p><em><strong>因此，当对象已经计算过一致性哈希码后，它就再也无法进入偏向锁状态了；</strong></em>而当对象当前正处于偏向锁状态，又收到需要计算其一致性哈希码请求时，它的偏向状态会被立即撤销，并且锁会膨胀为重量级锁。在重量级锁的实现中，对象头指向了重量级锁的位置，代表重量级锁的ObjectMonitor类里有字段可以记录非加锁状态（标志位为“01”)下的<code>Mark Word</code>,其中自然可以存储原来的哈希码。</p>
<p>偏向锁可以提高带有同步但无竞争的程序性能，但它同样是带有效益权衡(Trade Off)性质的优化，也就是说它并非总是对程序运行有利。如果程序中大多数的锁都总是被多个不同的线程访问，那偏向模式就是多余的。有时候使用参数&#96;-XX: -UseBiasedLocking1来禁止偏向锁优化反而可以提升性能。</p>
<h1 id="HotSpot参数大全"><a href="#HotSpot参数大全" class="headerlink" title="HotSpot参数大全"></a>HotSpot参数大全</h1><h2 id="Xmx"><a href="#Xmx" class="headerlink" title="-Xmx"></a>-Xmx</h2><h2 id="Xms"><a href="#Xms" class="headerlink" title="-Xms"></a>-Xms</h2><h2 id="Xmn"><a href="#Xmn" class="headerlink" title="-Xmn"></a>-Xmn</h2><p>分配给Minor的大小</p>
<h2 id="XX-PrintGCDetails"><a href="#XX-PrintGCDetails" class="headerlink" title="-XX:+PrintGCDetails"></a>-XX:+PrintGCDetails</h2><p>告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。</p>
<h2 id="verbose"><a href="#verbose" class="headerlink" title="-verbose:**"></a>-verbose:**</h2><h3 id="verbose-class"><a href="#verbose-class" class="headerlink" title="-verbose:class"></a>-verbose:class</h3><p>查看加载的类的情况。</p>
<h3 id="–verbose-gc"><a href="#–verbose-gc" class="headerlink" title="–verbose:gc"></a>–verbose:gc</h3><p>打印出gc相关的信息；该信息不够高全面，等同于<code>-XX:+PrintGC</code>。其实只要设置<code>-XX:+PrintGCDetails</code>就会自动带上<code>-verbose:gc</code>和<code>-XX:+PrintGC</code></p>
<h3 id="–verbose-jni"><a href="#–verbose-jni" class="headerlink" title="–verbose:jni"></a>–verbose:jni</h3><h2 id="XX-PretenureSizeThreshold"><a href="#XX-PretenureSizeThreshold" class="headerlink" title="-XX:PretenureSizeThreshold"></a>-XX:PretenureSizeThreshold</h2><p>指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作。</p>
<h2 id="XX-UseSerialGC"><a href="#XX-UseSerialGC" class="headerlink" title="-XX:+UseSerialGC"></a>-XX:+UseSerialGC</h2><p>select the serial collector with the option <code>-XX:+UseSerialGC</code>.</p>
<h2 id="XX-MaxTenuringThreshold"><a href="#XX-MaxTenuringThreshold" class="headerlink" title="-XX:MaxTenuringThreshold"></a>-XX:MaxTenuringThreshold</h2><p>设置对象晋升老年代的年龄阈值。</p>
<h2 id="XX-HeapDumpOnOutOfMemoryError"><a href="#XX-HeapDumpOnOutOfMemoryError" class="headerlink" title="-XX:+HeapDumpOnOutOfMemoryError"></a>-XX:+HeapDumpOnOutOfMemoryError</h2><p>可以让虚拟机在内存溢出异常出现之后自动生成堆转储快照文件，通过<code>-XX:+HeapDumpOnCtrlBreak</code>参数则可以使用[Ctrl]+[Break]键让虚拟机生成堆转储快照文件，又或者在Linux系统下通过<code>kill -3 pid</code>命令发送进程退出信号“恐吓”一下虚拟机，也能顺利拿到堆转储快照。</p>
<h2 id="Xverify-none"><a href="#Xverify-none" class="headerlink" title="-Xverify:none"></a>-Xverify:none</h2><p>如果程序运行的全部代码（包括自已编写的、第三方包中的、从外部加载的、动态生成的等所有代码）都已经被反复使用和验证过，在生产环境的实施阶段就可以考虑使用<code>-Xverify: none</code>参数来关闭大部分的类验证措施，以缩短虚拟机类加载的时间。</p>
<h2 id="Xint"><a href="#Xint" class="headerlink" title="-Xint"></a>-Xint</h2><p>无论采用的编译器是客户端编译器还是服务端编译器，解释器与编译器搭配使用的方式在虚拟机中被称为“混合模式”(Mixed Mode)，用户也可以使用参数“-Xint”强制虚拟机运行于“解释模式”(Interpreted Mode)，这时候编译器完全不介入工作，全部代码都使用解释方式执行。</p>
<h2 id="Xcomp"><a href="#Xcomp" class="headerlink" title="-Xcomp"></a>-Xcomp</h2><p>强制虚拟机运行于“编译模式”(Compiled Mode)，这时候将优先采用编译方式执行程序，但是解释器仍然要在编译无法进行的情况下介入执行过程。</p>
<blockquote>
<p>可以通过虚拟机的“-version”命令的输出结果显示出这三种模式（mixed mode、interpreted mode、compiled mode）。</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">└─(14:35:28)──&gt; java -version</span><br><span class="line">java version &quot;11.0.8&quot; 2020-07-14 LTS</span><br><span class="line">Java(TM) SE Runtime Environment 18.9 (build 11.0.8+10-LTS)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.8+10-LTS, mixed mode)</span><br><span class="line"></span><br><span class="line">└─(14:35:28)──&gt; java -Xint -version</span><br><span class="line">java version &quot;11.0.8&quot; 2020-07-14 LTS</span><br><span class="line">Java(TM) SE Runtime Environment 18.9 (build 11.0.8+10-LTS)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.8+10-LTS, interpreted mode)</span><br><span class="line"></span><br><span class="line">└─(14:35:28)──&gt; java -Xcomp -version</span><br><span class="line">java version &quot;11.0.8&quot; 2020-07-14 LTS</span><br><span class="line">Java(TM) SE Runtime Environment 18.9 (build 11.0.8+10-LTS)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.9 (build 11.0.8+10-LTS, compiled mode)</span><br></pre></td></tr></table></figure>

<h2 id="XX-AlwaysAtomicAccesses"><a href="#XX-AlwaysAtomicAccesses" class="headerlink" title="-XX:+AlwaysAtomicAccesses"></a>-XX:+AlwaysAtomicAccesses</h2><p>JDK 9起，HotSpot增加了一个实验性的参数<code>-XX: +AlwaysAtomicAccesses</code> （这是JEP 188对Java内存模型更新的一部分内容）来约束虚拟机对所有数据类型进行原子性的访问。</p>
<h2 id="XX-PreBlockSpin"><a href="#XX-PreBlockSpin" class="headerlink" title="-XX:PreBlockSpin"></a>-XX:PreBlockSpin</h2><p>设置自旋次数限制，自旋次数的默认值是十次。</p>
<h2 id="XX-UseBiasedLocking"><a href="#XX-UseBiasedLocking" class="headerlink" title="-XX: +UseBiasedLocking"></a>-XX: +UseBiasedLocking</h2><p>偏向锁开关参数</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之思维练习错题笔记</title>
    <url>/2020/08/05/English%E7%B3%BB%E5%88%97%E4%B9%8B%E6%80%9D%E7%BB%B4%E7%BB%83%E4%B9%A0%E9%94%99%E9%A2%98%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>Yesterday I had a phone call from Clint. I was very surprised. I ______ （write） to him many times but he ______ （never, reply） to my letters.<br>答案：had written, had never replied<br>解析：两个或两个以上相继发生的动作，用and或but按动作发生的先后顺序连接，此时要用一般过去时，而不用过去完成时。过去完成时则强调主语在过去的某一时刻“回顾”更早的动作。具体来说，如果在谈论过去某一事件时，又想到在这之前已发生的某事，就要用过去完成时态。   </p>
<p>A: I need to find a dermatologist.（皮肤科医生） You’re familiar with Dr. Smith. Do you recommend her?<br>B: Well, I ______ （see） by her a few times. And the best I can say for her is she has interesting magazines in her waiting room.<br>答案：have been seen<br>解析：在英语中，“动作表达”的完成时态强调最近发生的事件，而“状态表达”的完成时态强调“较远的过去”经历。   </p>
<p>It’s reported that by the end of this month the output of cement in the factory ______ （rise） by about 10%.<br>答案：will have risen<br>解析：将来完成时是以“将来”作为“坐标时间”，来表示开始于将来之前（可能是过去、现在或将来）的动作持续到将来。但动作开始的时间并不重要，关键是说话人要站在将来的某一时间来谈某一动作的完成情况。</p>
<p>I have entered the university for two years.<br>答案：错误，应改为：I have been in the university for two years，或者用一般过去时态说成：I entered the university two years ago.</p>
<p>He has left his native place for three years.<br>答案：“单一事件”完成时的肯定句不与持续的时间状语连用，动词leave（left的原形）是非延续性动词，不能跟一段时间状语（否定句除外）。</p>
<p>A: Are you glad you came to China?<br>B: Yes. Indeed. 我本来是要考虑去Tokyo or Singapore, but 我从不后 悔我的决定。<br>答案：I’d considered going to Tokyo or Singapore, but I’ve never regretted my decision.<br>解析：表示“非真实”的过去，主要是指intend，mean，hope，want，plan，suppose，expect， think，propose和wish等动词用于过去完成时，可表示过去未能实现的计划、设想、意图或希望等。   </p>
<p>George would certainly have attended the proceedings ______.<br>A. had he not had a flat tire<br>B. had the tire no flattened itself<br>C. if the flat tire hadn’t happened<br>D. if he didn’t get a flat tire<br>答案：A</p>
<p>If Greek civilization ______ all of Europe, English wouldn’t contain so many Greek words.<br>A. hadn’t influenced<br>B. doesn’t influence<br>C. hasn’t influenced<br>D. didn’t influence<br>答案：A</p>
<p>Nelson ______ the fight, with a little more training and a better manager.<br>A. would win<br>B. had won<br>C. could have won<br>D. won<br>答案：C<br>解析：尼尔森本可以赢得这场战斗，但需要更多的训练和更好的教练。</p>
<p>He would rather ______ than worked last night.<br>A. have slept<br>B. has slept<br>C. sleep<br>D. slept<br>答案：A<br>解析：本题考查 would rather have done 的虚拟句型，本题相当于“He would rather have slept than have worked last night.” ，后边的 have 被省去了。</p>
<p>If the climate had been more favorable, the crops ______ still better.<br>A. would have grown<br>B. would be growing<br>C. would be grown<br>D. will grow<br>答案：A</p>
<p>These facts suggested that women ______ in opportunity for physical exercise by cultural taboos.<br>A. should been limited<br>B. had been limited<br>C. be limited<br>D. have been limited<br>答案：B<br>解析：这里的 suggested 是“表明，显示”而不是“建议”的意思，因而不用虚拟语气。</p>
<p>The result has turned still worse than it ______<br>A. would otherwise have been<br>B. would be otherwise<br>C. has otherwise been<br>D. had otherwise been<br>答案：A<br>解析：这里有 otherwise ，表明要用虚拟，且是虚拟的主句形式。另根据句意判断，这里是表示过去虚拟，故要用 would have done 形式，所以 A 正确。</p>
<p>We (could, might) go to that new restaurant opposite the cinema.<br>答案：could<br>解析：用于表示委婉的“建议”，此时，could并不表示过去。</p>
<p>You (could, may) be right, but I still don’t agree with you!<br>答案：may<br>解析：could更加的委婉和客观，因为后面的but I still don’t agree with you，所有要用may，即使两者可能性程度都很低。</p>
<p>The situation was bad but it (could be, may have been, could have been) worse.<br>答案：could have been</p>
<p>Thank you very much for buying me flowers. You ______ (buy) me flowers.<br>错误答案：couldn’t have bought<br>正确答案：shouldn’t have bought<br>解析：虽然could用于表示委婉的“建议，但是couldn’t就失去了委婉的含义了。</p>
<p>Mary was a talented violinist at the age of ten. She ______ (play) the violin very well when she was ten.<br>错误答案：must have played<br>正确答案：could play<br>解析：这里要表达的是过去的能力（过去的潜能）</p>
<p>Our worrying so much was a waste of time.&#x3D;We ______ (worry) so much.<br>错误答案：shouldn’t worry<br>正确答案：needn’t have worried<br>解析：这里的need是情态动词。表示“没必要做……”</p>
<p>It’s possible that the last person to leave didn’t lock the door.&#x3D;The last person to leave ______ (lock) the door.<br>错误答案：could haven’t locked<br>正确答案：may not have locked<br>解析：过去推测，在否定句中，can’t&#x2F;couldn’t要比may not&#x2F;might not的否定语气强烈。</p>
<p>She paid him and walked off. Then she realized that he ______ (not, be) a deaf mute. How did she know? He must have heard her initial instructions or he ______ (not, know) where to take her.<br>正确答案：can’t have been    wouldn’t have known<br>解析：can’t在此表示不可能，后者是过去虚拟语气</p>
<p>The boss has promised that every player in NBA ______ have a rise in income.<br>A. would B. might C. shall D. should<br>正确答案：C<br>解析：shall用于第二、三人称的陈述句中，可以表示说话人的许诺。</p>
<p>He was a good swimmer so he ______ swim to the river bank when the boat sank.<br>A. could B. might C. succeeded to D. was able to<br>正确答案：D<br>解析：was able to才是表达过去具体的能力，could只能表达过去潜在的能力。</p>
<p>He did very badly on the exam. He ______ harder.<br>A. must study B. must have studied C. should study D. should have studied<br>正确答案：D<br>解析：</p>
<p>He ______ pull down a bull and acknowledged as a man with superman strength.<br>A. used to be able to B. would be able to C. should be able to D. might be able to<br>正确答案：A<br>解析：为什么C不可以？</p>
<p>This book falls overdue a week; I must be fined.<br>这本书过期一周了，我肯定会被罚款。</p>
<p>He looked ______.<br>A. nervously<br>B. around nervous<br>C. around nervously<br>正确答案：C<br>解析：C。look作系动词时，意为“看起来”，后面接形容词作表语。look作行为动词时，意为“看”，lookC。look作系动词时，意为“看起来”，后面接形容词作表语。look作行为动词时，意为“看”，look around意为“朝周围看”，可以被副词nervously修饰，充当其方式状语。</p>
<p>In 1952 Ernest Hemingway published The Old Man and the Sea, ______.<br>A. won him the Nobel Prize for Literature in 1954<br>B. and the Nobel Prize for Literature won in 1954<br>C. in 1954 won the Nobel Prize for Literature for this work<br>D. a work that won him the Nobel Prize for Literature in 1954<br>正确答案：D<br>解析：本题考查双宾语结构：win sb. sth.。这里D选项中 a work是作为同位语，补充说明The Old Man and the Sea。然后在work后边接一个定语从句。 精品译文：在1952年，欧内斯特·海明威发表了小说《老人与海》，这部作品为他赢得了1954年的诺贝尔文学奖。</p>
<p>The question is ______ can be put into practice.<br>A. how you have learned<br>B. how that you have learned<br>C. that why you have learned<br>D. how what you have learned<br>正确答案：D<br>解析：D。这是从句的嵌套结构。首先是how引导一个表语从句，然后在此从句中，嵌套一个what引导的主语从句。其中what充当从句谓语learned的宾语。</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之完成时态（过去完成时）</title>
    <url>/2020/07/11/English%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AE%8C%E6%88%90%E6%97%B6%E6%80%81-%E8%BF%87%E5%8E%BB%E5%AE%8C%E6%88%90%E6%97%B6/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记摘选自张满胜老师的《英语语法新思维中级教程通悟语法第2版》，以及其他网上知识点收集，只是我自己的个人复习笔记，禁止转载，如有侵权，请联系我删除。</p>
</blockquote>
<p>过去完成时就是站在“过去时间”的角度回顾更远的另一个过去，表示一个事件从这个更远的过去持续到离现在较近的过去。</p>
<h2 id="在“过去”回顾“更远的过去”"><a href="#在“过去”回顾“更远的过去”" class="headerlink" title="在“过去”回顾“更远的过去”"></a>在“过去”回顾“更远的过去”</h2><p>现在完成时态的参照时间“现在”往往潜含在语境中，并不需要明确地表达出来。但是，<em><strong>对于过去完成时态，其参照时间“过去”则一般是要明确地在上下文中给出</strong></em>。<br>说得更具体点，就是必须先有一个过去时，然后以这个过去时作为参照的时间点，来谈论更远的过去，此时这个更远的过去才能用过去完成时态。因此，<em><strong>过去完成时态可以说是一个不能独立使用的时态</strong></em>，它必须依附于一个在上下文中出现的一般过去时。</p>
<p>At the hotel she asked immediately for Dr. Barrett, of St. Louis. He had left for home that morning and would not be back, she was told.<br>这里的had left是发生在过去的动作asked之前的，所以用了过去完成时。<br>另外值得注意的是，这里还有一个具体的过去时间that morning。对于这样一个具体的过去时间，句子若采用一般过去时态是没有问题的， 而这里用了过去完成时态。由此可见，过去完成时态可以与具体的过去时间状语连用。这不同于现在完成时态，因为<em><strong>现在完成时态是绝对不可以与具体的过去时间连用的</strong></em>。<br>一到酒店，她就立即打听从圣路易斯市来的巴雷特医生的消息。但被告知他在那天一早就动身回家了，将不会再回来了。</p>
<p>另外，<em><strong>by the time常常可以与过去完成时搭配使用，具体结构是：“过去完成时+by the time+一般过去时”</strong></em>。<br>A: It was my grandmother’s birthday yesterday.<br>B: Is she old?<br>A: Well, by the time we lit up the last candle on her birthday cake, the first one had gone out!<br>因为<em><strong>by the time本身的意思是“在……之前”</strong></em>，所以过去的动作lit之前发生了had gone out的动作，故用过去完成时态。</p>
<h2 id="延续事件、重复事件和单一事件的过去完成时"><a href="#延续事件、重复事件和单一事件的过去完成时" class="headerlink" title="延续事件、重复事件和单一事件的过去完成时"></a>延续事件、重复事件和单一事件的过去完成时</h2><p>过去完成时里同样涉及两个时间点：一个事件从更远的过去开始发生，然后“延续”到另一个较近的过去，或者“重复”到另一个较近的过去，或者在过去的某一时刻已经结束，这就分别构成了延续事件、重复事件和单一事件，类似于现在完成时，区别只是“坐标时间”由“现在”移至“过去”。</p>
<ul>
<li>在该过去时刻仍然在继续，或在该过去时刻刚刚停止（延续事件）；</li>
<li>在该过去时刻之前的一段时间内重复的动作（重复事件）；</li>
<li>在该过去时刻之前的某一时刻停止的动作（单一事件）。</li>
</ul>
<h3 id="过去完成时表示“延续事件”"><a href="#过去完成时表示“延续事件”" class="headerlink" title="过去完成时表示“延续事件”"></a>过去完成时表示“延续事件”</h3><p>如同现在完成时，过去完成时可以表示开始于过去之前（即过去的过去）的动作或状态在过去这一时刻仍在持续。具体来说，就是表示一个动作或状态在过去的某一时间之前已经开始，这一动作或状态一直持续到这一过去时间，并且到这一过去时间还未结束并仍有可能继续持续下去。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/9EeA6s.png"></p>
<p>I had stayed in America for two years when he moved here.<br>moved是过去的动作，stayed发生在moved之前，即过去的过去，并且在moved之后还将会继续下去，因此用过去完成时had stayed。</p>
<p>I had learned 1,000 words by the end of last year.<br>learned在过去的时间the end of last year之前已开始发生，到“去年年底”之后还将可能持续下去，因此用过去完成时had learned。<br>到去年末，我已经学会了1,000个单词。</p>
<p>A: It’s already 10 o’clock. I guess Bob and Amy won’t be coming to the party.<br>B: They called at nine to say that they’d been held up.<br>现在的时间是10点，在9点钟这一过去的时间打电话时，Bob和Amy已经“有事被耽误了”，所以“被耽误”应该用过去完成时 had been held up。<br>A：现在已经10点了。我猜想鲍勃和埃米不会来参加聚会了。<br>B：他们9点钟来过电话说他们有事被耽误了，不来了。</p>
<h3 id="过去完成时表示“重复事件”"><a href="#过去完成时表示“重复事件”" class="headerlink" title="过去完成时表示“重复事件”"></a>过去完成时表示“重复事件”</h3><p>如同现在完成时，过去完成时可以表示在过去之前开始的动作，在过去之前的一段时间内重复发生。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/j6mic0.png"><br>I had proposed to her five times, but she still refused to marry me. 我已经向她求婚五次了，但还是被拒绝。<br>I had written her 100 letters when she finally promised to marry me. 我给她写了100封信，她最后终于答应嫁给我了。</p>
<h3 id="过去完成时表示“单一事件”"><a href="#过去完成时表示“单一事件”" class="headerlink" title="过去完成时表示“单一事件”"></a>过去完成时表示“单一事件”</h3><p>如同现在完成时，过去完成时可以表示开始于过去之前的动作到过去这一时刻之前即已停止。具体来说，就是表示一个动作或状态在过去的某一时间之前已经开始，并在这一过去的时间之前即告结束，而没有持续到这一过去的时刻。这时过去完成时的动作通常是短暂动作。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/535prN.png"></p>
<p>She had made everything ready before I came.<br>在我来之前，她已经把一切都准备好了。</p>
<p>I had just sat down in the recliner to watch TV when I heard a knock on the door. When I opened the front door I saw a young man standing there staring at me.<br>在过去的动作“听(heard)”之前“坐(sit)”的动作已经完成，故用过去完成时had sat。</p>
<h2 id="过去完成时的其他意义和用法"><a href="#过去完成时的其他意义和用法" class="headerlink" title="过去完成时的其他意义和用法"></a>过去完成时的其他意义和用法</h2><h3 id="表示“非真实”的过去"><a href="#表示“非真实”的过去" class="headerlink" title="表示“非真实”的过去"></a>表示“非真实”的过去</h3><p>主要是指intend，mean，hope，want，plan，suppose，expect， think，propose和wish等动词用于过去完成时，可表示过去未能实现的计划、设想、意图或希望等。</p>
<p>I had intended to watch just one program, but somehow I couldn’t make myself switch off the TV.<br>我本来打算只看一个电视节目，可不知怎的，电视打开之后我就不想关。</p>
<p>She had hoped that he would come to date her, but he didn’t show up.<br>她本来希望他能来约会她，但是他没露面。</p>
<h2 id="过去完成时与一般过去时的比较"><a href="#过去完成时与一般过去时的比较" class="headerlink" title="过去完成时与一般过去时的比较"></a>过去完成时与一般过去时的比较</h2><blockquote>
<p>两个或两个以上相继发生的动作，用and或but按动作发生的先后顺序连接，此时要用一般过去时，而不用过去完成时。过去完成时则强调主语在过去的某一时刻“回顾”更早的动作。具体来说，如果在谈论过去某一事件时，又想到在这之前已发生的某事，就要用过去完成时态。</p>
</blockquote>
<p>He opened the door and entered, but found nobody.<br>他打开门进去了，但一个人都没看见。</p>
<p>I heard voices and realized that there were several people in the next room.<br>我听见说话的声音，知道隔壁房间里有好几个人。</p>
<p>I realized that we had met before. 我意识到我们以前见过面。<br>这里不说“I realized that we met before.*”。</p>
<blockquote>
<p>在表示两个相继发生的动作时，用过去完成时可以表示一个动作完成以后，另一个动作才开始发生，从而使得两个动作相互独立，彼此脱离开来。用一般过去时，则可能表示一个动作“导致”另一个动作的发生，或两个动作之间有因果关系。</p>
</blockquote>
<p>When I had opened all the windows, I sat down and had a cup of tea. 我把所有的窗子都打开后，就坐下来喝了杯茶。<br>不宜说“When I opened all the windows, I sat down and had a cup of tea.*”。<br>When I opened the window the cat jumped in. （比说When I had opened…更自然。） 我刚把窗子一打开，就有只猫跳了进来。<br>When I wrote him a letter, he came at once. 我给他去了封信后，他立即就来了。<br>When the singer had sung her song, she sat down. 这名歌手唱完歌以后，就坐下了。<br>上面这句话若说成“When the singer sang her song, she sat down.”，则可能给人造成这种印象：这位歌手喜欢坐着唱歌。</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之虚拟语气</title>
    <url>/2020/08/02/English%E7%B3%BB%E5%88%97%E4%B9%8B%E8%99%9A%E6%8B%9F%E8%AF%AD%E6%B0%94/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记摘选自张满胜老师的《英语语法新思维中级教程通悟语法第2版》，以及其他网上知识点收集，只是我自己的个人复习笔记，禁止转载，如有侵权，请联系我删除。<br>思维导图版本<a href="http://www.xmind.net/m/PdjmPE">点击这里</a>（Web版的XMind有一些问题）。</p>
</blockquote>
<p>表示说话者的一种主观愿望、假想和建议等等，实际上并不能实现。 这在英语里，用语法术语表达就叫“虚拟语气”。<br>If I could rearrange the alphabet, I would put U and I together.<br>一般来讲，英语中的虚拟语气可以分为两大体系：一是表示与事实相反的或假想的情形，通常由if引导，叫作“非真实条件句（unreal conditional）”，或者叫“虚拟条件句”；另一个体系是在名词从句中使用虚拟语气，表示建议、命令或要求等语气，这是一个完全不同于非真实条件句的虚拟的结构形式。</p>
<h2 id="虚拟条件句：两类三时"><a href="#虚拟条件句：两类三时" class="headerlink" title="虚拟条件句：两类三时"></a>虚拟条件句：两类三时</h2><p>这里说的“两类三时”是指虚拟条件句具有两种类型，并会对三种时间进行虚拟。<br>具体来说，虚拟条件句的两种类型是：***假设条件句 （hypothetical）和事实相反句（counterfactual）。 ***<br>假设条件句，顾名思义，是表示一种假想的情形，表示说话者的一种主观愿望或态度等，实现的可能性不大或极小。<br>事实相反句，顾名思义，是表示与现在或过去的某个事实相反的情形。对三种时间进行虚拟，即是对将来、现在和过去这三种时间的虚拟。<br>对于将来的情形只能是假设；对于现在的情形既可以是假设，也可以是谈与现在事实相反的情况；对于过去，只能是谈与事实相反的情形。</p>
<p>If I were to have the time tomorrow, I would help him.<br>这里是表示将来虚拟假设的情形。用了虚拟，就表明说话人“我”认为自己明天有时间的可能性不大，所以言外之意是“我”可能帮不了他。这里用虚拟只是说明可能性不大（unlikely），而不是表达与事实相违背的不可能的情形（impossible）。<br>If I had the time now, I would help him.<br>这里是表示现在虚拟假设的情形。用了虚拟，就表明说话人“我”认为自己现在有时间的可能性不大，所以言外之意是“我”可能帮不了他。这里用虚拟也只是说明可能性不大（unlikely），而不是表达与事实相违背的不可能的情形（impossible）。比如“我”现在完全可以抛开一切事情不做而去帮他，所以可能性还是存在的。<br>If I were you, I would help him.<br>这里是表示与现在事实相反的情形。因为“我”成为“你”是不可能发生的（impossible）情形，而不是可能性不大 （unlikely）的情形了。</p>
<p>表示与现在事实相反的情形：<br>If I were the President, I would make some changes.<br>“我”现在不是“总统”，这是一个现在的事实，即这里是表示与现在事实相反的情形。<br>如果我是总统，我就会做一些改革。<br>If my grandfather were alive today, he would experience a very different world.<br>If my grandfather were here now, he would be angry.<br>“我爷爷”现在不在这里，这是一个现在的事实，即这里是表示与现在事实相反的情形。<br>如果我爷爷现在在这里，他会很生气的。<br>表示对过去事实虚拟的句子：<br>If I had had the time yesterday, I would have helped him.</p>
<p>综上所述，假设条件句表达的是一种在将来或现在可能性不大（unlikely）的情形，但不是不可能（impossible）的情形，表示说话人认为不可能，是一种比较主观的表达，而不是与客观事实相反。它尤其用来谈将来的情形，也可以谈现在。事实相反句表达的是一种与现在或过去的事实相违背的情形，因此是不可能发生的，而不是可能性不大。它适合谈现在或过去。由此可见，谈将来的情形，只能是假设条件句；谈现在的情形，既可能是假设条件句，也可能是事实相反句；谈过去的情形，只能是事实相反句。</p>
<h2 id="虚拟条件句的谓语变化"><a href="#虚拟条件句的谓语变化" class="headerlink" title="虚拟条件句的谓语变化"></a>虚拟条件句的谓语变化</h2><p>三种不同时间下的主、从句的谓语形式列表如下：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/3VPsxo.png"></p>
<h2 id="将来虚拟（ZjCj）"><a href="#将来虚拟（ZjCj）" class="headerlink" title="将来虚拟（ZjCj）"></a>将来虚拟（ZjCj）</h2><p>将来虚拟只能是谈将来的“不大可能”的情形，而不是一个与事实相反的情形。我们常常会用将来虚拟来谈一个不太可能实现的愿望。比如：<br>If I were to live my life over again, I would have you as my wife.<br>这句将来虚拟表达的是一个良好的愿望，将来是不会实现的。<br>如果我有来生，我一定会娶你为妻。<br>或者用将来虚拟来谈一个说话人认为不太可能发生的情形，这表明了说话人的自信程度。比如：<br>If I should win the lottery, I would buy a house.<br>万一我赢得了彩票大奖，我就会买一栋房子。</p>
<p>对于很多将来的情况，选择用虚拟还是不用虚拟，完全取决于说话人对所陈述事件的态度，或者说虚拟语气能表明说话人的态度。比如：<br>What do you think would be the value of the necklace, if I were to sell it?<br>这里“卖项链”这个事件是说话人完全可以控制的，不是像“假如我有来生”那样完全不能掌控，但说话人依然用了将来虚拟的谓语形式were to sell，这只是表明说话人这样一个态度——不会卖或不大可能会卖这个项链。<br>假如我把这串项链卖了，你觉得会是什么价？<br>将来虚拟在很大程度上是由说话人对事件的态度决定的，所以，将来虚拟使用起来非常灵活。比如，同样是上面这个“卖项链”的事件，如果是对于一个急需用钱而且想把自己的项链卖掉来换钱的人，若他在询问卖价，这时他就不会用将来虚拟了，而是用一般陈述的语气来这样说：<br>What do you think is the value of the necklace if I sell it to you?<br>如果我把这串项链卖给你，你能出什么价？<br>这里说话人是真想卖掉项链，所以他就用is和sell这样的一般时态来询问卖价。</p>
<p>真实条件和将来虚拟条件的区别：<br>1） If it were to rain, I would stay home.<br>2） If it rains, I will stay home.<br>这种不同语气的选择，反映了说话人对未来下雨的可能性的信心程度不同。在例句1）中，用了虚拟语气，表明说话人认为将来不太可能会下雨。在例句2）中，用了陈述语气，表明说话人认为将来下雨的可能性比较大。<br>1）万一要下雨，那我就在家呆着。<br>2）如果下雨了，我就在家呆着。</p>
<blockquote>
<p>思维总结：</p>
</blockquote>
<p><em><strong>从句用were to do或should do，主句用 would do。其意义是用将来虚拟谈论自己认为不太可能发生的事情。另外要注意的是，将来虚拟在很大程度上是由说话人对事件的态度决定的。所以，将来虚拟使用起来非常灵活，这一点需要读者注意，即你说话语气（虚拟还是不虚拟）的选择，反映了你的态度。</strong></em></p>
<h2 id="现在虚拟（ZxCx）"><a href="#现在虚拟（ZxCx）" class="headerlink" title="现在虚拟（ZxCx）"></a>现在虚拟（ZxCx）</h2><p>If everyone lived like Americans, then you would need three planet earths to sustain that level of consumption.<br>由此可见，美国人常常指责别国破坏地球环境，浪费资源，殊不知他们自己才是破坏地球环境真正的罪魁祸首。在这句话中，彼得就是用了虚拟语气，因为事实上我们没有三个地球来供我们浪费和糟蹋。所以，主从句的谓语分别采用了“would动词（need）原形”和过去式（lived）这样标准的一般虚拟形式。<br>如果世界上每一个人都像美国人这般生活的话，那我们得需要三个地球方能维持这样的消费水平。</p>
<p>This has been my life. I have found it worth living, and would gladly live it again if the chance were offered me.<br>这就是我的一生。我已经找到了它的价值。而且如果有机会，我很愿意能再活它一次。</p>
<p>注意，比如对于“假如我当总统，我会……”这样一个简单的句子，都要根据说话人的不同身份来选择不同的语气表达。比如，这句话若是出自一个小学生之口， 他应该说成：<br>If I became President, I would…<br><em><strong>因为对于一个小学生来说，“当总统”是一个与现实相反的虚拟假设，所以这句话要借助谓语动词变化（即从句用过去式became，主句用would接一个原形动词）来传达这种虚拟的情形。</strong></em>但若是对于一位正在竞选中的总统候选人，比如2016年美国总统大选中的民主党候选人希拉里（Hillary），她则要这么说：<br>If I become President, I will make America stronger at home and more respected in the world.<br>如果我当了美国总统，我要让美国变得更强大，在国际上更受尊重。<br><em><strong>因为她应该用表示真实条件的陈述语气来表明对自己未来总统竞选获胜的信心。 如果希拉里用虚拟语气说：“If I became President, I would…”，恐怕连本来支持她的选民都要改旗易帜支持她的竞争对手了。</strong></em></p>
<blockquote>
<p>思维总结：</p>
</blockquote>
<p><em><strong>主句和从句都表示对现在一般情况的虚拟。此时，主句用would do，而从句用一般过去时态did；若从句的谓语是be动词，则一律用were。</strong></em></p>
<h2 id="过去虚拟（ZgCg）"><a href="#过去虚拟（ZgCg）" class="headerlink" title="过去虚拟（ZgCg）"></a>过去虚拟（ZgCg）</h2><p>贝克汉姆曾在一次新闻发布会上说：<br>Two years ago if someone had turned round to me and said“in two years you’ll be England captain”, I would have turned round and said:“I don’t think so!”<br>这里是一个对过去事实的虚拟：两年前并没有人跟小贝说过“你将在两年后成为英格兰队的队长”，所以，小贝在这里用了虚拟语气：从句用过去完成时had turned，主句用would have turned。</p>
<blockquote>
<p>思维总结：</p>
</blockquote>
<p><em><strong>表示对过去的虚拟，主句的谓语要采用 would have done的形式，从句的谓语则要用过去完成时态had done。</strong></em></p>
<h2 id="混合虚拟（一）：主句现在-从句过去-（ZxCg）"><a href="#混合虚拟（一）：主句现在-从句过去-（ZxCg）" class="headerlink" title="混合虚拟（一）：主句现在+从句过去 （ZxCg）"></a>混合虚拟（一）：主句现在+从句过去 （ZxCg）</h2><p>某个故事的结尾：<br>Boy, were you lucky that I came along. If you had married him, you would be the wife of a gas station attendant instead of the wife of a chief executive officer. （你瞧，嫁给了我真是你的幸运啊，你当初要是嫁给 了他，你现在就做不了总裁的太太，而只能是加油工的太太了。）<br>他太太也不甘示弱地回敬道： My dear, if I had married him, he would be the chief executive officer and you would be the gas station attendant. （嘿，亲爱的，如果我当初嫁 的是他，他就是总裁，而你就是加油工了。）<br>在这两个例句中，从句的“结婚（married）”这一活动是发生在过去，而且是与过去事实相反的一个假设，即是对过去的虚拟，所以谓语用的是过去完成时had married。不同的是，这里的主句是表示与现在事实相反的一个假设，即是对现在事实的虚拟，所以谓语用would be这样的动词形式。<br>简言之，这里的主句是对现在的虚拟，从句是对过去的虚拟，即主句和从句的虚拟时间不同。我们把这种主句、从句虚拟时间不一致的虚拟语气叫作“混合时间虚拟语气”。<br>对于混合虚拟语气，可以分两步判断：首先是根据上下文的语境，要能判断出某个句子是表达了与事实相反的情形，即虚拟；其次，分析主从句各自的虚拟时间有何不同，从而选择各自的谓语形式来表达不同的虚拟意义。</p>
<p>有则笑话如下：<br>A: I don’t like my mother-in-law.<br>B: Listen, don’t you realize that you couldn’t have your wife if it hadn’t been for your mother-in-law?<br>A: Yes, that’s why I don’t like her.<br>根据主句和从句的谓语形式，我们知道这是一个混合时间虚拟语气。主句的谓语couldn’t have表明是对现在的虚拟，从句的谓语hadn’t been表明是对过去的虚拟。那就要思考这里为什么要用混合时间虚拟呢？该如何判断虚拟时间呢？其实，这里的主句说“你不可能有你的妻子”，但事实是现在“你有妻子”，即是对现在一般情况的虚拟。那么从句为什么是表示对过去时间的虚拟呢？因为从句说“如果不是因为你的岳母”，言外之意是，“如果没有你的岳母生下你的妻子”——这是发生在过去的。所以，这里的从句是表示对过去的虚拟，于是采用过去完成时hadn’t been。<br>A：我不喜欢我的岳母。<br>B：听着，你有没有想过，如果没有你的岳母，哪来你现在的妻子啊？<br>A：正是因为这个所以我才不喜欢她。</p>
<blockquote>
<p>思维总结：</p>
</blockquote>
<p><em><strong>是ZxCg（主现从过）型虚拟语气，即主句对现在虚拟，用would do形式；从句对过去虚拟，用had done形式。这是最常用的一种混合虚拟语气。</strong></em></p>
<h2 id="混合虚拟（二）：主句过去-从句现在-（ZgCx）"><a href="#混合虚拟（二）：主句过去-从句现在-（ZgCx）" class="headerlink" title="混合虚拟（二）：主句过去+从句现在 （ZgCx）"></a>混合虚拟（二）：主句过去+从句现在 （ZgCx）</h2><p>某个故事中，如果将“如果我不爱她，我就不会娶她”翻译为英文，若是不懂英文的思维规律，只按照汉语的思维表达，将其译成英文就是：<br>If I don’t love her, I won’t marry her.<br>其实，这是一个典型的中式英语，并没有表达出原句的“言外之意”：我当然爱她，要不我就不会娶她了。但实际上他们已经结婚了。<br>可以选择的翻译大概如下：<br>If I didn’t love her, I wouldn’t have married her.<br>If I hadn’t loved her, I wouldn’t have married her.<br>If I didn’t love her, I wouldn’t marry her.<br>“如果我不爱她”，其实这是“正话反说”，实际上约翰是爱路易丝的，而且是一直都深爱着她，因此，这在英文中就是对“现在事实”表示虚拟。我们知道，从句对现在的虚拟要用一般过去时来表示，所以，这句话用正确的英文就要说成“If I didn’t love her…”。<br>“我就不会娶她”，实际上他们已经结婚了，所以，这句话是对“过去事实”的虚拟。在英文中，主句对过去的虚拟要用would have done的谓语动词形式。所以，这句话的正确英文表达是“I wouldn’t have married her.”。<br>根据以上分析，原句是一个ZgCx（主过从现）型的混合时间虚拟语气，即主句表示对过去事实的虚拟，从句则是表示对现在事实的虚拟。<br>因此，“如果我不爱她，我就不会娶她”这句话的正确英文表达应该是“If I didn’t love her, I wouldn’t have married her.”。<br>再来分析另外两个例句：<br>If I hadn’t loved her, I wouldn’t have married her.<br>这是一个ZgCg（主过从过）型虚拟语气，即主句和从句都表示对过去的虚拟。含义是：在结婚时约翰是爱她的，要不然当时就不会娶她。言外之意 可能是：当时能和她结婚，是因为当时爱她，但现在已经不爱了（所以离婚吧）。<br>If I didn’t love her, I wouldn’t marry her.<br>这里的wouldn’t marry 表示两人还没有结婚，说的是将来的情况。真正意思是“如果我不爱她，我将来就不打算和她结婚了”。这显然是以男朋友的身份来说这话的。</p>
<blockquote>
<p>思维总结：</p>
</blockquote>
<p><em><strong>ZgCx（主过从现）型混合时间虚拟语气，即主句对过去虚拟，用would have done的形式；从句对现在虚拟，用did的形式。</strong></em></p>
<h2 id="倒装虚拟"><a href="#倒装虚拟" class="headerlink" title="倒装虚拟"></a>倒装虚拟</h2><p>在英文中，虚拟从句可以采用倒装结构。具体来说，当if引导的条件句省去if时，可将should，had或were置于句首，从而构成倒装虚拟句，而意义不变。<br>Should I win the lottery, I would buy a car.<br>&#x3D;If I should win the lottery, I would buy a car.<br>如果我能赢得大奖，我就会买一辆车。</p>
<p>Were he to leave today, he would get there by Monday.<br>&#x3D;If he were to leave today, he would get there by Monday.<br>如果他今天出发，他就能在星期一之前到达那里。</p>
<p>Should you change your mind, no one would blame you.<br>&#x3D;If you should change your mind, no one would blame you.<br>如果你改变主意的话，没有人会责怪你。</p>
<p>另外在英语口语里，我们常常会使用“疑问句+陈述句”这样的结构，如：<br>Are you ready? Okay we can leave.<br>这里的一般疑问句就相当于一个条件从句“If you are ready…”，于是整个句子相当于“如果你准备好了，那我们现在就走”。<br>你准备好了吗？那我们现在就走。</p>
<h2 id="跳层虚拟"><a href="#跳层虚拟" class="headerlink" title="跳层虚拟"></a>跳层虚拟</h2><p>He must have heard her initial instructions or he would not have known where to take her.<br>在她刚上车时告诉他要去哪里，他一定是听清了，否则他不会知道该把她送到哪儿。<br>这个句子的谓语比较复杂，一个是must have heard，另一个是would not have known，即两个都带有情态动词。要注意的是，这里的must have heard不是虚拟语气，而是must表示推测的用法。在英文中，“must+have done”结构表示对过去的推测。也就是说，这里谈论的是一个过去的情形。接下来有一个关键词or，表示“否则”，其后面接的就是虚拟语气。此时要搞清楚两点： 一是虚拟的时间。由or前面的句子我们知道，这里是表示对过去的虚拟；二是句子的谓语采用虚拟主句的谓语形式还是从句的谓语形式。因为or后面的句子相当于一个虚拟主句，所以其谓语自然要采用虚拟主句的谓语形式。搞清楚这两点，就知道为什么要说would not have known了，因为这正是一个过去虚拟的主句谓语结构形式。<br>这类虚拟句一般分为两部分，两部分在语气上截然相反，一部分虚拟，另一部分不虚拟，而用的是陈述语气，用以陈述一个事实。比如上面这个句子就是“陈述句or+虚拟句”这样的结构。它们二者之间往往有but，or，or else或otherwise来连接。正是因为这种虚拟与不虚拟兼而有之，一部分虚拟， 一部分又跳出虚拟的圈子，故称之为“跳层虚拟句”。</p>
<h3 id="陈述句-or-虚拟主句"><a href="#陈述句-or-虚拟主句" class="headerlink" title="陈述句+or+虚拟主句"></a>陈述句+or+虚拟主句</h3><p>这里的连接词除了or，还可以用or else和otherwise。需要注意的是，or前面的句子是陈述语气，而后面的句子用的是虚拟语气，而且是虚拟主句。具体的谓语搭配结构是：</p>
<ul>
<li>主语一般现在时的谓语形式, or+主语+would do→表示对现在事实的虚拟；</li>
<li>主语+一般过去时的谓语形式, or+主语+would have done→表示对过去事实的虚拟。</li>
</ul>
<p>We didn’t know his telephone number, otherwise we would have telephoned him.<br>&#x3D;We would have telephoned him if we had known his telephone number.<br>这里的didn’t表示陈述过去的事实，而otherwise的后面则是对过去的虚拟，且是虚拟主句的形式，因此 要用would have done.</p>
<p>He must have had an accident, or he would have been here then.<br>这里or的前面通过用must have had 这一形式来表示对过去的推测，是属于陈述过去，而or的后面则用过去虚拟。<br>他一定是出事故了，要不然早就到了。</p>
<p>Mary couldn’t have received my letter; otherwise she would have replied before now.<br>这里otherwise后面的句子表示对过去的虚拟，相应地，其前面的半个句子就是表示陈述过去，所以要用一般过去时。不过，这里情态动词的过去时态couldn’t have done的形式表示对过去的推测，类似于must表示推测。</p>
<h3 id="虚拟主句-but-陈述句"><a href="#虚拟主句-but-陈述句" class="headerlink" title="虚拟主句+but+陈述句"></a>虚拟主句+but+陈述句</h3><p>与or等词不同的是，这里but的前面是虚拟主句，but的后面是陈述句。该句型的使用规律是：</p>
<ul>
<li>主语+would do, BUT+主语+一般现在时的谓语形式→表示对现在事实的虚拟；</li>
<li>主语+would have done, BUT+主语+一般过去时的谓语形式→表示对过去事实的虚拟。</li>
</ul>
<p>当然，句中的would可换成should, might或could。这类跳层虚拟句的关键标志词是but，随着but一转折，句子的语气也由虚拟变为不虚拟，即but将句子一分为二，but前面部分的句子用虚拟语气，but后面部分的句子用陈述语气。</p>
<p>He would put on weight, but he doesn’t eat much.<br>&#x3D;He would put on weight if he ate much.<br>这里不用didn’t，而是doesn’t。因为前面的would不是表示过去时态，而是表示对现在事实的虚拟，原句相当于“If he ate much, he would put on weight.”。这就解释了为什么but前面的半句话相当于虚拟主句形式了，因为but后面的陈述句相当于一个虚拟从句。<br>他本来是会发胖的，但是他从来不会多吃。</p>
<p>Some women could have made a good salary in a job instead of staying home, but they decided not to work for the sake of the family.<br>&#x3D;Some women could have made a good salary in a job instead of staying home if they hadn’t decided not to work for the sake of the family.<br>这里but后面的句子是陈述过去的事实，but前面的句子是对过去的虚拟，所以采用过去虚拟主句的谓语形式could have made。<br>有些妇女本来是能够挣得高薪的，但是为了家庭，她们放弃了工作，呆在家里。<br>有时不用but来表示转折，而是用其他副词，比如下句中的 unfortunately：<br>A safety analysis would have identified the target as a potential danger. Unfortunately, it was never done.<br>这里的unfortunately在语义上相当于but，表示转折，使句子从虚拟转为不虚拟。这里的was表示过去，因此前半部分也是表示过去，所以采用过去虚拟主句的谓语形式would have identified。<br>若是做一下安全分析，就可以发现这个潜在的隐患，但遗憾的是，并没有做安全分析。</p>
<blockquote>
<p>思维总结:</p>
</blockquote>
<p>共有两类跳层虚拟句，一类是由or等引导的，具体的句型结构是： </p>
<ul>
<li>主语+一般现在时谓语形式，or+主语+would do→表示对现在事实的虚拟； </li>
<li>主语+一般过去时谓语形式，or+主语+would have done→表示对过去事实的虚拟。</li>
</ul>
<p>另一类是由but引导的，具体的句型结构是： </p>
<ul>
<li>主语+would do，but+主语+一般现在时谓语形式→表示对现在事实的虚拟； </li>
<li>主语+would have done，but+主语+一般过去时谓语形式→表示对过去事实的虚拟。</li>
</ul>
<p>注意这两类句型的前后两个分句的语气正好相反。</p>
<h2 id="名词从句中如何使用虚拟"><a href="#名词从句中如何使用虚拟" class="headerlink" title="名词从句中如何使用虚拟"></a>名词从句中如何使用虚拟</h2><p>在特定的名词从句中也需要用虚拟语气。这里所说的“特定的名词从句”，是指这样的名词从句中均要含有特定的标志词，这些标志词可用来表示愿望、建议、命令、请求或意志等语气。<br>而且，与非真实条件虚拟句中的主句和从句的谓语动词的形式完全不同的是，名词从句虚拟句的谓语变化的形式只有一条规律，那就是：名词从句虚拟句无论其主句的谓语动词是何种形式，从句的谓语形式均为“should动词原形”，其中should可以省去。这里特别要提醒读者注意：不是用would，而是用should。比如：<br>I suggest that we should go tomorrow.<br>I suggested that we should go the next day.<br>上面两个例句中的suggest 即是我们所说的标志词。这里从句中谓语的时态（should go）并没有受主句谓语时态（suggest， suggested）的影响。</p>
<ol>
<li>我建议我们明天走。 </li>
<li>我当时建议我们第二天走。</li>
</ol>
<blockquote>
<p>要掌握名词从句的虚拟句，最终归结为：记住相应的标志词即可：</p>
</blockquote>
<h3 id="此类虚拟语气的宾语从句常见标记词"><a href="#此类虚拟语气的宾语从句常见标记词" class="headerlink" title="此类虚拟语气的宾语从句常见标记词"></a>此类虚拟语气的宾语从句常见标记词</h3><p>ask （要求，请求），advise，beg，command，demand，decide， deserve，desire，determine，insist，move （动议，提议），order， prefer，propose，require，recommend，request，suggest和urge等。</p>
<p>His father urged that he study medicine.<br>注意这句话中用study，不用studies，省略了should。<br>他父亲要求他学医。</p>
<p>The instructions ask that we not take more than three tablets once.<br>从句的谓语not take相当于should not take，这里should被省去了。<br>说明书要求每次服用的量不超过三粒。</p>
<p>The board deemed it urgent that these files should be printed right away.<br>这里因为有了形容词urgent，所以从句要用虚拟语气， 即用动词should be printed的形式。<br>董事会要求把这些文件立刻打印出来。</p>
<h3 id="在it-is-形容词-x2F-过去分词-x2F-特定的名词-that的主语从句中"><a href="#在it-is-形容词-x2F-过去分词-x2F-特定的名词-that的主语从句中" class="headerlink" title="在it is+形容词&#x2F;过去分词&#x2F;特定的名词+that的主语从句中"></a>在it is+形容词&#x2F;过去分词&#x2F;特定的名词+that的主语从句中</h3><h4 id="形容词"><a href="#形容词" class="headerlink" title="形容词"></a>形容词</h4><p>astonishing，amazing，advisable，appropriate，crucial，desirable， essential，important，imperative，keen，necessary，natural，normal， odd，proper，preferable，strange，sorry，shocked，surprising，urgent， unusual和vital等。这些形容词一般表示个人对事件的反应。<br>If we are ever going to protect the atmosphere, it is crucial that those new plants be environmentally sound.<br>这里因为有了形容词crucial，所以从句要用虚拟语气，即用动词原形be。<br>我们若是想保护大气层，那么就应该要求那些新开工的工厂对环境无害。</p>
<p>It is natural that I should dwell upon his successes rather than upon his failures.<br>我宁愿强调他成功的地方，而不愿突出他的失败之处，这是理所当然的。</p>
<p>It is strange that he should not come here.<br>这里的should只表明一种意外的语气，可译为“竟然”。<br>他竟然没来，这真是太奇怪了。</p>
<p>It is important that the hotel receptionist make sure that guests are registered correctly.<br>宾馆的前台接待人员应该确认客人们登记注册无误，这是十分重要的。</p>
<h4 id="过去分词"><a href="#过去分词" class="headerlink" title="过去分词"></a>过去分词</h4><p>decided，desired，demanded，ordered，requested，required， recommended和suggested等。<br>It is requested that all members be present at the meeting. 要求所有的成员都出席这次会议。<br>It is politely requested by the hotel management that radios not be played after 11 o’clock at night.<br>宾馆的管理人员恳请客人晚上11点以后不要开收音机。</p>
<h4 id="特定的名词"><a href="#特定的名词" class="headerlink" title="特定的名词"></a>特定的名词</h4><p>advice，decision，desire，demand，suggestion，motion，pray， resolution，wish，preference，proposal，recommendation，requirement， idea和order等。<br>It is my proposal that he be sent to study further abroad. 我建议把他送到国外去学习。</p>
<h4 id="在上述名词的表语从句和同位语从句中"><a href="#在上述名词的表语从句和同位语从句中" class="headerlink" title="在上述名词的表语从句和同位语从句中"></a>在上述名词的表语从句和同位语从句中</h4><p>For my own part, it seems that the main requirement of an international language is that it be easily learned.<br>我个人认为，对于一门国际语言最主要的要求是，它必须易于学习。<br>The suggestion that the mayor present the prizes was accepted by everyone. 由市长颁奖的建议被所有人接受了。</p>
<h2 id="各种虚拟句型"><a href="#各种虚拟句型" class="headerlink" title="各种虚拟句型"></a>各种虚拟句型</h2><h3 id="在wish后面的宾语从句中"><a href="#在wish后面的宾语从句中" class="headerlink" title="在wish后面的宾语从句中"></a>在wish后面的宾语从句中</h3><p>这是读者非常熟悉的一个虚拟句型，它用来表示说话者难以实现的或与事实违背的愿望，具有较强的感情色彩，可分别表示对现在、过去和将来情景的虚拟。</p>
<h4 id="对现在的虚拟"><a href="#对现在的虚拟" class="headerlink" title="对现在的虚拟"></a>对现在的虚拟</h4><p>即表示对现状的愿望，从句的谓语动词用过去时。<br>I wish I were a little younger. 我希望我能够年轻一点。<br>I wish I could travel to the moon (but I can’t do that). 我希望我能够登上月球（但实际上我不能）。<br>Whenever something goes wrong, I just push this little Reset button and restart. I wish my whole life were like that!<br>每次电脑出故障的时候，我只要按一下Reset键，电脑就可以重启了。我真希望人生也能如此啊！<br>事实上，人生不可能如此简单。如果做错事了，想让时光倒流，重新来选择，这是不可能的。</p>
<h4 id="对过去的虚拟"><a href="#对过去的虚拟" class="headerlink" title="对过去的虚拟"></a>对过去的虚拟</h4><p>即对过去发生的事情表示遗憾或后悔，从句的谓语动词用过去完成时（had done）或“would&#x2F;could+现在完成时”，意指从句的谓语动词所表示的动作发生在主句的谓语所表示的动作之前。<br>I wish I had been there. 我真希望我当时在那儿。<br>I wish I could have gone with you to the concert last night. 我真希望昨晚能和你一起去听音乐会。</p>
<h4 id="对将来的虚拟"><a href="#对将来的虚拟" class="headerlink" title="对将来的虚拟"></a>对将来的虚拟</h4><p>指对将来发生的事情表示祝愿，从句的谓语动词用“would&#x2F;could+动词原形”，意指从句的谓语动词所表示的动作可能发生在主句的谓语所表示的动作之后。<br>I wish he could explain what he means. 我希望他能解释一下他是什么意思。<br>I wish you would shut up. 我希望你能闭嘴。<br>注意，即使将wish改为wished，上述例句谓语的时态仍然不变。</p>
<h3 id="在if-only感叹句中"><a href="#在if-only感叹句中" class="headerlink" title="在if only感叹句中"></a>在if only感叹句中</h3><p>if only表示“但愿”“要是……就好了”，其用法和wish基本相同，可表示对现在、过去和将来的虚拟，只是比wish具有更强烈的感情色彩。<br>If only the rain would stop. 但愿雨能停。（对将来的虚拟）<br>If only I were taller. 我的个子要是能高一点就好了。（对现在的虚拟）<br>If only he had followed your advice! 他要是听从了你的建议就好了！（对过去的虚拟）</p>
<p>另外需要注意的是，可以把only放到句中的位置。<br>If he had only followed your advice!</p>
<p>If I’d only remembered to lock the door.<br>&#x3D; I wish I had locked the door.<br>if only与wish的用法和意义均相同，比如这里wish的后面也是接过去完成时来表示过去虚拟的事件。<br>我要是记得锁门就好了。</p>
<h3 id="在as-if-x2F-as-though引导的从句中"><a href="#在as-if-x2F-as-though引导的从句中" class="headerlink" title="在as if&#x2F;as though引导的从句中"></a>在as if&#x2F;as though引导的从句中</h3><h4 id="表示与现在事实相反或对现在情况有所怀疑，谓语用过去时"><a href="#表示与现在事实相反或对现在情况有所怀疑，谓语用过去时" class="headerlink" title="表示与现在事实相反或对现在情况有所怀疑，谓语用过去时"></a>表示与现在事实相反或对现在情况有所怀疑，谓语用过去时</h4><p>I really don’t care for the way you’re speaking to me. It seems as if you were my father.<br>我真的非常讨厌你和我说话的方式。你听起来就好像是我爸爸。<br>You should live each day as if it were the last and use every second to your advantage. That means setting goals, being involved on campus and in your community, working hard, and most importantly, never giving up!</p>
<h4 id="表示与过去事实相反，谓语用过去完成时"><a href="#表示与过去事实相反，谓语用过去完成时" class="headerlink" title="表示与过去事实相反，谓语用过去完成时"></a>表示与过去事实相反，谓语用过去完成时</h4><p>It seems as if he has been to America. 他好像去过美国。</p>
<h4 id="在it-is-（high）-time-（that）从句中"><a href="#在it-is-（high）-time-（that）从句中" class="headerlink" title="在it is （high） time （that）从句中"></a>在it is （high） time （that）从句中</h4><p>该句型表示“该是做什么事的时候了”，含有“晚了一点”的意思，从句中用过去时。<br>Don’t dawdle away your youth any more. It is time you thought about your future.<br>不要再浪费青春了，你该考虑自己的将来了。<br>It seems to be high time that this argument were put to an end.<br>现在似乎是时候结束争吵了。</p>
<h4 id="在would-rather-would-（just）-as-soon-would-sooner-would-prefer等从句中"><a href="#在would-rather-would-（just）-as-soon-would-sooner-would-prefer等从句中" class="headerlink" title="在would rather, would （just） as soon, would sooner, would prefer等从句中"></a>在would rather, would （just） as soon, would sooner, would prefer等从句中</h4><h5 id="would-rather-do-sth"><a href="#would-rather-do-sth" class="headerlink" title="would rather do sth."></a>would rather do sth.</h5><p>would rather的后面接动词原形，可以表示将来或现在的事件，意指“主语宁愿自己做某事”。这是would rather最常见的用法。<br>I would rather go there tomorrow. 我想明天去那里。<br>He would rather stay at home than go to the cinema tonight.<br>他今晚就想在家里呆着, 而不想去看电影。<br>注意，对该句型的否定，要在动词的前面加not，而不是在would的后面加not。例如：<br>1） He would rather not stay at home tonight. 他今晚不想在家呆着。<br>2） He would not rather stay at home tonight. *</p>
<h5 id="would-rather-have-done-sth"><a href="#would-rather-have-done-sth" class="headerlink" title="would rather have done sth."></a>would rather have done sth.</h5><p>这是would rather后面接动词完成式的用法，表示过去的事件，意指“某人宁愿自己过去做了某事，但实际上没有做”，因此，具有过去虚拟的意味，如同过去虚拟条件主句的谓语形式。<br>I took Sally to the cinema last night, but I would rather have been there alone.<br>这里的would rather have been表示对过去的虚拟，意思是“还不如自己一个人去”，但实际上不是一个人去的。<br>我昨晚带萨莉看电影去了，可是我还不如自己一个人去呢（真不该带她去）。</p>
<h5 id="would-rather-sb-did"><a href="#would-rather-sb-did" class="headerlink" title="would rather sb. did"></a>would rather sb. did</h5><p>这是would rather后面接从句的用法，意指“主语宁愿让另一个人做某事”。这里从句的谓语用一般过去式，但表示的是现在或将来的事件，如同现在虚拟条件从句的谓语形式。<br>Don’t come tomorrow. I’d rather you came next weekend.<br>我们看到，这里的时间状语next weekend显然是表示一个将来的时间，但句子的谓语却用了came这样的一般过去式，而不用 will come，甚至也不用would come。<br>明天就别来了，我希望你下周末过来。<br>She says she’d rather he left tomorrow instead of today.<br>她说她希望他明天走，而不是今天。</p>
<h5 id="would-rather-sb-had-done"><a href="#would-rather-sb-had-done" class="headerlink" title="would rather sb. had done"></a>would rather sb. had done</h5><p>这是would rather后面接从句的用法，意指“主语宁愿别人过去做了某事，但实际上没有做”。这里从句的谓语用过去完成时表示过去的事件，如同过去虚拟条件从句的谓语形式。<br>For my ninth birthday, my father gave me a set of the World Book Encyclopedia. But I would rather he had given me a set of transformers.</p>
<blockquote>
<p>其他的结构，如would (just) as soon，would sooner和would prefer在接从句时，完全如同would rather的虚拟用法。</p>
</blockquote>
<p>I’d just as soon you didn’t speak rudely to her. 我希望你不要那么粗鲁地对她说话。<br>I’d as soon you hadn’t spoken rudely to her. 我希望你当时没有那么粗鲁地对她说话。</p>
<blockquote>
<p>might just as well接完成时的虚拟表达</p>
</blockquote>
<p>Our holidays were ruined by the weather—we might just as well have stayed at home.<br>这完全类似于would rather have done的意义和用法，都表示对过去的虚拟，意思是“还不如呆在家里”，但实际上没有这么做，而是出去度假了，但天气不好，玩得并不开心。<br>因为天气的原因，我们的假期全给毁了。我们还不如就在家里呆着哪儿也不去呢！</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之一般现在时</title>
    <url>/2020/08/28/English%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E8%88%AC%E7%8E%B0%E5%9C%A8%E6%97%B6/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记摘选自张满胜老师的《英语语法新思维初级教程第2版》，以及其他网上知识点收集，只是我自己的个人复习笔记，禁止转载，如有侵权，请联系我删除。</p>
</blockquote>
<h2 id="并非只表示现在"><a href="#并非只表示现在" class="headerlink" title="并非只表示现在"></a>并非只表示现在</h2><p>一般现在时态并非只表示“现在”。一般现在时本质的思维特征是：表示从过去到现在直至将来的一段时间内发生的动作（action）或存在的状态（state），它们可发生于任何时间，这一段时间可以近乎无限长（如表示客观真理），也可以是人们生活中的一段时间（如人们的习惯活动）。<br>因此，一般现在时态通常被描述为有两种基本用法：</p>
<ol>
<li>不受时间限制的科学事实、客观真理、 谚语格言，以及用于概括、结论、观点等；</li>
<li>表示人们日常生活习惯及 重复活动。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/leH4QA.png"></p>
<h2 id="用法一：表示普遍的事实或真理（expressing-a-general-truth）"><a href="#用法一：表示普遍的事实或真理（expressing-a-general-truth）" class="headerlink" title="用法一：表示普遍的事实或真理（expressing a general truth）"></a>用法一：表示普遍的事实或真理（expressing a general truth）</h2><blockquote>
<p>表示不受时间限制的科学事实、客观真理、谚语格言，以及用于概括、结论、观点等。此时，这些动作或状态的发生不限于某个特定的时间，即它们可发生于任何时间，包括现在、过去和将来。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/zh5h3G.png"></p>
<p>Water freezes at 32 Fahrenheit and boils at 212 Fahrenheit.<br>水在华氏32度结冰，在华氏212度沸腾。<br>The sun rises in the east and sets in the west.<br>太阳东升西落。<br>Knowledge is power.<br>知识就是力量。<br>Opportunities always favor the prepared minds.<br>机会总是青睐有准备的人。<br>Great minds think alike.<br>英雄所见略同。</p>
<h2 id="用法二：表示重复活动（expressing-a-regularly-occurring-event）"><a href="#用法二：表示重复活动（expressing-a-regularly-occurring-event）" class="headerlink" title="用法二：表示重复活动（expressing a regularly occurring event）"></a>用法二：表示重复活动（expressing a regularly occurring event）</h2><p>表示经常发生的、习惯性的动作（action）或者是存在的状态（state）。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/tvneHS.png"></p>
<h3 id="表示习惯的动作"><a href="#表示习惯的动作" class="headerlink" title="表示习惯的动作"></a>表示习惯的动作</h3><p>He often goes to the gym. 他经常去健身房。<br>I go to the gym twice a week. 我每周去两次健身房。<br>He walks to school every day. 他每天步行去上学。</p>
<h3 id="表示习惯的状态"><a href="#表示习惯的状态" class="headerlink" title="表示习惯的状态"></a>表示习惯的状态</h3><p>I like rice for dinner. 我晚餐喜欢吃米饭。</p>
<blockquote>
<p>这一用法常和一些表示动作频率的时间副词连用。</p>
</blockquote>
<ul>
<li>表示肯定的频度副词有：always, frequently, usually, sometimes, generally, occasionally和often等。</li>
<li>表示否定的频度副词有：never, seldom和rarely。</li>
<li>表示频度的副词短语有：once a week, twice a year和on alternate days等。</li>
</ul>
<p>在应用上述这些副词时，要注意以下几点：</p>
<ul>
<li>它在句子中的位置通常是：在be动词后、实义动词前。<br>He is always late. 他总是迟到。<br>He always goes to school by bike. 他总是骑自行车上学。</li>
<li>上述否定副词不能再与否定助动词（如don’t等）连用。<br>He doesn’t seldom come late. *（一般不这么说）<br>He seldom comes late. 他几乎从不迟到。</li>
<li>这些副词一般放在否定助动词前，always除外。<br>The history lectures sometimes aren’t interesting.<br>关于历史的讲座有时很没意思。<br>His wife complains that he sometimes doesn’t listen to her.<br>他的妻子抱怨，说他有时候不注意听她说话。<br>He doesn’t always leave before 6 o’clock. Sometimes he works until 7 o’clock.<br>他并不总是在6点钟之前下班，有时他会工作到7点。</li>
</ul>
<p>谋篇短文中频繁地使用了一般现在时来介绍“口腔清洁运动”。</p>
<ul>
<li>Brush your teeth at least twice a day.</li>
<li>Replace the toothbrush every 3 to 4 months.</li>
<li>Floss your teeth once a day.</li>
<li>Clean your tongue at least once a day.</li>
<li>Visit your dentist once in every 6 months.</li>
</ul>
<blockquote>
<p>这些都表示日常的重复活动，并且还明确给出了重复发生的频率， 如twice a day, every 3 to 4 months, once a day和every 6 months等。这些表示日常的习惯或重复发生的活动（regularly occurring event），我们要用一般现在时态。</p>
</blockquote>
<h2 id="用法比较：表示重复活动的一般现在时态和现在完成进行时态"><a href="#用法比较：表示重复活动的一般现在时态和现在完成进行时态" class="headerlink" title="用法比较：表示重复活动的一般现在时态和现在完成进行时态"></a>用法比较：表示重复活动的一般现在时态和现在完成进行时态</h2><p>在来比较下面两个句子：<br>1） I swim 1,000 meters every afternoon.<br>2） I have been swimming 1,000 meters every afternoon.<br>例句1）用一般现在时swim，我们是指昨天以前是swim 1,000 meters，今天也是swim 1,000 meters，明天以后还是swim 1,000 meters。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/BKmSmq.png"><br>例句2）话要理解成“到目前为止，我是每天下午游1,000米”。在这里我们加上了“到目前为止”来对应翻译英文的语言标记have been doing 这一动词变形，来潜含一个较为明确的时间段。这句话的意思是，也许“我”打算以后改变一下游泳锻炼的计划，比如说“我”决定游得更长些：<br>I have been swimming 1,000 meters every afternoon, but I think I’ll make it a little longer later.<br>在这样的上下文语境中，我们就不能说：<br>I swim 1,000 meters every afternoon, but I think I’ll make it a little longer later. *</p>
<h2 id="用法三：一般现在时表示正在发生的动作"><a href="#用法三：一般现在时表示正在发生的动作" class="headerlink" title="用法三：一般现在时表示正在发生的动作"></a>用法三：一般现在时表示正在发生的动作</h2><h3 id="一般现在时态用在以there或here开头的句子中，表示目前的短暂动作"><a href="#一般现在时态用在以there或here开头的句子中，表示目前的短暂动作" class="headerlink" title="一般现在时态用在以there或here开头的句子中，表示目前的短暂动作"></a>一般现在时态用在以there或here开头的句子中，表示目前的短暂动作</h3><p>Here comes your wife.<br>这里显然是说话人看到your wife正在走过来，然后说的这句话，即表示正在发生的动作。在这个结构中不能用现在进行时态，不能说“Here is coming your wife.”* 可以说“Your wife is coming.”。但是，此时的进行时是表示将来的动作，所以这句话的意思是：你妻子很快就要过来了。<br>你妻子来了。</p>
<p>There goes our bus; we’ll have to wait for the next one.<br>这句话是说话人看着自己要搭乘的车正在开走时说的。同样，在这个结构中不能用现在进行时态，说成“There is going our bus.”*<br>我们的车开走了，我们只好等下一辆了。</p>
<h3 id="表示现在瞬间的动作（instant-actions）"><a href="#表示现在瞬间的动作（instant-actions）" class="headerlink" title="表示现在瞬间的动作（instant actions）"></a>表示现在瞬间的动作（instant actions）</h3><p>这个瞬间动作是说话人在说话的同时即刻发生的。这只适用于表达动作的动词，表示对一些动作的解说，比如：球赛解说、剧情介绍、解释自己正在做的事情、给别人一边说一边做的示范动作等等。<br>这是球赛的解说，表示在说话时刻正在发生的动作。<br>迈克尔传给克林特，克林特传给杰克，杰克又回传给克林特——克林特射门——球进了！</p>
<p>The woman is a spy, now she enters the room, opens the drawer, takes out a pistol and slips it into her pocket.<br>这是剧情说明。<br>这个女人是个间谍。现在她走进房间，打开抽屉，拿出手枪塞进衣兜里。</p>
<h2 id="用法四：一般现在时表示将来发生的动作"><a href="#用法四：一般现在时表示将来发生的动作" class="headerlink" title="用法四：一般现在时表示将来发生的动作"></a>用法四：一般现在时表示将来发生的动作</h2><p>在某些特定的场合，一般现在时态有时可表示将来发生的动作。</p>
<h3 id="用在条件状语从句和时间状语从句中"><a href="#用在条件状语从句和时间状语从句中" class="headerlink" title="用在条件状语从句和时间状语从句中"></a>用在条件状语从句和时间状语从句中</h3><p>主要用在条件状语从句（if和unless）和时间状语从句（when, as soon as, before和after等）中，表示将来的动作。<br>Please let me know when he comes back.<br>他回来时请告诉我。<br>What are you going to do when you leave school?<br>你毕业以后想要干些什么？<br>I will get everything ready before you come back.<br>你回来之前我会把所有的东西都准备好。<br>I’ll give the book to him as soon as I see him.<br>我一见到他就会把书给他。</p>
<blockquote>
<p>若从句的动作含有“意愿”的意思，则从句中可用will。</p>
</blockquote>
<p>If you will give me a hand with these books, I’ll appreciate it.<br>如果你愿意帮我拿这些书，我将非常感激。<br>If they will not accept a check, we shall have to pay in cash, though it would be much trouble for both sides.<br>要是他们不愿意接受支票，我们就只好用现金支付，尽管这样会给双方带来不便。</p>
<h3 id="在谈到未来的计划和时间安排表的时候，表示将来的动作"><a href="#在谈到未来的计划和时间安排表的时候，表示将来的动作" class="headerlink" title="在谈到未来的计划和时间安排表的时候，表示将来的动作"></a>在谈到未来的计划和时间安排表的时候，表示将来的动作</h3><p>此时句中的动词往往是表示短暂性动作的动词，如go, come, leave, start和move等。<br>The train starts at 2 o’clock. 火车两点钟开。<br>We move next week. 我们下周搬家。<br>They leave for Shanghai by train tomorrow evening. 他们明晚出发去上海。</p>
<h3 id="在从句中表示将来的动作，此时主句往往用了一个将来时"><a href="#在从句中表示将来的动作，此时主句往往用了一个将来时" class="headerlink" title="在从句中表示将来的动作，此时主句往往用了一个将来时"></a>在从句中表示将来的动作，此时主句往往用了一个将来时</h3><p>I will reward the person who finds my lost kitten.<br>我将酬谢找到我丢失的猫的人。<br>I will give the booklet to whoever asks for it.<br>谁来索取这个小册子，我就把它给谁。</p>
<h2 id="用法五：一般现在时表示过去发生的动作"><a href="#用法五：一般现在时表示过去发生的动作" class="headerlink" title="用法五：一般现在时表示过去发生的动作"></a>用法五：一般现在时表示过去发生的动作</h2><h3 id="表示死者的理论、著作等"><a href="#表示死者的理论、著作等" class="headerlink" title="表示死者的理论、著作等"></a>表示死者的理论、著作等</h3><p>因为这些理论、著作到现在仍有效；或表示一些名人名言。<br>Francis Bacon says, “Reading makes a full man; conference a ready man; and writing an exact man.”<br>弗朗西斯·培根说：“读书使人充实，讨论使人机智，写作使人准确。</p>
<h3 id="引用书刊、报纸、通知或新近收到的信件的内容时"><a href="#引用书刊、报纸、通知或新近收到的信件的内容时" class="headerlink" title="引用书刊、报纸、通知或新近收到的信件的内容时"></a>引用书刊、报纸、通知或新近收到的信件的内容时</h3><p>The newspaper reads, “The criminal who killed eight women has been executed.”<br>这里的reads其实是表示过去的，因为显然是说话人看过the newspaper之后才说了这句话。<br>报纸上写着：“杀害八名妇女的那个罪犯已经被处决了”。<br>The sign on the washing machine says, “Out of Order.”<br>这里的says其实是表示过去的，因为显然是说话人看过the sign之后才说了这句话。<br>洗衣机上有一个告示写着：“洗衣机坏了。”</p>
<h2 id="用法六：一般现在时代指现在完成时"><a href="#用法六：一般现在时代指现在完成时" class="headerlink" title="用法六：一般现在时代指现在完成时"></a>用法六：一般现在时代指现在完成时</h2><p>在口语中，可以用一般现在时代指现在完成时。能这样使用的动词不多，通常有：hear, find, see, learn, tell和read等。<br>I am（&#x3D;have been） informed that you have been there. 有人告诉我，你去过那里。<br>I hear（&#x3D;have heard） that he has left Beijing. 我听说他已经离开北京了。<br>I hear（&#x3D;have heard） you’re getting married. 我听说你要结婚了。<br>I see&#x2F;find（&#x3D;have seen&#x2F;found） that you have your hair cut. You look terrific! 我发现你理发了。你看上去棒极了！<br>I read（&#x3D;have read） in the newspaper that the criminal who killed eight women has been executed.<br>我在报纸上看到，杀害八名妇女的那个罪犯已经被处决了。</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之完成进行时（现在完成进行时）</title>
    <url>/2020/07/17/English%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AE%8C%E6%88%90%E8%BF%9B%E8%A1%8C%E6%97%B6-%E7%8E%B0%E5%9C%A8%E5%AE%8C%E6%88%90%E8%BF%9B%E8%A1%8C%E6%97%B6/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记摘选自张满胜老师的《英语语法新思维中级教程通悟语法第2版》，以及其他网上知识点收集，只是我自己的个人复习笔记，禁止转载，如有侵权，请联系我删除。</p>
</blockquote>
<h2 id="完成进行时态的构成"><a href="#完成进行时态的构成" class="headerlink" title="完成进行时态的构成"></a>完成进行时态的构成</h2><p>以动词work为例，三种完成进行时态的构成形式如下：</p>
<ol>
<li>现在完成进行时：have been working</li>
<li>过去完成进行时：had been working</li>
<li>将来完成进行时：will have been working</li>
</ol>
<h2 id="完成进行时态的意义"><a href="#完成进行时态的意义" class="headerlink" title="完成进行时态的意义"></a>完成进行时态的意义</h2><p>从结构（structurally）的角度来看，完成进行时态是由完成时态与进行时态复合而成的，这种结构上的复合也必然会反映到意义上，因此完成进行时兼备“完成体”和“进行体”这两种时体的意义。<br>比如，对于现在完成进行时而言，一方面，完成体赋予了它“始于现在之前”的概念，即表示一个动作或状态是从过去持续或重复到现在；另一方面，进行体赋予它暂时的、不间断的延续性。所以，结合这两者的特点，现在完成进行时的核心意义是表示：被描述的事件开始于现在之前，而且是有限地（不会无限期地）持续下去。简言之，完成进行时的核心含义是表示“有限的延续性”。</p>
<h2 id="延续事件"><a href="#延续事件" class="headerlink" title="延续事件"></a>延续事件</h2><p>现在完成进行时强调动作的持续性，表示一个到目前为止尚未完成的活动。具体来说，它表示开始于过去的活动持续到现在，并且活动往往还没有结束，将继续持续下去。此时的完成进行时常与“for+时间段”“since+时间点”，all morning，all day，all week 等这样的表示一段时间的时间状语连用，以强调在这一段期间内，某项活动正在持续。<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/bxlo6A.png"></p>
<p>I’ve been studying English for over ten years now, but I still can’t speak it well.<br>该句的谓语have been studying采用了现在完成进行时态，表示学习英语这一动作从10年前开始，一直持续到目前说话的时候，并且还将继续持续下去。</p>
<p>你妈妈看到你正在看电视，不高兴地说：<br>A: Hey, you’re watching TV again.<br>B: I’ve been studying for the whole morning. I need to relax now.<br>该句的谓语have been studying采用了现在完成进行时态，但“学习”这个活动在说话时并没有在持续，而是在说话之前的一段时间内持续进行。</p>
<p>延续事件根据延续时间长短的不同，可以区分四种不同的延续事件：长期在延续的一般性活动；近期在延续的活动；在说话时刻仍在延续的活动；在说话时刻之前在延续的活动，或者说刚刚在延续但现在已结束的活动。</p>
<h3 id="长期在延续的事件"><a href="#长期在延续的事件" class="headerlink" title="长期在延续的事件"></a>长期在延续的事件</h3><p>现在完成进行时可以表示从过去到现在的一个相当长的时期内持续的一般性活动。<br>I’ve been learning English for over ten years now.<br>我学英语到现在有十多年了。<br>He has been working in the same job for 30 years.<br>他干同样的工作一干就是30年。<br>A: Winter is over at last. Time to pack up my gloves and boots.<br>B: I’ve been waiting for this for months.<br>A：冬天终于过去了，现在该把手套和长靴收拾起来了。<br>B：我等了好几个月了！<br>从以上例句可以看到，这些现在完成进行时表达的都是在相当长的一个时间段内（比如：for 30 years）持续的一般性活动。说它们是“一般性活动”，是因为这些活动并不具有很强的“正在进行”的动作的意味，或者说这些活动在说话的时刻一般并不正在持续。这些活动类似于一个持续的状态，更具有状态的意义，而没有多少动作的意义。<br>所以， 现在完成进行时的这一用法与“现在进行时态”的关系较远，而与“现在完成时态”的关系更近，完全类似于现在完成时所表达的“延续事件”的意义。比如，如果把上述句子的时态改成现在完成时态，也同样是正确的表达，而且意义上没有多大差别，所以可以这样说：<br>I’ve learned English for over ten years now.<br>He has worked in the same job for 30 years.<br>A: Winter is over at last. Time to pack up my gloves and boots.<br>B: I’ve waited for this for months.</p>
<p>现在完成进行时往往表示有限的延续性，这是进行体赋予它的这个特点。而这里提到现在完成进行时表示长期在延续的事件，二者就有了语义上的冲突，这也就解释了为什么现在完成进行时的这一用法与现在进行时关系较远的原因。这一语义上的冲突其实也是在告诉我们：能够表示长期延续事件的现在完成进行时对谓语动词有特殊要求。换句话说，并不是所有的动词用于现在完成进行时都能表示一个长期在持续的事件。来看下面这个句子：<br>He has been repairing his car since 6:00 this morning.<br>这里的现在完成进行时has been repairing也是表示延续事件，但不是长期在延续的事件，而是一个“从早上6点到现在”短短几个小时的延续活动。整个句子的意思是“从早上6点到现在，他一直在修理他的车”，这个句子的言外之意就是，他现在仍然在修车，也就是说，在说话的时刻，repair的动作依然在进行。这完全不同于上述表达状态意义的wait等动词。<br>如果这种动作意味很强的动词与表达较长时间的状语连用，会产生何种语义效果。比如说：<br>He has been repairing cars for almost 20 years.<br>当我们说“他修理汽车有将近20年了”，显然不是表示repair这个动作一直不间断地持续了将近20年，也就是说，这里的has been repairing与表达较长时间的状语for almost 20 years连用时，就不能把它解释成一个长期延续的事件了，而只能把它解释成“重复事件”，即在将近20年当中，他不断“重复”地修理汽车，这就强烈地表明，他是专门从事汽车维修工作的，修车是他的职业。而如果说“从早上6点到现在，他一直在修理他的车”，则并不能说明修车是他的职业，只是表示他一直在做的一项活动而已。<br>从对以上两个例句的比较可以看出，像repair这样的表示单一具体动作的动词用作谓语时，若句子接有一个表示较短时间的状语，则表示延续的活动；但若句子接一个表示较长时间的状语，则表示一个重复的活动。也就是说，像repair这样的动词虽然具有一定的延续性，但持续的时间不能太长，所以这类动词被称为有限延续动词。英文中的大多数动词都是有限延续动词。<br>由此可见，能够表示长期延续事件的谓语动词不能是那些动作意味很强的动词。在英文中，像study, live, work, learn, teach和wait这样的动词并不能表达出某一具体的动作，它们近乎一种状态的延续，这样的动词被称为无限延续动词。这一部分动词在英文中比较少。因此，现在完成进行时在表示长期持续的事件时，其谓语动词必须是一些无限延续动词。<br>“Someday, when I have some time, I’d like to…”Heard that one lately? I think I use that phrase at least 10 times a week. But“someday”never seems to arrive. Now is the time for those little activities you’ve been saving for the future.<br>这里的save不是一个具体的动作，而是一个具有状态意义的动词。<br>“等我哪天有了时间，我一定就会去做……”经常听人这么说吧？我自己一星期至少要说10次这样的话。可是，“哪天”似乎从来就没有来过。对于那些你一直攒着想等将来做的事情，现在就应该去做。<br>对于无限延续动词来说，其所接的时间状语不论长短，都表示延续事件的意义。例如work是无限延续动词，表示一种状态，所以下面两句不论是与表达短时间的状语for two hours连用，还是与表达长时间的状语for 30 years连用，都是表示延续事件：<br>He has been working on the puzzles for two hours.<br>他玩这个拼图游戏有两个小时了。<br>He has been working in the same job for 30 years.<br>这个工作他做了有30年了。<br>对于wait是同样的道理，与表达长时间与短时间的状语连用都表示延续事件。</p>
<h3 id="近期在延续的事件"><a href="#近期在延续的事件" class="headerlink" title="近期在延续的事件"></a>近期在延续的事件</h3><p>现在完成进行时除了可以表示一个长期持续的活动，还可用来表示最近一段时期内正在持续的一般性活动。<br>A: Has Cynthia been working hard on her term paper?<br>B: Day in and day out.<br>根据B的回答Day in and day out. （天天如此忙着。） 就可以知道，A的意思并不是在问Cynthia在说话的时刻是否一直在忙着写论文，而是问她近期是否在忙着写论文。<br>Cynthia is working hard on her term paper these days.<br>这里有时间状语these days，表明该句的语义重点不在于辛西娅在说话的时刻是否在写论文，而是表达她近期的一般性活动。<br>由此可见，现在完成进行时表示“近期在延续的事件”这一用法与现在进行时的关系更密切。</p>
<p>I have been thinking about changing my job. 我最近一直在考虑换个工作。<br>I have been thinking it over. 我最近一直在考虑这件事。</p>
<p>在口语中，如果想要表达“我一直想干什么”或“我早就想干什么”， 可以说“I have been wanting to do…”或“I have been meaning to do…”；如果要表达“一直想要什么”，可以说“I have been wanting…”。现在完成进行时的这一用法在大多数情况下是不带有持续时间状语的，不过也可以带有持续时间状语（如for the past couple days），都可以表示一个近期在持续的一般性活动。<br>Thank you so much for the binoculars. I’ve been wanting a pair for ages.非常感谢你送我这副望远镜，我一直想要一副。<br>I have been wanting to meet you for long. 我早就想见你了。<br>另外要注意，这里的“近期”是一个相对概念，可能是近几天，也可能是近几个星期，甚至是近几个月。所以，“近期”与“长期”并没有明确的界限，完全是根据实际生活经验来判断的。</p>
<h3 id="在说话时刻仍在延续的事件"><a href="#在说话时刻仍在延续的事件" class="headerlink" title="在说话时刻仍在延续的事件"></a>在说话时刻仍在延续的事件</h3><p>现在完成进行时可以表示一个在说话时刻之前一段时间内延续的活动，并且这个活动在说话的时刻仍然在进行。<br>A: You’ve certainly been reading that one page for a long time now.<br>B: Well, I’m being tested on it tomorrow.<br>这里read的动作从过去开始并且持续到了现在说话的时刻，在说话的时刻A仍然在看书。<br>A：那一页内容你显然已经看了很长时间了。<br>B：噢，我明天就要考这页内容啊。</p>
<h4 id="现在完成进行时-vs-现在进行时"><a href="#现在完成进行时-vs-现在进行时" class="headerlink" title="现在完成进行时 vs 现在进行时"></a>现在完成进行时 vs 现在进行时</h4><p>1） I’m staring at this computer.<br>2） I’ve been staring at this computer screen for hours and my eyes hurt.<br>一般不能说：I’m staring at this computer for hours. *<br>I’m trying to study. I’ve been trying to study for the last hour, but something always seems to interrupt me. I think I’d better go to the library.<br>可见，这里的现在完成进行时have been trying与持续的时间状语for the last hour搭配了，而现在进行时am trying却没有。</p>
<h4 id="现在完成进行时动作持续到现在，之后是否继续可由上下文给出"><a href="#现在完成进行时动作持续到现在，之后是否继续可由上下文给出" class="headerlink" title="现在完成进行时动作持续到现在，之后是否继续可由上下文给出"></a>现在完成进行时动作持续到现在，之后是否继续可由上下文给出</h4><p>A: Come to the movies with us. Everybody needs to take a break every once in a while.<br>B: I guess I might as well. I’ve been studying so long I can hardly concentrate.<br>由上文“不妨休息（I guess I might as well.）”可以推断，study的动作持续到说话时为止，不再延续。<br>A：和我们一起去看电影吧，谁都需要偶尔休息休息的。<br>B：我想也是，我学了老半天了，现在都无法集中精力了。</p>
<h3 id="在说话时刻之前在延续的事件（即刚刚在延续的事件）"><a href="#在说话时刻之前在延续的事件（即刚刚在延续的事件）" class="headerlink" title="在说话时刻之前在延续的事件（即刚刚在延续的事件）"></a>在说话时刻之前在延续的事件（即刚刚在延续的事件）</h3><p>一个事件在说话时刻之前一直在延续，换句话说，就是刚刚在延续但到说话时刻已经结束了（a recently finished activity）。从下面这个例句可以明确看出事件“刚刚在延续”：<br>He returned home yesterday. He has been traveling.<br>这里前一句话明确说“他昨天回家了”，这就表明他的旅行到现在说话时刻已经结束了，所以has been traveling就是表示一个“刚刚在延续的事件”——刚刚结束旅行。<br>他昨天回到家里了，在这之前他一直在外旅行来着。</p>
<p>What have you been doing while I have been away?<br>这个句子表示“我刚才不在的时候，你们都一直在干什么了”，所以，这里的have been doing也由于从句while I have been away 的存在而明确表明一个刚刚在延续的事件。<br>我不在的时候，你们一直在干什么？</p>
<p>但是，更多的时候，某个事件“刚刚在延续”并不会像上面这两个例句这样明确地表达出来，而是通过上下文来表明这个事件是“刚刚在延 续”。先来看下面这个例句：<br>A: You look hot.<br>B: Yes, I’ve been running.<br>对话中的have been running表示一个延续的动作，但这个动作并没有延续到现在（说话人现在不做running这个动作了），而是一直延续到离现在不远的过去时间结束的，即表示刚才一直在延续，但现在已结束的活动（a recently finished activity）。“刚才在延续”的活动所导致的“现在”结果往往清晰可见。<br>A：看你很热的样子。<br>B：是的，我刚刚一直在跑步来着。</p>
<p>同样一个带有持续的时间状语的句子，在不同的语境中，既可以表示“刚刚在延续”，也可以表示“一直在延续”。<br>I’ve been running for half an hour.<br>这句话既可以理解成“一直在延续”： 到现在为止我跑了有半小时了。<br>也可以理解成“刚刚在延续”：<br>刚才我跑了半小时。（所以为什么我现在满头大汗的）<br>前者表明现在“我”还在跑步，这个活动并未结束；后者表明“我”现在没有在跑步，这个活动已经结束。<br>这种歧义在真实的口语交际中一般不会存在，因为具体的语境告诉听者该如何理解说话人的意思。比如你的朋友在正健身房的跑步机 （treadmill）上跑步时对你说“I’ve been running for half an hour.”，显然 你就要理解成“跑步的活动一直在持续”；而如果他现在满头大汗地站在你面前说“I’ve been running for half an hour.”，显然你就要理解成“跑步的活动刚刚在持续”。<br>不过，在没有上下文语境帮助排除的情况下，对于带有持续的时间状语的完成进行时的句子，我们一般会解释成“一直在延续”的事件。</p>
<p>对于不带有持续的时间状语的句子同样会存在歧义。比如：<br>It’s been snowing.<br>这句话可以有两种意思。如果在说这句话时外面还在下着雪，则表示“一直在延续”而并未结束的动作：<br>一直在下雪。<br>或者，如果说这句话时外面的雪已经停了，则表示“刚刚在延续”——延续至不久前刚刚结束的动作：<br>刚刚下过雪。（瞧，地上是白的）<br>在没有上下文语境帮助排除的情况下，对于没有持续的时间状语的完成进行时的句子，我们一般会解释成“刚刚在延续”的事件。</p>
<h2 id="延续事件比较：完成进行时与完成时"><a href="#延续事件比较：完成进行时与完成时" class="headerlink" title="延续事件比较：完成进行时与完成时"></a>延续事件比较：完成进行时与完成时</h2><h3 id="比较（一）：完成进行时“刚刚在延续的事件”与完成时“单一事件”"><a href="#比较（一）：完成进行时“刚刚在延续的事件”与完成时“单一事件”" class="headerlink" title="比较（一）：完成进行时“刚刚在延续的事件”与完成时“单一事件”"></a>比较（一）：完成进行时“刚刚在延续的事件”与完成时“单一事件”</h3><p>两者有三个共同点：</p>
<ul>
<li>两者都表示一个事件在说话的时刻已经结束；</li>
<li>两者都伴随有现在清晰可见的后果；</li>
<li>两者都不接持续性的时间状语。不过，需要注意的是，现在 完成进行时可以接持续的时间状语，但意思往往会不同；而现在完成 时“单一事件”的用法是不能接持续的时间状语的。</li>
</ul>
<p>1） My hands are dirty. I’ve been cleaning the car.<br>2） I’ve just cleaned the car.<br>在例句1）中，现在完成进行时强调活动本身的持续性 （emphasis on duration），然后推导出一个与这个持续的活动本身有关的结果——手很脏了。从动词的延续性角度来看，这里的clean是一个延续活动。在例句2）中，现在完成时强调活动的结果，或者说强调活动的成果（emphasis on achievement）——车子现在干净了。从动词的延续性角度来看，这里的clean是用作一个短暂动词，而不是表示延续活动。<br>1）我的手很脏，我刚刚一直在洗车。<br>2）我刚把车洗干净了。<br>从这个例句可以得出二者的两点区别：<br>第一，现在完成进行时强调活动本身的持续性（emphasis on duration）；现在完成时强调活动的结果，或者说强调活动的成果 （emphasis on achievement）。<br>第二，从谓语动词的延续性的角度来看，现在完成进行时的“刚刚在延续的事件”的用法所采用的动词一定都是延续性动词，以表示一个延续活动；现在完成时的“单一事件”的用法所采用的动词都是短暂动词，或者用作表达短暂性的动词，不表示一个延续活动。所以，现在完成进行时可以接持续的时间状语，但意思往往会不同；而现在完成时“单一事件”的用法是不能接持续的时间状语的。这就证明二者在谓语动词的延续性方面有差别。</p>
<p>1） Be careful! I’ve been painting the door!<br>I’ve painted the door green.<br>在例句1）中，现在完成进行时强调活动本身的持续性——“我”刚刚一直在给门刷漆，由此推导出一个与这个持续活动本身有关的结果——门上的油漆现在还没有干，所以“你”要小心（be careful）。从动词的延续性的角度来看，这里paint是一个延续活动。在例句2）中，现在完成时强调活动的结果，或者说强调活动的成果——门现在变成绿色了（比如说原来是白色的）。从动词的延续性的角度来看，这里的paint是用作一个短暂动词而不是表示延续活动。<br>1）小心！这门我刚刚刷过油漆！<br>2）我把门漆成了绿色。 </p>
<p>这里也可以看到，现在完成进行时的这一用法与现在完成时态的关系更接近，而与现在进行时的关系较远，因为现在进行时没有表示事件在说话时刻已经结束的用法。</p>
<h3 id="比较（二）：完成进行时的“延续”与完成时的“延续”"><a href="#比较（二）：完成进行时的“延续”与完成时的“延续”" class="headerlink" title="比较（二）：完成进行时的“延续”与完成时的“延续”"></a>比较（二）：完成进行时的“延续”与完成时的“延续”</h3><p>现在完成时和现在完成进行时都可以表示“延续事件”。</p>
<h4 id="与持续的时间状语连用"><a href="#与持续的时间状语连用" class="headerlink" title="与持续的时间状语连用"></a>与持续的时间状语连用</h4><p>在带有持续的时间状语时，用两种时态几乎没有多大区别，都表示一个开始于过去的动作一直延续到现在。<br>我教书有25年了。 可以用两种时态来表达如下：<br>1） I have been teaching for 25 years.<br>2） I have taught for 25 years.<br>不过也有这样一种观点，认为此时二者的细微区别在于：现在完成进行时一般强烈暗示动作会继续持续下去；而现在完成时则往往表示动作有可能会持续下去。<br>1） I have been teaching for 25 years, and I can’t imagine doing anything else.<br>我教书有25年了，我真想象不出还能干什么别的事情。<br>2） I have taught for 25 years, so now it’s time to think about doing something else.<br>我教书有25年了，现在是该考虑改行做别的事情的时候了。</p>
<h4 id="不与持续的时间状语连用"><a href="#不与持续的时间状语连用" class="headerlink" title="不与持续的时间状语连用"></a>不与持续的时间状语连用</h4><p>表示“延续事件”的现在完成时必须具备两个条件，其中之一就是必须与持续的时间状语连用，如果没有持续的时间状语，则不表示延续至今的事件，而是表示一个在过去完成了的事件，即表示“单一事件”中的过去的经历。而现在完成进行时在没有持续的时间状语的情况下，依然可以表示延续至今的事件。<br>1） I have worked in this company.<br>2） I have been working in this company.<br>在例句1）中，现在完成时have worked表示曾经的经历，即现在不在这家公司工作了。<br>在例句2）中，现在完成进行时have been working表示一直在延续的事件，即现在还在这家公司工作。<br>1）我在这家公司工作过。<br>2）我一直就在这家公司工作。</p>
<p>在不带有时间状语时，现在完成时指的是在过去某一时间完成了的动作（refer to a singular occurrence at an<br>indefinite time in the past），现在完成进行时则表示一个正在持续的活动（refer to an ongoing activity），活动还没有结束。下面的例句也可以证明这一区别。请比较：<br>1） I’ve been cleaning the house, but I still haven’t finished.<br>2） I’ve cleaned the house, but I still haven’t finished. *<br>在例句1）中，因为现在完成进行时have been cleaning 表示一个一直在持续的活动，活动并没有结束，相当于汉语中说的“我一直在打扫房间”，所以接下去可以说but I still haven’t finished，表示“但是还没有打扫完”，这样来明确表示活动还没有结束。在例句2） 中，因为现在完成时have cleaned表示一个过去完成了的活动，相当于汉语中说的“我把房间打扫完了”，所以接下去无法说but I still haven’t finished（但是还没有扫完），这样前后语义矛盾，故例句2）是错误的。</p>
<h2 id="重复事件"><a href="#重复事件" class="headerlink" title="重复事件"></a>重复事件</h2><p>现在完成进行时可表示重复事件，具体来说，就是表示到目前为止的一段时间内重复发生的活动。<br>现在完成进行时表示“重复事件”的用法主要分为两种情况：一种是“短暂动词”用于现在完成进行时可以表示一个重复事件，这是最典型的重复事件的用法；另一种是“有限延续动词”用于现在完成进行时可以表示一个重复事件。</p>
<h3 id="重复事件（一）：短暂动词"><a href="#重复事件（一）：短暂动词" class="headerlink" title="重复事件（一）：短暂动词"></a>重复事件（一）：短暂动词</h3><p>I have been coming to Beijing for 14 years.<br>这里的have been coming表示的是一个重复的活动，所以这句话正确的意思应该是：<br>在过去的14年中，我常常来北京。<br>从这个例子，可以看到现在完成进行时的另一种思维表达——用短暂动词（如come）的完成进行时（如have been coming）来表示到目前为止的一段时间内重复发生的动作。<br>I’ve been coming to see him for 10 years.<br>这里的have been coming同样是表示一个在10年当中不断重复的活动。<br>10年来，我常常过来看望他。</p>
<p>再来看下面这个句子：<br>They have been going there for 10 years.<br>虽然这句话译成汉语可以是：他们去那里已经有10年了。<br>但这并不是表示他们一直生活在那里，而是表示“10年期间，他们屡次去那里”，即表示一个重复活动。可以把这个句子放在一个更完整的语境中：<br>Every Sunday they meet in the bar. They have been going there for 10 years.<br>这里的have been going表示一个在10年当中不断重复的活动，即在10年期间，每周日他们都去那家酒吧。所以，“他们去那里已经有10年了”并不是表示他们一直生活在那里。<br>他们每周日都会在那家酒吧会面，他们去那里已经有10年了。</p>
<p>“结婚”的英文是marry，它是一个短暂动词，所以，如果要表示“我结婚有一年了”，要用“状态表达”说成“I’ve been married for a year.”，而不是“I’ve married for a year. *”。因此，如果把marry用于现在完成进行时，则是表示一个重复的活动。比如：<br>Koreans have been marrying U.S. soldiers stationed here since the 1950s. The peak years were during the 1970s, when more than 4,000 Koreans married U.S. soldiers each year.<br>这里的have been marrying表示一个不断重复发生的事件，即重复事件，所以翻译时要注意体会。<br>自20世纪50年代以来，就不断有韩国人嫁给在当地的美国驻军，70年代达到了高峰，每年有四千多人嫁给美国大兵。</p>
<p>Over the past few years, many towns in the United States have been joining with neighboring communities to share the costs of government.<br>这里join的动作不是一次完成的，而是在近几年当中 （over the past few years）不断重复发生的，所以要用have been joining来表示这一重复活动。<br>在近几年中，美国的许多城镇不断与邻近社区合并， 以降低政府的费用开支。</p>
<blockquote>
<p>短暂动词用于完成进行时态（如have been coming）一般不宜接“短的时间状语”。</p>
</blockquote>
<p>比如：<br>Mike has been winning that race for two hours. *<br>这句话是没有太大的实际意义的，因为一个人一般不可能在两个小时内连续两次、甚至多次赢得某个比赛的胜利。所以，后面接的都应该是表达较长时间的状语，表示在一段相对较长的时间内重复的动作。比如这么说：<br>Mike has been winning that race for years.<br>这就表示“迈克多年以来多次赢得那个比赛”。这里的win同样是一个短暂动词，它用于现在完成进行时，可以被解释成一个重复发生的事件。</p>
<h3 id="重复事件（二）：有限延续动词"><a href="#重复事件（二）：有限延续动词" class="headerlink" title="重复事件（二）：有限延续动词"></a>重复事件（二）：有限延续动词</h3><p>I’ve been chatting online for a little over three years.<br>这里的chat虽然是一个可以延续的动词，但它用在I have been chatting online for a little over three years这句话里面，显然就不能表示一个不间断的延续活动了，因为“聊天”不可能是一直不间断地“延续”了三年多。所以，根据日常的实际经验，只能把它解释为是在三年之中“重复”上网聊天，也即这里的have been chatting应该是表示一个重复事件，而不是延续事件。<br>我上网聊天已经有三年多了。<br>另一方面，也可以将上面这个例句中的“三年”的时间段缩短为“三小时”，而仍然保留完成进行时have been chatting：<br>I have been chatting online for three hours now.<br>在这一句里面，have been chatting则显然表示的是一个延续活动而不是重复活动，即“聊天”这一活动是一直不间断地持续了三个小时。<br>我上网聊天到现在已有三个小时了。<br>have been chatting如果接一个“较长的时间段”，则表示的是一个“重复活动”；如果接一个“较短的时间段”，则表示的是一个“延续活动”。</p>
<p>像动词chat，listen， interview，ask和eat等，都是表示可以延续的动作，所以这些动词用于完成进行时都可以表示延续的活动。这不同于come这样的瞬间即结束的动词，因为它不能延续，所以它的完成进行时have been coming用于较长的时间段时，只好把它解释为重复的动作。但在另一方面，像动词chat，listen，interview，ask和eat等，虽然比瞬间动词come具有较强的延续性，但它们所表达的延续性也是有限的，因为它们都是表达某个单一具体的动作，而对于一个能体现出具体动作的动词，一般不可能持续太长的时间。因此，当它们用于表达较长时间的时间状语时，就不能说某一活动在“延续”，而只能解释成“重复”了。</p>
<blockquote>
<p>“有限延续动词”用于完成进行时态，若接表达较长时间的状语表示“重复活动”，若接表达较短时间的状语则表示“延续活动”。</p>
</blockquote>
<h2 id="重复事件比较：完成进行时与完成时"><a href="#重复事件比较：完成进行时与完成时" class="headerlink" title="重复事件比较：完成进行时与完成时"></a>重复事件比较：完成进行时与完成时</h2><ul>
<li>重复动作的分割性：现在完成进行时表示重复活动时，不能被分割开来，即不能说出具体的次数。它的重复性是根据人们的实际经验而体会出来的。而完成时表示的重复活动，往往要说出具体的次数。因此，可以这样来看二者的差别：现在完成进行时的重复是“隐性”的，是模糊的；现在完成时的重复是“显性”的，是明确的。</li>
<li>短暂动词的完成进行时表示重复活动。</li>
<li>完成进行时的“重复事件”与一般现在时的“重复事件”。</li>
</ul>
<h3 id="比较（三）：重复动作的分割性"><a href="#比较（三）：重复动作的分割性" class="headerlink" title="比较（三）：重复动作的分割性"></a>比较（三）：重复动作的分割性</h3><p>比如这个错误的例句：<br>I have been drinking five cups of coffee this afternoon.*<br>这里涉及完成时态和完成进行时态的区别问题。完成进行时具有进行时的特点，而进行时强调动作的持续性，因此这一活动必须是连续不断的。如果把动作分割开来看， 则违背了进行时态的核心意义——持续性，所以不能用进行时态。我们在下列两种情况下就会把动作分割开：<br>一是谈到在一段时间内一共做了 多少件事情（比如说喝了五杯咖啡）；<br>二是说明某件事发生的次数。<br>这两种情形下都不能使用各种进行时态，包括现在完成进行时。<br>结论：完成进行时态不能用来谈某个动作的具体次数或几件事情，而要用完成时态。<br>I have drunk five cups of coffee this afternoon.<br>今天下午我喝了五杯咖啡。<br>比如要说“去过三次洛杉矶”，就可以用完成时态这样说：<br>He has gone to Los Angeles three times this year.<br>或 He has been to Los Angeles three times this year.<br>但不能用完成进行时，说成“He has been going to Los Angeles three times this year. *”。</p>
<p>Larry King has been interviewing important people for more than 40 years. King has been asking famous people questions throughout his career and has done more than 40,000 interviews. He has talked with every American president since Richard Nixon.<br>这里has been interviewing和has been asking都是表示重复的动作，但由于并没有说明具体的次数，所以用了完成进行时态，来强调他到目前为止还一直在从事采访活动。而接下来由于说出了具体的40000次采访以及采访过每一位美国总统（every American president），这都使得动作被分割开，强调一个结果或成就，而不是一个不间断的过程，所以改用了现在完成时has done和has talked来表达。<br>拉里·金从业40多年来，采访过众多名人，向他们提出各种问题，累计采访达四万多人次。自从尼克松总统以来，历届美国总统都接受过他的采访。</p>
<blockquote>
<p>它所表示的重复动作是不能被分割开来的，而只能看作是一个不间断的过程，这是进行体赋予它的特点。完成时态则常常表示间断的重复活动，可以标明具体几次或几件事，这也是完成时强调活动结果的体现。现在完成进行时表示的重复活动都是不能说出具体次数的，而只能从上下文体会出来，或者依据我们的实际经验体会出来。</p>
</blockquote>
<p>A: I’ve been calling David for the past half hour, but I keep getting a busy signal.<br>B: Well, if you don’t get him soon we’ll just have to go to the movies without him.<br>A：近半个小时，我一直在给戴维打电话，但总是忙音。<br>B：噢，如果你不能快点联系上他，我们只好不带他去看电影了。<br>从后文的but I keep getting a busy signal可知，这里“我”打电话给戴维是多次的活动，而且都是在过去近半小时内发生的。这里的重复活动的意味是从下文but引导的分句体会出来的，但句中并没有明确说出打电话的具体次数。如果要说出具体的次数，则必须改用现在完成时态。<br>I’ve called David four times for the past half hour, but I keep getting a busy signal.<br>近半个小时我给戴维打了四次电话，但每次都是忙音。<br>因此，可以这么来看待两种时态所表示的重复活动：现在完成进行时的重复是“隐性”的，是模糊的，它的重复性是根据人们的实际经验体会出来的；现在完成时的重复是“显性”的，是明确的。比如：<br>1） I’ve been writing letters this morning.<br>2） I’ve written three letters this morning.<br>在例句1）中，复数名词letters表明“我上午写了不止一封信”，也即这里的现在完成进行时表示一个重复活动。但并没有具体说出是几封信。在例句2）中，明确地说出了是三封信。<br>1）今天上午到目前为止我一直在写信。<br>2）今天上午到目前为止我写了三封信。</p>
<h3 id="比较（四）：短暂动词用于完成进行时来表示重复活动"><a href="#比较（四）：短暂动词用于完成进行时来表示重复活动" class="headerlink" title="比较（四）：短暂动词用于完成进行时来表示重复活动"></a>比较（四）：短暂动词用于完成进行时来表示重复活动</h3><p>I have been coming to Beijing for 14 years.<br>I’ve been coming to see him for 10 years.<br>Every Sunday they meet in the bar. They have been going there for 10 years.<br>从上面这些例句可以看到，短暂动词的完成进行时可以与持续的时间状语连用，来表示一个重复活动。但是，短暂动词的完成时是不能与持续的时间状语连用的，因为短暂动作无法延续，这与持续的时间状语形成语义上的冲突。所以，上述句子都不可能改为现在完成时：<br>I have come to Beijing for 14 years. *<br>I’ve come to see him for 10 years. *<br>Every Sunday they meet in the same bar. They’ve gone there for years. *</p>
<p>短暂动词的完成进行时可以与持续的时间状语连用，来表达一个在这个时段内的重复活动；而短暂动词的完成时不能与持续的时间状语连用，不能表示重复活动。如果短暂动词的完成时要表示重复活动，如上面讨论的那样，就只能加上具体的次数。</p>
<h3 id="完成进行时的“重复事件”与一般现在时的“重复事件”"><a href="#完成进行时的“重复事件”与一般现在时的“重复事件”" class="headerlink" title="完成进行时的“重复事件”与一般现在时的“重复事件”"></a>完成进行时的“重复事件”与一般现在时的“重复事件”</h3><p>一般现在时也可以表示一个重复的习惯活动：<br>I run a mile every afternoon.<br>这句话表示“我每天下午都会跑一英里”，即已养成跑步的习惯了。现在把这个句子改为现在完成进行时：<br>I’ve been running a mile every afternoon.<br>可以把这个句子放在一个更完整的语境中：<br>A: I’ve been running a mile every afternoon for the past month, but I still haven’t been able to lose more than a pound or two. I wonder if it’s worth it.<br>B: Oh, don’t give up now. It always seems hard when you are just starting out.<br>这里添加了一个持续的时间状语for the past month，表示到目前为止的一个时间段内，重复发生“跑步”这个活动。<br>由此可见，当用现在完成进行时表达一个重复活动时，我们的头脑中就会有一个较明确的表示到目前为止的时间段，而一般现在时就不能这么用：<br>I run a mile every afternoon for the past month. *<br>当用一般现在时来谈一个重复活动时，我们的头脑里没有这样的一个时间段的概念，而只表示一种泛泛的日常习惯。<br>所以，现在完成进行时表示“重复事件”的一个重要概念就是：到目前为止的一个时间段内重复的活动。有时，若上下文的语境中已暗示有一个时间段的概念，即使没有明确说出这个时间段，也要用have been doing来表示在这一未明示的时间段内重复的动作。<br>I have been running a mile every afternoon, but I think I’ll run two miles later.<br>这里的but I think I’ll run two miles later就告诉我们，说话人是强调现在和将来的对比，也就是说，他头脑里是强调“到目前为止的一个时间段内每天跑一英里”，所以才有下文说“不过我想以后改为两英里”。 此时就不能说：<br>I run a mile every afternoon, but I think I’ll run two miles later. *</p>
<p>因此，遇到现在完成进行时表示的重复活动，即使没有明确的时间段出现，也要理解成这一重复活动是在从过去到目前为止的一个时间段内发生的。</p>
<p>1） I go to the gym every three days.<br>2） I’ve been going to the gym every three days, but I think I’ll make it every other day from now on.<br>1）我每三天去健身一次。<br>2）到目前为止，我每三天去健身一次，不过我想从今往后改为每隔一天去一次。</p>
<h2 id="完成进行时与完成时对比总结"><a href="#完成进行时与完成时对比总结" class="headerlink" title="完成进行时与完成时对比总结"></a>完成进行时与完成时对比总结</h2><h3 id="比较（五）：完成进行时强调“延续过程”，-完成时强调“成果”"><a href="#比较（五）：完成进行时强调“延续过程”，-完成时强调“成果”" class="headerlink" title="比较（五）：完成进行时强调“延续过程”， 完成时强调“成果”"></a>比较（五）：完成进行时强调“延续过程”， 完成时强调“成果”</h3><blockquote>
<p>完成进行时重在“进行（ongoing）”，即未完成（incomplete），强调动作持续的过程（emphasis on duration）；完成时重在“完成”，即已完成（completed），强调动作的结果或成就（emphasis on achievement）。具体来讲，现在完成进行时所强调的是在一段时期内某项活动的持续性，强调的是动作本身；现在完成时则是强调动作产生的结果或取得的成就，而不是动作本身。</p>
</blockquote>
<p>比如我们一般用现在完成进行时来谈论不断的变化和发展，这是现在进行时赋予它的意义，因为现在进行时可以谈不断变化的过程。例如：<br>Scientists believe that the universe has been expanding since the beginning of time.</p>
<h4 id="未完成与已完成"><a href="#未完成与已完成" class="headerlink" title="未完成与已完成"></a>未完成与已完成</h4><p>先来比较现在完成进行时的“未完成”与现在完成时的“已完成”。<br>1） I have been reading your grammar book. After I finish it, I’ll discuss some problems with you.<br>2） I have read your grammar book and I have questions to ask you.<br>在例句1）中，现在完成进行时表示read的动作未完成。<br>在例句2）中，现在完成时表示read的动作已完成。<br>1）我一直在看你的语法书，看完以后我会有一些问题要和你讨论。<br>2）我看过你的语法书了，现在有问题要问你。</p>
<h4 id="延续过程与结果或成果"><a href="#延续过程与结果或成果" class="headerlink" title="延续过程与结果或成果"></a>延续过程与结果或成果</h4><p>1） How long have you been learning English?<br>2） How many words have you learned?<br>在例句1）中，询问学英语的持续时间，强调活动的持续过程，所以用现在完成进行时have been learning。<br>在例句2）中，询问学会了多少单词，强调学习的成果，所以用现在完成时have learned。<br>1）你学习英语有多久了？<br>2）你已经学会了多少英语单词？</p>
<p>1） It has been snowing all day. I wonder when it will stop.<br>2） We have had three major snowstorms so far this winter. I wonder how many more we will have.<br>1）下了一整天的雪，不知什么时候能停。<br>2）今年冬天已经下了三场大雪了，不知还会不会再下。</p>
<h4 id="感情色彩的不同"><a href="#感情色彩的不同" class="headerlink" title="感情色彩的不同"></a>感情色彩的不同</h4><p>由于完成进行时更强调动作的延续性，因而往往带有强烈的感情色彩，较为口语化。所以，在口语中完成进行时使用得较为普遍。而现在完成时则只是说明一个事实，一种结果，较为平铺直叙，缺乏明显的感情色彩。例如：<br>A: Why are you so late? I’ve been waiting here for more than an hour!<br>B: Sorry to have kept you waiting. But it has been a hectic day today. I’ve got a million things to attend to.<br>这里说话人A用了have been waiting的形式，显得较为生气。如果他说have waited则显得很平铺直叙，只是简单地说明“等了一个多小时”这样的事实。<br>A：你怎么来得这么晚啊？我在这里一直等了有一个多小时了！<br>B：对不起让你久等了，因为我今天一直忙得不可开交，有一大堆事情要处理。</p>
<h4 id="重复活动：完成进行时强调持续，不讲次数；完成时强调成果，讲次数"><a href="#重复活动：完成进行时强调持续，不讲次数；完成时强调成果，讲次数" class="headerlink" title="重复活动：完成进行时强调持续，不讲次数；完成时强调成果，讲次数"></a>重复活动：完成进行时强调持续，不讲次数；完成时强调成果，讲次数</h4><p>1） I’ve been ironing my shirts this morning.<br>2） I’ve ironed five shirts this morning.</p>
<h4 id="现在完成进行时与现在完成时的思维差异总结"><a href="#现在完成进行时与现在完成时的思维差异总结" class="headerlink" title="现在完成进行时与现在完成时的思维差异总结"></a>现在完成进行时与现在完成时的思维差异总结</h4><h5 id="时（tense）与态（aspect）"><a href="#时（tense）与态（aspect）" class="headerlink" title="时（tense）与态（aspect）"></a>时（tense）与态（aspect）</h5><p>谈到“时（tense）”的时候，我们关心的是这个动作发生的时间，即是在现在、过去还是将来发生的。<br>谈到“态（aspect）”（也叫“体”）的时候，我们关心的则是:</p>
<ul>
<li>这个动作是固定不变的还是动态变化的（fixed or changing）；</li>
<li>这个动作是完成了的还是在延续的（complete or ongoing）；</li>
<li>这个动作持续的时间是很短还是很长（lasting for only a moment or for a long time）。</li>
</ul>
<h5 id="完成进行时的意义"><a href="#完成进行时的意义" class="headerlink" title="完成进行时的意义"></a>完成进行时的意义</h5><blockquote>
<p>无限延续动词</p>
</blockquote>
<p>无限延续动词（如live）用于现在完成进行时的时候，只能表示一个延续事件。<br>I’ve been living in Beijing for 20 years now.<br>这就是“长期在延续的事件”。事实上，完成进行时的“有限延续性”这个核心意义与这里的长期延续事件是有语义上的冲突的。确切来说，这里的“长期延续性”并不是完成进行时所赋予的，而是无限延续动词本身所具有的特点。因此，这里即使不用现在完成进行时而用现在完成时，依然是表示一个长期在延续的事件。比如说：<br>I’ve lived in Beijing for 20 years now.<br>这也就解释了为什么现在完成进行时的这一用法与现在完成时的关系更近，而与现在进行时的关系较远。这一语义上的冲突其实也说明：能够表示长期延续事件的现在完成进行时对谓语动词有特殊要求。换句话说，并不是所有的动词用于现在完成进行时都能表示一个长期在持续的事件。</p>
<blockquote>
<p>有限延续动词</p>
</blockquote>
<p>这样的动词往往是一些表示单一具体活动的动词，比如repair这样的动词。这样的动词非常典型地反映出完成进行时的“有限延续性”的特点，因为这样的动词用于现在完成进行时，若要表示延续事件时，则只能接一个表达短暂时间的状语。比如：<br>He has been repairing his car since 6:00 this morning.<br>而不能接一个表达较长时间的状语。如果是表达较长时间的状语， 则只能解释为重复事件。比如：<br>He has been repairing cars for almost 20 years.<br>这说明完成进行时表示有限的延续性，除非是一些近似于状态的无限延续动词用于完成进行时，可以接表达较长时间的状语表示延续事件外，一般动词只能接表达较短时间的状语才能表示延续事件，否则会变成重复事件。<br>另一方面，这里的重复事件又是我们根据常识经验体会出来的。比如一个人若是修理一辆汽车，不可能是一直不间断地修了20年，这不符合常识，显得很荒唐。这时只能把这“修车”的活动理解为这20年来重复发生的一个活动，才能讲得通。</p>
<blockquote>
<p>短暂动词</p>
</blockquote>
<p>短暂动词与完成进行时“有限延续性”的含义发生作用后，产生了重复事件的解释。比如：<br>I have been coming to Beijing for 14 years.</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之情态动词</title>
    <url>/2020/08/08/English%E7%B3%BB%E5%88%97%E4%B9%8B%E6%83%85%E6%80%81%E5%8A%A8%E8%AF%8D/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记摘选自张满胜老师的《英语语法新思维中级教程通悟语法第2版》，以及其他网上知识点收集，只是我自己的个人复习笔记，禁止转载，如有侵权，请联系我删除。<br>思维导图版本<a href="http://www.xmind.net/m/b3xU3U">点击这里</a>（Web版的XMind有一些问题）。</p>
</blockquote>
<h2 id="多情多义的情态动词"><a href="#多情多义的情态动词" class="headerlink" title="多情多义的情态动词"></a>多情多义的情态动词</h2><h3 id="情态动词的“全家福”"><a href="#情态动词的“全家福”" class="headerlink" title="情态动词的“全家福”"></a>情态动词的“全家福”</h3><p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/zMxKiC.png"><br>需要注意的是，四个情态动词的过去式could，might，would和should只是在形式上是can，may，will和shall的过去式，而在意义上并不是完全对应于can，may，will和shall。<br>一方面，现在式和过去式这两类情态动词的意义并不完全对等。例如，can和could的意义并不完全等同，它们既有共同的用法，如表示“能力”，也有各自不同的用法。另一方面，这四个过去形式的情态动词并不一定表示过去的时间（实际上通常都不是）。</p>
<h3 id="情态动词的意义"><a href="#情态动词的意义" class="headerlink" title="情态动词的意义"></a>情态动词的意义</h3><p>情态动词（modals）用在实义动词（main verb）的前面， 以添加某种意思。比较下列句子用与不用情态动词在意义上的差别：<br>1） John isn’t in class. He is sick.<br>2） John isn’t in class. He must be sick.<br>在例句1）中，没有使用情态动词，只用了一般现在时态的is，表达的是一个客观事实。在例句2）中，用了情态动词must，则是表示说话人的主观猜测。我们看到，因为有了must，使得例句2）比例句1）更带有主观色彩，意思也不同了。<br>1） 约翰今天没上课，他病了。<br>2） 约翰今天没上课，他一定是病了。</p>
<p>I must go to school today.<br>比较上面的例句2）和本句可以发现，两句中情态动词must的意思是不一样的：例句2）中的must表示推测，而本句中的must没有推测的意思，而是表示“必须”。<br>今天我一定得上学去。</p>
<p>有时，即使是同一个句子，也可能会因为语境不同，其中的情态动词会有不同的理解。<br>He must drink a lot of milk.<br>没有上下文的语境，我们很难判断。即比如，如果这句话是出自医生之口，显然就会被理解成是医生对病人提的一个忠告或建议，即“他得多喝牛奶”。言外之意，就是说明喝牛奶对健康是有好处的。因此，此时的must是“必须”之意。我们再想象这句话可能出现的另一个场景，比如，有一天我们在商店里看到一个人买了很多牛奶，这时我们就可以推断说“He must drink a lot of milk”。<br>显然这时要说的意思是“他准是爱喝很多牛奶”。因此，此时的must表示的是推测。<br>情态动词的含义大致可以分为以下两大类：</p>
<ul>
<li>一类是表示“逻辑可能性”，将其称为推测用法，即表示人们对某件事发生的可能性大小所做的判断。</li>
<li>另一类是各个情态动词有各自基本的意思，比如，can意为“能够”，must意为“必须”，should意为“应该”等等。</li>
</ul>
<p>关于“约翰生病”的例子：<br>1） John isn’t in class. He is sick.<br>2） John isn’t in class. He must be sick.<br>3） John isn’t in class. He may be sick.<br>例句1）没有使用情态动词，只用了一般现在时态的is，这表明说话人只是在陈述一个客观事实，即“约翰生病了”。这句话没有表明说话人的态度（the speaker’s attitude）。而例句2）和3）这两句使用了情态动词，表明了说话人的态度。例句2）用的是must，意为“一定是，准是”，这表明说话人对于“约翰生病了”这件事是很有把握和信心的一个推断（deduction）。例句3）用的是may，意为“可能是，或许是”，这表明说话人对于“约翰生病了”这件事是比较没有把握和信心的一个推断。说话人推断“约翰生病了”。<br>这件事从三个不同的角度（perspective）来表达：</p>
<ul>
<li>简单地陈述事实（is）； </li>
<li>非常有把握的推断（must be）； </li>
<li>比较没有把握的推断（may be）。</li>
</ul>
<p>总之，对于情态动词的推测用法，说话人是基于一定的信息情况来对某个事件发生的可能性进行推断。说话人不同的肯定程度（different degrees of certainty）是以说话人所掌握的不同信息情况为基础的。</p>
<p>关于“喝牛奶”的例子：<br>1） You must drink some milk.<br>2） You may drink some milk.<br>可以想象这样一个场景：父母要求自己的孩子多喝牛奶，这时他&#x2F;她就会说“你必须多喝牛奶”，即例句1）的意思。这里的must表达孩子应尽的“义务（obligation）”。而如果是孩子向他们要东西喝，这时他们就可以回答说“你可以喝点牛奶”，即例句2）的意思。这里的may表达“许可（permission）”。<br>这里，说话人能用must（必须） 或may（允许）这样的词，是基于其社会角色——父母，作为父母他可以控制孩子的行为。这是情态动词的基本用法，或者说社交功 能的用法，交际双方都会根据彼此之间确定的社会关系，来选择使用情态动词。</p>
<blockquote>
<p>虚拟语气其实就是情态动词could，might，would和should的用法的一部分，这一虚拟用法其实是属于推测用法中的一个重要分支。因此，如果把虚拟用法从推测用法中独立出来，那么情态动词就有三大类用法：推测用法、基本用法和虚拟用法。</p>
</blockquote>
<h3 id="情态动词的结构搭配与意义关系"><a href="#情态动词的结构搭配与意义关系" class="headerlink" title="情态动词的结构搭配与意义关系"></a>情态动词的结构搭配与意义关系</h3><p>情态动词的结构搭配与意义之间的关系有下列三点：</p>
<h4 id="情态动词-一般式"><a href="#情态动词-一般式" class="headerlink" title="情态动词+一般式"></a>情态动词+一般式</h4><p>这一结构就是在情态动词后面接一个动词原形。<br>He must drink a lot of milk.<br>译文1：他得多喝牛奶。<br>译文2：他准是爱喝很多牛奶。<br>在“情态动词一般式”这个结构搭配中，情态动词可以是推测意义，也可以有基本意义。</p>
<h4 id="情态动词-完成式-x2F-进行式-x2F-完成进行式"><a href="#情态动词-完成式-x2F-进行式-x2F-完成进行式" class="headerlink" title="情态动词+完成式&#x2F;进行式&#x2F;完成进行式"></a>情态动词+完成式&#x2F;进行式&#x2F;完成进行式</h4><p>在这一结构搭配中，完成式如may have done；进行式如should be doing；完成进行式如must have been doing。<br>I think I may have annoyed Mary. 我想我可能是惹玛丽生气了。<br>He should still be working right now. 他现在应该还在工作。<br>Could he be waiting for us at the station? 他会不会正在车站等我们呢？<br>You look very tired. You must have been working all day. 你看起来很累，你准是忙了一整天了。<br><em><strong>在情态动词接完成式、进行式或完成进行式的时候，情态动词都是具有推测意义，而没有各自的基本意义。</strong></em><br>比如上面例句中的may，should，could和must都是用了推测意义。具体来说，这里的may不是“许可”的意思，而是表示推测的“可能”；should不是表示义务的“应该”，而是表示推测的“应该”；could不是表示“能力”，也不是表示过去，而是表示对现在的推测；must不是表示“必须”，而是表示推测的“准是”。</p>
<blockquote>
<p>换句话说，用于基本意义的情态动词，其后面一般只接动词的一般式，而不接完成式、进行式或完成进行式。</p>
</blockquote>
<p>另外，<em><strong>四个过去形式的情态动词would，could，might 和should接完成式（have done）可以表示对过去的虚拟，此时情态动词不是推测的意义，而是虚拟含义。</strong></em>如果把虚拟意义看作是推测意义的一种特例——推测某种可能性不存在，此时也就与情态动词的推测用法有联系了，这样就依然证明了上面的规律：在情态动词接完成式、进行式或完成进行式的时候，情态动词都具有推测意义，而没有各自的基本意义。<br>就出现的频率来说，最常用的是情态动词与一般式的搭配，其次是与完成式的搭配；与进行式的搭配较少，而与完成进行式的搭配最不常见。</p>
<h4 id="情态动词-情态动词短语"><a href="#情态动词-情态动词短语" class="headerlink" title="情态动词+情态动词短语"></a>情态动词+情态动词短语</h4><p>情态动词对应于这样一些短语：be able to，be allowed to，have (got) to，be supposed to&#x2F;ought to和be going to。这些短语可以用在情态动词后面。<br>We’re supposed to do our best and we should be able to finish this work before the boss has to start screaming at us again.<br>我们应该竭尽全力，这样才能够在老板再次冲我们大喊大叫之前完成这项工作。<br>If you could just concentrate on getting finished, we might be allowed to leave early this afternoon.<br>如果你能集中精力干完活儿，我们今天下午或许可以早点走。<br>He may be able to help. 他或许能够帮忙。<br>You might have to work late. The others may be allowed to leave early. 你可能得加班，其他人或许可以早走。<br>从上面这些句子看到，<em><strong>情态动词接短语时，往往也是只有推测的意义，而没有基本意义。</strong></em></p>
<blockquote>
<p>思维总结：</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/WbGJ8T.png"></p>
<h2 id="推测用法（一）：现在推测（情态动词一般式）"><a href="#推测用法（一）：现在推测（情态动词一般式）" class="headerlink" title="推测用法（一）：现在推测（情态动词一般式）"></a>推测用法（一）：现在推测（情态动词一般式）</h2><p>在英语中，对现在或当前的情况进行推测，要用“情态动词一般式”这一结构。同时要注意，对现在的肯定推测与否定推测所使用的情态动词也不尽相同。</p>
<h3 id="对现在的肯定推测"><a href="#对现在的肯定推测" class="headerlink" title="对现在的肯定推测"></a>对现在的肯定推测</h3><h4 id="must表示“推测”及其他含义"><a href="#must表示“推测”及其他含义" class="headerlink" title="must表示“推测”及其他含义"></a>must表示“推测”及其他含义</h4><p>看下面这些对现在的肯定推测的例子：<br>A: I’ve had no sleep for 48 hours.<br>B: You must be exhausted.<br>A：我48个小时没有合眼了。<br>B：你一定筋疲力尽了。<br>You’ve been traveling all day. You must be tired.<br>你跑了一天了，一定累了。</p>
<p>must除了表示“推测”之外，还有另一个常见的用法是表示“责任”或“义务”，译成“必须”，这其实是must的基本用法。<br>must在表示“必须”时，可以是非常“强烈的义务（strong obligation）”，比如法律规定：<br>You must wear a seat belt while driving.开车时必须系安全带。<br>或者是某些规章制度或规定等。比如：<br>Door must be closed when machine is in operation.机器运转时门必须关闭。<br>Students must pay course fees before attending classes. 学生必须先交费，然后才能上课。<br>以上句子中的must语气非常强烈。must还可以是表示说话人主观认为某事是重要的、必须完成的“义务”。比如：<br>You must concentrate on one thing at a time. 做事时你必须一心一意。<br>这里must表示“义务”的程度就要比上面句子中法律规定的“义务”要弱很多。另外，在“义务”的含义更弱的情况下，即把must用于描述说话人自身的情况。比如：<br>I must remember to feed the cat. 我得记住一定要喂猫。<br>I must try harder next time. 我下次必须更努力。<br>以上区分了三种“强烈”程度不同的“义务”的含义。在现代英语口语中，还有一种语气更弱的“义务”，用来谈未来的“安排 （arrangement）”。比如：<br>We must get together for lunch sometime. 我们得找个时间聚一聚，吃个午饭。<br>总之，must表示“必须”时，大致可以分为以上四种不同的强烈程度。</p>
<blockquote>
<p>must的“推测”用法和“必须”用法之间的关系：</p>
</blockquote>
<ul>
<li>表示“推测”时，must不能表示将来，只能表示对现在的推测和对过去的推测。若是表示对现在的推测，其谓语形式是“must一般式”，即must do；或“must进行式”，即must be doing。若是表示对过去的推测，其谓语形式是“must完成式”，即must have done。</li>
<li>表示“必须”时，must不能谈过去的事件，只能谈现在和将来的事情。其谓语形式都是“must一般式”，即must do。不能用“must进行式或完成式”，即<em><strong>must be doing或must have done中的must一定不会译成“必须”，而只能是表示推测。must表示“必须”的意义时是没有过去时态的，要表示“过去必须”，则要借用had to来表达。</strong></em></li>
<li>在表示“必须”时，must后面的谓语动词一般是表示动作 （action）的，具体来说，就是现在的动作或将来的动作（present and future actions），不会是表示状态。在表示“推测”时，must后面的谓语动词可以是动作，也可以是状态。比如：<br>He must be dead.<br>因为这句话的谓语动词be表示状态，所以这句话不会译成“他必须死掉”，而只能译成“他一定是死了”，即表示推测。<br>与must相关的情态动词短语是have (got) to。它同must一样，既可以表示“推测”，也可以表示“必须”。比如下面两句中的have to都表示“推测”：<br>Look at that house! Those people have to have a lot of money.<br>这里的have to表示推测。<br>你看他们那房子！那些人一定很有钱。<br>He is really big; he has to be over seven feet tall.<br>这里的have to表示推测。<br>他块头很大，肯定超过7英尺高了。<br>用had to表示对过去的推测，如：<br>He was really big; he had to be over seven feet tall.</li>
</ul>
<p>用have to表示“必须”时，与must主要有两点区别：</p>
<blockquote>
<p>第一，在时态的表达上，must只能谈现在或将来，不能谈过去。 must没有时态的变化，而have to有各种时态的变化，比如过去式had to，将来式will have to，现在完成式have had to，过去完成式had had to等。</p>
</blockquote>
<p>When I was in school, we had to wear school uniform.<br>这里的had to表示“过去必须”。<br>我上学时，我们都得穿校服。</p>
<p>A: Do we really have to go to this meeting?<br>B: Yes, and we will have to present our report.<br>这里的will have to表示“将来必须”。<br>A：我们真的一定得去参加这个会议吗？<br>B：是的，因为我们得展示我们的报告。</p>
<blockquote>
<p>第二，如果是来自外界的不可控的行为（uncontrollable external behavior），此时要用have to。比如，“要打喷嚏”是我们无法控制的。</p>
</blockquote>
<p>Excuse me, but I have to sneeze. 对不起，我要打喷嚏。<br>此时，一般不用must。</p>
<blockquote>
<p>除了以上两点，还需要注意的是，must（“必须”）的否定形式 mustn’t不是表示“不必”，而是“千万别做某事”的意思，表示“不必”要说 don’t have to。另外，must的推测用法“一定是”的否定不是mustn’t，而是 can’t（“不可能是”）</p>
</blockquote>
<p>在口语中，have got to作为have to的口语形式更为常用，同样可以有两个意思：推测和必须。<br>They’ve got to try harder next time.<br>这里的have got to表示“必须”。<br>他们下次得更努力些。<br>You’ve got to be joking!<br>这里的have got to表示“推测”。<br>你准是在开玩笑！<br><strong><em>不过需要注意的是，have to有各种时态的变化，而have got to没有时态的变化（只能表示现在或将来，这一点同must表示“必须”意义时相同），比如不说had got to</em>等。</strong>*</p>
<h4 id="其他表示推测的情态动词"><a href="#其他表示推测的情态动词" class="headerlink" title="其他表示推测的情态动词"></a>其他表示推测的情态动词</h4><p>当然，我们还可以用其他的情态动词来表示对现在的推测，这些情态动词有may，might和could等。<br>A: I wonder where Tom is.<br>B: He may&#x2F;might&#x2F;could be in the library.<br>A：我不知道汤姆在哪里。<br>B：他或许在图书馆。</p>
<p>While this might explain some cases, it is not universally applicable.<br>这种观点或许可以解释某些情况，但它并非放之四海而皆准。</p>
<blockquote>
<p>不同的情态动词所表达的可能性的程度是不一样的，比如：</p>
</blockquote>
<p>A: Why isn’t John in class?<br>B: He is sick. （100%确定，对客观事实的陈述）<br>He must be sick. （90％确定，很有把握的陈述）<br>He may be sick. （50％确定，不太有把握的陈述）<br>He could&#x2F;might be sick. （25％确定，很没有把握的陈述，只是提供一种可能的情况）<br>以上百分比只是家比较直观地了解不同的情态动词所表达的确定程度的差别而已。比如，用must肯定要比用could或might所表示的说话人的把握大得多。用could或might，说话人只是为约翰没来上学提供一种解释而已，所以，这里到底要用什么词，完全取决于说话人当时的确信程度，或其掌握的信息情况。</p>
<h3 id="对现在的否定推测"><a href="#对现在的否定推测" class="headerlink" title="对现在的否定推测"></a>对现在的否定推测</h3><p>我们也可以对当前的情况做一个否定的推测。比如：<br>A: The restaurant is always empty.<br>B: It isn’t good. （100%确定，对客观事实的陈述）<br>It can’t&#x2F;couldn’t be good. （90％确定，很有把握的陈述）<br>It may not be good. （50％确定，不太有把握的陈述）<br>It might not be good. （25％确定，很没有把握的陈述，只是提供一种可能）<br>有四点是值得注意的：</p>
<ul>
<li>在否定推测中没有must，因为must表示推测时一般只用在肯定句中，而否定的mustn’t常用于表示“命令别人不要做什么”，译为“千万别”。</li>
<li>与must相反，can表示推测时不能用在肯定句中，只用在否定句和疑问句中。must不能在否定句表示推测这一空白正好由can’t来填补，也就是说表示推测的must，否定时要改为can’t，而不是mustn’t。比如：You must be joking. You can’t be serious. 你准是在开玩笑，你不可能当真吧。</li>
<li>在肯定推测时，could的肯定程度很低；但在否定推测时，couldn’t则表示十分确信，译为“不可能”。</li>
<li>could和might虽然是过去式，但在这里并不是表示对过去的推测，而是表示对现在的推测，或者是对将来的推测。</li>
</ul>
<h3 id="对现在进行推测的其他情态动词"><a href="#对现在进行推测的其他情态动词" class="headerlink" title="对现在进行推测的其他情态动词"></a>对现在进行推测的其他情态动词</h3><p>表示对现在的推测，常用的情态动词是must，may，might和 could，在否定句中还有can’t （来替换must）。不过<em><strong>will和should也可以用来表示对现在的推测，其肯定程度等同于must。</strong></em><br>Ring his home number. He’ll be at home now.<br>这里用will，表示“我肯定他在家”，相当于“He must be at home now.”。<br>给他家打电话吧，他现在肯定在家。<br>A: Someone is knocking at the door.<br>B: That’ll be the postman.<br>A：有人在敲门。<br>B：准是邮递员。<br>It’s no use asking Tom; he won’t know.<br>相当于“我肯定他不知道”。<br>这事问汤姆没用，他不会知道的。</p>
<blockquote>
<p>will很少用于表示对现在的推测，主要是表示对将来的“预测”。 should表示推测时还有其他限制。</p>
</blockquote>
<h2 id="推测用法（二）：将来预测（情态动词一般式）"><a href="#推测用法（二）：将来预测（情态动词一般式）" class="headerlink" title="推测用法（二）：将来预测（情态动词一般式）"></a>推测用法（二）：将来预测（情态动词一般式）</h2><h3 id="一"><a href="#一" class="headerlink" title="(一)"></a>(一)</h3><p>对将来的推测，确切地说应该是“预测（prediction）”，谓语形式也是用“情态动词一般式”。<br>实际上，<em><strong>除了must，情态动词如will，should，may，might和 could都可以表示对将来的预测。</strong></em><br>A: What did the weatherman say?<br>B: It will rain tomorrow.<br>It should rain tomorrow.<br>It may rain tomorrow.<br>It might&#x2F;could rain tomorrow.<br><em><strong>上述例句的确定程度同样是由高到低。比如，should在表示推断时，不如用will表示推断时的自信心强：</strong></em><br>1） Tom will know the address. 我肯定汤姆知道地址。<br>2） Tom should know the address. 我想汤姆会知道地址。<br>A: Think it’ll rain tomorrow? I am sure it won’t.<br>B: But according to the weather report, it will rain tomorrow.<br>说话人A很自信地说“I am sure…”，所以他在后面用了won’t。<br>A：你认为明天会下雨吗？我敢肯定不会下雨。<br>B：可是天气预报说明天要下雨。</p>
<p><em><strong>would表示确定程度较大的预测。</strong></em><br><em><strong>New Year’s Superstitions</strong></em><br>In many European countries, people believe that the first visitor on New Year’s Day would bring them either good luck or bad luck. A dark-haired man would bring good luck. A woman or a man with light hair would bring bad luck. So some towns would choose a man with dark hair to go quickly from house to house. After he makes his rounds, the houses would be open to other visitors.<br>这里的前三个would都是表示推测。注意，在So some towns would choose a man with dark hair to go quickly from house to house.After he makes his rounds, the houses would be open to other visitors. 中的 两个would不是表示推测，而是表示“意愿”，即属于情态动词的基本用法。<br><em><strong>新年的迷信</strong></em><br>在许多欧洲国家，人们相信，在新年这天你遇到的第一个人将会给你带来好运或者厄运。若是遇到一头黑发的男子，这就意味着好运。若是遇到浅色头发的女子或男子，则意味着是厄运。因此，有的城镇就会专门挑选出一名深色头发的男子迅速地挨家挨户走动。等他转一圈下来之后，屋门才会打开，迎接其他客人。</p>
<p><em><strong>should表示确定程度较大的预测，相当于“很可能将会这样了（most probably the case）”。</strong></em><br>The results are expected tomorrow. We should know the results tomorrow.<br>结果明天就出来了。我们明天就该知道结果了。<br>He should have plenty of time to get to the station.<br>他应该有足够多的时间去车站。<br>The journey should take two or three days.<br>行程应该需要两到三天。<br><em><strong>注意，should在表示推测时，也翻译成“应该”，但这并不是表示义务或责任的“应该”，而是表示说话人的主观判断或推测。</strong></em></p>
<p><em><strong>may表示约50％确定的预测。</strong></em><br>Tomorrow’s computers may have something for your nose to enjoy. 未来的计算机可能就会使你的鼻子能够闻到气味。<br>This bridge may collapse in an earthquake. 这座桥可能会在地震中坍塌。</p>
<p><em><strong>could&#x2F;might表示很不确定（如只有25%）的预测。</strong></em><br>There might&#x2F;could be a strike next week. 下周可能会有罢工。<br>A campaign on the harsh terrain of a nation as large as California could be longer and more difficult than some predict.<br>这里说话人用的是确定程度最低的情态动词could，表示对未来战争局势的预测。<br>在一个面积同加利福尼亚州一样大的、并且充满险恶地形的国家里进行战争，意味着战争的时间可能比人们预想的要长，困难要大。</p>
<p><em><strong>同样要注意，在否定句中，can’t&#x2F;couldn’t要比may not&#x2F;might not的否定语气强烈。</strong></em><br>1） We may not&#x2F;might not go camping this summer. 今年夏天我们可能不去野营。<br>2） We can’t&#x2F;couldn’t go camping this summer. 今年夏天我们不可能去野营。</p>
<h3 id="二"><a href="#二" class="headerlink" title="(二)"></a>(二)</h3><p><em><strong>should表示说话人的一种合理的假设（the speaker’s reasonable assumption），因此它是用来对说话人所希望发生的事进行推断的。若将来的事件不是他所期望发生的，则不用should表示这种推测，也就是should带有主观性。</strong></em><br>1） Let’s not go to the movie. It could be bad.<br>2） Let’s go to the movie. The film should be really good.<br>在例句1）中，“电影可能不好”并不是说话人所期望的，所以不说“It should be bad.*”。在例句2）中，“电影好看”自然是人人希望的，所以说话人用should。<br>1） 我们别去看电影了，它或许不好看。<br>2） 我们去看那电影吧，它应该很好看。</p>
<p>There should be another disaster shortly. *<br>这样说话显得很别扭，因为它暗示说话人对灾难持赞许的态度。所以正确的说法应该是：<br>There could be another disaster shortly. 很快就会发生另一场灾难。</p>
<p>A: I have flushed cheeks and a slight fever.<br>B: You should be coming down with something. *<br>B的回答有问题，因为说话人用了should，暗示A的生病症状是他所希望的，这显然不妥，所以B最好用could，might，may或must来表达。尽管在汉语中可以用“应该”来表达不好的事情，但英文中不可以这样表达。<br>A：我脸颊发红，有些低烧。<br>B：你应该是生病了。</p>
<p>A: These summer days are getting to be more than I can take. It was even too hot to go to the pool yesterday.<br>B: Hold on, according to the weather report we should have some relief by the end of the week.<br>“天气转凉”是人们所希望发生的，所以用了should。<br>A：这夏天热得让我越来越受不了了。昨天热得都无法去游泳池了。<br>B：别急，天气预报说，到这个周末，可能就会凉快点。</p>
<blockquote>
<p>思维总结：</p>
</blockquote>
<ul>
<li>首先，表示对将来的预测的情态动词较多，除了must外都可以，比如could和might等这样的过去形式的情态动词都可以表示对将来的预测。</li>
<li>其次，不同的情态动词所表示的确定程度不同。</li>
<li>最后，要理解should用来对说话人所希望发生的事进行推断。</li>
</ul>
<h2 id="推测用法（三）：过去推测（情态动词完成式）"><a href="#推测用法（三）：过去推测（情态动词完成式）" class="headerlink" title="推测用法（三）：过去推测（情态动词完成式）"></a>推测用法（三）：过去推测（情态动词完成式）</h2><p><em><strong>表示对过去的推测，英语的谓语形式要用“情态动词完成式”，常用的情态动词有must，may，might和could，所以要说成 must have been, may have been, might have been和could have been等形式；若是在否定句中，则需要将must换成can或could，说成can’t have done或couldn’t have done，<br>其中情态动词所表达的推测的确定程度与对现在的推测中所说的一样，即must表示非常确定的推测，may其次，might或could最不确定。</strong></em><br>A: Why wasn’t John in class yesterday?约翰昨天怎么没来上课？<br>B: He was sick.他病了。<br>He must have been sick.他一定是病了。<br>He may have been sick. 他可能病了。<br>He could&#x2F;might have been sick. 他或许是病了。</p>
<h3 id="虚拟还是推测？"><a href="#虚拟还是推测？" class="headerlink" title="虚拟还是推测？"></a>虚拟还是推测？</h3><p>He should have had a covered bulletproof car, as most world leaders do today.<br>他（约翰·肯尼迪总统）应该像如今的各国政要那样，乘坐封闭的防弹汽车才对。<br>His death could have been prevented.<br>他（约翰·肯尼迪总统）也就不会丧命了。<br>这两句话并不是表示对过去的推测，而是表示与过去事实相反的假设，即表示对过去的虚拟。事实上，英语中四个过去形式的情态动词would，could，might和should既可以表示推测，也可以表示虚拟。具体来说，<em><strong>would&#x2F;could&#x2F;might&#x2F;should do可以表示对现在或将来的推测，也可以表示对现在或将来的虚拟；would&#x2F;could&#x2F;might&#x2F;should have done可以表示对过去的推测，也可以表示对过去的虚拟。</strong></em></p>
<p>1） I don’t know who killed John, but I guess his wife Mary could have killed him.<br>2） You could have killed me, I hope you know.<br>在例句1）中，根据上下文语境可知，could have killed是表示对过去的推测，“玛丽杀死自己丈夫约翰”存在一定的可能性。<br>在例句2）中，根据上下文语境可知，could have killed是表示对过去的虚拟，事实上“我”没有死，即不存在“我过去死”的可能性。<br>1） 我不知道是谁杀死了约翰，但我猜测他的妻子玛丽可能杀了他。<br>2） 你差点要了我的命，我希望你知道这一点。</p>
<p>所以，对于某些谓语带有would，could，might和should的句子，在没有具体语境的情况下，可能会在“推测”与“虚拟”之间产生歧义。比如：<br>He could have sent a message.<br>这个句子既可以理解为对过去的虚拟，译成：他本来可以事先捎个口信过来的（但实际上没有这么做，表示抱怨）。<br>也可以理解成对过去的推测，译成：他可能已经捎口信过去了。</p>
<p>He might have been drowned.<br>译文1：他当时差点就被淹死了。（虚拟）<br>译文2：他可能已经被淹死了。（推测）</p>
<p>但是如果是这样的句子：<br>You might have been drowned!<br>因为主语是you，所以这句译成虚拟的意思较为妥当。<br>你当时差点就被淹死了！</p>
<p>1） You should have received four letters by now.<br>2） I should have received four letters from them, but I got none.<br>在例句1）中，说话人是在推断说“到现在你们应该收到过四封信”，他用should来表示非常确定的推测，言外之意是，如果不出意外，四封信应该已经在你们手里了。<br>在例句2）中，说话人是在用虚拟语气抱怨说“我应该收到他们的四封信，但实际上我一封也没有收到”。这里的should表示虚拟，就不像例句1）中的推测那样存在“很可能收到了信，也可能没有收到”这两种可能性，而只有一个现实：我一封信都没有收到。<br>1）到现在你们应该收到过四封信。<br>2）我应该收到他们的四封信，但实际上我一封也没有收到。</p>
<blockquote>
<p>would， could，might，should do&#x2F;have done可能出现的推测或虚拟的歧义，可以这样来分辨是推测还是虚拟：知道确切结果的是表示虚拟，而不知道确切结果，即存在两种可能性的是表示推测。</p>
</blockquote>
<p><em><strong>现在形式的情态动词must，can，may和will不能表示虚拟，所以 must&#x2F;can&#x2F;may&#x2F;will have done只能是表示对过去的推测，而不能表示对过去的虚拟。</strong></em><br>A: I must have lost some weight. Look, how baggy my pants are.<br>我准是瘦了不少，你看我这裤子多肥。<br>B: They don’t look that loose to me.<br>可是我看它并不显得那么肥。</p>
<p>A: Why are the windows open? 窗户怎么是开着的？<br>B: A burglar must have broken in. 一定有贼闯进来了。</p>
<p>Oh no, a traffic jam. There must have been an accident.<br>哦，又是堵车，一定是发生交通事故了。</p>
<p><em><strong>另外，“情态动词have done”的结构不一定相当于现在完成时。例如：</strong></em><br>You must have seen him.（你一定见过他了。）<br>可以相当于：<br>I assume now you have seen him before.<br>I assume now you saw him last night.<br>I assume now you had seen him before you came here.<br><em><strong>在must have seen这个结构中的have seen，在时间上可以 相当于一个现在完成的动作have seen，也可以相当于一个过去的动作 saw，甚至可以相当于一个过去完成的动作had seen。</strong></em></p>
<blockquote>
<p>思维总结：<br>对过去的推测，需要用“情态动词完成式”这一结构。这里的情态动词既可以是现在形式的may，can和will，也可以是过去形式的might，could，would和should。<br>对于过去形式的情态动词could，might，would和should，在没有具体语境的情况下，可能会在“推测”与“虚拟”之间产生歧义。可以这样来分辨是推测还是虚拟：知道确切结果的是表示虚拟，而不知道确切结果，即存在两种可能性的是表示推测。</p>
</blockquote>
<h2 id="推测用法（四）：情态动词（完成）进行式"><a href="#推测用法（四）：情态动词（完成）进行式" class="headerlink" title="推测用法（四）：情态动词（完成）进行式"></a>推测用法（四）：情态动词（完成）进行式</h2><p><em><strong>情态动词接完成式、进行式及完成进行式时，情态动词均是表示推测的含义。所以，情态动词与进行式或完成进行式连用时，表达的意思与相应的进行时态或完成进行时态的意思差不多，只是增加了情态的意义——推测含义。</strong></em><br>I can’t reach my friend. His line is always busy. He might be using the Internet now.<br>这里是说，我打不通朋友的电话，电话总是占线，于是我就推测他现在可能正在上网，占用了电话线。如果我是很确信他在上网，那就可以说成：<br>He must be using the Internet now.<br>或者不是很确信地说：<br>He may be using the Internet now.<br>当然，如果知道他确实就在上网，则可以不用情态动词，而直接用现在进行时态说成：<br>He is using the Internet now.<br><em><strong>“情态动词进行式”同一般进行时态一样，表达的是一个现在正在进行的活动，只是因为有了情态动词而增添了情态的意义——推测含义。</strong></em></p>
<p>《老友记》某个片段：<br>She’s not here yet. She’s not here. She’s having my baby and she’s not here. God, I don’t believe this. She could be giving birth in the cab.<br>could be giving是情态动词接进行式，表示在说话的时刻可能发生的事情。我们也看到，这里罗斯用了最不肯定的词could，一方面表明他不希望他的前妻在出租车上生孩子这件事真的发生，另一方面也说明了他的焦急程度——急得如此胡思乱想！如果他希望这件事发生，他就会用should了。<br>她还没有到，她还没有到，她就要生下我的孩子了，可她现在却还没有到。天啊，真不敢相信。她现在或许正在出租车上生产。</p>
<p>I am afraid he hasn’t found a job. He must still be checking the papers.<br>我恐怕他现在还没有找到工作，他一定还在翻着报纸找呢。<br>The plane should be landing now.<br>飞机现在肯定在降落。</p>
<p>情态动词与have been doing连用的情形：<br>A: Oh, I must have been sitting in the same position too long. My legs have fallen asleep.<br>B: Shake it a little before you get up.<br>这里must的后面接完成进行式表示推测，而且这里的完成进行式就相当于一个现在完成进行时态have been sitting，表示一直持续的动作或状态。<br>A：噢，我一定是同样一个姿势坐得太久了，我的两条腿都麻了。<br>B：站起来之前，你先把腿甩甩。</p>
<p>You must have been dreaming. 你刚才一定是一直在做梦。</p>
<p>“情态动词完成进行式”也可以用在虚拟语气中。比如：<br>You shouldn’t have been following him so closely; you should have kept your distance.<br>你本不该一直跟着他那么近，你应该和他保持一定的距离。</p>
<h2 id="基本用法（一）：现在或将来的能力"><a href="#基本用法（一）：现在或将来的能力" class="headerlink" title="基本用法（一）：现在或将来的能力"></a>基本用法（一）：现在或将来的能力</h2><p>说到表示“能力”的情态动词，首先会想到can。不过，不能把can与“能力”完全等同起来。can的含义远不止“能力”这一个意思，英语表达的“能力”和汉语是有差别的，而且差别很大。<br>首先，从核心意义（core meaning）的角度来看，<em><strong>can强调的是“潜在可能性”，而不是真正去实施。</strong></em><br>传统语法书上说，can主要有三个意义，即“能力（ability）”“可能（possibility）”和“许可（permission）”，其实都是源自“潜能 （potential）”这一核心意思。比如下面句子中的can表示“能力”：<br>A: My son can play the piano.<br>B: My daughter is only four and she can ride a bicycle.<br>C: Hey, that’s nothing. My dog can count to ten.<br>这里的三个can都是强调具备这样的“潜能”，或说“潜在的可能性”，而不是强调真正去实施。比如说话人C不会去把他家的狗牵来，真的让它数数。<br>A：我儿子能够弹钢琴。<br>B：我女儿才四岁，就能够骑自行车了呢。<br>C：嘿，这都没什么。我家的狗能够数到10呢！</p>
<p>再比如下面句中的can表示“可能”：<br>Don’t go out alone at night. That can be very dangerous.<br>这里的can表示“可能”。<br>晚上不要独自出门，那可能很危险。</p>
<p>再比如下面句中的can表示“许可”：<br>You can use my car tomorrow.<br>这里的can表示“许可”——我允许你用我的车，但实际上你并不一定用，只是一种潜在的可能。</p>
<p>所以，上述三个例句都只是表明主语有完成某一行为的“潜在可能”，而并不一定真正去实施，或者表示某事可能存在。<br>I don’t know how she knows, but Mom can always detect when I’m lying.<br>我不知道妈妈是怎么知道的，每次我撒谎的时候，她总是能够察觉出来。<br>The theater can seat 10,000 people.<br>这家剧院可坐10000人。<br>上述例句都只是表明主语有完成这一行为的“潜能”，而并没有真正去实施。</p>
<h2 id="基本用法（二）：现实“可能”与理论“可能”"><a href="#基本用法（二）：现实“可能”与理论“可能”" class="headerlink" title="基本用法（二）：现实“可能”与理论“可能”"></a>基本用法（二）：现实“可能”与理论“可能”</h2><p>比较下面这些中文句子里的“可能”在含义上的差别：<br>1） 这孩子可能会很淘气。<br>2） 这孩子脸色煞白，他可能是病了。<br>3） 这里的交通有时可能会很拥堵。<br>4） 约翰现在还没到，他可能是在路上堵车了。<br>从can的核心意义——潜在的可能性——来分析。can既然是强调“潜在的可能”，所以它是强调某事在理论上发生的可能性是存在的，而与说话时的实际情况无关。比如说“这个孩子可能会很淘气”，就是从一般的理论意义上来说的，而与这个孩子当时的行为表现毫无关系。比如即使这个孩子当时正在甜美地熟睡着，我们仍然可以指着他说“这个孩子有时可能会很淘气”。同样，当我们说“这里的交通有时可能会很拥堵”时，我们并不需要考虑说话当时的交通状况，即使是在夜里没有车辆通行的情况下，我们依然可以说“这里的交通有时可能会很拥堵”。因此，can具有“偶然的可能性”或“理论上的可能性”的含义，而不是“实际上的可能性”。<em><strong>一般可以把这时的can翻译成“有时会”“可能会”。</strong></em><br>由此可见，can所表示的“可能”与前文讲过的could，may和might所表示的“推测”是完全不同的。尽管在汉语中都可译成“可能”，但两者的内涵是有巨大差别的。前面讨论的could，may和might所表示的“推测”，是强调“实际上的可能”。说话人要紧密结合当时的实际情况来判断某事发生的“确定程度（degrees of certainty）”的大小，从而选择might， could或may，甚至是must来表达不同的确定程度。此时，我们往往是表示根据现有事件的某种结果来推断其发生的原因。比如我们说“这个孩子脸色煞白”，对说话时的这一现状，我们推断“他可能是病了”。同样，对于“约翰现在还没有到”这一现有的结果，我们可以推测出各种原因，其中一个原因是“他可能是在路上堵车了”。<br><em><strong>区分“理论上的可能”与“实际上的可能”的一个关键点，是看所说的可能情况与说话时的现状是否有联系。与说话时的现状有联系的，则是“实际上的可能”。这时往往是谈论一个具体的事件，所以也可称之为“具体的可能”，这尤其用于针对一个现状或后果来推断其产生的原因。与说话当时的现状无关的，则是“理论上的可能”。</strong></em><br><em><strong>由于can具有“潜能”这一特性，决定了它只能用来表示“理论上的可能”，而不能表示“实际上的可能”，即不能具体地谈一个事件。所以，上面提到的推测含义中，都没有提到用can，而说的是could，might和may。</strong></em></p>
<p>The boy can be very naughty. （理论上、潜在的可能）<br>The boy looks pale. He could be sick. （实际上、现实的可能）<br>Grammar can be fun!<br>这里的can表示一种“理论上的可能”。比如说现在市面上有很多枯燥乏味的英语语法书，而且有很多内容语焉不详。于是我就想说“语法可能会很有趣”，并且我一直在努力这么做。只不过，这种理论上的可能，在实践中是要下一番苦功夫的。<br>语法可能会很有趣！<br>He can be very rude. 他有时会非常粗鲁。<br>A visit to the dentist can be frightening. 去看牙医可能会很恐怖。</p>
<p><em><strong>注意，can这种“理论上的可能”往往只适用于肯定句中，不宜用于否定句。正如上文说过的，这种“理论上的可能”就意味着“世事无绝对”这样一个普遍的真理。如果用can’t来否定，就相当于说“什么事情都不可能发生”，这显然有悖于一般真理。比如不宜说：</strong></em><br>Even experienced teachers can’t make mistakes. *<br>表示“即使再有经验的老师都不会犯错误”，这显然不符合常理，在中文里也讲不通。<br>由此可见，can表示“理论上的可能”时不宜用在否定句中。</p>
<p><em><strong>如果真的要用can’t来否定一个“可能性”，这个“可能性”一般就是“实际上的可能”或者说“具体的可能”，即否定具体特定的一件事情，而不是否定一般的真理，也就是上面谈到的 can’t表示否定推测的“不可能”。表示说话人的信心非常大，对应的是肯定推测的must。或者说can’t是用来帮助must构成否定句的。</strong></em></p>
<h2 id="基本用法（三）：过去的能力"><a href="#基本用法（三）：过去的能力" class="headerlink" title="基本用法（三）：过去的能力"></a>基本用法（三）：过去的能力</h2><p>如果是“今天我能去迪士尼乐园”，用英语可以这么说：<br>Today I can go to Disneyland.<br>或者说：Today I am able to go to Disneyland.<br>can强调的是“潜在的可能性”，而不是真正去实施，所以这句话其实是说“尽管理论上有条件去，但实际上我可能去，也可能不去”。<br>现在把时间改为“昨天”，来表达一个确定的事实，即“我昨天终于能够去迪士尼乐园”，这时要怎么说呢？<br>把can改成过去式could的话是错误的：<br>Yesterday I could go to Disneyland. *<br>这种说法是不正确的，或者说在英语中不存在上面这样的句子。如果一个英语为母语的人听到了这个句子，他或许还会进一步问你“昨天你到底是去了还是没有去？”。如果是去了，他会让你说：<br>Yesterday I was able to go to Disneyland.<br>如果是要表达“我昨天本来是可以去，但结果没有去成”这样的虚拟意思，则要说成：<br>Yesterday I could have gone to Disneyland.<br>所以，在英语中不存在“Yesterday I could go to Disneyland.”这样的句子。<br>这个问题涉及could和was able to在表达“过去的能力（past ability）”时的区别。<br>汉语里完全可以说“昨天能够怎样怎样”，但在英语里却不能说“Yesterday I could…”这样的句子。can&#x2F;could的核心意思是表示一种“潜能”，强调的是“潜在的可能性”，而不一定真正去实施。<br>*<strong>“将来能够”或者是“今天能够”去迪士尼乐园，强调的都是一种“潜在的可能性”，而不一定真正去实施。也就是说，尽管理论上我可以去迪士尼乐园，但实际上我可能去，也可能不去。但如果我们谈一个具体的过去的事件，如“昨天能够去迪士尼乐园”，则表达一个确定的事实，没有“潜在的可能”的意思了，这就违背了can表示“潜能”这一核心意思。故不能说出“Yesterday I could go to Disneyland. <em>”这样的句子。</em></strong></p>
<blockquote>
<p>could表示“过去的一般能力”，was able to表示“过去的具体能力”。具体地说，所谓“过去的一般能力”就是指在过去有能力想做某件事就随时可以去做，但并不说明真正实施了这个行为，即强调的是一种“潜能”，而不是某一次具体的过去行为。</p>
</blockquote>
<p>I could run after a bus and catch it twenty years ago, but I can’t do that now.<br>这里只是说明我过去有“追上汽车”的能力，而并没有强调我真的有过“追车”这个行为，即表示的是一种“潜能”或“一般能力”，所以用could来表示“潜在的可能”。这里不能用can，因为can表示的是现在或将来。<br>20年前我可以追上汽车，但现在不行了。</p>
<p><em><strong>所谓过去的“具体的能力”，即表示主语在过去的某个特定场合所实施的具体行动，此时没有“潜在的可能性”，所以不能用could，而要用was&#x2F;were able to，表示“成功地做成了某事”。因此was&#x2F;were able to do可 用succeeded in doing或managed to do替换</strong></em><br>I ran after the bus yesterday and was able to catch it.<br>这里用was able to表示的正是过去的一次具体的行为，说明具体实施了“追车”这一行为，而且成功地追上了，即表示“具体的能力”，而不是过去的“潜能”。<br>昨天我追赶了一辆汽车，并成功地追上它了。</p>
<blockquote>
<p>综上所述，could同can一样，表示的是一种“潜能”或者说“过去的一般能力”，而不是“实际行动”；was&#x2F;were able to则更多的是用来表示过去的“实际行动”或者说“具体的能力”。但注意，也可以用was&#x2F;were able to 表示“潜能”，但不如could常用。</p>
</blockquote>
<h3 id="表示过去的“潜能”"><a href="#表示过去的“潜能”" class="headerlink" title="表示过去的“潜能”"></a>表示过去的“潜能”</h3><p>He could&#x2F;was able to pull down a bull and acknowledged as a man with super strength.<br>这里只是说他“曾经能够”，并没有具体说是哪次活动，所以是“潜能”，不是“实际行动”。<br>他曾能够拉倒一头牛，被公认为是具有神力的人。<br>In those days few workers could support their families.<br>那时很少有工人能够养家糊口。</p>
<h3 id="表示过去的“实际行动”（均不能用could）"><a href="#表示过去的“实际行动”（均不能用could）" class="headerlink" title="表示过去的“实际行动”（均不能用could）"></a>表示过去的“实际行动”（均不能用could）</h3><p>I applied everywhere and finally I was able to get a good job.<br>我四处应聘，终于找到了一份不错的工作。<br>He didn’t agree with me at first but I was able to persuade him.<br>起初他并不同意我的意见，但最终我成功说服了他。</p>
<p>对于某些句子，既可以用could，又可以用was&#x2F;were able to，此时的含义是不同的。比如：<br>1） I could repair the old car.<br>2） I was able to repair the old car.<br>在例句1）中，用could表达的是过去的一般能力，即表示“我过去是能够修理旧汽车的”，这里是泛指任何一辆旧汽车。在例句2）中，用was able to表达的是过去的具体能力，即表示“我终于把那辆旧汽车修理好了”，这里是具体指某一辆特定的旧汽车。<br>1） 我过去是能够修理旧汽车的。<br>2） 我终于把那辆旧汽车修理好了。</p>
<p><em><strong>有趣的是，上述could和was&#x2F;were able to的区别仅限于肯定句中，在否定句中could 和was&#x2F;were able to可以互换使用，没有区别。</strong></em>比如可以说：<br>I ran after the bus yesterday, but wasn’t able to&#x2F;couldn’t catch it.<br>昨天我追赶了公共汽车，但是没赶上。<br>I applied everywhere and I wasn’t able to&#x2F;couldn’t get any good job.<br>我四处应聘，但是没能找到好工作。<br>The fire spread through the building quickly and people weren’t able to&#x2F;couldn’t escape.<br>大火在大楼中迅速蔓延，人们没能逃脱。<br><em><strong>尽管这里是表示过去的具体场合，但依然用了could，因为有否定的not，即couldn’t表示过去具体的能力。</strong></em></p>
<h2 id="基本用法（四）：许可"><a href="#基本用法（四）：许可" class="headerlink" title="基本用法（四）：许可"></a>基本用法（四）：许可</h2><ul>
<li>可以用的情态动词有 may，might，can和could，但多用can或be allowed to do表示许可；</li>
<li>表示“许可”一般用陈述句（若用疑问句则表示“请求 〈request〉”）</li>
<li>肯定的陈述表示允许某人做某事；否定的陈述则表示不允许某人做某事。</li>
</ul>
<h3 id="肯定句——给予许可"><a href="#肯定句——给予许可" class="headerlink" title="肯定句——给予许可"></a>肯定句——给予许可</h3><p>We can borrow these books from the library. 我们可以从图书馆借出这些书。<br>相当于“We are allowed to borrow these books from the library.”。<br>You can use my car tomorrow. 明天你可以用我的车。<br>相当于“You are allowed to use my car tomorrow.”。</p>
<p>也可以用may来表示“许可”。<br> A: May I turn on the TV? B: Yes, of course you may.<br>这里may用在疑问句中表示“请求许可”，用在肯定的陈述句中表示“给予许可”。<br>You may only register for two classes. 你只能报两门课。<br>在口语中，我们更多的还是用can来表达“许可”。而may表示“许可”会用在非常正式的文体中，所以在口语中比较少见。<br>can表示“许可”，可以和表示将来的时间状语连用。尽管前面讲过，can可以表示将来的能力，不过此时一般不与表示将来的时间状语连用。<em><strong>若有表示将来的时间状语，要说will be able to do。</strong></em><br>You can use my car tomorrow.<br>该句中的can是表示“许可”，所以可以与tomorrow连用。<br>明天你可以用我的车。<br>You can pass your driving test next time you take it.*<br>因为该句中的can是表示“能力”，所以不宜与表达将来的从句next time you take it连用，最好改为“You will be able to pass your driving test next time you take it.”。<br>你下次参加驾照考试应该就能通过了。</p>
<h3 id="否定句——拒绝许可，甚至禁止"><a href="#否定句——拒绝许可，甚至禁止" class="headerlink" title="否定句——拒绝许可，甚至禁止"></a>否定句——拒绝许可，甚至禁止</h3><p>A: May I borrow your car?<br>B: No, I’m afraid you may not.<br>may用在疑问句中表示“请求许可”，用在否定的陈述句中表示“拒绝许可”。<br>You may not smoke in here.<br>&#x3D;You are not allowed to smoke in here.<br>这里不让抽烟。</p>
<p><em><strong>我们还可用must not表示强烈的拒绝许可——禁止，但must not比cannot或may not的语气强烈。</strong></em>比如：<br>Students must not take the test papers out of the classroom. 任何学生都不得把试卷带出教室。</p>
<h3 id="could一般不用来表示现在的许可，而表示过去的许可"><a href="#could一般不用来表示现在的许可，而表示过去的许可" class="headerlink" title="could一般不用来表示现在的许可，而表示过去的许可"></a>could一般不用来表示现在的许可，而表示过去的许可</h3><p><em><strong>表示过去的一般许可，could与was&#x2F;were allowed to do可以互换。</strong></em><br>I could&#x2F;was allowed to read what I liked when I was a child.<br>我小时候爱看什么书，就看什么书。<br><em><strong>不过，若表示过去允许进行某项特定的活动时，要用was&#x2F;were allowed to do，这一区别与表示“能力”时的could和was&#x2F;were able to的区别类似。</strong></em><br>Yesterday evening, Peter was allowed to watch TV for an hour.<br>昨晚，彼得被允许看了一个小时电视。<br>但不说“Yesterday evening, Peter could watch TV for an hour. *”。<br>同理，might在表示“许可”时，也只能是表示过去的一般许可，而不能表达具体场合的某一个活动。不能说“Yesterday evening, Peter might watch TV for an hour. *”。</p>
<p>请比较：<br>1） They might have a break after lunch.<br>2） They were allowed to have a break after lunch.<br>在例句1）中，用might是表示过去一般的许可，所以该句的意思是：他们在过去的一段时期内，是被允许在吃完午饭后休息一会儿的。<br>在例句2）中，用were allowed to可以表示过去一般的许可。但若表示过去具体的许可，则该句的意思是：在过去的某一天他们被允许在吃完午饭后休息了一会儿。<br>1） 那时，他们吃完午饭后是可以休息一会儿的。<br>2） 那次，他们吃完午饭后被允许休息了一会儿。</p>
<h2 id="基本用法（五）：建议与忠告"><a href="#基本用法（五）：建议与忠告" class="headerlink" title="基本用法（五）：建议与忠告"></a>基本用法（五）：建议与忠告</h2><p>在英语中，表示“建议”与“忠告”的情态动词比较多，比如可以用could, shall和should等。</p>
<h3 id="could表示“建议”"><a href="#could表示“建议”" class="headerlink" title="could表示“建议”"></a>could表示“建议”</h3><p><em><strong>could可以表示“推测”（可用于将来、现在及过去时间）、过去的“能力”、过去的“许可”。这里来看could用于表示“建议”，此时，could并不表示过去。</strong></em>比如：<br>A: I’ve been invited to a dinner party at Janet’s. Do you think I should bring something?<br>B: You could pick up a cake. Chocolate is her favorite.<br>说话人A是在征求B的建议，于是B通过could来提出自己的建议，建议A“买一份蛋糕”。<br>A：我受邀去珍妮特家参加晚宴，你认为我该带点什么东西去吗？<br>B：你可以顺便买一份蛋糕嘛，她最喜欢巧克力口味。<br>It is a nice day. We could go for a walk. 今天天气不错，我们可以出去散散步。</p>
<h3 id="Shall-I…-Shall-we…"><a href="#Shall-I…-Shall-we…" class="headerlink" title="Shall I…? Shall we…?"></a>Shall I…? Shall we…?</h3><p><em><strong>shall用于第一人称的一般疑问句中，表示征求对方的“建议”。</strong></em><br>Shall we leave at two? Is that OK? 我们两点钟走如何？怎么样？</p>
<h3 id="may-（just）-as-well-might-（just）-as-well"><a href="#may-（just）-as-well-might-（just）-as-well" class="headerlink" title="may （just） as well, might （just） as well"></a>may （just） as well, might （just） as well</h3><p><em><strong>这组情态动词表示“建议换另一种方式做某事”，可译成“倒不如”“不妨”“最好”。</strong></em><br>A: I’ll go on Monday by train.<br>我将在周一坐火车去。<br>B: You might just as well wait till Wednesday and go by plane.<br>你不妨等到周三坐飞机去。 </p>
<p>We may as well stay here tonight.<br>今晚我们最好呆在这里。</p>
<p>另外，<em><strong>may&#x2F;might as well还有一种多少有些勉强或讥讽的意味，表示“在没有其他更好的选择的情况下，只好为之”之意。</strong></em><br>It’s no use waiting here. We might as well start walking.<br>在这里干等没用，我们还不如开始步行回去。<br>You might as well tell the truth (as continue to tell lies).<br>这里言外之意是“别再继续撒谎了”，相当于“There is no point in your continuing to tell lies.”。<br>（与其继续撒谎）你最好实话实说。</p>
<h3 id="should和ought-to表示“忠告”"><a href="#should和ought-to表示“忠告”" class="headerlink" title="should和ought to表示“忠告”"></a>should和ought to表示“忠告”</h3><p>should最主要的意义和用法就是表示“建议”“忠告”或者说“规劝”，表示“某事是应该做的或恰当的（appropriate behavior）”。<br>You should brush your teeth twice a day. 你应该每天刷牙两次。<br>We should study harder because the finals are near. 快要期末考试了，我们得更用功了。<br>此时的should往往也会含有“责任”和“义务”的含义。<br>Drivers should obey the speed limit. 司机应该遵守车速限制（的规定）。<br><em><strong>这种“责任”的意味比must要轻。</strong></em><br>Drivers must obey the speed limit. 司机必须遵守车速限制（的规定）。<br>表示“责任”的should也常见于疑问句中，表示否定一个“责任”。<br>Why should I do what everyone else does? 我为什么非得跟其他人一样啊？<br>Why should I go there when I’m quite happy here? 我在这里很快乐，为什么非要去那里啊？</p>
<blockquote>
<p>总之，should的基本含义是表示进行恰当的行为（expressing appropriate behavior）、正确地做事（correct ways of doing things），所以可以用来表示规劝、建议或忠告等等。</p>
</blockquote>
<p><em><strong>另外，上述例句也都可以用ought to，只不过它更多地出现在口语中，而不是书面语中。</strong></em></p>
<h3 id="should表示“忠告”与could表示“建议”的比较"><a href="#should表示“忠告”与could表示“建议”的比较" class="headerlink" title="should表示“忠告”与could表示“建议”的比较"></a>should表示“忠告”与could表示“建议”的比较</h3><p><em><strong>should表示强烈的、明确的忠告；could表示建议某事的可能性。</strong></em><br>A: I need to get to the airport.<br>B1: You should take the airport bus. It’s cheaper than a taxi.<br>B2: Well, you could take the airport bus. Or you could take a taxi. Maybe Clint could take you. He has a car.<br>A：我得去机场。<br>B1：你应该坐机场大巴，比坐出租车便宜。<br>B2：嗯，你可以坐机场大巴，也可以坐出租车。克林特也许能送你去，他有车。<br><em><strong>总体来说，could比should的语气要弱得多，只是表示提供一种参考意见，听话人可以有多种选择。而should则是表示听话人最好应该采用的一种选择。</strong></em></p>
<h3 id="had-better表示“忠告”"><a href="#had-better表示“忠告”" class="headerlink" title="had better表示“忠告”"></a>had better表示“忠告”</h3><p>常用于口语中，后面接动词原形，否定用had better not do。<br>We had better study harder, or we’ll probably fail in the exam. 我们最好用功学习，不然就有可能考试不及格。<br>需要注意的是，<em><strong>had better在表示“忠告”时，有时会暗含“如果不这么做，就会有不良后果”的意思，而should则更为中性。</strong></em>比如：<br>You had better return the book to the library.<br>这相当于警告对方，如果不及时还书，图书馆就会有惩罚措施，比如罚款。<br>你最好把书还给图书馆。</p>
<h2 id="基本用法（六）：意愿、意图与执意"><a href="#基本用法（六）：意愿、意图与执意" class="headerlink" title="基本用法（六）：意愿、意图与执意"></a>基本用法（六）：意愿、意图与执意</h2><p>will主要有两个意义和用法：预测和意愿。<br>A: The phone’s ringing.<br>B1: That’ll be for me.<br>B2: I’ll get it.<br>这里B的第一种回答方式，是表示很确定的预测，即“肯定是我的电话”。而B的第二种回答方式，则是表示自己愿意去接这个电话，是表示意愿，即“我来接”。<br>We’ll carry those for you if he won’t.<br>表示意愿。<br>如果他不愿意，我们会帮你拿那些东西的。</p>
<h3 id="意图（intention）"><a href="#意图（intention）" class="headerlink" title="意图（intention）"></a>意图（intention）</h3><p>表示“意图”往往涉及将来准备好的事件。<br>I will borrow some money and buy a car.<br>这里will表示说话人的意图和打算，而不是在预测或表达意愿。这句话相当于“I intend to borrow some money and buy a car.”。<br>如果把“意图”的含义向两个极端——承诺与威胁——延展开来，在表达意图时，如果是希望的行为（desirable action），则可解释为一种“承诺 （promise）”；若是不希望的行为（undesirable action），则解释成为一种“威胁（threat）”。<br>I will make dinner tomorrow night.<br>这里的will表达的是一种承诺。<br>明晚我来做晚饭。<br>I’ll call the police if you don’t leave.<br>这里的will表达的是一种威胁。<br>如果你不离开，我就要叫警察了。</p>
<h3 id="执意（insistence）"><a href="#执意（insistence）" class="headerlink" title="执意（insistence）"></a>执意（insistence）</h3><p>will表示“执意”，来源于其表示“意图”的含义，因为当某人坚持自己的“意图”而不愿意改变时，就变成了“执意”。<br>此时，肯定的will表示“某人坚持要做某事”，I will相当于I insist；否定的won’t表示“某人坚持不愿意做某事或禁止做某事”，比如说I won’t相当于I refuse、<br>If they will pay in cash, we have to accept it although it’ll cause trouble to both sides.<br>这里if引导的从句中的will就是表示执意。一般来讲，在if引导的条件状语从句中是不能用将来时态will的，但这里will用于if引导的条件状语从句中了。究其原因，就是因为这里的will不是表示将来时态，而是侧重于表示“执意”这样的情态含义。另外，although引导的从句中的will是表示说话人的预测。<br>如果他们非要坚持用现金支付，那我们也只好接受了，尽管这会给双方都造成麻烦。<br>类似上面这个句子，我们可以造一个will not的否定句，来表示说话人拒绝做某事。比如：<br>If they will not accept a check, we shall have to pay cash, though it would be much trouble for both sides.<br>这里if引导的条件状语从句中，will not就是表示“执意不做某事”，相当于refuse。<br>如果他们就是不愿意接受支票，那我们只好付现金了，尽管这会给双方都造成麻烦。<br><em><strong>注意，当will用于表达“执意”这样强烈的感情色彩时，一方面不要缩写成’ll，而要用will；另一方面，will要重读。</strong></em></p>
<p><em><strong>will的过去式would也有类似表示“执意”的用法。</strong></em><br>We all tried to stop him smoking in bed but he wouldn’t do it.<br>我们大家都尽力阻止他在床上抽烟，但是他就是非得要这么做。<br>同理，这里的would不能缩略写成’d，而且要重读。</p>
<h2 id="基本用法（七）：请求"><a href="#基本用法（七）：请求" class="headerlink" title="基本用法（七）：请求"></a>基本用法（七）：请求</h2><h3 id="（一）"><a href="#（一）" class="headerlink" title="（一）"></a>（一）</h3><p>在日常交往中，我们往往会请求别人为我们做某事，此时，我们当然要表现出礼貌或委婉的态度，而不能直截了当地，甚至是粗鲁地提出“要求”。为了表示礼貌，就需要借助情态动词。<br>A: Hey, you! Open this door!<br>B: It’s locked. Want us to get the key?<br>A: Yeah. Get it. Fast!<br>A：嘿，说你呢，把门打开！<br>B：门锁了。想要钥匙？<br>A：去给我拿，快点！<br>这种直接而唐突的表达，显然缺乏礼貌，显得说话人很粗鲁。但是如果借助情态动词及其相关句型，就可以使我们的请求显得客气和委婉。<br>A: Excuse me, would you please open this door?<br>B: I’m afraid it’s locked. Shall I get a key?<br>A: Please, if you wouldn’t mind, as quickly as you can.<br>A：对不起，你能把门打开吗？<br>B：恐怕门被锁上了，要我替你把钥匙拿来吗？<br>A：太好了，那就麻烦你快点去拿，好吗？</p>
<h3 id="（二）"><a href="#（二）" class="headerlink" title="（二）"></a>（二）</h3><p><em><strong>用第一人称（I&#x2F;we）和第二人称（you）来提出请求。当用第一人称时，可以用四个情态动词：can&#x2F;could和may&#x2F;might，表示“请求对方允许我们做某事”。</strong></em><br>Can&#x2F;Could I…?<br>May&#x2F;Might I…?</p>
<blockquote>
<p>“May I…?”和“Could I…?”表示较正式、很礼貌地提出请求。 比如在询问陌生人的姓名时：</p>
</blockquote>
<p>May I have your name, please? 请问您怎么称呼？<br>Could I see your driving license? 可以给我看看您的驾照吗？</p>
<blockquote>
<p>“Can I…?”是非正式的请求允许，一般用于说话人与对方相当熟悉的情况下。比如和朋友之间的对话：</p>
</blockquote>
<p>Can I use your pen? 我能用一下你的钢笔吗？</p>
<blockquote>
<p>“Might I…?”显得过于正式和客气，所以一般很少用。</p>
</blockquote>
<p><em><strong>当用第二人称时，请注意要用的情态动词是：can&#x2F;could和 will&#x2F;would，这是“请求对方为我们做某事”。</strong></em><br>Can&#x2F;Could you…?<br>Will&#x2F;Would you…?<br>同样要注意这几个词表达不同的礼貌程度，“Would you…?”和“Could you…?”都是用来表示很客气地请求对方，客气程度相同。<br>Could you put out your cigarette, please? 请你把烟熄了，好吗？<br><em><strong>“Will you…?”不如“Would you…?”客气，比如较熟悉的朋友之间的对话：</strong></em><br>A: I am on duty this afternoon. Will you please cover for me? I have a doctor’s appointment.<br>B: I am sorry I can’t. My term paper is due tomorrow.<br>A：今天下午我值班，你能替我一下吗？我得去看医生。<br>B：对不起，我替不了你。我明天得交学期论文。<br><em><strong>“Can you…?”常用于非正式场合、熟人之间。</strong></em>比如，在吃饭时，你对母亲说：<br>Can you pass me the salt, Mom? 妈妈，把盐递给我好吗？</p>
<blockquote>
<p>综上所述，在“请求”时，不同人称所使用的情态动词不尽相同。 can&#x2F;could可以同时用于两个人称，如“Can&#x2F;Could I…?”或者“Can&#x2F;Could you…?”，但may&#x2F;might只能用于第一人称，不能说“May&#x2F;Might you…? *”，而will&#x2F;would只能用于第二人称，不能说“Will&#x2F;Would I…?*”。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/4q8XnX.png"><br>在英语中表示“请求”往往都是用一般疑问句式，因为“请求”的含义有三个来源：</p>
<ul>
<li>询问听话人是否愿意，这就是“Will&#x2F;Would you…?”表示“请求”</li>
<li>询问听话人是否允许我做某事，这就是“May I…?”或“Could&#x2F;Can I…?”表示“请求”</li>
<li>询问听话人是否能够帮助，这就是“Could&#x2F;Can you…?”表示“请求”</li>
</ul>
<p>（三）<br>表示请求时，在语气上越是不肯定，越是犹豫，就越显得礼貌。所以，由“直截了当”到“极为犹豫不决”，可以用不同的情态动词句型来表达不同程度的礼貌。以下都是表示很礼貌的“请求”句型：<br>Could you do…? Could you please do…?<br>Could you possibly do…?（注意副词）<br>Would you do…?<br>Would you please do…?<br>Would you kindly do…?（注意副词）<br>Would you mind doing…?<br>Would you be good&#x2F;kind enough to do…?<br>Would you be so kind as to do…?<br>Do you think I could…?<br>Do you think you could&#x2F;would do&#x2F;would mind doing…?</p>
<p>Excuse me, but would you kindly lend me your mobile phone?<br>对不起，你能把手机借我用一下吗？</p>
<p>表示请求的句型通常是一般疑问句。但也可以用wonder的各种陈述句型来表示比上述例句更加礼貌的请求：<br>I wonder if I could do…<br>I wondered if I could do…<br>I was wondering if I could do…<br>I wonder if you could&#x2F;would do&#x2F;would mind doing…<br>I wondered if you could&#x2F;would do&#x2F;would mind doing…<br>I was wondering if you could&#x2F;would do&#x2F;would mind doing…<br>比如上面那个借手机的例子。如果你告诉对方你要借他的手机，从中国往美国打一个国际长途，这时你就应该用上述这些更为礼貌的（尤其是最后一个“超级”礼貌的）句型来表达你的这一“过分请求”，以显得你“极为犹豫不决”和不好意思：<br>Excuse me, sir, I was wondering…um…if you…er…if you could possibly lend me your mobile phone, coz I really need to make a long distance call to America right now.<br>对不起，先生，我想……嗯……您能不能……呃……您能不能把手机借我用一下，因为我现在急着要往美国打个长途电话。</p>
<h2 id="基本用法（八）：过去习惯"><a href="#基本用法（八）：过去习惯" class="headerlink" title="基本用法（八）：过去习惯"></a>基本用法（八）：过去习惯</h2><h3 id="（一）-1"><a href="#（一）-1" class="headerlink" title="（一）"></a>（一）</h3><p>并不是任何时候只要句中出现了would就是虚拟用法，would在句中的含义要依据上下文的语境而定。有时候的would是表示过去反复发生或习惯性 的动作。<br>当回顾自己的孩提时代时，我们也许会这样说：<br>When I was a child, my mother would read me a story at night before bed.<br>小时候，晚上睡觉前妈妈常常会给我讲故事。<br>或许小时候我们都有过这样的经历：<br>When I was a child, I would take a flashlight to bed with me so that I could read comic books without my parents’ knowing about it.<br>小时候，我常常会拿着手电筒在床上看连环画，这样爸妈就不会发觉了。</p>
<h3 id="（二）-1"><a href="#（二）-1" class="headerlink" title="（二）"></a>（二）</h3><p>用would表示过去习惯或重复的动作时，还可以指某人一贯的行为。这时，往往用来批评人们的行为或表示对他人 的行为怀有某种恼怒的情绪，此时would要重读。<br>A: Jack would get lost, wouldn’t he? 杰克老是迷路，是吧？<br>B: It’s typical. 可不是嘛！<br>He was a nice boy, but he would talk about himself all the time.<br>他人还不错，但就是老喜欢谈论他自己。</p>
<p>A: Bill objected. 当时比尔反对。<br>B: He would! 他老是反对！<br><em><strong>值得注意的是，也可用used to来表示过去习惯的动作。但二者之间的区别是：used to可以表示过去重复的动作，也可以指过去存在的状态，有“现在不再”的含义。would常用来表示过去重复的动作，不表示过去的状态。</strong></em><br>My own mother used to be very busy the whole day.<br>这里用的是used to，而不是would，因为be very busy是过去存在的一种状态，不是动作。<br>以前，我母亲每天总是忙忙碌碌的。<br>Illiteracy is still a problem in my country, but it used to be much worse.<br>一般不说it would be much worse，因为be much worse同样表示的是一种状态。<br>文盲在我们国家仍然是一个问题，但在过去更为严重。</p>
<h2 id="基本用法（九）：should的特殊用法"><a href="#基本用法（九）：should的特殊用法" class="headerlink" title="基本用法（九）：should的特殊用法"></a>基本用法（九）：should的特殊用法</h2><p>should还有另外一些比较特殊的用法，不表示劝告，这时不能译成“应该”，而是表示“竟然”和“万一”。</p>
<h3 id="should表示“竟然”"><a href="#should表示“竟然”" class="headerlink" title="should表示“竟然”"></a>should表示“竟然”</h3><p>用在下列形容词后面的从句中的should，带有一种很“惊奇”的感情色彩，含有“竟然”的意思。比如：It is&#x2F;was absurd, amazing, annoying, funny, ludicrous, odd, ridiculous, strange, surprising, unthinkable that…等。<br>It is ridiculous that we should be short of water in a country where it is always raining.<br>在经常下雨的国家里，我们竟然会缺水，这简直是荒谬！<br>It’s odd that you and I should have the same name.<br>很奇怪，我们的名字竟然相同。<br>Why should anyone bother to risk losing his treasure to help a stranger?<br>为什么竟然会有人冒着失去自己财产的危险而去帮助一个陌生人呢？</p>
<h3 id="should表示“万一”"><a href="#should表示“万一”" class="headerlink" title="should表示“万一”"></a>should表示“万一”</h3><p>should常常用在lest，for fear that和in case引导的从句中，表示“万一”。比如：<br>I’ve brought my umbrella in case it should rain. 我带伞了，以防万一下雨。</p>
<h2 id="基本用法（十）：shall的特殊用法"><a href="#基本用法（十）：shall的特殊用法" class="headerlink" title="基本用法（十）：shall的特殊用法"></a>基本用法（十）：shall的特殊用法</h2><h3 id="用于第一人称的疑问句中：Shall-I-x2F-we…"><a href="#用于第一人称的疑问句中：Shall-I-x2F-we…" class="headerlink" title="用于第一人称的疑问句中：Shall I&#x2F;we…?"></a>用于第一人称的疑问句中：Shall I&#x2F;we…?</h3><p>当shall用于第一人称时，此时的shall可以表示主动提供帮助、提供建议或请求给予指示。</p>
<h4 id="主动提供帮助"><a href="#主动提供帮助" class="headerlink" title="主动提供帮助"></a>主动提供帮助</h4><p>此时的Shall I…?相当于Would you like me to do sth.?<br>Shall I open the window?<br>相当于“Would you like me to open the window? 你要不要我把窗户打开？”。</p>
<h4 id="主动提供建议"><a href="#主动提供建议" class="headerlink" title="主动提供建议"></a>主动提供建议</h4><p>Shall we meet at the theater? 我们在剧院见面好吗？<br>&#x3D; Let’s meet at the theater, shall we? 我们在剧院见面吧，好吗？</p>
<h4 id="表示请求给予指示"><a href="#表示请求给予指示" class="headerlink" title="表示请求给予指示"></a>表示请求给予指示</h4><p>How shall I cook it? 这东西该怎么做着吃？<br>Where shall we put this? 我们该把这东西放在哪里？</p>
<h3 id="用于第三人称的疑问句中"><a href="#用于第三人称的疑问句中" class="headerlink" title="用于第三人称的疑问句中"></a>用于第三人称的疑问句中</h3><p>在表示提供建议或请求给予指示的意思时，shall可以用于第三人称。比如：<br>A man wants to see you, sir. Shall he wait outside?<br>相当于“Would you like him to wait outside? 你要不要让他在外面等呢？”。<br>Shall he come with us?<br>相当于“Would you like him to come with us?（你）要不要让他和我们一起去呢？”。</p>
<h3 id="用于第二、三人称的陈述句中"><a href="#用于第二、三人称的陈述句中" class="headerlink" title="用于第二、三人称的陈述句中"></a>用于第二、三人称的陈述句中</h3><h4 id="表示“命令”"><a href="#表示“命令”" class="headerlink" title="表示“命令”"></a>表示“命令”</h4><p><em><strong>在法律条文、规章制度中，常用shall表示“命令”，这主要用于第三人称。此时，shall在意思上接近must。</strong></em><br>The license of a person who is arrested for driving while intoxicated shall be suspended.<br>因醉酒驾车而被捕的司机，其驾照应该被吊销。<br>The Permit Holder shall comply with all conditions of this Permit.<br>许可证持有人必须完全遵守本许可证的全部条件。<br>这样使用的shall很正式，若是在不是很正式的场合，可以用must或are to do来代替shall。</p>
<h4 id="表示说话人的许诺"><a href="#表示说话人的许诺" class="headerlink" title="表示说话人的许诺"></a>表示说话人的许诺</h4><p><em><strong>shall用于第二、三人称的陈述句中，表示说话人的许诺。</strong></em><br>You shall have the money back next week.<br>相当于“I promise you will have the money back next week.<br>（我答应）你下周一定能拿回这钱。”。<br>The boss has promised that every employee shall have a rise in income.<br>老板已经答应给每一位员工涨工资。</p>
<h4 id="表示说话人强烈的意愿，甚至威胁"><a href="#表示说话人强烈的意愿，甚至威胁" class="headerlink" title="表示说话人强烈的意愿，甚至威胁"></a>表示说话人强烈的意愿，甚至威胁</h4><p><em><strong>shall用于第二、三人称的陈述句中，表示说话人强烈的意愿，甚至威胁。</strong></em><br>He shall be punished if he disobeys. 若他不服从，定将受到处罚。<br>You shall do exactly as I say. 你一定得按我说的去做。<br>You shall pay for this. 你一定得为此付出代价！</p>
<h2 id="基本用法（十一）：may的特殊用法"><a href="#基本用法（十一）：may的特殊用法" class="headerlink" title="基本用法（十一）：may的特殊用法"></a>基本用法（十一）：may的特殊用法</h2><p>may的含义主要有：“可能”“许可”和“请求”，may还有一种特殊的用法，即用在may…but这样的结构中，表示让步。<br>We may have our differences from time to time, but basically we trust one another’s judgment.<br>尽管我们常常有分歧，但是我们基本上还是信任彼此的判断。<br>这里的may几乎已失去了“可能”的含义，而是表示被认为是真实的陈述，所以上句应改写为：<br>We admit that we have our differences, but basically we trust one another’s judgment.<br>或者：Although we have our differences, basically we trust one another’s judgment.<br>而不是改写成“It is possible that we have our differences, but basically we trust one another’s judgement.*”。<br>人们之所以习惯用may have这一情态动词结构，而不是用一般现在时have，主要是出于礼貌或委婉表达的考虑。<br>You may be in charge, but it doesn’t give you the right to be rude.<br>&#x3D;Although you are in charge, it doesn’t give you the right to be rude.<br>尽管是你负责，但这并不说明你就有权对别人粗鲁。<br>基于may可以表示让步，因此它常常用于各种结构的让步状语从句中。比如：<br>But however amazed our descendants may be at how far from Utopia we were, they will look just like us.<br>但是不管我们的后代对我们离乌托邦之遥远感到多么吃惊，他们的长相将和我们一样。<br>这个句子本来的结构是“Our descendants may be amazed at how far from Utopia we were, they will look just like us.”。现在因为有了连词however，所以amazed和however一同提到了句首。这里however引导一个让步状语从句，从句的谓语含有may。</p>
<h2 id="情态动词的否定"><a href="#情态动词的否定" class="headerlink" title="情态动词的否定"></a>情态动词的否定</h2><h3 id="情态动词否定意义的深层结构——内部否定和外部否定"><a href="#情态动词否定意义的深层结构——内部否定和外部否定" class="headerlink" title="情态动词否定意义的深层结构——内部否定和外部否定"></a>情态动词否定意义的深层结构——内部否定和外部否定</h3><p>A: The restaurant is always empty.这家餐馆总是很空。<br>B1: It can’t be good.这家餐馆不可能好。<br>B2: It may not be good.这家餐馆可能不好。<br>对于“cannot谓语动词”的结构，真正的否定意义的结构是“否定情态动词谓语动词”，即“NOTCANVERB（不可能）”；而对于“may not谓语动词”的结构，真正的否定意义结构是“情态动词否定谓语动词”，即“MAYNOTVERB（可能不）”。</p>
<blockquote>
<p>以否定词NOT的位置为标准，否定词NOT在外部的“NOTMODALVERB”称为外部否定；否定词NOT在中间的“MODALNOTVERB”称为内部否定。</p>
</blockquote>
<p>尽管在表层结构上，否定词not都是跟在情态动词的后面，但在深层结构上是不同的。因此，对于某些句子来说，就可能会在外部否定与内部否定这两种结构上产生歧义。比如：<br>Paul won’t come.<br>如果把该句理解成外部否定，即“Paul NOT will come.”。<br>这里被否定的是情态动词will，即“NOTwill”，这就表示“保罗不愿意来”。<br>如果把该句理解成内部否定，即“Paul will NOT come.”。<br>这里被否定的是谓语动词come，即“NOTcome”，这就表示“保罗来不了”。<br>外部否定：保罗不愿意来。<br>内部否定：保罗不会来。<br>所以Paul won’t come. 这句话就产生了歧义，比如把该句放在下面两个不同的语境中：<br>1） Paul won’t come because he doesn’t want to.保罗不愿意来，因为他就是不想来。<br>2） Paul won’t come because he’s too busy.保罗不会来，因为他太忙。<br>在陈述句中，不论是外部否定还是内部否定，not总是要紧跟在情态动词后面。但是，若在疑问句中，就能看出外部否定和内部否定在句子结构上的差别。<br>1） Could you not come?<br>2） Couldn’t you come?<br>从句子的结构上来看，例句1）采用的是内部否定，在变成疑问句时，只能把情态动词could提前，而把否定词not留在被否定的谓语动词come之前，这就露出了该句的“庐山真面目”。但例句2）采用的是外部否定，在变成疑问句时，要把否定词与被否定的情态动词一起提至句首。<br>所以，例句1）否定的是谓语动词，意思是“能不来”；例句2）否定的是情态动词，意思是“不能来”。<br>1） 你能不来吗？（不希望你来）<br>2） 你不能来吗？（非常希望你能来）</p>
<p>1） Could we not go together?<br>2） Couldn’t we go together?<br>1） 我们能不走在一起吗？<br>2） 我们难道就不能走在一起吗？</p>
<blockquote>
<p>如果否定词not没有与情态动词的缩写形式一起被提至句首，而是直接置于谓语动词之前，这时被否定的就是谓语动词，即“某事不应该做”；而当否定词与情态动词的缩写形式放在一起时，被否定的就是情态动词，是用来加强“请求”的情态含义，强调“某事应该做”。</p>
</blockquote>
<p>1） Could you not tell him? 你能不告诉他吗？（不希望你告诉他）<br>2） Couldn’t you tell him? 你难道就不能告诉他吗？（非常希望你告诉他）</p>
<h3 id="内部否定和外部否定的使用规律"><a href="#内部否定和外部否定的使用规律" class="headerlink" title="内部否定和外部否定的使用规律"></a>内部否定和外部否定的使用规律</h3><ul>
<li>推测用法的情态动词，一般是内部否定，即否定的是谓语动作；</li>
<li>基本用法的情态动词，一般是外部否定，即否定的是情态意义。</li>
</ul>
<p>1） You can leave now, but he may not leave.<br>2） Tom will come, but John may not come.<br>在例句1）中，may表示“许可（permission）”，是基本用法，所以may not是外部否定，译成“不可以”。<br>在例句2）中，may表示“可能（possibility）”，是推测用法，所以may not是内部否定，译成“可能不”。<br>1） 你现在可以走了，但他不可以走。<br>2） 汤姆会来，但约翰可能不来了。<br>It shouldn’t last long.<br>这里should表示推测，所以shouldn’t是内部否定。<br>应该不会太久的。<br>He won’t help us.<br>这里will表示“意愿”，属于基本用法，所以won’t是外部否定。<br>他不愿意帮我们。<br>You can’t be serious.<br>这里can表示推测，属于推测用法。但这里can’t是外部否定“不可能”，而不是内部否定“可能不”。但按照上面的规律——表示推测用法，应该是内部否定。由此可见，此时can不适用于上述规则。<br>你不可能是当真的吧。<br>同样，对于must，上述规则也不适用。因为must用于推测用法时，本身没有否定，即不能说mustn’t。当must用于基本含义表示“必须”时，其否定形式mustn’t的意思是“千万别做某事”，这里否定的是谓语动作，即一个内部否定，而不是上面规则说的外部否定，即含义为“不必”。must的外部否定“不必”应说成don’t have to。</p>
<p>最后，还有这样特殊的否定句：<br>Rachel: (to Ross) I can’t believe you don’t want to know. I mean, I couldn’t not know, I mean, if, if the doctor knows, and Carol knows, and Susan knows…<br>这里的couldn’t not是一个双重否定，很像汉语里说的“不能不”。这种否定比较罕见。<br>蕾切尔：（对罗斯说）我真不敢相信，你都不想知道。我的意思是说，就是说，既然医生知道了，卡萝尔也知道了，苏珊也知道了，我就不能不知道。</p>
<h2 id="总结：英文情态与中文情态的简单对比"><a href="#总结：英文情态与中文情态的简单对比" class="headerlink" title="总结：英文情态与中文情态的简单对比"></a>总结：英文情态与中文情态的简单对比</h2><h3 id="英文情态动词的委婉表达在汉语中的缺失"><a href="#英文情态动词的委婉表达在汉语中的缺失" class="headerlink" title="英文情态动词的委婉表达在汉语中的缺失"></a>英文情态动词的委婉表达在汉语中的缺失</h3><p>比如汉语里常这样说：<br>1） 请看一下这篇文章。<br>2） 我们希望你明天能过来和我们一起吃午饭。<br>3） 请你过来坐在这儿。<br>4） 我建议你去和他说一下。<br>如果直接生硬地译成英语，则显得并不十分礼貌：<br>Please read this article.<br>We hope that you will come and have lunch with us tomorrow.<br>You come and sit here, please.<br>I suggest that you have a word with him<br>下列表达会显得更自然而礼貌：<br>You may like to read this article.<br>We were wondering whether you could come and have lunch with us tomorrow.<br>Would you come and sit here, please?<br>You might want to have a word with him.<br>上面这些句子还有其他更多礼貌的表达形式，这时都得使用情态动词。比如，对于最后一句的“提建议”，还可以这样说：<br>I would suggest that you have a word with him.<br>May I suggest that you have a word with him</p>
<p>1） That’s impossible.<br>2） Unfortunately that wouldn’t be possible.<br>在例句1）中，谓语动词用的是is，显得说话的语气非常直白和生硬，容不得对方商量。这自然就会让对方难以接受。在例句2）中，首先是借助would来“软化”生硬的口气。其次，把impossible换成not possible，让人认为有商量的余地。再次，因为是在拒绝对方，所以用副词unfortunately来表达遗憾，给对方以安慰。做了以上三个方面的处理后，语气显得更加委婉、礼貌。<br>1） 这是不可能的。<br>2） 很遗憾，这恐怕不太可能。</p>
<p>1） We need a commitment from you now.<br>2） We would like some kind of commitment from you now.<br>在例句1）中，用need比较直截了当地提出自己的要求。在例句2）中，用would来委婉地说出自己的需要。其次，增添了some kind来缓和语气。<br>1） 我们现在就需要你的承诺。<br>2） 现在我们想知道你能不能给我们一些承诺。</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之完成进行时（将来完成进行时）</title>
    <url>/2020/07/26/English%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AE%8C%E6%88%90%E8%BF%9B%E8%A1%8C%E6%97%B6-%E5%B0%86%E6%9D%A5%E5%AE%8C%E6%88%90%E8%BF%9B%E8%A1%8C%E6%97%B6/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记摘选自张满胜老师的《英语语法新思维中级教程通悟语法第2版》，以及其他网上知识点收集，只是我自己的个人复习笔记，禁止转载，如有侵权，请联系我删除。</p>
</blockquote>
<p>将来完成进行时的用法与现在完成进行时基本相同，只是将“坐标时间”移到了将来。同样是强调动作的持续性，表示开始于将来某个时刻之前的动作持续到将来这一时刻，并可能继续持续下去。从时间的角度来看，将来完成进行时需要在上下文中有将来的时间坐标，这类似于过去完成进行时的过去的时间坐标。通常用“by+将来时间”或者是“by the time+从句（从句谓语用一般现在时）”来给出一个将来的时间坐标。<br>My brother has promised to help me study for my exam tomorrow. I get home from school at 3:00 and he gets home from school at 5:00. I will have been studying for two hours by the time he gets home.<br>这里是“by the time+从句”结构给出的将来的时间坐标，从句的谓语gets是一般现在时态，但表示将来的动作。然后在这个将来时间的基础上谈论之前的一个延续事件——一直在学习（到5:00时，studying的活动仍将持续），此时就要用将来完成进行时will have been studying这一较为复杂的动词形式。<br>图示如下：<br><img src="https://cdn.jsdelivr.net/gh/coding-by-feng/oss@master/uPic/9tcgtR.png"></p>
<h2 id="长期延续的事件："><a href="#长期延续的事件：" class="headerlink" title="长期延续的事件："></a>长期延续的事件：</h2><p>I’m retiring this fall. By then I’ll have been teaching for 30 years.<br>我将于今年秋天退休，到那时，我教书就有30年了。<br>She will have been taking care of her blind husband for 20 years by then.<br>到那时，她照顾她双目失明的丈夫就将有20年了。</p>
<h2 id="说话时刻在延续的事件"><a href="#说话时刻在延续的事件" class="headerlink" title="说话时刻在延续的事件"></a>说话时刻在延续的事件</h2><p>The old man will have been getting up at 4:00 for ten years by next month.<br>到下个月，这老头坚持凌晨4:00起床就将长达10年时间了。<br>By tomorrow I will have been doing morning exercises for 100 days.<br>到明天，我坚持做早操就将有100天了。</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之自然拼读</title>
    <url>/2020/07/22/English%E7%B3%BB%E5%88%97%E4%B9%8B%E8%87%AA%E7%84%B6%E6%8B%BC%E8%AF%BB/</url>
    <content><![CDATA[<h2 id="单词结尾的s什么时候读-“s”-与-“z”"><a href="#单词结尾的s什么时候读-“s”-与-“z”" class="headerlink" title="单词结尾的s什么时候读 “s” 与 “z”"></a>单词结尾的s什么时候读 “s” 与 “z”</h2><ul>
<li>做动词时结尾读”z”</li>
<li>做形容词、副词、名词时结尾读”s”</li>
</ul>
<p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/aXaxF4.png"><br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/kwz7k7.png"><br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/G9b1HK.png"><br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/s6UeVk.png"><br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/qJ0Dzb.png"><br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/odIBhw.png"><br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/q8mAhm.png"></p>
<blockquote>
<p>参考来源<a href="https://www.zhihu.com/zvideo/1268214408456630272">知乎</a></p>
</blockquote>
<h1 id="字母组合发音"><a href="#字母组合发音" class="headerlink" title="字母组合发音"></a>字母组合发音</h1><h2 id="ar"><a href="#ar" class="headerlink" title="ar"></a>ar</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/ɑː/</span><br></pre></td></tr></table></figure>
<p>garbage</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之一般过去时</title>
    <url>/2020/08/28/English%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%80%E8%88%AC%E8%BF%87%E5%8E%BB%E6%97%B6/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记摘选自张满胜老师的《英语语法新思维初级教程第2版》，以及其他网上知识点收集，只是我自己的个人复习笔记，禁止转载，如有侵权，请联系我删除。</p>
</blockquote>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>据说，在美国的新闻报道中，最精练简明的导语出现在1906年4月的旧金山大地震之时，这个导语是：<br>San Francisco Was<br>这里除了地名San Francisco外，就只有唯一的一个关键词was，通过was表明了这次地震对旧金山所造成的破坏程度——已将其夷为平地，该城市不复存在了。因此，这个导语不妨译成：<br>旧金山已成为过去</p>
<h2 id="基本用法一：过去发生的短暂动作或状态"><a href="#基本用法一：过去发生的短暂动作或状态" class="headerlink" title="基本用法一：过去发生的短暂动作或状态"></a>基本用法一：过去发生的短暂动作或状态</h2><p>一般过去时常表示在过去某一个特定的时间所发生的动作或存在的状态，此时常和表示过去的特定的时间状语连用。这些时间状语有：yesterday, yesterday evening, last night, the night before last（前天晚上）, last year, last spring（去年春天）以及three days&#x2F;months&#x2F;years ago等等。注意，这些时间状语之前不需加介词，比如不能说：at last night*, in last year<em>或in three years ago</em>等等。<br>I saw him in the library yesterday morning. 我昨天早上在图书馆看到他了。<br>I bought this computer three years ago. 我3年以前买的这台电脑。<br>是表示过去存在的状态：<br>He was late for school this morning. 他今天早上上学迟到了。<br>I was tired last night, so I went to bed early. 我昨晚感到很累，所以早早地上床睡觉了。<br>图示：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/jCl8Ia.png"></p>
<p>I didn’t choose this life; it chose me.<br>这是巴基斯坦反对派领袖、前总理贝·布托（Bhutto）在其回忆录中的一句话。这里虽然没有明确的过去的时间状语，但根据语境判断，是表示过去发生的事件，所以用了一般过去时态。<br>我没有选择这种命运，而是命运选择了我。</p>
<h2 id="基本用法二：过去发生的重复或延续活动"><a href="#基本用法二：过去发生的重复或延续活动" class="headerlink" title="基本用法二：过去发生的重复或延续活动"></a>基本用法二：过去发生的重复或延续活动</h2><p>除了表示短暂动作之外，一般过去时还可以表示过去的一段时间（a specific period of time in the past）内延续或重复的动作，图示为：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/AWxXqn.png"><br>I slept for eight hours last night. 我昨晚睡了8个小时。<br>She lived in our town for three years, but now she is living in Beijing.<br>她在我们这个小镇生活了3年，不过她现在住在北京。<br>I lived in the country for ten years. 我在农村生活了10年。</p>
<p>表示过去重复发生的活动：<br>I wrote a letter once a week to my family when I was in my first college year.<br>这里的wrote是表示过去一段期间内不断重复发生的活动。<br>在大一的时候，我通常每个星期给家里写一封信。<br>He used to do morning exercises. 他过去常常晨练。<br>用表格简单地总结如下：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/OQuczd.png"></p>
<h2 id="用法比较：一般过去时和现在完成时用于“for-时间段”的区别"><a href="#用法比较：一般过去时和现在完成时用于“for-时间段”的区别" class="headerlink" title="用法比较：一般过去时和现在完成时用于“for+时间段”的区别"></a>用法比较：一般过去时和现在完成时用于“for+时间段”的区别</h2><p>一般过去时态可以与“for+时间段”连用。比如：<br>I slept for eight hours last night. 我昨晚睡了八个小时。<br>He worked in that dot-com company for one year. Now he is studying in America.<br>他在那家网络公司工作过一年，现在在美国上学。</p>
<p>一般过去时表示的延续动作图示如下：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/0oBmFa.png"><br>现在完成时表示的延续动作图示如下：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/ldiQ3p.png"></p>
<blockquote>
<p>一般过去时与“for+时间段”连用，表示动作在过去已经结束，并没有延续到现在；而现在完成时与“for+时间段”连用，则表明动作延续到现在，并且还有可能延续下去。</p>
</blockquote>
<p>1） She lived in our town for three years.<br>2） She has lived in our town for three years.<br>1） 她在我们小镇生活过三年（但现在不在这里）。<br>2） 她在我们小镇已经生活了三年（现在还在这里）。</p>
<p>表示事件延续到了现在，因此可以在时间状语for three years的后面填上一个now，但对于例句1）则不可以。比如：<br>1） She lived in our town for three years now. *<br>2） She has lived in our town for three years now.</p>
<h2 id="口语用法一：“我不知道”——“I-don’t-know”-or-“I-didn’t-know”"><a href="#口语用法一：“我不知道”——“I-don’t-know”-or-“I-didn’t-know”" class="headerlink" title="口语用法一：“我不知道”——“I don’t know” or “I didn’t know”?"></a>口语用法一：“我不知道”——“I don’t know” or “I didn’t know”?</h2><p>A: Do you see the person with loose pants and long hair? Is it a boy or girl?<br>B: A girl. She is my daughter.<br>A: Oh, please forgive me. I didn’t know you were her mother.<br>B: No, I’m her father.<br>A: 你看见那边那个穿着宽松裤子、留着长发的人了吗？是男的还是女的？<br>B: 是女的。她是我女儿。<br>A: 哦，真对不起，我不知道你是她母亲。<br>B: 不，我是她父亲。</p>
<p>A说“我不知道”的时候其实他已经知道了，因为B已经告诉他“She is my daughter.”了，也就是说，他的真正意思应该是“我刚才不知道”，因此正确的英文应该说成：<br>I didn’t know you were her mother.</p>
<p>下面的短文是讲作者在一次不得已的情况下让一位陌生的邻居格林夫人（Mrs. Green）开车送自己去学校，后来当她知道格林夫人竟是一位癌症患者时，她的内心对此深感不安：<br>Mrs. Green, the woman with cancer. I stood on the stairs, my hand covering my mouth: I had asked a person struggling with cancer to go out in a snowstorm to give me a lift to school. “Oh, Mrs. Green,” I stammered, “I didn’t realize who you were. Please forgive me.”<br>作者在事先不知情的情况下给一位癌症患者带来麻烦，因而感到内疚。但她现在知道真相了。<br>格林夫人——竟是那位患了癌症的女人！我站在楼梯上，手掩着嘴一时说不出话来：我竟然让一个身患癌症的病人冒着暴风雪开车送我去学校！“噢，格林夫人，”我结结巴巴地说道，“我真不知道您就是格林夫人。请原谅我！”</p>
<h2 id="口语用法二：“我忘记了”——“I-forget”-or-“I-forgot”？"><a href="#口语用法二：“我忘记了”——“I-forget”-or-“I-forgot”？" class="headerlink" title="口语用法二：“我忘记了”——“I forget” or “I forgot”？"></a>口语用法二：“我忘记了”——“I forget” or “I forgot”？</h2><p>“我忘记了这个单词的意思”和“我忘记把你的耳机带来”，这两个“忘记”在汉语中丝毫没有区别，但在英文中却是大不相同，即它们发生的时间不一样。“我忘记了这个单词的意思”是“我”现在还不知道；而“我忘记把你的耳机带来”是当“我”想起来之后说的一句话，“忘记”已成为过去。因此，这两句英文要分别说成：<br>I forget the meaning of the word.<br>I forgot to bring your earphone back.</p>
<p>A: I am sorry I forgot to return your physics book last night.<br>B: I’ll forgive you considering the test isn’t until Friday.<br>A：很抱歉，昨晚我忘了还你的那本物理书。<br>B：没关系，因为周五才考试呢。</p>
<p>在汉语中说“我忘记做某事”，英文一般都是说成I forgot to do…，因为这一定是当你想起来之后才能说的一句话，“忘记”已成为过去。<br><em><strong>英文中一般没有使用I forget to do…的语境。</strong></em></p>
<blockquote>
<p>“我忘记”还可以说成It slipped my mind…。</p>
</blockquote>
<p>A: Did you pick up my books from Ron’s house?<br>B: Sorry. It slipped my mind.</p>
<p>A：你是否从罗恩家把我的书捎过来了？<br>B：对不起，我忘记了。</p>
<h2 id="口语用法三：“我以为”——“I-think”-or-“I-thought”？"><a href="#口语用法三：“我以为”——“I-think”-or-“I-thought”？" class="headerlink" title="口语用法三：“我以为”——“I think” or “I thought”？"></a>口语用法三：“我以为”——“I think” or “I thought”？</h2><p>A: I really thought that I’d win the match.<br>B: Oh, well, better luck next time, Henry.<br>A：我（本来）真的以为这个比赛我会赢的。<br>B：哦，没关系，希望你下次好运，亨利。<br>若说成： I really think that I will win the match.（我真的很肯定我会赢得这场比赛。）<br>这就一定是在比赛之前说的话，表明自己很有信心赢得这场比赛。所以，简单来说，I thought是强调“我刚才这么想”，而现实情况往往不同（如上句的I really thought that I’d win the match，即“我本来以为我会赢”，但实际没有赢）。而I think则相当于I have an opinion（我这么认为），表示自己的观点。因此，两者的意思可谓是大相径庭。</p>
<p>再比如目前大学毕业生找工作很难，我们可以说出这样的一句话：<br>开始我以为找工作很容易，但现实情况比我想的还要难。<br>这句话可以这样讲：<br>At first I thought it would be easy to find a job, but the real situation has proved more difficult than I thought.</p>
<blockquote>
<p>当我们要说“我本来还以为……”时，在英文中就要说成I thought…。</p>
</blockquote>
<h2 id="口语用法四：根据上下文的语境灵活地使用一般过去时"><a href="#口语用法四：根据上下文的语境灵活地使用一般过去时" class="headerlink" title="口语用法四：根据上下文的语境灵活地使用一般过去时"></a>口语用法四：根据上下文的语境灵活地使用一般过去时</h2><p>在英语里，当两人见面刚认识，都会说“认识你很高兴”，用英语说成：<br>It is nice to meet you.<br>这里用的是一般现在时is。但是，在两人聊天结束后，在分手告别时还不会忘记说上一句“认识你很高兴”，这时英语就要用过去时态了：<br>It was nice meeting you.<br>或者说“和你聊天很开心”：<br>It was nice talking to you.<br>上面两句告别用语可以分别简化成“Nice meeting you.”和“Nice talking to you.”。</p>
<blockquote>
<p>告别时说“认识”用的是动名词meeting，而不是不定式to meet。</p>
</blockquote>
<p>A: Excuse me. I believe I ______（be） here first. Do you mind waiting your turn?<br>B: Oh, sure. Sorry.<br>A: That’s OK.<br>根据语境，空格中我们应该用过去时这么说“I believe I was here first.”。<br>A：对不起，我想我比你先来这里的。你能排队等候吗？<br>B：哦，对不起。<br>A：没事。</p>
<h2 id="口语用法五：礼貌表达"><a href="#口语用法五：礼貌表达" class="headerlink" title="口语用法五：礼貌表达"></a>口语用法五：礼貌表达</h2><p>在口语中，一般过去时（也可用过去进行时）可以表示语气委婉，此时的过去时丝毫没有过去的意味，而谈的是现在的情况。<br>I wondered if you could help me. 我想知道你能否帮我。<br>Could you give me a hand? 你能帮我一下吗？<br>I was wondering if you could possibly lend me your car for this evening. 我想知道你今晚能否把车借给我用用。</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构系列之哈希表（Java）</title>
    <url>/2020/09/02/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E4%B9%8B%E5%93%88%E5%B8%8C%E8%A1%A8-Java/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode-cn.com/tag/hash-table/">Leetcode哈希表专题</a></p>
</blockquote>
<h2 id="哈希表（散列表）"><a href="#哈希表（散列表）" class="headerlink" title="哈希表（散列表）"></a>哈希表（散列表）</h2><p>散列表（Hash table，也叫哈希表），是根据键（Key）而直接访问在内存储存位置的数据结构。也就是说，它通过计算一个关于键值的函数，将所需查询的数据映射到表中一个位置来访问记录，这加快了查找速度。这个映射函数称做散列函数，存放记录的数组称做散列表。</p>
<h3 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h3><p>线程安全的<code>java.util.Hashtable</code>的散列函数是基于<code>除留余数法</code>的方式来计算，其计算代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Entry&lt;?,?&gt; tab[] = table; // 表存储是采用数组来实现的</span><br><span class="line">int hash = key.hashCode();</span><br><span class="line">int index = (hash &amp; 0x7FFFFFFF) % tab.length;</span><br></pre></td></tr></table></figure>
<p><em><strong>如果单单只是通过取模来计算映射地址的话，可能会出现<code>冲突</code>问题。</strong></em></p>
<h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>散列函数可能会把不同的Key值映射到同一个数组下标。</p>
<h3 id="散列函数的要求"><a href="#散列函数的要求" class="headerlink" title="散列函数的要求"></a>散列函数的要求</h3><ul>
<li>散列函数的定义域必须包含全部需要存储的Key值，而Value值的范围则依赖于散列表的大小或地址范围。</li>
<li>散列函数计算出来的地址应该能等概率、均匀分布在整个地址空间中，从而减少冲突的发生。</li>
<li>散列函数应尽量简单，能够在较短时间内计算出任一关键字对应的散列地址。</li>
</ul>
<h3 id="散列表的构造方法"><a href="#散列表的构造方法" class="headerlink" title="散列表的构造方法"></a>散列表的构造方法</h3><h4 id="直接定址法"><a href="#直接定址法" class="headerlink" title="直接定址法"></a>直接定址法</h4><p>取关键字或关键字的某个线性函数值为散列地址。<br>其线性函数可以表示为：<code>Hash(k)=a*k+b（a、b均为常数）</code>。</p>
<blockquote>
<p>直接定址法的弊端是，若Key值分布不均衡，Hash(k)计算出来的值也不均衡，会造成空间浪费。</p>
</blockquote>
<h4 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h4><p>取Key（Java里面是计算Key的hashCode）被某个不大于散列表（HashTable是取其内部table的长度）表长的数p除后所得的余数为散列地址，也就是基于取模运算。<br>其散列函数公式表示为：<code>Hash(k)=k%p</code>。</p>
<blockquote>
<p>p值最好是取最接近或等于表长的质数，这样可以减少冲突（<code>java.util.Hashtable</code>内部直接使用表长作为p值了）。</p>
</blockquote>
<h4 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h4><p>假设Key是以r为基的数，并且哈希表中可能出现的Key都是事先知道的，则可取Key的若干数位组成哈希地址。<br>好比如以下的一组二进制数：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/CP99ZS.png"><br>则可只取后面的几位作为散列地址的计算依据或者结果。</p>
<blockquote>
<p>只适合Key是已知的集合。</p>
</blockquote>
<h4 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h4><h4 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h4><blockquote>
<p>参考来源：<a href="https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8">哈希表-维基百科</a>、<a href="https://www.bilibili.com/video/BV1b7411N798?p=68">王道考研</a></p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>哈希表</tag>
        <tag>散列表</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构系列之栈（Java）</title>
    <url>/2020/09/04/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E4%B9%8B%E6%A0%88-Java/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode-cn.com/tag/stack/">leetcode栈专题</a></p>
</blockquote>
<h2 id="顺序栈的定义"><a href="#顺序栈的定义" class="headerlink" title="顺序栈的定义"></a>顺序栈的定义</h2><p>顺序栈栈和线性表很类似，可以认为栈是一种特殊的线性表，只是插入和删除只能允许在其一端进行，把允许操作的一端称为栈顶（Top），不可操作的一端称为栈底（Bottom），同时把插入元素的操作称为入栈(Push),删除元素的操作称为出栈(Pop)。若栈中没有任何元素，则称为空栈。</p>
<p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/iSJO68.png"></p>
<p>栈插入的元素将第一个被删除，栈也称为后进先出(Last In First Out,LIFO)或先进后出(First In Last Out FILO)的线性表。</p>
<h2 id="栈的操作"><a href="#栈的操作" class="headerlink" title="栈的操作"></a>栈的操作</h2><ul>
<li>peek（未删除只获取值）</li>
<li>push（入栈，更新栈顶Top指向）</li>
<li>Pop（出栈，删除并获取值，更新栈顶Top指向）</li>
</ul>
<h2 id="链式栈"><a href="#链式栈" class="headerlink" title="链式栈"></a>链式栈</h2><h3 id="空栈"><a href="#空栈" class="headerlink" title="空栈"></a>空栈</h3><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/GGkvFd.png"></p>
<h3 id="非空栈"><a href="#非空栈" class="headerlink" title="非空栈"></a>非空栈</h3><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/ghOgbZ.png"></p>
<h3 id="栈顶插入"><a href="#栈顶插入" class="headerlink" title="栈顶插入"></a>栈顶插入</h3><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/vzjf3l.png"></p>
<h3 id="栈顶删除"><a href="#栈顶删除" class="headerlink" title="栈顶删除"></a>栈顶删除</h3><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/lWtLTv.png"></p>
<blockquote>
<p>链式栈插入和删除依然只能在栈顶操作。</p>
</blockquote>
<h2 id="栈的应用"><a href="#栈的应用" class="headerlink" title="栈的应用"></a>栈的应用</h2><ul>
<li>符号匹配</li>
<li>HTML和XML文件中的标签匹配</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之名词从句</title>
    <url>/2020/09/05/English%E7%B3%BB%E5%88%97%E4%B9%8B%E5%90%8D%E8%AF%8D%E4%BB%8E%E5%8F%A5/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记摘选自张满胜老师的《英语语法新思维中级教程第2版》，以及其他网上知识点收集，只是我自己的个人复习笔记，禁止转载，如有侵权，请联系我删除。</p>
</blockquote>
<h2 id="简单句与名词从句"><a href="#简单句与名词从句" class="headerlink" title="简单句与名词从句"></a>简单句与名词从句</h2><h3 id="何谓名词从句？"><a href="#何谓名词从句？" class="headerlink" title="何谓名词从句？"></a>何谓名词从句？</h3><p>在英语中，名词或名词短语主要充当四种句子成分：主语、宾语、表语和同位语，如果把句子当作名词来用，分别充当另一句话的主语、宾语、表语或同位语。<br>构成了四种从句：主语从句、宾语从句、表语从句和同位语从句，因为这四种从句在本质上相当于名词，所以将其统称为名词从句。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/js3epz.png"></p>
<blockquote>
<p>相当于名词的句子有三类：陈述句、一般疑问句以及特殊疑问句。</p>
</blockquote>
<h3 id="陈述句作句子成分"><a href="#陈述句作句子成分" class="headerlink" title="陈述句作句子成分"></a>陈述句作句子成分</h3><h4 id="要在陈述句句首加上that"><a href="#要在陈述句句首加上that" class="headerlink" title="要在陈述句句首加上that"></a>要在陈述句句首加上that</h4><p>当把一个完整的陈述句当作名词来使用时，需要在陈述句句首加that，然后可使“that+陈述句”这一结构分别充当另一个句子的主语、宾语、表语或同位语等四种成分，即构成主语从句、宾语从句、表语从句或同位语从句。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/1kNWSL.png"></p>
<h4 id="为什么要加that？"><a href="#为什么要加that？" class="headerlink" title="为什么要加that？"></a>为什么要加that？</h4><p>That English is important（主语从句）is an undoubted fact（谓语部分）.<br>假如把that去掉，上句就变成“English is important is an undoubted fact.”。<br>这句话就有两个中心谓语部分，即is important和is an undoubted fact。但是，在英语中，句子的核心意思主要是靠谓语部分来表达的，一个句子只表达一个核心意思（因为我们说话要一句一句地说），也就只能有一个谓语部分。现在这个句子有两个谓语部分，读者就会纳闷：你要表达的意思到底是“某个东西重要（something is important）”，还是要说“某个东西是事实（something is an undoubted fact）”？<br>为了避免混淆，在句首加上一个标志that，这里的that就相当于一个指路牌，它的出现就等于是在告诉读者：that后面紧接着的句子是要作为另一个句子的某一个成分来使用的，不是要表达的核心意思。因此，当读者读到“That English is important…”，他就会知道这个句子的核心意思并没有讲出来，他一定会期待着句子接下来的中心意思。当他读到“…is an undoubted fact”时，他知道了，句子要表达的意思是“英语很重要，这是一个毋庸置疑的事实”，而不是要说“英语很重要”。<br>英语很重要，这是一个毋庸置疑的事实。</p>
<p>1） The criminal confessed his sins harmed many people.<br>2） The criminal confessed that his sins harmed many people.<br>对于例句2），因为有了that的存在，我们能轻而易举地判断出the criminal confessed是主句，而his sins harmed many people是宾语从句，所以我们的大脑就不会做出像例句1）那样的错误断句，因而缩短了理解的时间。<br>这名罪犯承认，他的罪行伤害了很多人。</p>
<p>He said no word at the meeting was strange.<br>对于这个句子，很多读者自然会将其当作宾语从句理解：“He said that no word at the meeting was strange.”。此时句子的意思是：他说，会上人们的发言都很正常，并没有什么奇怪的。<br>但是，如果在句首添加一个that而将其改写为“ That he said no word at the meeting was strange.”。<br>此时则要理解成：他在会上一言不发，这真让人觉得有些蹊跷。</p>
<blockquote>
<p>那么为什么宾语从句中的that可以省去呢？这是因为对于宾语从句，主句的谓语已经出现，谓语后面所接的成分自然是宾语，所以在不影响句子意思的情况下，可以把that省去。</p>
</blockquote>
<p>比如“I think you are right.”或“I think that you are right.”都可以。<br>但是，像上面的例句<code>The criminal confessed that his sins harmed many people.</code>，即使是宾语从句，that也不宜省去。</p>
<h3 id="一般疑问句作句子成分"><a href="#一般疑问句作句子成分" class="headerlink" title="一般疑问句作句子成分"></a>一般疑问句作句子成分</h3><h4 id="用whether或if引导"><a href="#用whether或if引导" class="headerlink" title="用whether或if引导"></a>用whether或if引导</h4><p>当把一个一般疑问句当作名词来使用时，<em><strong>需要先将疑问句的倒装语序变成陈述句语序</strong></em>，并在句首加上whether或if（if只用在宾语从句中）来引导，以保留原句的疑问意义。<br>然后， 用“whether+陈述句”这一结构分别充当另一个句子的主语、宾语、表语或同位语等四种成分，即构成主语从句、宾语从句、表语从句或同位语从句等四种名词从句。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/K3NI0I.png"></p>
<h4 id="if还是whether？"><a href="#if还是whether？" class="headerlink" title="if还是whether？"></a>if还是whether？</h4><p>对于if和whether这两个连词，其用法有以下区别：</p>
<ul>
<li>if一般只用于引导宾语从句，而whether可引导包括宾语从句在内的其他名词从句。<br>If he comes or not makes no difference. *<br>这个句子不妥，应改为“Whether he comes or not makes no difference.”。这里是主语从句，应由whether引导。<br>他来不来无关紧要。<br>The question is if he will come. *<br>这个句子不妥，应改为“The question is whether he will come.”。这里是表语从句，应由whether引导。<br>问题是他是否会来。</li>
<li>if不和or not直接连用，即一般不说if or not，但可以说if…or not。而whether没有此限制。<br>I don’t know if or not he comes. *<br>I don’t know whether or not he comes.<br>例句1）错误，因为if和or not不能直接连用，即不能说 成if or not。例句2）正确。<br>我不知道他是否会来。</li>
</ul>
<h3 id="特殊疑问句作句子成分"><a href="#特殊疑问句作句子成分" class="headerlink" title="特殊疑问句作句子成分"></a>特殊疑问句作句子成分</h3><h4 id="变倒装语序为陈述句语序"><a href="#变倒装语序为陈述句语序" class="headerlink" title="变倒装语序为陈述句语序"></a>变倒装语序为陈述句语序</h4><p>当把一个特殊疑问句当作名词来使用时，<em><strong>需要先将疑问句的倒装语序变成陈述句语序</strong></em>，然后分别充当另一个句子的主语、宾语、表语或同位语等四种成分，即构成主语从句、宾语从句、表语从句或同位语从句等四种名词从句。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/RyjbNf.png"></p>
<h4 id="特殊疑问词作主语，无需调整句子语序"><a href="#特殊疑问词作主语，无需调整句子语序" class="headerlink" title="特殊疑问词作主语，无需调整句子语序"></a>特殊疑问词作主语，无需调整句子语序</h4><p>如果特殊疑问词在句中作主语，则特殊疑问句无需调整语序而直接作成分，因为此时的问句即是一个陈述句语序。<br>1） Who will chair the meeting?<br>2） Who will chair the meeting has not yet been decided.<br>在例句1）中，特殊疑问词who作主语，此时整个问句“Who will chair the meeting?”是一个“主语+谓语”结构的陈述句语序，因此用该问句作成分时，无需调整语序，而直接在例句2）中充当主语，构成一个主语从句。<br>1）谁将会主持这个会议？<br>2）谁将会主持这个会议，目前还没有决定。</p>
<h3 id="引导名词从句的连接词"><a href="#引导名词从句的连接词" class="headerlink" title="引导名词从句的连接词"></a>引导名词从句的连接词</h3><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/JDxvF5.png"></p>
<h2 id="主语从句"><a href="#主语从句" class="headerlink" title="主语从句"></a>主语从句</h2><h3 id="陈述句作主语"><a href="#陈述句作主语" class="headerlink" title="陈述句作主语"></a>陈述句作主语</h3><p>把“that+陈述句”这一结构放在主语的位置即构成主语从句。<br>That the seas are being overfished has been known for years.<br>这里that引导的从句that the seas are being overfished是一个主语从句，直接置于主语的位置。<br>海洋正在被人类过度捕捞，多年以来这已是尽人皆知的。</p>
<p>That English is important is an undoubted fact.英语很重要，这是一个毋庸置疑的事实。<br>That he doesn’t understand English is obvious.很显然，他不懂英语。<br>That the world is round is a fact.地球是圆的，这是一个事实。<br>对于陈述句作主语，更常见的是用it作形式主语置于句首，而将主语从句放在句末。因此上面各句可分别改为：<br>It has been known for years that the seas are being overfished.<br>It is an undoubted fact that English is important.<br>It is obvious that he doesn’t understand English.<br>It is a fact that the world is round.</p>
<p><em><strong>下列都是常见的主语从句句型（重点内容）：</strong></em></p>
<h4 id="It-is-过去分词-that从句"><a href="#It-is-过去分词-that从句" class="headerlink" title="It is+过去分词+that从句"></a>It is+过去分词+that从句</h4><p>It’s reported that…（据报道……）<br>It’s believed that…（人们相信……）<br>It is generally thought that…（人们普遍认为……）<br>It should be noted that…（应当注意……）<br>It has been found that…（现已发现……）<br>It must be pointed out that…（必须指出……）<br>类似动词还有say，expect，know，estimate和forecast等。</p>
<p>As a child and as an adult as well, Bill Gates was untidy. It has been said that in order to counteract this, Mary drew up weekly clothing plans for him.<br>不论是在小时候还是长大成人以后，比尔·盖茨都是不修边幅的。据说为了让他改掉这个习惯，玛丽专门为他制定了一周的着装计划。</p>
<h4 id="It-is-形容词-that从句"><a href="#It-is-形容词-that从句" class="headerlink" title="It is+形容词+that从句"></a>It is+形容词+that从句</h4><p>It is clear that…（显然……）<br>It is possible that…（很可能……）<br>It is likely that…（很可能……）<br>It is natural that…（很自然……）<br>It is certain that…（可以相信……）<br>It is strange that…（奇怪的是……）<br>It is fortunate that…（幸运的是……）<br>It is necessary that…（有必要……）</p>
<p>It is true that English is becoming an international language.<br>的确，英语正日益成为一门国际通用语言。</p>
<h4 id="It-is-名词短语-that从句"><a href="#It-is-名词短语-that从句" class="headerlink" title="It is+名词短语+that从句"></a>It is+名词短语+that从句</h4><p>常用的名词有：a pity，a shame，an honor，a good idea和no wonder等等。<br>It is a pity that…（可惜的是……）<br>It is a fact that…（事实是……）<br>It is good news that…（……真是太好了）<br>It is a good thing that…（……真是件好事）<br>It is no wonder that…（难怪……）<br>It is a shame that…（遗憾的是……；……真是太不像话了）<br>It is an honor that…（真荣幸……）<br>It is common knowledge that…（……是常识）<br>It is my belief that…（我相信……）<br>It is a miracle that…（……真是奇迹）</p>
<p>It is common knowledge that the whale is not a fish. 鲸鱼不是鱼类，这是一个常识。<br>It is a shame that you did not pass the test. 你没通过这次考试，真遗憾。</p>
<h3 id="一般疑问句作主语"><a href="#一般疑问句作主语" class="headerlink" title="一般疑问句作主语"></a>一般疑问句作主语</h3><p>一般疑问句作主语时，要把一般疑问句变成陈述句，并且用whether来引导，然后充当句子的主语，即构成主语从句。<br>Whether he comes or not makes no difference to me. 他来不来对我来说无所谓。</p>
<h3 id="特殊疑问句作主语"><a href="#特殊疑问句作主语" class="headerlink" title="特殊疑问句作主语"></a>特殊疑问句作主语</h3><p>What we need is a wholly new kind of police force.<br>这里的特殊疑问词what是作need的宾语，所以需将原来的倒装句what do we need调整为陈述句语序what we need，然后作主句的主语，即构成主语从句。<br>我们需要的是一个全新的警察机构。</p>
<p>When the meeting is to be held has not yet been decided.<br>这里的特殊疑问词when是作从句的时间状语，所以需将原来的倒装句when is the meeting to be held调整为陈述句语序when the meeting is to be held，然后作主句的主语，即构成主语从句。<br>会议何时举行还没决定。</p>
<p>How a person masters his fate is more important than what his fate is.<br>这里的特殊疑问词how是作从句的方式状语，所以需将原来的倒装句how does a person master his fate调整为陈述句语序how a person masters his fate，然后作主句的主语，即构成主语从句。<br>对于一个人来说，重要的是如何掌握自己的命运，而不是被动地接受命运的安排。</p>
<p>September 11, 2001 started out as an ordinary day, but what happened that morning will be forever etched（铭刻） in our memories.<br>这里的特殊疑问词what是作从句的主语，所以无需调整语序，而直接将疑问句what happened that morning作主句的主语，即构成主语从句。<br>2001年9月11日那天和平日一样到来，但是那天早晨发生的事情将永远铭刻在人们的记忆里。</p>
<h3 id="because引导的主语从句"><a href="#because引导的主语从句" class="headerlink" title="because引导的主语从句"></a>because引导的主语从句</h3><p>这种主语从句的结构一般是“because+陈述句”，置于主语位置，后面直接加谓语，而且这个谓语往往都是does not mean。在because前面往往会有just一词，起强调语气的作用。</p>
<p>There is a big difference between activity and accomplishment. Just because you are doing something doesn’t mean you are getting anywhere. One must evaluate one’s activity in order to have accomplishment.<br>该句的主语是just because you are doing something这个从句，谓语是doesn’t mean。<br>工作与成就这两者之间是有很大差距的，仅仅是不停地工作并不意味着你就取得了成就。因此，人们必须认真审视自己眼下的工作，看是否真的能够取得成就。</p>
<h2 id="宾语从句"><a href="#宾语从句" class="headerlink" title="宾语从句"></a>宾语从句</h2><h3 id="陈述句作宾语"><a href="#陈述句作宾语" class="headerlink" title="陈述句作宾语"></a>陈述句作宾语</h3><p>把“that+陈述句”这一结构放在宾语的位置即构成宾语从句。<br>We know (that) the world is round.<br>我们知道，地球是圆的。</p>
<blockquote>
<p>只有宾语从句中的that才可以省去（在不影响对句意的理解的情况下），而主语从句、表语从句和同位语从句中的that一般不能省去。</p>
</blockquote>
<h4 id="that在宾语从句中省略的问题"><a href="#that在宾语从句中省略的问题" class="headerlink" title="that在宾语从句中省略的问题"></a>that在宾语从句中省略的问题</h4><p>I once read that “the beauty of life is its changes”and that “the art of life lies in a constant readjustment to our surroundings”.<br>句中含有两个that从句，连词that一般不省去。这里两个that从句作read的宾语，即构成并列的宾语从句。<br>我曾经读到过这样一句话：“生活的魅力在于变化，而生活的艺术在于不断地适应周围环境的变化。”</p>
<h3 id="一般疑问句作宾语"><a href="#一般疑问句作宾语" class="headerlink" title="一般疑问句作宾语"></a>一般疑问句作宾语</h3><p>把“whether &#x2F; if+陈述句”这一结构放在宾语的位置即构成宾语从句。<br>I don’t know if&#x2F;whether he needs my help.<br>我不知道他是否需要我的帮助。</p>
<p>No one knew whether or not interest rates would rise.<br>这里原来的一般疑问句是would interest rates rise，变成陈述句语序后成为interest rates would rise，然后为了保留疑问的意义又添加了whether or not，构成宾语从句。一般不说if or not，所以这里的连词不宜用if。</p>
<h3 id="特殊疑问句作宾语"><a href="#特殊疑问句作宾语" class="headerlink" title="特殊疑问句作宾语"></a>特殊疑问句作宾语</h3><p>把特殊疑问句变成陈述句语序后放在宾语的位置即构成宾语从句。<br>I have not decided whom I should vote for.<br>这里的特殊疑问词whom是作vote for的宾语，所以需将原来的倒装句whom should I vote for调整为陈述句语序whom I should vote for，然后作主句谓语decided的宾语，即构成宾语从句。<br>我还没有决定该投谁一票。</p>
<p>No one knows exactly how speech began.<br>这里的特殊疑问词how是作began的方式状语，所以需将原来的倒装句how did speech begin调整为陈述句语序how speech began，然后作主句谓语knows的宾语，即构成宾语从句。<br>没有人确切地知道语言是如何产生的。</p>
<h2 id="表语从句"><a href="#表语从句" class="headerlink" title="表语从句"></a>表语从句</h2><h3 id="陈述句作表语"><a href="#陈述句作表语" class="headerlink" title="陈述句作表语"></a>陈述句作表语</h3><p>把“that+陈述句”这一结构放在表语的位置即构成表语从句。<br>My idea is that the child should be sent to school.<br>我的看法是，应该把这个孩子送去上学。</p>
<h3 id="一般疑问句作表语"><a href="#一般疑问句作表语" class="headerlink" title="一般疑问句作表语"></a>一般疑问句作表语</h3><p>把“whether+陈述句”这一结构放在表语的位置即构成表语从句。<br>My concern is whether he comes or not.<br>我关心的是他到底来不来。</p>
<h3 id="特殊疑问句作表语"><a href="#特殊疑问句作表语" class="headerlink" title="特殊疑问句作表语"></a>特殊疑问句作表语</h3><p>把特殊疑问句变成陈述句语序后放在表语的位置即构成表语从句。<br>Change is what keeps us fresh and innovative. Change is what keeps us from getting stale . Change is what keeps us young.<br>变革能使我们保持思维敏锐，富有创造性。变革能防止我们思想僵化。变革能使我们永葆青春。<br>Yesterday is history. Tomorrow is a mystery. Today is a gift. That’s why it’s called the present!<br>昨天是历史。明天是一个谜。今天是一个礼物。因此它才被称为present!<br>The point is when you will become rich.<br>问题的关键是你何时才能有钱。</p>
<h2 id="同位语从句"><a href="#同位语从句" class="headerlink" title="同位语从句"></a>同位语从句</h2><p>所谓同位语，就是用来补充说明名词的成分。被补充说明的名词，叫作先行词。当用一个完整的句子来补充说明名词时，即构成同位语从句。所以，同位语从句都位于一个名词的后面，便构成了“名词+连词+同位语从句”这样的结构。</p>
<h3 id="陈述句作同位语"><a href="#陈述句作同位语" class="headerlink" title="陈述句作同位语"></a>陈述句作同位语</h3><p>把“that陈述句”这一结构放在同位语的位置即构成同位语从句。<br>He was prepared to prove his theory that two different weights would fall to the ground at the same time.<br>这里的先行词是his theory，同位语从句是that two different weights would fall to the ground at the same time。<br>他准备证明他的这一理论：两个重量不同的物体将同时落地。</p>
<p>The fact that he succeeded in the experiment pleased everybody.<br>这里的先行词是the fact，同位语从句是that he succeeded in the experiment。<br>他的实验取得了成功，这让大家很高兴。</p>
<p>The rumor that Tom was a thief turned out to be untrue.<br>这里的先行词是the rumor，同位语从句是that Tom was a thief。<br>有谣传说汤姆是小偷，结果证明是假的。</p>
<blockquote>
<p>同位语从句可能与其修饰的名词被其他成分隔开。</p>
</blockquote>
<p>They spread the lie everywhere that Tom was guilty of theft.<br>这里的先行词the lie与同位语从句that Tom was guilty of theft被状语everywhere隔开。<br>他们到处散布谣言说汤姆犯有盗窃罪。</p>
<p>A saying goes that practice makes perfect.<br>这里的先行词a saying与同位语从句that practice makes perfect被谓语goes隔开。<br>俗话说，熟能生巧。</p>
<h4 id="同位语从句句型（一）：名词-that-陈述句"><a href="#同位语从句句型（一）：名词-that-陈述句" class="headerlink" title="同位语从句句型（一）：名词+that+陈述句"></a>同位语从句句型（一）：名词+that+陈述句</h4><p>I have been left with the knowledge that it’s better to expect nothing than to give everything and then be disappointed.<br>我从中懂得了，不抱任何期待比付出努力却最终失望要好。</p>
<h4 id="同位语从句句型（二）：名词-定语-that-陈述句"><a href="#同位语从句句型（二）：名词-定语-that-陈述句" class="headerlink" title="同位语从句句型（二）：名词+定语+that+陈述句"></a>同位语从句句型（二）：名词+定语+that+陈述句</h4><p>如果一个名词后面既有定语又有同位语从句，那么往往定语在前，同位语从句在后，这样便形成了先行词与同位语从句被定语分隔的结构。<br>The statement by the driver of the vehicle that he did not see the lorry was rejected by the Court.<br>the statement by the driver of the vehicle表示“这位汽车司机的陈述”，即用介词短语来限定statement；the statement…that he did not see the lorry表示“他说没有看见卡车这一陈述”，即同位语从句用来详细说明statement的内容是什么。<br>该汽车司机说自己没有看见卡车，但法庭并不相信这个说法。</p>
<h4 id="同位语从句句型（三）：名词-谓语-that-陈述句"><a href="#同位语从句句型（三）：名词-谓语-that-陈述句" class="headerlink" title="同位语从句句型（三）：名词+谓语+that+陈述句"></a>同位语从句句型（三）：名词+谓语+that+陈述句</h4><p>如果一个名词作主语，并且它后面还带有一个同位语从句，此时我们通常把这个同位语从句置于谓语的后面，而不是放在名词的后面，因而造成先行名词与同位语从句的分隔。<br>Concerns were raised that witnesses might be encouraged to exaggerate their stories in court to ensure guilty verdicts.<br>这里的先行词concerns与that引导的同位语从句被谓语were raised隔开。<br>人们日益担心，证人可能会受到鼓励，在法庭上夸大其词以确保陪审团对被告做出有罪的判决。</p>
<h3 id="一般疑问句作同位语"><a href="#一般疑问句作同位语" class="headerlink" title="一般疑问句作同位语"></a>一般疑问句作同位语</h3><p>把“whether+陈述句”这一结构放在同位语的位置即构成同位语从句。<br>They are faced with the problem whether they should continue to work .<br>他们面临这样一个问题：他们是否应该继续工作。</p>
<h3 id="特殊疑问句作同位语"><a href="#特殊疑问句作同位语" class="headerlink" title="特殊疑问句作同位语"></a>特殊疑问句作同位语</h3><p>把特殊疑问句变成陈述句语序后放在同位语的位置即构成同位语从句。<br>There arose the question where we could get the loan.<br>现在的问题是我们去哪里弄到这笔贷款。</p>
<p>I have no idea when he will return.<br>我不知道他什么时候回来。</p>
<h2 id="嵌套结构"><a href="#嵌套结构" class="headerlink" title="嵌套结构"></a>嵌套结构</h2><p>所谓名词从句的“嵌套结构”，即指多个名词从句之间存在的包含与被包含的关系。<br>I realized that what I said was not exactly what I meant to say.<br>在that引导的宾语从句中同时含有what引导的主语从句 what I said和what引导的表语从句what I meant to say。<br>我后来意识到，当时所说的话并非是我真正想要说的。</p>
<p>The question is how what you have learned can be put into practice.<br>在how引导的表语从句中含有what引导的主语从句what you have learned。how引导的从句的谓语是can be put into practice，而what引导的从句的谓语是have learned。<br>问题是，你所学到的知识如何才能应用于实践。</p>
<h3 id="连词与动词的配比原则"><a href="#连词与动词的配比原则" class="headerlink" title="连词与动词的配比原则"></a>连词与动词的配比原则</h3><p>在分析句子结构时，我们可以先找到句中的各个谓语动词，然后再找连词。又因为连词后面必然是从句，而从句中必然有谓语动词，因此，在每个连词后面必然要找到一个与之相应的从句的谓语动词。当把连词与对应的谓语动词划分清楚之后，整个难句的结构也就迎刃而解了。</p>
<blockquote>
<p>在英语中，有N个谓语动词，就会对应有N-1个连词以及N-1个对应的从句，这就是张满胜老师提出的“连词与动词的配比原则”。</p>
</blockquote>
<p>That the seas are being overfished has been known for years. What researchers such as Ransom Myers and Boris Worm have shown is just how fast things are changing.<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/b7MBnS.png"><br>海洋正在被人们过度捕捞，许多年以来这已是尽人皆知的事实了。研究人员（如Ransom Myers和Boris Worm）所揭示的仅仅是情况变化得多么迅速。</p>
<p>还可以带有定语从句或者是状语从句，这样就形成了三大从句的“嵌套结构”。<br>No one takes much interest in the marks a little child gets on his test; what we are interested in is whether we can conclude from his mark on the test that the child will do better or worse than other children of his age at tasks which we think require “general intelligence”.<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/Jg8cKF.png"><br>宾语从句的结构图示：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/G7bBNF.png"><br>我们对一个小孩在考试中取得的分数并不感兴趣，我们所感兴趣的是我们是否能够从他的考试分数中做出判断：这个孩子在我们认为需要“一般智商”的练习任务中的表现是否将会好于或差于其他同龄孩子。</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构系列之队列（Java）</title>
    <url>/2020/09/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E4%B9%8B%E9%98%9F%E5%88%97-Java/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode-cn.com/tag/queue/">leetcode队列专题</a></p>
</blockquote>
<h2 id="队列的定义"><a href="#队列的定义" class="headerlink" title="队列的定义"></a>队列的定义</h2><p>队列是一种特殊的线性表，特殊之处在于它只允许在表的前端（front）进行删除操作，而在表的后端（rear）进行插入操作，和栈一样，队列是一种操作受限制的线性表。进行插入操作的端称为队尾，进行删除操作的端称为队头。队列的特点就是先进先出(First In First Out)。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/pRoXuq.png"></p>
<h2 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h2><p>建立顺序队列结构必须为其静态分配或动态申请一片连续的存储空间，并设置两个指针进行管理。一个是队头指针front，它指向队头元素；另一个是队尾指针rear，它指向下一个入队元素的存储位置。</p>
<blockquote>
<p>如果没有两个指针，入队操作直接执行顺序表尾部插入操作，其时间复杂度为O(1)，出队操作直接执行顺序表头部删除操作，其时间复杂度为O(n)，<br>增加了front和rear指针，出队操作的时间复杂度也是O(1)了。</p>
</blockquote>
<p>空队列：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/VOhvX9.png"><br>往队列里面插入A：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/Tvnv7J.png"><br>继续插入元素：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/DFz5Ix.png"><br>将A和B出队：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/SKuBUa.png"><br>继续将D、E、F、G入队：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/Bh2zXE.png"><br>由于队列暂时”已满”，G将无法入队，但是此时front前面实际上还有未被利用的空间，这称为<code>&quot;假上溢&quot;现象</code>。<br>之所以出现这样”假溢出”现象是因为顺序表队列的存储单元没有重复利用机制，而解决该问题的最合适的方式就是将顺序队列设计为循环结构。</p>
<h3 id="“下溢”现象"><a href="#“下溢”现象" class="headerlink" title="“下溢”现象"></a>“下溢”现象</h3><p>当队列为空时，做出队运算产生的溢出现象。“下溢”是正常现象，常用作程序控制转移的条件。</p>
<h3 id="“真上溢”现象"><a href="#“真上溢”现象" class="headerlink" title="“真上溢”现象"></a>“真上溢”现象</h3><p>当队列满时，做进栈运算产生空间溢出的现象。“真上溢”是一种出错状态，应设法避免。</p>
<h3 id="“假上溢”现象"><a href="#“假上溢”现象" class="headerlink" title="“假上溢”现象"></a>“假上溢”现象</h3><p>由于入队和出队操作中，头尾指针只增加不减小，致使被删元素的空间永远无法重新利用。当队列中实际的元素个数远远小于向量空间的规模时，也可能由于尾指针已超越向量空间的上界而不能做入队操作。该现象称为”假上溢”现象，如上面的图解。</p>
<h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p>循环队列就是将顺序队列设计为在逻辑结构上首尾相接的循环结构，使队列空间能重复使用，往往对队列的使用方法稍加改进：无论插入或删除，一旦rear指针增1或front指针增1时超出了所分配的队列空间，就让它指向这片连续空间的起始位置。自己真从MaxSize-1增1变到0，可用取余运算<code>(rear+1)%MaxSize</code>和<code>(front+1)%MaxSize</code>来实现（如果front和rear是从1开始的，则无需+1）。<br>这实际上是把队列空间想象成一个环形空间，环形空间中的存储单元循环使用，用这种方法管理的队列也就称为循环队列。除了一些简单应用之外，真正实用的队列是循环队列。<br>向循环队列插入A：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/id3Re7.png"><br>继续插入B、C（每次入队rear都在增1）：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/L9wzvj.png"><br>将A、B、C出队（每次出队front都在增1）：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/JVFghB.png"><br>重新插入A、B、C（此时队列出现”假上溢”现象，使用<code>(rear+1)%MaxSize</code>计算rear）：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/M40vAU.png"><br>继续将A、B、C出队（此时队列出现”假上溢”现象，使用<code>(front+1)%MaxSize</code>计算front）：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/rQlZy9.png"><br>重新插入直至队列出现”真上溢”现象，然后可以动态对循环队列进行扩展（并按照原来队列的次序复制元素数组）：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/gHQzZs.png"></p>
<h2 id="链式队列"><a href="#链式队列" class="headerlink" title="链式队列"></a>链式队列</h2><p>基于链表的队列，要动态创建和删除节点，效率较低，但是可以动态增长，可以使用带头指针front和尾指针rear的单链表实现，front直接指向队头的第一个元素，rear指向队尾的最后一个元素。<br>队列采用的FIFO(first in first out)，新元素（等待进入队列的元素）总是被插入到链表的尾部，而读取的时候总是从链表的头部开始读取。每次读取一个元素，释放一个元素。所谓的动态创建，动态释放。因而也不存在溢出等问题。由于链表由结构体间接而成，遍历也方便。<br>空链式队列：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/YVIozT.png"><br>插入元素（入队）：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/cbwuMz.png"><br>出队和入队都分别改变front和rear的指向即可。</p>
<h2 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h2><p>在某些情况下，有些应用系统要求不仅需要按照“先来先服务”的原则进行，而且还需按照任务的重要或紧急程度进行排队处理，此时就需要使用到优先队列。比如在操作系统中进行进程调度管理，每个进程都具备一个优先级值以表示进程的紧急程度，优先级高的进行先执行，同等级进程按照先进先出的原则排队处理，此时操作系统使用的便是优先队列管理和调度进程。<br>优先队列也是一种特殊的数据结构，队列中的每个元素都有一个优先级，按照排序可分类为：</p>
<ul>
<li>降序优先级队列：每次出队的是队列当前具有最高优先级的元素。</li>
<li>升序优先级队列：每次出队的是队列当前具有最低优先级的元素。</li>
</ul>
<p>优先队列的实现可以有三种方案：</p>
<ul>
<li>有序数组</li>
<li>有序链表</li>
<li>也可以使用二叉树（二叉堆）实现</li>
</ul>
<h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><p>双端队列可以在队列任意一端入队和出队。此外，经常还会有一个查看（Peek）操作，返回该端的数据而不将其出队。</p>
<h2 id="队列的应用"><a href="#队列的应用" class="headerlink" title="队列的应用"></a>队列的应用</h2><ul>
<li>异步数据的处理、传输；</li>
<li>短信群体发送 应用的发布订阅模式；</li>
<li>模拟真实的订单服务、售票，以及其他先到先服务的场景。</li>
</ul>
<h2 id="Java中的队列"><a href="#Java中的队列" class="headerlink" title="Java中的队列"></a>Java中的队列</h2><h3 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h3><ul>
<li>PriorityQueue</li>
<li>ConcurrentLinkedQueue</li>
</ul>
<h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
<li>PriorityBlockingQueue</li>
<li>DelayQueue</li>
<li>SynchronousQueue</li>
</ul>
<blockquote>
<p>参考来源：<a href="https://blog.csdn.net/javazejian/article/details/53375004">某篇博客</a>、<a href="https://baike.baidu.com/item/%E9%98%9F%E5%88%97/14580481">百度百科</a>等。</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>队列</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构系列之树（Java）</title>
    <url>/2020/09/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E4%B9%8B%E6%A0%91-Java/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode-cn.com/tag/tree/">leetcode树专题</a></p>
</blockquote>
<h2 id="树的定义"><a href="#树的定义" class="headerlink" title="树的定义"></a>树的定义</h2><p>树是由n个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。<br>当n&#x3D;0时，称为空树。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/pbMQ0p.png"></p>
<h2 id="树的特点"><a href="#树的特点" class="headerlink" title="树的特点"></a>树的特点</h2><ul>
<li>每个节点都只有有限个子节点或无子节点；</li>
<li>没有父节点的节点称为根节点；</li>
<li>每一个非根节点有且只有一个父节点；</li>
<li>除了根节点外，每个子节点可以分为多个不相交的子树；</li>
<li>树里面没有环路(cycle)。</li>
</ul>
<h2 id="树的术语"><a href="#树的术语" class="headerlink" title="树的术语"></a>树的术语</h2><ul>
<li>根节点： 根节点没有父节点，树中最多有一个根节点（如上图的Root）；</li>
<li>节点的度：一个节点含有的子树的个数称为该节点的度（如上图的Root的度为3，L2_*所有节点的度为0）；</li>
<li>树的度：树中最大的节点度称为树的度（如上图树的度&#x3D;Root的度&#x3D;L1_C的度）；</li>
<li>叶节点（终端节点）：度为0的节点（如上图L2_*的所有节点）；</li>
<li>父节点：若一个节点含有子节点，则这个节点称为其子节点的父节点；</li>
<li>子节点：一个节点的子树的根节点称为其孩子节点；</li>
<li>兄弟节点：具有相同父节点的节点互称为兄弟节点；</li>
<li>树的层（节点的层）：从根开始定义起，根为第1层，根的子节点为第2层，以此类推；</li>
<li>分支节点（非终端节点）：度不为零的节点；</li>
<li>深度：对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0；</li>
<li>高度：对于任意节点n,n的高度为从n到其子孙中的最长路径，所有树叶的高度为0；</li>
<li>节点的祖先：从根到该节点所经分支上的所有节点；</li>
<li>森林：由m（m&gt;&#x3D;0）棵互不相交的树的集合称为森林；</li>
<li>子孙：以某节点为根的子树中任一节点都称为该节点的子孙。</li>
</ul>
<h2 id="有序树"><a href="#有序树" class="headerlink" title="有序树"></a>有序树</h2><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于2的节点）的树结构，是n(n≥0)个节点组成的有限集合：</p>
<ul>
<li>n&#x3D;0时称为空二叉树；</li>
<li>n&gt;0的二叉树由一个根节点和两棵互不相交的子树组合而成，通常分支被称作“左子树”或“右子树”，二叉树的分支具有左右次序，不能随意颠倒。</li>
</ul>
<h4 id="二叉树的五种形态"><a href="#二叉树的五种形态" class="headerlink" title="二叉树的五种形态"></a>二叉树的五种形态</h4><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/r9NLTh.png"></p>
<h4 id="三个节点的二叉树有多少种？"><a href="#三个节点的二叉树有多少种？" class="headerlink" title="三个节点的二叉树有多少种？"></a>三个节点的二叉树有多少种？</h4><p>五种。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/MKUYFS.png"></p>
<h4 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h4><ul>
<li>二叉树的第i层上至多有$2^{i-1}(i≥1)$个节点；</li>
<li>深度为h的二叉树中至多含有2^{h}-1个节点;</li>
</ul>
<h4 id="完全二叉树（Complete-Binary-Tree）"><a href="#完全二叉树（Complete-Binary-Tree）" class="headerlink" title="完全二叉树（Complete Binary Tree）"></a>完全二叉树（Complete Binary Tree）</h4><p>假设二叉树的深度为h，除第h层外，其它各层<code>[1～h-1]</code>的节点数都达到最大个数，第h层所有的节点都连续集中在最左边，这就是完全二叉树<br>换句话说，在一颗二叉树中，若除最后一层外的其余层都是满的，并且最后一层要么是满的，要么在右边缺少<em><strong>连续</strong></em>一个或若干节点，则此二叉树为完全二叉树。<br>比如，下面三棵树都是完全二叉树：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/g7pm5P.png"></p>
<h5 id="完全二叉树的性质"><a href="#完全二叉树的性质" class="headerlink" title="完全二叉树的性质"></a>完全二叉树的性质</h5><ul>
<li>若<code>i≤[n/2]</code>， 则节点i为分支节点，否则为叶子节点。</li>
<li>叶子节点只可能在层次最大的两层上出现。对于最大层次的叶子节点，都依次排在最左边的位置上。</li>
<li>度为1的节点若存在，则最多只能只有一个，且是编号最大的分支节点，其孩子节点一定是左节点。</li>
</ul>
<h5 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h5><p>一棵高度为h的满二叉树（Full Binary Tree）是具有$2^{h}−1(h≥0)$个节点的二叉树。满二叉树的最大特点是每一层次的节点数都达到最大值。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/pjgSLj.png"></p>
<blockquote>
<p>对于编号为i的节点，若存在，其双亲的编号为<code>i/2</code>,左孩子为<code>2i</code>,右孩子为<code>2i+1</code>。</p>
</blockquote>
<h4 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h4><p>二叉树可以用数组或链接串列来存储，主要采用的是链式存储结构，至于顺序存储结构仅适用于完全二叉树或满二叉树，若是满二叉树就能紧凑排列而不浪费空间。</p>
<h5 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h5><p>用一组连续的存储单元依次自上而下、自左至右存储完全二叉树上的节点元素。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/2AJIGM.png"><br>但是如果二叉树树是非完全二叉树的情况下，就必须使用顺序表的空元素来代替，如：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/27x3Tt.png"><br>这样的话，在非完全二叉树的情况下，采用顺序存储结构的二叉树就有很大弊端了，可能会造成很大空间的浪费，比如这种类型的树：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/1XluNE.png"><br>因此，非完全二叉树还是要使用链式存储结构来实现，这也是最常见的实现二叉树的存储结构。</p>
<h5 id="二叉树的链式存储结构"><a href="#二叉树的链式存储结构" class="headerlink" title="二叉树的链式存储结构"></a>二叉树的链式存储结构</h5><ul>
<li>双指针链式存储结构<br>双指针链式结构主要由一个数据域和两个分别指向左、右孩子的指针组成。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/Ir7nGG.png"><br>从图中可以看出，采用双指针链式存储结构，每个节点只存储了到其孩子节点的单向关系，而没有存储到父节点的关系，这样的话，每次要获取父节点时将消耗较多的时间，因为需要从root根节点开始查找，花费的时间是遍历部分二叉树的时间。</li>
<li>三指针链式存储结构<br>三指针链式结构主要是在双指针的基础上多添加了一个指向父节点的域，这样我们就存储了父节点与孩子节点的双向关系，当然这样也增加了一定的空间开销。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/hvHTKU.png"></li>
</ul>
<h4 id="二叉查找树（二叉排序树、二叉搜索树、Binary-Seary-Tree）"><a href="#二叉查找树（二叉排序树、二叉搜索树、Binary-Seary-Tree）" class="headerlink" title="二叉查找树（二叉排序树、二叉搜索树、Binary Seary Tree）"></a>二叉查找树（二叉排序树、二叉搜索树、Binary Seary Tree）</h4><p>二叉查找树的特性是，对于树种的每个节点T,它的左子树中所有项的值小T中的值，而它的右子树中所有项的值都大于T中的值。</p>
<blockquote>
<p>它既有链表的快速插入与删除操作的特点，又有数组快速查找的优势。</p>
</blockquote>
<h5 id="二叉排序树的查询"><a href="#二叉排序树的查询" class="headerlink" title="二叉排序树的查询"></a>二叉排序树的查询</h5><p>二叉树非空时，查找根结点，若相等则查找成功;<br>若不等，则当小于根结点值时，查找左子树;当大于根结点的值时，查找右子树。<br>当查找到叶节点仍没查找到相应的值，则查找失败。</p>
<blockquote>
<p>BOILERPLATE（递归转非递归并非一定要通过栈）:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public TreeNode searchBST(TreeNode node, int key)&#123;</span><br><span class="line">    while(node !=null &amp;&amp; key != node.val)&#123;</span><br><span class="line">        if(key &lt; node.val)&#123;</span><br><span class="line">            node = node.left;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            node = node.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h4><h5 id="先序（先根次序）遍历"><a href="#先序（先根次序）遍历" class="headerlink" title="先序（先根次序）遍历"></a>先序（先根次序）遍历</h5><ul>
<li>访问根节点</li>
<li>先序遍历左子树</li>
<li>先序遍历右子树</li>
</ul>
<p>比如以下二叉树的访问次序是：1、2、4、5、3<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/T6UmeX.png"></p>
<h6 id="先根遍历的递归实现"><a href="#先根遍历的递归实现" class="headerlink" title="先根遍历的递归实现"></a>先根遍历的递归实现</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private String preOrder(BinaryNode&lt;T&gt; node)&#123;</span><br><span class="line">    if (node!=null) &#123;</span><br><span class="line">        //先访问根节点</span><br><span class="line">        peek(node);</span><br><span class="line">        //遍历左子树</span><br><span class="line">        preOrder(node.left);</span><br><span class="line">        //遍历右子树</span><br><span class="line">        preOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也可以使用非递归实现，比如使用栈。</p>
</blockquote>
<h5 id="中序（中根次序）遍历"><a href="#中序（中根次序）遍历" class="headerlink" title="中序（中根次序）遍历"></a>中序（中根次序）遍历</h5><p>二叉搜索树的中序遍历的序列是递增排序的序列，中序遍历的遍历次序：Left -&gt; Node -&gt; Right。</p>
<ul>
<li>中序遍历左子树</li>
<li>遍历根节点</li>
<li>中序遍历右子树</li>
</ul>
<p>比如以下二叉树遍历顺序是a、b、c，也就是4、2、5、1、3、6：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/8xLHgi.png"><br> 中序遍历的递归实现</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private String inOrder(BinaryNode&lt;T&gt; node)&#123;</span><br><span class="line">    if (node!=null) &#123;</span><br><span class="line">        //遍历左子树</span><br><span class="line">        inOrder(node.left);</span><br><span class="line">        //先访问根节点</span><br><span class="line">        peek(node);</span><br><span class="line">        //遍历右子树</span><br><span class="line">        inOrder(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="中序遍历的非递归实现"><a href="#中序遍历的非递归实现" class="headerlink" title="中序遍历的非递归实现"></a>中序遍历的非递归实现</h6><blockquote>
<p>可以使用栈来实现。</p>
</blockquote>
<p>遍历思想：</p>
<ul>
<li>1、初始时依次扫描根节点的所有左侧节点并将它们进栈;</li>
<li>2、出栈一个节点，访问它;</li>
<li>3、扫描该节点的右节点并将其进栈;</li>
<li>4、依次扫描右节点的所有左侧节点并一一进栈;</li>
<li>5、反复该过程直到栈空为止。</li>
</ul>
<p>比如以下树，进出栈顺序为：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/oy8slf.png"></p>
<ul>
<li>进栈：1、2、4、7（遍历思想第1步）；</li>
<li>出栈：7；（栈中：：1、2、4，遍历思想第2步）</li>
<li>访问7所在节点，尝试拿到其右节点压入栈，但是此时为空，不能递归空节点是否有左节点（遍历思想上面的第3步）；</li>
<li>出栈：4；（栈中：1、2，遍历思想第2步）</li>
<li>遍历思想第3步，此时为空；</li>
<li>出栈：2；（栈中：1，遍历思想第2步）</li>
<li>遍历思想第3步，发现其右节点；</li>
<li>进栈：5；（栈中：1、5）</li>
<li>遍历思想第4步，此时为空；</li>
<li>出栈：5；（栈中：1，遍历思想第2步）</li>
<li>遍历思想第3步，此时为空；</li>
<li>出栈：1（遍历思想第2步）</li>
<li>遍历思想第3步，此时发现右节点，进栈3（栈中：3）；</li>
<li>遍历思想第4步，此时发现左节点，进栈6（栈中：3、6）；</li>
<li>重复第2步2次，至此结束。</li>
</ul>
<p>所以不难发现，其实z整个过程只是在遍历思想的5步中循环，从第3步到第4步，只要访问想要的节点为空就退回到上一步然后继续往后走，直至栈空。</p>
<blockquote>
<p>BOILERPLATE：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void inOrder(TreeNode node)&#123;</span><br><span class="line">    Stack stack = new Stack();</span><br><span class="line">    Object e = node;</span><br><span class="line">    while(e != null || !stack.isEmpty())&#123;</span><br><span class="line">        if(e != null)&#123;</span><br><span class="line">            stack.push(e);</span><br><span class="line">            e = e.left;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            e = stack.pop();</span><br><span class="line">            peek(e);</span><br><span class="line">            e = e.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="后序（后根次序）遍历"><a href="#后序（后根次序）遍历" class="headerlink" title="后序（后根次序）遍历"></a>后序（后根次序）遍历</h5><ul>
<li>后序遍历左子树</li>
<li>后序遍历右子树</li>
<li>访问根节点</li>
</ul>
<p>比如以下二叉树遍历顺序是a、b、c，也就是4、5、2、6、3、1：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/kysHQi.png"></p>
<h6 id="后序遍历的递归实现"><a href="#后序遍历的递归实现" class="headerlink" title="后序遍历的递归实现"></a>后序遍历的递归实现</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private String postOrder(BinaryNode&lt;T&gt; node)&#123;</span><br><span class="line">    if (node!=null) &#123;</span><br><span class="line">        //遍历左子树</span><br><span class="line">        postOrder(node.left);</span><br><span class="line">        //遍历右子树</span><br><span class="line">        postOrder(node.right);</span><br><span class="line">        //先访问根节点</span><br><span class="line">        peek(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>同样也可以使用栈来实现。</p>
</blockquote>
<h5 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h5><blockquote>
<p>使用队列来实现。</p>
</blockquote>
<p>遍历思想：</p>
<ul>
<li>1、初始将根入队并访问根结点，然后出队;</li>
<li>2、若有左子树，则将左子树的根入队;</li>
<li>3、若有右子树，则将右子树的根入队;</li>
<li>4、然后出队，访问该结点;</li>
<li>5、反复该过程直到队列空为止。</li>
</ul>
<blockquote>
<p>BOILERPLATE：</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void levelOrder(BiTree root)&#123;</span><br><span class="line">    queue.push(root);</span><br><span class="line">    BiTree node;</span><br><span class="line">    while(!queue.isEmpty())&#123;</span><br><span class="line">        node = queue.pop();</span><br><span class="line">        peek(node);</span><br><span class="line">        if(node.left != null) queue.push(node.left);</span><br><span class="line">        if(node.right != null) queue.push(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="遍历序列确定唯一二叉树"><a href="#遍历序列确定唯一二叉树" class="headerlink" title="遍历序列确定唯一二叉树"></a>遍历序列确定唯一二叉树</h5><p>后序或者先序遍历序列+中序遍历序列，可以确定一颗唯一二叉树。<br>比如：</p>
<ul>
<li>先序遍历序列（1、2、4、5、3、6）</li>
<li>中序遍历序列（4、2、5、1、6、3）</li>
</ul>
<p>其对应的树如下：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/EmDKEi.png"></p>
<h4 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h4><p>线索化：</p>
<ul>
<li>若无左子树，则将左指针指向其前驱结点;</li>
<li>若无右子树，则将右指针指向其后继结点。</li>
</ul>
<h5 id="线索二叉树-1"><a href="#线索二叉树-1" class="headerlink" title="线索二叉树"></a>线索二叉树</h5><p>比如先序遍历序列为<code>124536</code>的二叉树先序线索化如下图：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/oblrFJ.png"><br>同样是这颗树的中序序列为<code>425163</code>，其对应的中序线索化如下图：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/p5lMPP.png"></p>
<blockquote>
<p>其后序线索二叉树<code>452631</code>也是同理。<br>最常用的是中序线索二叉树。<br>中序线索二叉树线索化的BOILERPLATE:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">class TreeNode &#123;</span><br><span class="line">        String data;    //数据域</span><br><span class="line">        Node left;      //左节点</span><br><span class="line">        Node right;     //右节点</span><br><span class="line">        boolean isLeftToPre;  </span><br><span class="line">        boolean isRightToNext; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 方法调用传入二叉树的中序遍历后的顺序的第一个节点对象实例</span><br><span class="line">public void initInThread(TreeNode first)&#123;</span><br><span class="line">    TreeNode pre = null;</span><br><span class="line">    inThreadOrder(first, pre);</span><br><span class="line">    pre.right = null;</span><br><span class="line">    pre.isLeftToPre = true;</span><br><span class="line">&#125;</span><br><span class="line">public void inThreadOrder(TreeNode node, TreeNode pre)&#123;</span><br><span class="line">    if(node == null) return;</span><br><span class="line">    inThreadOrder(node.left, node);</span><br><span class="line">    if(node.left == null)&#123;</span><br><span class="line">        node.left = pre;</span><br><span class="line">        node.isLeftToParent = true;</span><br><span class="line">    &#125;</span><br><span class="line">    if(pre != null &amp;&amp; pre.right == null)&#123;</span><br><span class="line">        pre.right = node;</span><br><span class="line">        pre.isRightToNext = true;</span><br><span class="line">    &#125;</span><br><span class="line">    pre = node;</span><br><span class="line">    inThreadOrder(node.right, node.pre);</span><br><span class="line">&#125;</span><br><span class="line">// 寻找中序排列第一个节点，传入根节点</span><br><span class="line">publid TreeNode firstNode(TreeNode node)&#123;</span><br><span class="line">    while(!node.isLeftToPre)&#123;</span><br><span class="line">        node = node.left;</span><br><span class="line">    &#125;</span><br><span class="line">    return node;</span><br><span class="line">&#125;</span><br><span class="line">// 寻找中序排序之后的后继节点</span><br><span class="line">publid TreeNode nextNode(TressNode node)&#123;</span><br><span class="line">    if(!node.isRightToNext)&#123;</span><br><span class="line">        return firstNode(node.right);</span><br><span class="line">    &#125;</span><br><span class="line">    return node.right;</span><br><span class="line">&#125;</span><br><span class="line">// 所以，中序线索化遍历某颗树可以这么实现：</span><br><span class="line">// 传入树的根节点，简单明了</span><br><span class="line">public void inOrder(TreeNode root)&#123;</span><br><span class="line">    for(TreeNode temp = firstNode(root); temp != null; temp = nextNode(temp))&#123;</span><br><span class="line">        peek(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h6 id="线索二叉树数据结构特点"><a href="#线索二叉树数据结构特点" class="headerlink" title="线索二叉树数据结构特点"></a>线索二叉树数据结构特点</h6><p>其节点数据结构增加两个Boolean类型的标志域（成员变量）：</p>
<ul>
<li>isLeftToPre<code>true</code>时代表其左孩子节点指向其前驱节点，反之代表其左孩子节点指向其后继节点。</li>
<li>isRightToNext：当为<code>true</code>时代表其右孩子节点指向其前驱结点，反之代表其右孩子节点指向其后继节点。</li>
</ul>
<h3 id="字典树（前缀树、trie）"><a href="#字典树（前缀树、trie）" class="headerlink" title="字典树（前缀树、trie）"></a>字典树（前缀树、trie）</h3><p>trie，又称前缀树或字典树，是一种有序树，用于保存关联数组，其中的键通常是字符串。与二叉查找树不同，键不是直接保存在节点中，而是由节点在树中的位置决定。一个节点的所有子孙都有相同的前缀，也就是这个节点对应的字符串，而根节点对应空字符串。一般情况下，不是所有的节点都有对应的值，只有叶子节点和部分内部节点所对应的键才有相关的值（或者说真实的值）。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/DyNHln.png"></p>
<h3 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h3><h3 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h3><h2 id="无序树"><a href="#无序树" class="headerlink" title="无序树"></a>无序树</h2><blockquote>
<p>参考来源<a href="https://zh.wikipedia.org/wiki/%E4%BA%8C%E5%8F%89%E6%A0%91">维基百科</a>、<a href="https://www.bilibili.com/video/BV1b7411N798?p=42">王道考研</a>等</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构系列之图（Java）</title>
    <url>/2020/09/18/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E4%B9%8B%E5%9B%BE-Java/</url>
    <content><![CDATA[<blockquote>
<p><a href="https://leetcode-cn.com/tag/graph/">leetcode图专题</a></p>
</blockquote>
<h2 id="广度优先搜索（Breadth-First-Search、BFS）"><a href="#广度优先搜索（Breadth-First-Search、BFS）" class="headerlink" title="广度优先搜索（Breadth-First-Search、BFS）"></a>广度优先搜索（Breadth-First-Search、BFS）</h2><p>BFS与树的层次遍历有点类似，可以用于树或者图的遍历，其具体过程如下：</p>
<ul>
<li>访问起始顶点<code>vertex</code>;</li>
<li>由顶点依次访问<code>vertex</code>的各个<em><strong>未被访问过</strong></em>的邻接顶点W1、W2、W3、…Wn;</li>
<li>然后依次访问W1、W2、W3、… Wn;的所有<em><strong>未被访问过</strong></em>的邻接顶点;</li>
<li>如果所在顶点没有未被访问过的领接顶点，则退回到上一层顶点；</li>
<li>继续从第二步开始重复，以此类推。</li>
</ul>
<p>如果仅仅是树的层次遍历来实现BFS的话，无法满足只访问未被访问过的这一约束，比如如下的图：</p>
<p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/ihab4j.png"></p>
<p>因此其实现原理需要额外的一个<code>队列</code>和一个<code>辅助性的数组</code>。</p>
<blockquote>
<p>BOILERPLATE:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private class Graph &#123;</span><br><span class="line">    int val;</span><br><span class="line">    int index;</span><br><span class="line">    Graph[] neighbors;</span><br><span class="line">    int currentVisitNeighborIndex;// getFristNeighbor时为0, getNextNeighbor每次+1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean[] visitedRecord = new boolean[MAX];</span><br><span class="line">private Queue&lt;Graph&gt; queue;</span><br><span class="line">private void BFS(Graph g)&#123;</span><br><span class="line">    peek(g); // 具体的访问代码逻辑</span><br><span class="line">    visitedRecord[g.index] = true; // 代表已经访问过</span><br><span class="line">    queue.push(g);</span><br><span class="line">    while(!queue.isEmpty())&#123;</span><br><span class="line">        Graph temp = intqueue.pop();</span><br><span class="line">        for(Graph next = getFristNeighbor(temp); next != null ; next = getNextNeighbor(temp))&#123;</span><br><span class="line">            if(!visitedRecord[next.index])&#123;</span><br><span class="line">                peek(next);</span><br><span class="line">                visitedRecord[next.index] = true; // 代表已经访问过</span><br><span class="line">                queue.push(next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void mutilGraphVetex(Graph... gs)&#123;</span><br><span class="line">    // 如果存在多个顶点的图</span><br><span class="line">    gs.forEach(this::BFS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="深度优先搜索（Depth-First-Search、DFS）"><a href="#深度优先搜索（Depth-First-Search、DFS）" class="headerlink" title="深度优先搜索（Depth-First-Search、DFS）"></a>深度优先搜索（Depth-First-Search、DFS）</h2><p>DFS与树的先序遍历比较类似，可以用于树或者图的遍历，其具体过程如下：</p>
<ul>
<li>访问起始顶点<code>vertex</code>;</li>
<li>由顶点依次访问<code>vertex</code>的任意一个<em><strong>未被访问过</strong></em>的邻接顶点W;</li>
<li>然后再访问W的任意一个<em><strong>未被访问过</strong></em>的邻接顶点Y;</li>
<li>如果W没有未被访问过的领接顶点，则退回到上一层顶点；</li>
<li>继续从第二步开始重复，以此类推。</li>
</ul>
<p>其实现原理可以采用递归思维，加额外的一个<code>辅助性的数组</code>。</p>
<blockquote>
<p>BOILERPLATE:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private class Graph &#123;</span><br><span class="line">    int val;</span><br><span class="line">    int index;</span><br><span class="line">    Graph[] neighbors;</span><br><span class="line">    int currentVisitNeighborIndex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private boolean[] visitedRecord = new boolean[MAX];</span><br><span class="line"></span><br><span class="line">private void DFS(Graph g)&#123;</span><br><span class="line">    peek(g); // 具体的访问代码逻辑</span><br><span class="line">    visitedRecord[g.index] = true; // 代表已经访问过</span><br><span class="line">    for(Graph next = getFristNeighbor(g); next != null ; next = getNextNeighbor(g))&#123;</span><br><span class="line">        if(!visitedRecord[next.index])&#123;</span><br><span class="line">            (next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void mutilGraphVetex(Graph... gs)&#123;</span><br><span class="line">    // 如果存在多个顶点的图</span><br><span class="line">    gs.forEach(this::DFS);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="这是一种多顶点的图"><a href="#这是一种多顶点的图" class="headerlink" title="这是一种多顶点的图"></a>这是一种多顶点的图</h3><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/54HWwB.png"><br>其DFS序列为：<code>ACDEB</code>。</p>
<h2 id="拓扑排序（Topological-sorting）"><a href="#拓扑排序（Topological-sorting）" class="headerlink" title="拓扑排序（Topological sorting）"></a>拓扑排序（Topological sorting）</h2><blockquote>
<p>参考来源：<a href="https://www.bilibili.com/video/BV1b7411N798?p=59">王道考研</a></p>
</blockquote>
<p>对DAG所有顶点的一种排序，使若存在一条从顶点A到顶点B的路径，在排序中B排在A的后面。<br>有环无向图不存在拓扑排序。</p>
<h3 id="有向无环图（DAG，Directed-Acyclic-Graph）"><a href="#有向无环图（DAG，Directed-Acyclic-Graph）" class="headerlink" title="有向无环图（DAG，Directed Acyclic Graph）"></a>有向无环图（DAG，Directed Acyclic Graph）</h3><p>在图论中，如果一个有向图从任意顶点出发无法经过若干条边回到该点，则这个图是一个有向无环图。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/o7XLuA.png"></p>
<h3 id="算法思维"><a href="#算法思维" class="headerlink" title="算法思维"></a>算法思维</h3><ul>
<li>从DAG图中选择一个没有前驱的顶点并输出；</li>
<li>从图中删除该顶点和所有以它为起点的有向边；</li>
<li>重复1、2步直到当前的DAG图为空或当前图中不存在无前驱的顶点为止，后一种情况说明图中有环。</li>
</ul>
<blockquote>
<p>DAG其拓扑排序的过程如下：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/jZ07up.png"></p>
</blockquote>
<blockquote>
<p>非DAG图：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/2KaG2f.png"><br>算法结束时没有访问所有顶点，则存在以剩下顶点组成的环。</p>
</blockquote>
<blockquote>
<p>出现多个没有入边的顶点（入度不为0）的情况：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/FpsB7k.png"><br>拓扑排序的结果不一定唯一。</p>
</blockquote>
<blockquote>
<p>BOILERPLATE:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private class Graph &#123;</span><br><span class="line">    int val;</span><br><span class="line">    int index;</span><br><span class="line">    Graph[] neighbors;</span><br><span class="line">    int currentVisitNeighborIndex = 0;</span><br><span class="line"></span><br><span class="line">    public Graph firstNeighbor() &#123;</span><br><span class="line">        if (neighbors == null || neighbors.length == 0) &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        return neighbors[currentVisitNeighborIndex++];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Graph nextNeighbor() &#123;</span><br><span class="line">        if (neighbors != null &amp;&amp; currentVisitNeighborIndex &lt; neighbors.length) &#123;</span><br><span class="line">            return neighbors[currentVisitNeighborIndex++];</span><br><span class="line">        &#125;</span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private Graph getGraph(int index) &#123;</span><br><span class="line">    // dosomething</span><br><span class="line">    return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">boolean topologicalSort(int[] indegrees) &#123;</span><br><span class="line">    // 当前顶点</span><br><span class="line">    Graph g = null;</span><br><span class="line">    Stack&lt;Integer&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    // 找出入度为0的顶点</span><br><span class="line">    for (int i : indegrees) &#123;</span><br><span class="line">        if (i == 0) &#123;</span><br><span class="line">            stack.push(i);</span><br><span class="line">            // 顶点入队之后，其入度已经不存在，也就是删除顶点与其出边</span><br><span class="line">            --indegrees[i];</span><br><span class="line">            g = getGraph(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 记录当前访问顶点的个数</span><br><span class="line">    int count = 0;</span><br><span class="line">    // 用一个数组来记录排序的序列</span><br><span class="line">    int[] print = new int[indegrees.length];</span><br><span class="line">    while (!stack.isEmpty()) &#123;</span><br><span class="line">        // 记录当前的额顶点下标（排序）</span><br><span class="line">        print[count++] = stack.pop();</span><br><span class="line">        for (Graph tmp = g.firstNeighbor(); tmp != null; tmp = g.nextNeighbor()) &#123;</span><br><span class="line">            // 删除入度，如果此时入度为0，代表又是一个顶点</span><br><span class="line">            if (--indegrees[tmp.index] == 0) &#123;</span><br><span class="line">                // 顶点入队</span><br><span class="line">                stack.push(tmp.index);</span><br><span class="line">                // 删除顶点与其出边</span><br><span class="line">                --indegrees[tmp.index];</span><br><span class="line">                g = getGraph(tmp.index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    if (count &lt; indegrees.length) &#123;</span><br><span class="line">        // 如果有顶点没有被访问到，不是DAG，剩下的是环状结构</span><br><span class="line">        return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        // 拓扑排序成功，输出print</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>数据结构系列之串（Java）</title>
    <url>/2020/09/20/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%B2-Java/</url>
    <content><![CDATA[<h2 id="串的朴素模式匹配"><a href="#串的朴素模式匹配" class="headerlink" title="串的朴素模式匹配"></a>串的朴素模式匹配</h2><blockquote>
<p>较简单，略过。</p>
</blockquote>
<h2 id="KMP算法（朴素模式匹配的优化）"><a href="#KMP算法（朴素模式匹配的优化）" class="headerlink" title="KMP算法（朴素模式匹配的优化）"></a>KMP算法（朴素模式匹配的优化）</h2><p>朴素模式匹配的缺点是：每当模式串匹配失败的时候，当前的匹配指针都只是往后移动一位，也就是只是把模式串右移一位，而且主串的扫描指针（模式串中匹配到哪一位）都要经常回溯，会造成多余的开销。</p>
<p>假定在某个主串中要匹配<code>google</code>这个模式串，那么其匹配逻辑如下：</p>
<ul>
<li>声明主串扫描指针为i；</li>
<li>声明模式串扫描指针为j；</li>
<li>KMP的算法关键在于匹配失败时，j回溯，而i不回溯（下标从0开始）。</li>
<li>当j&gt;0匹配成功时，j++，i++</li>
<li>当j&#x3D;0匹配不成功时，j不变，i++</li>
<li>当j&gt;0匹配不成功时，j回到最后一个有可能接下来匹配成功的下标，i不变（比如模式串google，在j等于4时不匹配，那么j应该回溯到1）</li>
</ul>
<p>j指针的具体回溯如下，并且可以一个<code>int类型数组</code>来存储器其回溯的下标。</p>
<ul>
<li>若当前两个字符匹配，则i++，j++</li>
<li>若j&#x3D;0时发生不匹配，则应让i++，但是此时的next[j]&#x3D;-1</li>
<li>若j&#x3D;1时发生不匹配，则应让j回到0</li>
<li>若j&#x3D;2时发生不匹配，则应让j回到0</li>
<li>若j&#x3D;3时发生不匹配，则应让j回到0</li>
<li>若j&#x3D;4时发生不匹配，则应让j回到1</li>
<li>若j&#x3D;5时发生不匹配，则应让j回到0</li>
</ul>
<p>数组next[0]&#x3D;-1 next[1]&#x3D;0 next[2]&#x3D;0 next[3]&#x3D;0 next[4]&#x3D;1 next[5]&#x3D;0</p>
<blockquote>
<p>BOILERPLATE:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">private int[] next;</span><br><span class="line">public int kmp(String main, String pattern)&#123;</span><br><span class="line">    // 先构建模式串的next数组，下标从0开始</span><br><span class="line">    initNext(pattern);</span><br><span class="line">    int i=0,j=0;</span><br><span class="line">    while(i &lt; main.length() &amp;&amp; j &lt; pattern.length())&#123;</span><br><span class="line">        if(j == -1 || main.charAt(i) == pattern.charAt(j))&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if(j &gt;= pattern.length())&#123;</span><br><span class="line">        return i - pattern.length();</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="next数组的构建（fail数组）"><a href="#next数组的构建（fail数组）" class="headerlink" title="next数组的构建（fail数组）"></a>next数组的构建（fail数组）</h3><ul>
<li>串的前缀：包含第一个字符，且不包含最后一个字符的子串。</li>
<li>串的后缀：包含最后一一个字符，且不包含第一一个字符的子串。</li>
</ul>
<p>对于长度只有1的串来说，其前后缀都是空集。<br>当第j个字符匹配失败时，假定前面<code>1~j-1</code>个字符组成的串为S，那么，<code>next[j]=S的最长相等前后缀的长度</code>（当下标从1开始时，需要+1）。</p>
<blockquote>
<p>BOILERPLATE:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public void initNext(String pattern)&#123;</span><br><span class="line">    // 冗余出最后一个元素位，防止下标溢出</span><br><span class="line">    next = new int[pattern.length() + 1];</span><br><span class="line">    int i = 1, j = 0;</span><br><span class="line">    next[0] = j;</span><br><span class="line">    while(i &lt; pattern.length())&#123;</span><br><span class="line">        if(j == -1 || pattern.charAt(i) == pattern.charAt(j))&#123;</span><br><span class="line">            ++i;</span><br><span class="line">            ++j;</span><br><span class="line">            next[i] = j;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            j = next[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以<code>google</code>为例，上面的Boilerplate执行过程如下：</p>
<ul>
<li>j&#x3D;&#x3D;-1	    i&#x3D;1 j&#x3D;0 	next[1]&#x3D;0   </li>
<li>o!&#x3D;g	    i&#x3D;1 j&#x3D;0  	j &#x3D; next[0] &#x3D; -1</li>
<li>j&#x3D;&#x3D;-1	    i&#x3D;2 j&#x3D;0	    next[2]&#x3D;0</li>
<li>o!&#x3D;g	    i&#x3D;2 j&#x3D;0	    j &#x3D; next[0] &#x3D; -1</li>
<li>j&#x3D;&#x3D;-1	    i&#x3D;3 j&#x3D;0	    next[3] &#x3D; 0</li>
<li>g&#x3D;&#x3D;g	    i&#x3D;4 j&#x3D;1	    next[4] &#x3D; 1</li>
<li>l!&#x3D;o		i&#x3D;4 j&#x3D;1     j&#x3D;next[1] &#x3D; 0</li>
<li>l!&#x3D;g		i&#x3D;4 j&#x3D;0	    j&#x3D;next[0] &#x3D; -1</li>
<li>j&#x3D;&#x3D;-1	    i&#x3D;5 j&#x3D;0     next[5] &#x3D; 0</li>
<li>e!&#x3D;g      i&#x3D;6 j&#x3D;1     break;</li>
</ul>
<h3 id="KMP算法的优化"><a href="#KMP算法的优化" class="headerlink" title="KMP算法的优化"></a>KMP算法的优化</h3>]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>数据结构</tag>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>Algorithm Compilation</title>
    <url>/2020/09/28/Algorithm%20Compilation/</url>
    <content><![CDATA[<blockquote>
<p>程序 &#x3D; 数据结构 + 算法</p>
</blockquote>
<h1 id="算法的效率度量"><a href="#算法的效率度量" class="headerlink" title="算法的效率度量"></a>算法的效率度量</h1><h2 id="时间复杂度（Time-complexity）"><a href="#时间复杂度（Time-complexity）" class="headerlink" title="时间复杂度（Time complexity）"></a>时间复杂度（Time complexity）</h2><p>算法的时间复杂度是一个函数，它定性描述该算法的运行时间，时间复杂度常用大O符号表述，不包括这个函数的低阶项和首项系数，使用这种方式时，时间复杂度可被称为是渐近的（渐近分析（asymptotic analysis、asymptotics），在数学分析中是一种描述函数在极限附近的行为的方法）。<br>例如，如果一个算法对于任何大小为n（必须比n0大）的输入，它至多需要$5n^{3}+3n$的时间运行完毕（也就是时间开销和问题规模n的关系为：$T_{(n)}&#x3D;5n^{3}+3n$，这个时候，低阶项3n应该被抛弃，首项系数5也不保留），那么它的渐近时间复杂度是$O(n^{3})$；某个算法的运行时间至多需要$n^{2}+3n+1000$，那么其时间复杂度为$O(n^{2})$。</p>
<p>渐近规则：</p>
<ul>
<li>多项相加，只保留最高阶的项，且系数变为1；</li>
<li>多项相乘，都保留。</li>
</ul>
<p>阶数由低到高如下：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/0DiJ6d.png"><br>上图从左到右的算法中，随着问题规模的增大，时间开销会依次递增。</p>
<blockquote>
<p>BOILERPLATE:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void test(int n)&#123;// n为问题规模</span><br><span class="line">    int i = 1; // 只运算1次</span><br><span class="line">    while(i&lt;=n)&#123; // 总共会运算n+1次</span><br><span class="line">        i++;     // 总共会运算n次</span><br><span class="line">        doSomething(i);  // 总共会运算n次</span><br><span class="line">    &#125;</span><br><span class="line">    doMore(i);   // 只运算1次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个算法的时间开销与问题规模n关系如下：<br>$T(n)&#x3D;3n+3$<br>换算成渐近的时间复杂度就是<code>O(n)</code>。<br>如果在while循环里面增加一个for循环：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void test(int n)&#123;// n为问题规模</span><br><span class="line">    int i = 1; // 只运算1次</span><br><span class="line">    while(i&lt;=n)&#123; // 总共会运算n+1次</span><br><span class="line">        i++;     // 总共会运算n次</span><br><span class="line">        doSomething(i);  // 总共会运算n次</span><br><span class="line">        for(int j = 0; j &lt; n; j++)&#123; // 共总会运算n次</span><br><span class="line">            doSomething(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    doMore(i);   // 只运算1次</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个算法的时间开销与问题规模n关系如下：<br>$T(n)&#x3D;O(n)+O(n^{2})$<br>换算成渐近的时间复杂度就是$O(n^{2})$（去掉低阶项）。</p>
<blockquote>
<p>如果有多层嵌套循环，只需关注最深层循环循环了几次。</p>
</blockquote>
<h1 id="查找（Search）"><a href="#查找（Search）" class="headerlink" title="查找（Search）"></a>查找（Search）</h1><blockquote>
<p><a href="https://leetcode-cn.com/tag/binary-search/">leetcode二分查找专题</a></p>
</blockquote>
<h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>顺序查找又称现行查找，主要用于在线性表中进行查找，序列有序无序皆可。</p>
<ul>
<li>对无序线性表进行顺序查找，查找失败时要遍历整个线性表。</li>
<li>对有序线性表进行顺序查找，查找失败时不一定要遍历整个线性表。</li>
</ul>
<h2 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h2><p>折半查找又称二分查找，仅适用于有序的顺序表。</p>
<blockquote>
<p>BOILERPLATE:</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 重点在于low和high的摇摆切换</span><br><span class="line">public int BS(int[] arr, int key) &#123;</span><br><span class="line">    int low = 0;</span><br><span class="line">    int high = arr.length - 1;</span><br><span class="line">    int half;</span><br><span class="line">    while (low &lt;= high) &#123;</span><br><span class="line">        half = (low + high) / 2;</span><br><span class="line">        if (arr[half] == key) &#123;</span><br><span class="line">            return half;</span><br><span class="line">        &#125; else if (arr[half] &gt; key) &#123;</span><br><span class="line">            high = half - 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            low = half + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h2><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><ul>
<li>内部排序指在排序期间元素全部存放在内存中的排序。</li>
<li>外部排序指在排序期间元素无法全部同时存放在内存中，必须在排序的过程中根据要求不断地在内、外存之间进行移动。</li>
</ul>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><h3 id="折半（二分）插入排序"><a href="#折半（二分）插入排序" class="headerlink" title="折半（二分）插入排序"></a>折半（二分）插入排序</h3><h2 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h3 id="简单选择排序"><a href="#简单选择排序" class="headerlink" title="简单选择排序"></a>简单选择排序</h3><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h1 id="贪心算法（贪婪算法-x2F-Greedy-Algorithm）"><a href="#贪心算法（贪婪算法-x2F-Greedy-Algorithm）" class="headerlink" title="贪心算法（贪婪算法&#x2F;Greedy Algorithm）"></a>贪心算法（贪婪算法&#x2F;Greedy Algorithm）</h1><blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95">维基百科</a></p>
</blockquote>
<p>在对问题求解时，总是做出在当前看来是最好的选择。简单地说，问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。这种子问题最优解成为最优子结构。<br>贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果,并根据以前的结果对当前进行选择,有回退功能。</p>
<h1 id="动态规划（Dynamic-programming-x2F-DP）"><a href="#动态规划（Dynamic-programming-x2F-DP）" class="headerlink" title="动态规划（Dynamic programming&#x2F;DP）"></a>动态规划（Dynamic programming&#x2F;DP）</h1><blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92">维基百科</a></p>
</blockquote>
<blockquote>
<p><a href="https://www.bilibili.com/video/BV1b7411N798?p=69">参考来源：王道考研</a></p>
</blockquote>
<h1 id="LRU算法（缓存淘汰算法-x2F-页面置换算法-x2F-Least-Recently-Used）"><a href="#LRU算法（缓存淘汰算法-x2F-页面置换算法-x2F-Least-Recently-Used）" class="headerlink" title="LRU算法（缓存淘汰算法&#x2F;页面置换算法&#x2F;Least Recently Used）"></a>LRU算法（缓存淘汰算法&#x2F;页面置换算法&#x2F;Least Recently Used）</h1><h1 id="DFA算法"><a href="#DFA算法" class="headerlink" title="DFA算法"></a>DFA算法</h1><h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><ul>
<li>敏感词中间填充无意义字符问题（当循环到这类无意义的字符时进行跳过，避免干扰）</li>
<li>敏感词用拼音或部分用拼音代替（敏感词用拼音或部分用拼音代替）</li>
</ul>
<blockquote>
<p><a href="https://blog.csdn.net/qq_36827957/article/details/74357283">参考</a></p>
</blockquote>
]]></content>
      <categories>
        <category>algorithm</category>
      </categories>
      <tags>
        <tag>algorithm</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之简单句和复合句</title>
    <url>/2020/09/01/English%E7%B3%BB%E5%88%97%E4%B9%8B%E7%AE%80%E5%8D%95%E5%8F%A5%E5%92%8C%E5%A4%8D%E5%90%88%E5%8F%A5/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记摘选自张满胜老师的《英语语法新思维中级教程第2版》，以及其他网上知识点收集，只是我自己的个人复习笔记，禁止转载，如有侵权，请联系我删除。</p>
</blockquote>
<h2 id="句型一：主语-系动词-表语"><a href="#句型一：主语-系动词-表语" class="headerlink" title="句型一：主语+系动词+表语"></a>句型一：主语+系动词+表语</h2><h3 id="其谓语动词特点"><a href="#其谓语动词特点" class="headerlink" title="其谓语动词特点"></a>其谓语动词特点</h3><p>该句型的谓语动词是系动词，又叫连系动词，顾名思义，这种动词并没有具体的动作，而只是起连接主语和后面成分的作用。这种动词后面所接的成分用来说明主语的特点，表明主语的性质特征，因此被称为主语补足语或表语（能表示主语特征的成分）。</p>
<h3 id="系动词的分类"><a href="#系动词的分类" class="headerlink" title="系动词的分类"></a>系动词的分类</h3><h4 id="单纯表示主语的特征或状态"><a href="#单纯表示主语的特征或状态" class="headerlink" title="单纯表示主语的特征或状态"></a>单纯表示主语的特征或状态</h4><p>这样的系动词有feel，look，sound，taste，smell，seem和appear等。<br>The iron feels hot.这块铁摸起来很热。<br>The rose doesn’t smell much.这枝玫瑰花不是很香。</p>
<h4 id="表示主语由一种状态转变为另一种状态"><a href="#表示主语由一种状态转变为另一种状态" class="headerlink" title="表示主语由一种状态转变为另一种状态"></a>表示主语由一种状态转变为另一种状态</h4><p>这样的系动词有become，grow，get，turn，fall，go和come等。<br>The leaf will turn yellow in autumn.<br>叶子秋天就会变黄。<br>The teacher became angry.<br>老师生气了。</p>
<p>fall, go和come等词作系动词时，与形容词连用一般具有固定的搭配关系。<br>Our supplies of sugar and rice fell short.<br>我们的糖和大米供应不足。<br>The jokes fell flat.这个玩笑毫无效果。<br>The book was old and soon fell apart.<br>这本书很旧，很快就散了。<br>fall due 到期<br>fall asleep 睡着<br>因为这里的fall都是作系动词，所以其后面不能接shortly或flatly这样的副词，即不能说fall shortly<em>或fall flatly</em>等。</p>
<p>go作系动词的例子：<br>go hungry 饿了，挨饿<br>go mad 变疯了<br>go bad 坏掉了<br>go wrong 出错了</p>
<blockquote>
<p>go作系动词时，一般用于贬义，即表示主语是朝着坏的或消极的一面改变。相反，come作为系动词，则是表示褒义的，即表示主语是朝着好的或积极的一面改变。</p>
</blockquote>
<p>Hope your dreams will come true. 祝你好梦成真。<br>The dream has come true. 梦想已经实现。<br>come right 纠正了，正确了</p>
<h4 id="表示主语保持某种状态"><a href="#表示主语保持某种状态" class="headerlink" title="表示主语保持某种状态"></a>表示主语保持某种状态</h4><p>这样的系动词有continue，remain，stay，keep，hold，rest和prove等。<br>He has fallen into the habit of doing morning exercises to stay healthy.<br>不要说stay healthily*，因为副词healthily不能作表语。<br>为了保持健康，他已经养成了晨练的习惯。</p>
<p>He never stays angry for long.<br>不要说stay angrily*，因为副词angrily不能作表语。<br>他生气时间从不会长。</p>
<p>You may rest assured that he will come to the party.<br>rest assured是一个固定搭配。<br>尽管放心，他会来参加聚会的。</p>
<p>The weather continued fine for several days. 连续几天都是晴天。<br>He held silent for the whole day. 他一整天都沉默不语。</p>
<h4 id="近似于不及物动词的系动词"><a href="#近似于不及物动词的系动词" class="headerlink" title="近似于不及物动词的系动词"></a>近似于不及物动词的系动词</h4><p>近似于不及物动词的系动词有 sit，act，arrive，blush，marry，die 和be born等。有人将其称为“半系动词”，因为它们介于不及物动词和系动词之间。<br>He arrived in the U.S. a penniless 21-year-old.<br>首先，介词短语in the U.S. 显然是表示地点的，修饰谓语arrived，即是一个地点状语，表示“他到达了美国”。其次，名词短语a penniless 21-year-old起什么作用呢？作arrived的宾语吗？显然不行，因为arrive是不及物动词，不可能接宾语。从语义上来看，a penniless 21-year-old显然是补充说明主语he的，表示“他到达美国的时候是一个身无分文的21岁的穷小子”，即a penniless 21-year-old是一个主语补足语，也就是相当于表语。可以把这个句子改写成：“He was a penniless 21-year-old when he arrived in the U.S.”。</p>
<blockquote>
<p>从而证明这里的谓语arrived相当于一个系动词的作用，连接主语he 和表语a penniless 21-year-old。</p>
</blockquote>
<p>It lived the life of and died a prairie chicken.<br>这个句子原本的结构是“It lived the life of a prairie chicken and died a prairie chicken.”。名词短语a prairie chicken同时充当两个谓语部分 lived the life of和died的成分。a prairie chicken是作介词of的宾语，但是die是不及物动词，不能接宾语。从语义的角度来看，即使把a prairie chicken看作是died的宾语，也是讲不通的，因为这样一来句子的意思就成了“它把一只草原鸡弄死了”，这显然不对，因为这里it就是a prairie chicken，而不是两种不同的动物。其实，这里的die相当于一个系动词，其后面的名词短语a prairie chicken是用来补充说明主语的，也就是说是主语补足语，可以将其改写成：“It was a prairie chicken when it died. （死的时候它也就是一只普通的草原鸡。）”<br>它就如同一只普通的草原鸡那样度过了一生然后死去。</p>
<p>1） Jane Austin died a spinster.<br>2） He died a hero’s death.<br>这两句话在表面上看都一样，就是在died后面接名词短语，分别是a spinster和a hero’s death。但实际上二者内在的深层结构是不同的。<br>在例句1）中，a spinster作表语或者说是主语补足语，即补充说明主语Jane Austin的性质特征，所以可以将原句改写成“Jane Austin was a spinster when she died.”。<br>但在例句2）中，a hero’s death则不具有a spinster这样的特点，即并不是充当表语来修饰主语he，因为“He was a hero’s death when he died. *”是讲不通的。事实上，a hero’s death是一类较为特殊的宾语，英语里称为“同源宾语”。因为death和die同词源，所以这里的a hero’s death是同源宾语。除了同源宾语外，die不能接其他正常的宾语。比如翻译这个句子“他把这个姑娘杀死了”，不能说“He died the girl. *”，而要说“He killed the girl.”。<br>1）简·奥斯汀去世时，依然未嫁。<br>2）他英勇牺牲了。</p>
<blockquote>
<p>其他可以带同源宾语的不及物动词有live（如“He lived a dog’s life.”），dream（如“He dreamt a beautiful dream.”）等等。</p>
</blockquote>
<p>下面将表语和状语进行比较。<br>1） Lei Feng died young.<br>2） Lei Feng worked hard.<br>在例句1）中，young是形容词，作表语（或者说是主语补足语），说明主语Lei Feng的性质特征，所以可将原句改写成“Lei Feng was young when he died.”。从这个句子里也可看出young不是用来修饰谓语动词die的。<br>而在例句2）中，hard是副词，作状语，用来修饰work，说明work的行为特征，而不是说明主语Lei Feng的性质特征。所以，不能将这句话改写成：“Lei Feng is hard when he works. *”。<br>1）雷锋英年早逝。<br>2）雷锋工作很努力。</p>
<p>He died a local company manager.<br>这句话相当于“He was a local company manager when he died.”。<br>他死的时候是一家公司的经理。</p>
<p>1） Don’t act stupid.<br>2） Don’t act stupidly.<br>这两句话仅有形容词stupid和副词stupidly一词之差，但两句话的意思不同。在例句1）中，act是作系动词，表示to appear or seem to be，所以这个act不是讲行为动作，而只是讲故意装出某种样子。<br>而在例句2）中，由于是用副词stupidly作状语来修饰谓语动词act以说明行为动作的特点，所以这里的act是讲具体的行为动作。<br>1）别装傻。<br>2）别笨手笨脚的。</p>
<p>act作行为动词和系动词时的词义区别：<br>1） I acted foolish.<br>2） I’m ashamed I acted foolishly.<br>在例句1）中，act是系动词，后接形容词foolish作表语。在例句2）中，act是行为动词，后接副词foolishly作状语。<br>1）我当时只是故意装傻。<br>2）我为自己的愚蠢行为感到羞耻。</p>
<blockquote>
<p>“装病”就应该说成act sick，而不能说act sickly。</p>
</blockquote>
<p>He acted quickly and seized the thief.<br>这里的act是行为动词，后接副词quickly作状语。<br>他动作很快，一下子就抓住了窃贼。</p>
<p>All the audience sat silent.<br>这里的silent是说明主语all the audience的特征，而不是修饰sat，故不用silently。<br>全场观众鸦雀无声。<br>He was born poor.<br>这里的poor是说明主语he的特征，而不是修饰born，故不用poorly。<br>他出身贫寒。<br>The boy blushed scarlet.<br>这里的scarlet是说明主语the boy的特征，而不是修饰blushed。<br>这孩子羞红了脸。<br>I married young.<br>这里的young是说明主语I的特征，而不是修饰married，所以这句话可以改写成“I was young when I married.”。<br>我结婚早。</p>
<h3 id="简单句叠加成复杂难句"><a href="#简单句叠加成复杂难句" class="headerlink" title="简单句叠加成复杂难句"></a>简单句叠加成复杂难句</h3><p>Vitamins are organic compounds.<br>这个句子的主语是vitamins，谓语是系动词are，名词短语organic compounds是表语。<br>维生素是一种有机化合物。<br>这个句子很简单，但现在要逐步将其复杂化。比如在名词compounds后面添加一个后置定语，如下句：<br>Vitamins are organic compounds necessary for the normal growth of life.<br>这里我们添加了一个形容词短语necessary for the normal growth of life，将其后置修饰名词compounds。<br>维生素是一种有机化合物，是生命正常生长所必不可少的。<br>进一步把后置定语复杂化：<br>Vitamins are organic compounds necessary for the normal growth and maintenance of life of animals, including man.<br>这里的形容词短语是necessary for the normal growth and maintenance of life of animals, including man，依然将其后置修饰名词compounds。<br>维生素是一种有机化合物，是所有动物（包括人类）正常生长和生命延续所必不可少的。<br>还可以把上句进一步复杂化：<br>Vitamins are organic compounds necessary in small amounts in the diet for the normal growth and maintenance of life of animals, including man.<br>这里是在necessary和for之间添加了介词短语in small amounts in the diet，整个形容词短语是 necessary in small amounts in the diet for the normal growth and maintenance of life of animals, including man，依然将其后置修饰名词compounds。<br>维生素是一种有机化合物，尽管在饮食中的含量很少，但却是所有动物（包括人类）正常生长和生命延续所必不可少的。</p>
<h2 id="句型二：主语-谓语"><a href="#句型二：主语-谓语" class="headerlink" title="句型二：主语+谓语"></a>句型二：主语+谓语</h2><h3 id="其谓语动词特点-1"><a href="#其谓语动词特点-1" class="headerlink" title="其谓语动词特点"></a>其谓语动词特点</h3><p>该句型的谓语动词是不及物动词（intransitive verb），所表示的动作没有作用对象，其本身意思完整，其后不需带宾语。<br>The egg hatched.<br>The little eagle grew up.<br>It clucked and cackled.<br>最后一句话的谓语是并列谓语，即有两个动词clucked和cackled充当谓语。这些动词都是不及物动词，所以没有接宾语。</p>
<ol>
<li>这枚蛋孵化成了一只小鹰。</li>
<li>小鹰慢慢长大了。 </li>
<li>它发出咯咯的叫声。</li>
</ol>
<p>尽管这个句型里没有宾语，但是在谓语动词后面往往会接状语，用来修饰谓语动词，比如表示动作发生的地点等。<br>An eagle’s egg（主语）was placed（谓语）in the nest of a prairie chicken（地点状语）.<br>一只苍鹰的蛋被放置在一只草原土鸡的窝里。</p>
<p>It scratched in the dirt for seeds.<br>It（主语）scratched（谓语）in the dirt（地点状语）for seeds（目的状语）.<br>它在土里找种子吃。</p>
<h3 id="简单句叠加成复杂难句-1"><a href="#简单句叠加成复杂难句-1" class="headerlink" title="简单句叠加成复杂难句"></a>简单句叠加成复杂难句</h3><p>This trend began during the Second World War.<br>该句的主语是this trend，谓语began是一个不及物动词，后边没有带宾语。介词短语during the Second World War作时间状语。<br>这种趋势始于第二次世界大战期间。<br>下面开始一步步把这个句子复杂化：<br>This trend began during the Second World War, when several governments came to the conclusion.<br>这里加了一个定语从句when several governments came to the conclusion，来修饰时间the Second World War。<br>这种趋势始于第二次世界大战期间，当时一些国家的政府得出这样的结论。<br>再进一步把这个句子复杂化：<br>This trend began during the Second World War, when several governments came to the conclusion that the specific demands cannot generally be foreseen in detail.<br>这里添加了一个同位语从句that the specific demands cannot generally be foreseen in detail，补充说明conclusion。这个同位语从句也是一个“主语+谓语”的句型，这里的主语是the specific demands，谓语是一个被动结构cannot generally be foreseen，介词短语in detail作状语。<br>这种趋势始于第二次世界大战期间，当时一些国家的政府得出结论：具体要求通常是无法详尽预见的。<br>再进一步把这个句子复杂化:<br>This trend began during the Second World War, when several governments came to the conclusion that the specific demands that a government wants to make of its scientific establishment cannot generally be foreseen in detail.<br>这里添加了一个定语从句that a government wants to make of its scientific establishment，来修饰the specific demands。这个定语从句是一个“主语+谓语+宾语”的句型，主语是a government，谓语是wants，宾语是to make of its scientific establishment。这里的that指代先行词demands，在定语从句中作谓语make的宾语，从而构成一个make demands of的搭配，表示“对……提出要求”。<br>这种趋势始于第二次世界大战期间，当时一些国家的政府得出结论：政府想向科研机构提出的具体要求通常是无法详尽预见的。</p>
<h2 id="句型三：主语-谓语-宾语"><a href="#句型三：主语-谓语-宾语" class="headerlink" title="句型三：主语+谓语+宾语"></a>句型三：主语+谓语+宾语</h2><h3 id="其谓语动词特点-2"><a href="#其谓语动词特点-2" class="headerlink" title="其谓语动词特点"></a>其谓语动词特点</h3><p>该句型的谓语动词是及物动词（transitive verb），这种动词告诉我们由主语发出的动作所作用的对象是什么，这个“所作用的对象”就是通常所说的宾语，即宾语是主语动作的承受对象。英文中绝大多数动词都是及物动词。<br>But the not-so-easy way may mean getting down on your hands and knees and pulling out the weeds by the roots.<br>但是复杂方法意味着你自己得双膝跪地，然后用双手把杂草连根拔除。<br>They are looking for one-minute solutions to everything.<br>他们想投机取巧，对一切事情都想快速解决。<br>Just like instant coffee, they want instant happiness.<br>这就像速溶咖啡一样，他们想要的只是“幸福快餐”。<br>There are no quick fixes. This attitude leads to disappointment or even failure.<br>生活中没有捷径，一味想找捷径最终会导致失望甚至失败。<br>在以上例句中，谓语动词mean和want都是及物动词。若是不及物动词，则可以加适当的介词，然后再接宾语，比如looking for和leads to。</p>
<h3 id="简单句叠加成复杂难句-2"><a href="#简单句叠加成复杂难句-2" class="headerlink" title="简单句叠加成复杂难句"></a>简单句叠加成复杂难句</h3><p>The emphasis helped to obscure the great importance.<br>该句的主语是the emphasis，谓语是helped，宾语是不定式短语to obscure the great importance。<br>这种强调模糊了这一重要性。<br>一步步把这个句子复杂化：<br>The emphasis given by both scholars and statesmen helped to obscure the great importance.<br>这里是在主语emphasis后面添加了一个分词短语given by both scholars and statesmen，作后置定语，表明是谁在强调。<br>学者和政治家们的这种强调模糊了这一重要性。<br>再进一步把这个句子复杂化：<br>The emphasis given by both scholars and statesmen to the presumed disappearance of the American frontier helped to obscure the great importance.<br>介词短语to the presumed disappearance of the American frontier是补充说明主语emphasis的，表明强调的内容是什么。<br>学者和政治家们强调美国边疆消失的假设，这种强调模糊了这一重要性。<br>再进一步把这个句子复杂化：<br>The emphasis given by both scholars and statesmen to the presumed disappearance of the American frontier helped to obscure the great importance of changes in the conditions and consequences of international trade.<br>这里在importance后面添加了介词短语of changes in the conditions and consequences of international trade，作后置定语。这里还要搞清楚并列关系，不是changes in the conditions和consequences of international trade并列，而是conditions和consequences并列，然后介词短语of international trade修饰conditions and consequences，表示“国际贸易的条件和后果”。<br>最后整个介词短语in the conditions and consequences of international trade修饰changes，表示在哪方面发生的变化，即“在国际贸易的条件和后果两方面发生的变化”。<br>学者和政治家们强调美国边疆消失的假设，这种强调模糊了国际贸易的条件和后果方面发生变化的巨大作用。<br>再进一步把这个句子复杂化：<br>The emphasis given by both scholars and statesmen to the presumed disappearance of the American frontier helped to obscure the great importance of changes in the conditions and consequences of international trade that occurred during the second half of the nineteenth century.<br>这里在international trade后面添加了定语从句that occurred during the second half of the nineteenth century，作后置定语。这个定语从句则是一个“主语+谓语”的句型，其主语是关系词that，谓语是 occurred。<br>学者和政治家们强调美国边疆消失的假设，这种强调模糊了在19世纪后半期国际贸易的条件和后果两方面发生变化的巨大作用。<br>综上所述，这个复杂的句子其实就是一个“主语+谓语+宾语”的句型，即the emphasis…helped to obscure the great importance…。其内部又带有一个“主语+谓语”的句型，即that occurred…。</p>
<h2 id="句型四：主语-谓语-间接宾语-直接宾语"><a href="#句型四：主语-谓语-间接宾语-直接宾语" class="headerlink" title="句型四：主语+谓语+间接宾语+直接宾语"></a>句型四：主语+谓语+间接宾语+直接宾语</h2><h3 id="其谓语动词的特点"><a href="#其谓语动词的特点" class="headerlink" title="其谓语动词的特点"></a>其谓语动词的特点</h3><p>该句型的谓语动词是双宾动词（dative verb），这种动词后面所接的成分有人又有物。一般来讲，这里的“人”表示动作的接受者，称作间接宾语（indirect object）；“物”表示动作作用的对象，是动作的承受者，称作直接宾语（direct object）。间接宾语和直接宾语合起来称为双宾语。<br>He showed the guard（间接宾语）his passport（直接宾语）.<br>对于这个句型，一般可以进行这样的改写，即把直接宾语提前至谓语后面，然后添加介词to或for，再把间接宾语放在介词后面。比如上面这个句子可以改写成“He showed his passport to the guard.”。<br>他把护照给门卫看了。<br>I am going to buy her a gift.&#x3D;I am going to buy a gift for her.<br>我打算给她买个礼物。</p>
<p><em><strong>选择介词for还是to，取决于谓语动词。</strong></em>具体详述如下：</p>
<ul>
<li>同show一样，当间接宾语后移时，间接宾语前需带介词to，表示间接宾语是动作的接受者。这样的动词有：assign，award，bring， deliver，deny，feed，give，grant，hand，lend，offer，owe，pass， pay，promise，post，read，recommend，sell，send，show，take和write 等等。</li>
<li>同buy一样，当间接宾语后移时，间接宾语前需带介词for。这样的动词有：book （预订），buy，build，change，choose，cook， fetch，find，get，keep，make，order，prepare和sing等等。</li>
<li>有个别动词只用于“主语+动词+间接宾语（+直接宾语）”的结构，而不用介词来替换。这样的动词有：charge，cost和bet等等。比如：<br>I’ll bet you ten dollars. 我跟你赌10美元。<br>The repairman charged me ten dollars. 修理工收了我10美元。<br>上面这些句子都是无法用for或to来改写的。</li>
<li>还有更特殊的动词（如ask）当间接宾语后移时，间接宾语前需带介词of。比如：<br>Can I ask you a question?&#x3D;Can I ask a question of you? 我能问你一个问题吗？<br>I have a question to ask of you. 我有一个问题要问你。<br>I have a big favor to ask of you. 我想请你帮个忙。</li>
</ul>
<h3 id="简单句叠加成复杂难句-3"><a href="#简单句叠加成复杂难句-3" class="headerlink" title="简单句叠加成复杂难句"></a>简单句叠加成复杂难句</h3><p>Her work won her the Nobel Prize in 1983.<br>该句的动词won是一个双宾动词，其后要接双宾语，即 win sb. sth.，表示“为某人赢得某物”。这里的her是间接宾语，the Nobel Prize是直接宾语。<br>她的工作使她赢得了1983年的诺贝尔奖。<br>Her work in genetics won United States scientist Barbara McClintock the Nobel Prize in 1983.<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/cb2rKF.png"><br>原句型为<code>win sb. sth.，</code>即表示“为某人赢得某物”。<br>芭芭拉·麦克林托克在遗传学领域的研究成果使她赢得了1983年的诺贝尔奖。</p>
<h2 id="句型五：主语-谓语-宾语-宾语补足语"><a href="#句型五：主语-谓语-宾语-宾语补足语" class="headerlink" title="句型五：主语+谓语+宾语+宾语补足语"></a>句型五：主语+谓语+宾语+宾语补足语</h2><h3 id="其谓语动词的特点-1"><a href="#其谓语动词的特点-1" class="headerlink" title="其谓语动词的特点"></a>其谓语动词的特点</h3><p>该句型的谓语动词是宾补动词（factitive verb），这种动词后面接宾语，而此宾语后又接补充说明宾语的补足语（object complement）。宾语和宾语补足语合起来称为复合宾语。<br>常见的带复合宾语的动词有：appoint，believe，call，choose， consider，declare，elect，feel，find，keep，leave，let，make，name， nominate，prove，see，suppose和vote等等。请看例句：<br>I very much hope that this new medium will make my Christmas message more personal and direct.<br>从句中的宾语是my Christmas message，宾语补足语是more personal and direct。<em><strong>这里是形容词作宾语补足语。</strong></em><br>我衷心希望，这种新媒体能让我的圣诞寓意更有人情味、更加直接。</p>
<p>A hedge （树篱） between keeps friendship green.<br>该句的宾语是friendship，宾语补足语是green。<em><strong>这里是形容词作宾语补足语。</strong></em><br>保持距离，友谊长青。（这句话可引申为“君子之交淡如水”。）</p>
<p>They appointed John chairman.<br>该句的宾语是John，宾语补足语是chairman。<em><strong>这里是名词作宾语补足语。</strong></em><br>他们任命约翰为主席。</p>
<p>I believe him to be true.<br>该句的宾语是him，宾语补足语是to be true。<em><strong>这里是不定式作宾语补足语。</strong></em><br>我相信他是真诚的。</p>
<p>The chairman declared the meeting over.<br>该句的宾语是the meeting，宾语补足语是over。<em><strong>这里是副词作宾语补足语。</strong></em><br>主席宣布会议结束。</p>
<h3 id="区分双宾语和复合宾语"><a href="#区分双宾语和复合宾语" class="headerlink" title="区分双宾语和复合宾语"></a>区分双宾语和复合宾语</h3><p>区分这两种宾语的方法很简单，就是在宾语后面加上be动词，若能构成一个语义通顺的句子，即是补足语。因为宾语与宾语补足语的语义关系就相当于主语与主语补足语的关系，即类似一个主系表结构，而间接宾语与直接宾语二者之间就没有这样的语义关系。<br>1） I made John our chairman.<br>2） I made John a cake.<br>在例句1）中，在宾语John后面添加is，即“John is our chairman.”。这说得通，所以例句1）中的our chairman是宾语补足语。<br>而在例句2）中，在宾语John后面添加is，即“John is a cake.* （约翰是一块蛋糕。）”。这显然讲不通，所以例句2）是一个双宾语结构，a cake是直接宾语。<br>1）我选了约翰当我们的主席。<br>2）我给约翰做了一块蛋糕。</p>
<p>1） She will make him a good husband.<br>2） She will make him a good wife.<br>在例句1）中，在宾语him后面加上 is，即“He is a good husband.”。这说得通，所以例句1）是一个复合宾语结构，句中的a good husband是宾语补足语。<br>而在例句2）中，在宾语him后面加上is，即“He is a good wife.* （他是一个好妻子。）”。这显然有悖常理。实际上它是补充说明主语she的，应该算作主语补足语，例句2）可以改写为“She will make a good wife for him.”。<br>在例句1） 中，make是大家熟悉的使役动词，英文解释是to cause to be or become，表示“使……成为”；而在例句2）中，make并非使役动词，英文解释是to develop into，表示“成为”。<br>1）她会把他变成一个好丈夫。<br>2）她会成为他的好妻子。</p>
<h3 id="简单句叠加成复杂难句-4"><a href="#简单句叠加成复杂难句-4" class="headerlink" title="简单句叠加成复杂难句"></a>简单句叠加成复杂难句</h3><p>Willa Cather considered this novel her best work.<br>该句的动词considered是一个宾补动词，其后不但要带宾语this novel，还要接宾语补足语her best work，补充说明前面的宾语。若只说“Willa Cather considered this novel.*”，这句话的意思显然不完整。<br>薇拉·凯瑟认为这部小说是她最好的一部作品。<br>把这句话稍微变得复杂一点：<br>Willa Cather considered her novel of life in nineteenth-century Nebraska, My Antonia her best work.<br>这句话的宾语较长，是her novel of life in nineteenth- century Nebraska, My Antonia，其中My Antonia是小说的名字，与名词短语her novel of life in nineteenth-century Nebraska构成同位语。宾语补足语是her best work。<br>薇拉·凯瑟认为她的那部描写19世纪内布拉斯加州生活的小说《我的安东尼亚》是她最好的一部作品。</p>
<h2 id="复合句框架图"><a href="#复合句框架图" class="headerlink" title="复合句框架图"></a>复合句框架图</h2><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/T1fST3.png"></p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之定语从句</title>
    <url>/2020/09/09/English%E7%B3%BB%E5%88%97%E4%B9%8B%E5%AE%9A%E8%AF%AD%E4%BB%8E%E5%8F%A5/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记摘选自张满胜老师的《英语语法新思维中级教程第2版》，以及其他网上知识点收集，只是我自己的个人复习笔记，禁止转载，如有侵权，请联系我删除。<br>思维导图版本<a href="http://www.xmind.net/m/FtkHvu">点击这里</a></p>
</blockquote>
<h2 id="定语从句概述"><a href="#定语从句概述" class="headerlink" title="定语从句概述"></a>定语从句概述</h2><p>在英文中，被定语从句所修饰的对象叫作antecedent，英文中对这个词的解释是a word, phrase, clause, or sentence to which a pronoun refers，即表示“代词所指代的词、短语、从句或句子”，所以先行词可以是一个词、短语、分句或者独立的句子等。</p>
<h3 id="形容词作定语与从句作定语比较"><a href="#形容词作定语与从句作定语比较" class="headerlink" title="形容词作定语与从句作定语比较"></a>形容词作定语与从句作定语比较</h3><p>当要表达复杂的意思时，往往需要借助于定语从句来完成，即要用定语从句来修饰某个名词或名词短语。比如当我们说“我不喜欢懒人”，这时只需要用一个形容词lazy来作定语就可以。<br>I don’t like lazy people.<br>如果要表达稍微复杂一点的意思，比如说“我不喜欢不守信用的人”，这时，简单地用形容词作定语就无能为力了，就要借助于一个句子来修饰名词，用作名词的定语，对名词进行限制。<br>I don’t like people who never keep their word.<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/KmgSIt.png"></p>
<h3 id="定语从句的两个重要概念：先行词和关系词"><a href="#定语从句的两个重要概念：先行词和关系词" class="headerlink" title="定语从句的两个重要概念：先行词和关系词"></a>定语从句的两个重要概念：先行词和关系词</h3><p>被定语从句所修饰的对象称为先行词。<br>重复指代先行词、起连接主句和从句的作用，并且在定语从句中充当一定成分的连接词称为关系词。<br>关系词有两个作用：</p>
<ul>
<li>代词的作用： 重复指代先行词并且在定语从句中充当一定成分。</li>
<li>连接作用：即连接主句和从句。</li>
</ul>
<h2 id="先行词的结构特点"><a href="#先行词的结构特点" class="headerlink" title="先行词的结构特点"></a>先行词的结构特点</h2><h3 id="先行词是一个词"><a href="#先行词是一个词" class="headerlink" title="先行词是一个词"></a>先行词是一个词</h3><p>先行词可以是一个单词，通常是名词，也可以是代词。主要包括：人称代词he（其他人称代词不可以），指示代词that&#x2F;those，不定代词one等。<br>There is this difference between happiness and wisdom: he who thinks himself the happiest man really is so; but he who thinks himself the wisest is generally the greatest fool.<br>这里的两个定语从句的先行词都是代词he。注意：这里的he不是具体指某个人，而是表示泛指。一般来讲，人称代词后面是不能接定语从句的，比如我们不能说“We who think ourselves…*”，或“You who think yourself…*”等等，因为人称代词已经表达了一个完整的意思，不需要任何定语从句来修饰。但人称代词若是表示泛指，则可以接定语从句来进行修饰<br>幸福与智慧的区别在于：认为自己最幸福的人，他真的就是最幸福；而认为自己最智慧的人，却往往是最大的傻瓜。</p>
<p>Only those who have the patience to do simple things perfectly will acquire the skill to do difficult things easily.<br>这里的those指人，作先行词，被定语从句who have the patience to do simple things perfectly所修饰。<br>只有那些有耐心将简单的事情做得完美的人，才能学会轻松地做好难事的技能。</p>
<h3 id="先行词是一个短语"><a href="#先行词是一个短语" class="headerlink" title="先行词是一个短语"></a>先行词是一个短语</h3><p>In Europe, as elsewhere, multi-media groups have been increasingly successful groups which bring together television, radio, newspapers, magazines and publishing houses that work in relation to one another.<br>这里的关系词which指代的先行词是successful groups这个名词短语，关系词that指代的先行词是television, radio, newspapers, magazines and publishing houses这个名词短语。<br>在欧洲，像在其他地方一样，多媒体集团越来越成功了。这些集团把相互间联系密切的电视台、电台、报纸、杂志以及出版社组合到了一起。</p>
<h3 id="先行词是一个分句"><a href="#先行词是一个分句" class="headerlink" title="先行词是一个分句"></a>先行词是一个分句</h3><p>He said that he had no time, which isn’t true.<br>这里which指代的是一个宾语从句that he had no time。<br>他说他没有时间，事实并非如此。</p>
<h3 id="先行词是一个完整的句子"><a href="#先行词是一个完整的句子" class="headerlink" title="先行词是一个完整的句子"></a>先行词是一个完整的句子</h3><p>My girlfriend likes dancing with other guys, which really drives me crazy.<br>先行词是my girlfriend likes dancing with other guys这一完整的句子。<br>我女友喜欢和别的小伙子跳舞，这让我十分恼火。</p>
<h2 id="先行词的位置特点"><a href="#先行词的位置特点" class="headerlink" title="先行词的位置特点"></a>先行词的位置特点</h2><h3 id="先行词-其他定语-定语从句"><a href="#先行词-其他定语-定语从句" class="headerlink" title="先行词+其他定语+定语从句"></a>先行词+其他定语+定语从句</h3><p>这种情形最常见。这是由于先行词同时带有多个定语，定语从句与其他定语相比，一般较长，结构也较复杂，因此，按照英语的“尾重原则（principle of end weight）”，结构复杂的定语从句置于其他定语后边，从而造成与先行词隔离。<br>The mineral elements from the soil that are usable by the plant must be dissolved in the soil solution before they can be taken into the root.<br>土壤中可供植物利用的矿物质只有先溶解在土壤中，然后才能被植物的根部吸收。</p>
<h3 id="先行词-状语-定语从句"><a href="#先行词-状语-定语从句" class="headerlink" title="先行词+状语+定语从句"></a>先行词+状语+定语从句</h3><p>造成先行词与关系词被分隔的第二种情形，就是在先行词与关系词之间插入一个状语，这个状语一般是修饰主句的谓语动词的。<br>Never leave that until tomorrow which you can do today.<br>这里的先行词是that，定语从句是which you can do today。现在二者之间插入了一个时间状语until tomorrow来修饰leave，从而造成先行词与关系词被分隔。<br>今日事，今日毕（不要把今天能做的事情留到明天做）。</p>
<p>If there is anything in the world that a young man should be more grateful for than another, it is the poverty which necessitates starting life under very great disadvantage.<br>这里的 关系代词that在从句中作介词for的宾语。<br>对于青年人来说，如果世上真的有什么事物是他最应该感激的，那就是贫穷，因为贫穷能促使他在非常恶劣的环境下开创生活。</p>
<h3 id="作主语的先行词-谓语部分-定语从句"><a href="#作主语的先行词-谓语部分-定语从句" class="headerlink" title="作主语的先行词+谓语部分+定语从句"></a>作主语的先行词+谓语部分+定语从句</h3><p>先行词与关系词被分隔的第三种情形就是两者被主句谓语隔开。这是因为先行词在主句中作主语，然后它又被一个定语从句所修饰，而定语从句一般都会比主句谓语的结构复杂。因此，按照英语的“尾重原则（principle of end weight）”，结构复杂的定语从句置于主句谓语后边，从而造成关系词与先行词被隔离。<br>It can be predicted, however, that from time to time questions will arise which will require specific scientific answers.<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/FOWXxR.png"><br>然而，可以预见的是，将来会经常出现一些问题，这些问题需要给出专门的科学的回答。</p>
<p>Social science is that branch of intellectual enquiry which seeks to study humans and their endeavors in the same reasoned, orderly, systematic, and dispassioned manner that natural scientists used for the study of natural phenomena.<br>社会科学是知识探索的一个分支，它力图像自然科学家研究自然现象那样，用理性的、有序的、系统的和冷静的方式研究人类及其行为。</p>
<h2 id="定语从句中的主谓一致问题"><a href="#定语从句中的主谓一致问题" class="headerlink" title="定语从句中的主谓一致问题"></a>定语从句中的主谓一致问题</h2><blockquote>
<p>定语从句的谓语动词是用单数还是用复数，这不取决于关系词，而是由先行词决定的。</p>
</blockquote>
<p>Despite【A】 much research, there are still certain elements in【B】 the life cycle of the insect that is【C】 not fully understood【D】.<br>C，应改为are。<br>这里先行词elements与关系词that被分隔，因为elements还有一个后置定语in the life cycle of the insect。显然，这种分隔属于：先行词+其他定语+定语从句。that指代elements，在从句中作主语，所以，谓语动词要用复数形式的are。</p>
<h2 id="关系词在定语从句中充当的成分"><a href="#关系词在定语从句中充当的成分" class="headerlink" title="关系词在定语从句中充当的成分"></a>关系词在定语从句中充当的成分</h2><h3 id="关系词用作从句的主语"><a href="#关系词用作从句的主语" class="headerlink" title="关系词用作从句的主语"></a>关系词用作从句的主语</h3><p>比较简单句和定语从句，看看一个简单句如何变成定语从句。<br><em><strong>The woman</strong></em> is a famous dancer and she lives next door.<br>这个句中有一个“重复元素”，这里的she指代 the woman，即两句之间有一个交叉点，而通过这个交叉点建立起两句之间的联系。现在要用she lives next door来作定语修饰the woman，以告诉对方哪位女士是舞蹈演员。而在定语从句中，指代“人”的关系词要用who。<br>因此，上句可改写成：<br>The woman is a famous dancer who (&#x3D;and she) lives next door.<br>这里的关系词who既取代了代词she也取代了连词and， 即who既具有代词的作用也起着连接的作用。另外，定语从句一般要紧跟在它所修饰的名词后面。因此，上一句又可进一步改写成：<br>The woman who lives next door is a famous dancer.<br>由此看到，关系词who既指代the woman，同时又在从句中作主语，而且还替换了and，起着连词的作用。<br>这位女士是一名著名的舞蹈演员，她就住在我家隔壁。</p>
<p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/ONSgS8.png"><br>这里的关系词who取代and they，来引导定语从句who have a good sense of humor，修饰名词guys。<br>我喜欢有幽默感的男士。</p>
<p>在变换过程中要注意三点：</p>
<ul>
<li>用关系词who代替人称代词（如she或they）后，定语从句里就不能再保留这些代词了。比如不能说：<br>The woman who she lives next door is a famous dancer. *<br>I like guys who they have a good sense of humor. *</li>
<li>事实上，定语从句可以修饰一个主句当中的任何一个名词。但是，我们关注的往往是关系词在定语从句中所充当的成分，不关心定语从句是修饰主句的哪个名词。</li>
<li>定语从句的谓语动词形式是由关系词所指代的先行词来决定的，而不是取决于关系词本身。定语从句who lives next door中的who指代的woman是单数名词，故谓语用单数的lives；而定语从句who have a good sense of humor中的who指代的guys是复数名词，故谓语用复数的have。</li>
</ul>
<p>Anger is a thief who steals away the nice moments .<br>愤怒就如同一个窃贼，盗取了我们的幸福时光。<br>He who is not handsome at twenty, nor strong at thirty, nor rich at forty, nor wise at fifty , will never be handsome, strong, rich, or wise.<br>一个人若在20岁时不俊美、30岁时不健康、40岁时不富有、50岁时不明智，那么他将永远不会拥有这些。<br>There is this difference between happiness and wisdom: the person who thinks himself the happiest man really is so; but the person who thinks himself the wisest is generally the greatest fool.<br>幸福与智慧区别于此：认为自己是最幸福的，他真的就是最幸福的；而认为自己是最有智慧的，他却往往是最大的傻瓜。<br>The world is a book, and those who do not travel read only one page.<br>世界犹如一本书，而那些从不出门旅行的人仅仅读了这本书的一页。<br>Of course I am not talking about easy-come-easy-go friendship. I’m talking about friends who care deeply about each other, who support each other, who make life worth living.<br>当然了，我这里所说的友谊不是那种“来得快去得也快”的泛泛之交，而是那种彼此之间能真正互相关心的朋友，能够互相支持的朋友，能够让你的人生更有意义的朋友。</p>
<h3 id="关系词用作从句中动词的宾语"><a href="#关系词用作从句中动词的宾语" class="headerlink" title="关系词用作从句中动词的宾语"></a>关系词用作从句中动词的宾语</h3><p>关系词除了在定语从句中作主语外，还可以在从句中作宾语。而且，还可以进一步区分为从句动词的宾语和从句介词的宾语。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/8WGhly.png"><br>在例句1）中，这里的him指代名词短语a friend，可以用关系词who来替代him，充当动词trust的宾语。又因为who有连词的作用，所以此时and就要去掉了，如例句2）所示。另一方面，关系词who要置于从句的开头，所以要把who移到I的前面，原句从而变成了下面的例句3）：<br>3）I’d really like to find a friend who I can trust completely.<br>我想找一个我完全能够信任的人做朋友。</p>
<p>He is the best grammar teacher who I have ever seen.<br>他是我见过的最好的语法老师。</p>
<p>It’s hard to have a friend who you can trust completely.<br>很难有一个你能完全信任的朋友。</p>
<h3 id="关系词用作从句中介词的宾语"><a href="#关系词用作从句中介词的宾语" class="headerlink" title="关系词用作从句中介词的宾语"></a>关系词用作从句中介词的宾语</h3><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/YGRKuS.png"><br>这里的who充当介词with的宾语。<br>我这里说的朋友，是指那些你几乎可以把一切与之分享的人。</p>
<p>I hope I never have a boss who I can’t talk to about my problems.<br>这里的who充当介词to的宾语。<br>我不希望有一个无法与其谈论我的问题的老板。</p>
<p>I’d prefer someone who I have something in common with — who I can talk to easily.<br>这里的关系词who分别充当介词with和to的宾语。<br>我喜欢那些与我有共同点的人，这样易交流。</p>
<h3 id="作宾语的关系词可以省去"><a href="#作宾语的关系词可以省去" class="headerlink" title="作宾语的关系词可以省去"></a>作宾语的关系词可以省去</h3><p>作宾语的关系词可以省去，不论关系词是作动词的宾语还是作介词的宾语都可以省去。比如以上讨论过的相关例句，可以分别改写成：<br>I’d really like to find a friend ( ) I can trust completely.<br>I hope I never have a boss ( ) I can’t talk to about my problems.</p>
<blockquote>
<p>在从句中作主语的关系词无法省去。比如不能说：</p>
</blockquote>
<p>I like guys ( ) have a good sense of humor. *</p>
<h2 id="关系代词与先行词的搭配关系"><a href="#关系代词与先行词的搭配关系" class="headerlink" title="关系代词与先行词的搭配关系"></a>关系代词与先行词的搭配关系</h2><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/gScElI.png"></p>
<h3 id="先行词指“人”，用关系代词who或whom"><a href="#先行词指“人”，用关系代词who或whom" class="headerlink" title="先行词指“人”，用关系代词who或whom"></a>先行词指“人”，用关系代词who或whom</h3><h3 id="who和whom的区别"><a href="#who和whom的区别" class="headerlink" title="who和whom的区别"></a>who和whom的区别</h3><ul>
<li>who的前面不能与介词搭配使用<br>因为who是主格形式，所以在介词的后面不能用who，比如不说with who*，而说with whom。<br>I’m talking about friends who you can share almost everything with.<br>不能说“I’m talking about friends with who you can share almost everything. *”。<br>而应该说“I’m talking about friends with whom you can share almost everything.”。<br>主格形式的who除了作定语从句的主语外，还可以充当定语从句的宾语或表语。</li>
<li>whom在定语从句中不能作主语，但可作宾语或表语<br>A rich person is not one who has the most, but is one who needs the least.<br>这里的who作从句的主语，所以不能用whom，不说whom has…*。<br>一个富有的人，不是因为他拥有的最多，而是因为他需要的最少。</li>
</ul>
<p>Only the people who have the patience to do simple things perfectly will acquire the skill to do difficult things easily.<br>这里的who作从句的主语，所以不能用whom，不说whom have…*。<br>只有有耐心圆满完成简单工作的人，才能够轻而易举地完成困难的事。</p>
<blockquote>
<p>总之，who可以作主语，也可以代替whom作宾语或表语，但不能用在介词后面。而因为whom是宾格形式，所以不能作主语。</p>
</blockquote>
<h3 id="表示人或物的所有关系，用whose"><a href="#表示人或物的所有关系，用whose" class="headerlink" title="表示人或物的所有关系，用whose"></a>表示人或物的所有关系，用whose</h3><p>whose表示所有关系，其作用就如同物主代词my，your，her，his，their和our，whose的后面要接名词。whose可指人也可指物。“whose+名词”在从句中可作主语、动词的宾语或介词的宾语，whose同that一样，既可以指人，也可以指物。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/7KbXpL.png"><br>例句2）里的whose代替了例句1）里的his，指friend，即表示人。<br>我认识一个朋友，他哥哥是一名流行歌手。</p>
<p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/FzNNnM.png"><br>例句2）里whose代替了例句1）里的its，指schoolroom，即表示物。<br>这些孩子就坐在窗玻璃都打破了的教室里上课。</p>
<p>When I looked through the window, I saw a girl whose beauty took my breath away.<br>这里的whose beauty作从句的主语，whose指人即a girl。<br>当我朝窗外看去，猛然看见一个美女，其美貌让我惊讶不已。</p>
<p>It was a meeting whose importance I did not realize at the time.<br>这里的whose importance作从句动词realize的宾语，whose指物即a meeting。<br>这个会议的重要性当时我并没有意识到。</p>
<h3 id="先行词指“物”，用关系代词which"><a href="#先行词指“物”，用关系代词which" class="headerlink" title="先行词指“物”，用关系代词which"></a>先行词指“物”，用关系代词which</h3><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/z263sW.png"><br>这里的先行词是sentences，表示“物”，因此不能用who。要用which代替they，指代sentences，告诉对方“我们正在学习什么类型的句子”。<br>我们正在学习带有定语从句的句子。</p>
<p>关系词which所指代的先行词比较复杂，它除了可以指单个的名词外，还可以指代短语甚至是从句。</p>
<h4 id="先行词是单个的名词"><a href="#先行词是单个的名词" class="headerlink" title="先行词是单个的名词"></a>先行词是单个的名词</h4><p>Anger is a wind which blows out the lamp of the mind.<br>先行词是wind，即which指单个的名词。<br>愤怒是吹灭心灵之灯的风。</p>
<p>Perhaps it is human to appreciate little that which we have and to long for that which we have not.<br>先行词是that，即which指单个的名词。<br>或许，“不惜已获，贪求不得”是人类共同的弱点吧。</p>
<h4 id="先行词是一个短语-1"><a href="#先行词是一个短语-1" class="headerlink" title="先行词是一个短语"></a>先行词是一个短语</h4><p>which可以指代一个短语。<br>He likes climbing mountains, which is a good exercise.<br>先行词是主句中的一个动名词短语climbing mountains。<br>他喜欢爬山，这是一项很好的运动。</p>
<h4 id="先行词是一个句子"><a href="#先行词是一个句子" class="headerlink" title="先行词是一个句子"></a>先行词是一个句子</h4><p>which可以指代前面的整个句子。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/sLf9DC.png"><br>汤姆迟到了，这让我很吃惊。</p>
<p>He tore up my photo, which upset me.<br>全句“he tore up my photo”作which的先行词。<br>他把我的照片给撕了，这让我很生气。</p>
<h3 id="that可以指代“人”，也可以指代“物”"><a href="#that可以指代“人”，也可以指代“物”" class="headerlink" title="that可以指代“人”，也可以指代“物”"></a>that可以指代“人”，也可以指代“物”</h3><p>关系代词that的意义和用法主要有以下三点：</p>
<ul>
<li>that既可指“人”也可指“物”，指“物”时可以替换which，指“人”时可以替换who；</li>
<li>that不用在非限制性定语从句中；</li>
<li>that不能用于介词的后面（同who一样）。</li>
</ul>
<p>Too many people spend money which they haven’t earned, to buy things which they don’t want, to impress people who they don’t like.<br>可以用that替换其中的which和who而将这句话改写成“Too many people spend money that they haven’t earned, to buy things that they don’t want, to impress people that they don’t like.”。<br>这里that的先行词有“物（money和things）”，也有“人（people）”。<br>作宾语的关系词可以省去，因此这句话也可说成“Too many people spend money ( ) they haven’t earned, to buy things ( ) they don’t want, to impress people ( ) they don’t like.”。<br>太多的人花他们还没挣到的钱，买他们不想要的东西，取悦他们不喜欢的人。</p>
<p>that与which和who在用法上的区别：</p>
<ul>
<li>先行词中同时出现“人”和“物”时，用that<br>The writer and his novels that the article deals with are quite familiar to us.<br>这里的先行词是the writer and his novels，即同时有“人（writer）”和“物（his novels）”，所以要选用that引导定语从句。<br>这篇文章里所说的这个作家以及他的小说，我们都比较熟悉。</li>
<li>先行词为指“物”的all，little，few，much，none和the first时, 用that<br>All that glitters is not gold.<br>这里的先行词是all，所以用that来引导定语从句。另外要注意的是，<em><strong>这里有一个半否定的问题：all…not要译成“并非都是”，不能译成全否定的“所有都不”。</strong></em><br>闪光的并非都是金子。<br>The book contains little that is useful.<br>这里的先行词是表示否定意义的代词little（几乎没有什么），所以用that来引导定语从句。<br>这本书里几乎没有有用的东西。<br>There is not much that can be done.<br>这里的先行词是代词much，所以用that来引导定语从句。<br>这没有什么可以做的了。<br>As long as you stand up to the difficulties, there are none that cannot be overcome.<br>这里的先行词是代词none，所以用that来引导定语从句。<br>只要你勇敢地去面对困难，就没有什么克服不了的。</li>
<li>先行词是不定代词something，anything，nothing和everything时，一般用that</li>
<li>先行词被any，only，all，every，no，some，much，few，little，序数词，形容词的最高级，the only，the one，the very，the right和the last等成分修饰时，用that<br>Tell us all things that you know.<br>把你知道的都告诉我们。<br>The very problem that I want to solve is like this.<br>我想解决的问题就像这个一样。<br>He is the only man that can speak four foreign languages in our company.<br>他是我们公司唯一一个会说四种外语的人。</li>
<li>that不用在非限制性定语从句中<br>I became a single mother overnight, which is nothing like becoming famous overnight.<br>我在一夜之间成了单亲妈妈，这跟一夜成名可完全不同。<br>不能说“I became a single mother overnight, that is nothing like becoming famous overnight. *”。</li>
<li>that不能用于介词后面<br>The world in which we live is made up of matter. 我们所生活的世界是由物质组成的。<br>或：The world which we live in is made up of matter.<br>或：The world that we live in is made up of matter.<br>但不能说“The world in that we live is made up of matter. *”。</li>
</ul>
<h2 id="介词-关系代词"><a href="#介词-关系代词" class="headerlink" title="介词+关系代词"></a>介词+关系代词</h2><h3 id="看从句选介词"><a href="#看从句选介词" class="headerlink" title="看从句选介词"></a>看从句选介词</h3><h4 id="所用介词须与定语从句中的动词构成固定搭配（最常见）"><a href="#所用介词须与定语从句中的动词构成固定搭配（最常见）" class="headerlink" title="所用介词须与定语从句中的动词构成固定搭配（最常见）"></a>所用介词须与定语从句中的动词构成固定搭配（最常见）</h4><p>这里所说的动词往往是指定语从句中的谓语动词。<br>The girl with whom you work is his girlfriend.<br>关系词whom前面的介词with与定语从句中的谓语动词work构成固定搭配work with，表示“和……一起工作”。<br>He is the man on whom I think you can depend.<br>关系词whom前面的介词on与定语从句中的谓语动词depend构成固定搭配depend on，表示“依靠”。</p>
<h4 id="看从句的形容词：所用介词须与定语从句中的形容词构成搭配（比较常见）"><a href="#看从句的形容词：所用介词须与定语从句中的形容词构成搭配（比较常见）" class="headerlink" title="看从句的形容词：所用介词须与定语从句中的形容词构成搭配（比较常见）"></a>看从句的形容词：所用介词须与定语从句中的形容词构成搭配（比较常见）</h4><p>如果定语从句的谓语不是一个实义动词，而是由be动词与某个形容词构成的，我们则要使用与该形容词搭配的介词。<br>He referred me to some reference books with which I am not very familiar.<br>关系词which前面的介词with与定语从句谓语部分中的 形容词familiar构成固定搭配be familiar with sth.，表示“对……熟悉”。<br>他让我参考的几本书我一本也不熟悉。</p>
<p>They will pass along their fresh impressions to the youth groups in which they are active.<br>关系词which前面的介词in与定语从句谓语部分中的形容词active构成固定搭配be active in sth.，表示“积极参与”。<br>他们会把自己获得的新鲜印象与他们积极参与的青年团体分享。</p>
<h4 id="看从句的名词：所用介词须与定语从句中的某个名词构成搭配（较少用）"><a href="#看从句的名词：所用介词须与定语从句中的某个名词构成搭配（较少用）" class="headerlink" title="看从句的名词：所用介词须与定语从句中的某个名词构成搭配（较少用）"></a>看从句的名词：所用介词须与定语从句中的某个名词构成搭配（较少用）</h4><p>Many hypersomniacs suffer from narcolepsy, for which the primary symptom is excessive daytime sleepiness.<br>这里的关系词which前面的介词for与定语从句中的名词symptom构成固定搭配symptom for，表示“是……症状”。<br>许多嗜睡的人都患有发作性嗜睡病，其早期症状就是在白天都极度想睡觉。</p>
<h4 id="看先行词选介词"><a href="#看先行词选介词" class="headerlink" title="看先行词选介词"></a>看先行词选介词</h4><p>The ease with which Mr. Zhang cracked the complex sentence was unbelievable.<br>拆分句子如下：<br>Mr. Zhang cracked the complex sentence with ease and the ease was unbelievable.<br>把the ease was unbelievable作为主句，将Mr.Zhang cracked the complex sentence with ease作为定语从句来修饰the ease，将这两句合并起来就是：<br>The ease （Mr. Zhang cracked the complex sentence with ease） was unbelievable.<br>先行词是ease，所以我们用关系词which来指代，再将上句改写成：<br>The ease （Mr. Zhang cracked the complex sentence with which） was unbelievable.<br>关系词which应该放在从句的开头，又因为with which（就相当于 with ease）是一个固定搭配，所以要将with which一同移到句子开头，于是上句就进一步改写成：<br>The ease （with which Mr. Zhang cracked the complex sentence） was unbelievable.<br>这个复杂的句子，张老师能够如此轻而易举地分析出来，真是让人难以置信。</p>
<blockquote>
<p>常见的有：with ease, at the rate, in the direction, to the extent, to the degree, at the temperature, by the means, by the mode, in a culture, in practice等等。</p>
</blockquote>
<p>at the speed和at the rate，表示“以这种速度”。<br>The speed at which an animal lives is determined by measuring the rate at which it uses oxygen.<br>通过测定动物消耗氧气的速率可以测定该动物的生长速度。</p>
<p>to the extent，表示“在某种程度上”。<br>When television was first introduced, the extent to which it would affect human society could not have been foreseen.<br>人们发明电视的时候，并没能预见到它会对人类社会产生多大的影响。</p>
<p>by the means，表示“通过这种方式”。<br>Public demonstrations are an effective means by which the people can bring social inequalities to the attention of government officials.<br>by which就等于说by the means，表示“通过这种方式”，在定语从句中作状语，修饰从句的谓语。<br>公众通过游行示威这种方式，可以有效地让政府官员们注意到不平等的社会现实。</p>
<h3 id="表示所属关系或部分与整体的关系时用介词of"><a href="#表示所属关系或部分与整体的关系时用介词of" class="headerlink" title="表示所属关系或部分与整体的关系时用介词of"></a>表示所属关系或部分与整体的关系时用介词of</h3><p>The company, of which Max Harrison was until recently the chairman, has made loss of three million pounds this year.<br>这里的of which相当于of the company，于是整个定语从 句相当于Max Harrison was until recently the chairman of the company，所以这里的of表示所属关系，即the chairman是属于这个公司的。原定语从句可以改写为：the chairman of which was Max Harrison until recently。<br>这家公司今年亏损达三百万英镑，直到前不久Max Harrison还是它的董事长。</p>
<blockquote>
<p>该句型的结构往往是“不定代词&#x2F;数量词&#x2F;形容词的比较级或最高级+of which&#x2F;whom”，用来表示数量或某种特点。具体来讲，在介词of前面常出现的词包括：all, each, both, either, neither, none, little, few, many, much, some, most, any, the majority, half, several, a number, half, none以及 数字和形容词的最高级等等。<br>值得注意的是，这里of前面的成分都可以后移至定语从句中。</p>
</blockquote>
<h3 id="固定的介宾结构"><a href="#固定的介宾结构" class="headerlink" title="固定的介宾结构"></a>固定的介宾结构</h3><p>关系代词前面的介词有时与固定的介宾短语结构有关，比如in this case, in one’s honor和with one’s help等，它们若出现在定语从句中，则会相应地变成in which case, in whose honor和with whose help。<br>He may be late, in which case we should wait for him.<br>这里的in which case就是由短语in this case变过来的，这里which指前面整个句子“he may be late”。<br>他可能要迟到，如果是这样，我们就应该等等他。</p>
<h3 id="定语从句的倒装结构"><a href="#定语从句的倒装结构" class="headerlink" title="定语从句的倒装结构"></a>定语从句的倒装结构</h3><p>具体的结构就是“介词+关系代词+从句谓语+从句主语”，即一个将整个谓语放在主语前面的全部倒装结构。<br>This is the world out of which grows the hope, for the first time in history, of a society where there will be freedom from want and freedom from fear.<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/zjmvG7.png"><br>第一个定语从句out of which grows the hope, for the first time in history, of a society修饰world。在这个定语从句里有一个倒装结构和分隔结构。分隔结构是在the hope和of a society中间插入了短语for the first time in history，也就是说，如果没有这个插入语，就是the hope of a society，表示“希望建立这样一个社会”。 整个短语the hope, for the first time in history, of a society就表示“在人类历史上，首次希望建立这样一个社会”，这个名词短语是作定语从句的主语。<br>定语从句的谓语是grows，out of which在定语从句中作状语，所以整个定语从句是一个全部倒装结构。正常语序应该是：the hope, for the first time in history, of a society grows out of which （out of the world）。 第二个定语从句where there will be freedom from want and freedom from fear修饰society，说明是什么样的社会。难点是如何翻译freedom from want and freedom from fear这个短语。这里freedom from来自于形容词短语free from，表示“免除，没有”。另外，名词want表示“贫困”。因此，整个短语我们可以译成“摆脱贫困，摆脱恐惧”。</p>
<p>The intellectual process I learned in that class is also life’s process, because every life is a great work with all the richness of its gifts and the wealth of its possibilities. When you graduate from here, you exit with thousands of pages of personal text on which are inscribed beliefs and values shaped by years of education, family interactions, relationships, experiences. And buried within those thousands of pages is your personal truth, your essence.<br>这段话来自惠普公司总裁在斯坦福大学的一次毕业典礼上对毕业生们的演讲。定语从句on which are inscribed beliefs and values shaped by years of education, family interactions, relationships, experiences修饰名词短语thousands of pages of personal text。该从句的主语是beliefs and values shaped by years of education, family interactions, relationships, experiences，谓语是are inscribed，on which作地点状语。所以，整个定语从句是一个全部倒装结构，正常语序是：beliefs and values shaped by years of education, family interactions, relationships, experiences are inscribed on which （on thousands of pages of personal text）。<br>我在那门课中所学的掌握知识的过程，也是生活的过程。因为每种人生都是一部伟大的著作，其中包含丰富的才智和美好的 可能。当你从这里毕业时，你会带着数千页的人生教科书走出校门，在这本教科书里铭刻着经过多年教育、家庭的作用、社会关系以及个人经历所形成的信念和价值观。而真实的你和你的精华就深藏在这数千页记录中。</p>
<h3 id="“介词-关系代词-to-do”结构"><a href="#“介词-关系代词-to-do”结构" class="headerlink" title="“介词+关系代词+ to do”结构"></a>“介词+关系代词+ to do”结构</h3><p>1） The farmer used wood to build a house in which he could store grains.<br>2） The farmer used wood to build a house in which to store grains.<br>由1）句简化为2）句，先是把定语从句in which he could store grains中的主语he省去（因为he与主句主语the farmer一致，所以可以省略），然后把情态动词could替换为不定式to（因为不定式具有情态意义），于是便得到in which to store grains。<br>这位农夫用一些木材建造了一座房子，在那里储存粮食。<br>还可以进一步简化上面的例句2），就是把关系词which去掉，此时就必须把介词in移到句末去。<br>3） The farmer used wood to build a house to store grains in.</p>
<ul>
<li>在例句1）中，是一个定语从句（in which he could store grains）作后置定语，修饰house；</li>
<li>在例句2）中，则是一个“半定语从句半不定式”的混合形式（in which to store grains）作后置定语，修饰house；</li>
<li>在例句3）中，则是一个不定式（to store grains in）作后置定语，修饰house。</li>
</ul>
<p>在使用这一结构时应注意以下几点：</p>
<ul>
<li>“介词+关系代词”不能用一个关系副词来替换。比如不能说“The farmer used wood to build a house where to store grains. *”。</li>
<li>有介词、有关系代词时，不能将介词置于句末。比如不能说“The farmer used wood to build a house which to store grains in. *”。</li>
<li>若没有介词，我们不能采用“半定语从句半不定式”的混合形式作后置定语。比如不能说“I can’t think of anybody whom to invite.*”。而要说“I can’t think of anybody to invite.”，或者“I can’t think of anybody who I should invite.”。</li>
</ul>
<h2 id="关系代词as"><a href="#关系代词as" class="headerlink" title="关系代词as"></a>关系代词as</h2><h2 id="as引导非限定性定语从句"><a href="#as引导非限定性定语从句" class="headerlink" title="as引导非限定性定语从句"></a>as引导非限定性定语从句</h2><p>as引导的非限定性定语从句的特点主要有两个：</p>
<blockquote>
<p>1、as所指代的先行词通常都是一个完整的句子；</p>
</blockquote>
<blockquote>
<p>2、as引导的定语从句位置很灵活，可以在句首、句中或句末。</p>
</blockquote>
<h3 id="as引导的非限定性定语从句可放在句首"><a href="#as引导的非限定性定语从句可放在句首" class="headerlink" title="as引导的非限定性定语从句可放在句首"></a>as引导的非限定性定语从句可放在句首</h3><p>as引导的非限定性定语从句可以放在句首，此时as指代后面的整个主句。换句话说，关系代词as的先行词可以出现在as后边。<br>这点不同于which及任何其他关系词，因为which及其他关系词所指代的先行词必须出现在它们的前面，因此which引导的非限定性定语从句不能放在句首。<br>As is so often pointed out, knowledge is a two-edged weapon which can be used equally for good or evil.<br>这是一个放在句首的由as引导的定语从句，此时as所指代的先行词是其后面的完整的主句，即knowledge is a two-edged weapon which can be used equally for good or evil。as在定语从句中作主语。注意：在这里我们不能说“Which is so often pointed out, …*”。</p>
<p>1） ______ is known to us all, the whale is not fish but a mammal.<br>2） ______ is known to us all that the whale is not fish but a mammal.<br>3） ______ is known to us all is that the whale is not fish but a mammal.<br>在例句1）中，<em><strong>两个分句间有逗号分隔，表明这是一个放在句首的非限定性定语从句，此时只能用as。</strong></em><br>在例句2）中，两个分句间多了一个连词that，替换了例句1）中的逗号，表明这是一个主语从句，其基本的结构是“It is+过去分词+that”。<br>例句3）与例句2）相比多了一个谓语is，表明is前面的成分是主语，后面的成分是表语。在主语部分is known to us all里又有一个谓语is，这就表明充当主语的应该是一个主语从句，而且空白处填入的连词必须又能在主语从句中作主语，所以只能填What。<br>我们知道，鲸不是鱼类，而是哺乳类动物。</p>
<h3 id="as引导的非限定性定语从句可放在句中"><a href="#as引导的非限定性定语从句可放在句中" class="headerlink" title="as引导的非限定性定语从句可放在句中"></a>as引导的非限定性定语从句可放在句中</h3><p>放在句中，往往会分隔主句中的某两个成分，因此在分析句子时要跳过这个as引导的从句，直接将从句的前后两个成分联系起来看，这样才便于理解。尽管as引导的从句放在句中，但as所指代的先行词依然是主句，只不过此时的主句是被as引导的从句分隔成了前后两部分。which引导的非限定性定语从句也可以放在句中，但which的先行词必须出现在其前面。<br>Stratford-on-Avon, as we all know, has only one industry—William Shakespeare—but there are two distinctly separate and increasingly hostile branches.<br>as引导的定语从句放在句中，隔开了主语Stratford-on- Avon与其谓语has。此时as指代的先行词依然是主句，只不过此时的主句是被as引导的从句分隔成了Stratford-on-Avon和has only one industry— William Shakespeare—but there are two distinctly separate and increasingly hostile branches两部分。as指代这个主句的同时在定语从句中作know的宾语。<br>这里若用which替换as，说成which we all know，那么which只能指代Stratford-on-Avon而不能指代整个主句。因此，which表示“我们所知道”的是Stratford-on-Avon这个城市。<br>众所周知，埃文河上的斯特拉特福德镇只有一个产业，即威廉·莎士比亚，但是存在着两个明显不同且日益敌对的分支。</p>
<p>There is, as has been suggested, a growing body of research literature in journalism and broadcasting, but very little significant attention has been devoted to the study of the interview itself.<br>此时as所指代的先行词依然是主句，只不过此时的主句被as引导的从句分隔成了There is和a growing body of research literature in journalism and broadcasting, but very little significant attention has been devoted to the study of the interview itself两部分。<br>这里不能用which代替as，因为定语从句前面只有there is这个结构，它不是一个名词，因而无法作which的先行词。<br>正如前面已经提及的，对新闻与广播的研究文献越来越多，但是却很少有关注新闻采访本身的研究。</p>
<h3 id="as引导的非限定性定语从句可放在句末"><a href="#as引导的非限定性定语从句可放在句末" class="headerlink" title="as引导的非限定性定语从句可放在句末"></a>as引导的非限定性定语从句可放在句末</h3><blockquote>
<p>which引导的非限定性定语从句也常常放在句末。</p>
</blockquote>
<p>在as引导的定语从句中，as有“正好……”“就像……”“由……而知”的含义。</p>
<ul>
<li>当主句和从句在内容上一致时，或者说从句内容是顺着主句的意思说下来时，通常用as。</li>
<li>若主句和从句在内容上不一致，或从句的内容对主句的内容起消极作用，即对主句内容起反对、排斥、否定等作用时，则多用which。</li>
</ul>
<p>1） She has married again, as was expected.<br>2） She has married again, which was unexpected.<br>在例句1）中，定语从句中的关键词expected表明定语从句的意思与前面主句的意思是顺接关系，所以用as比较妥当，表示“正如人们所意料的那样”。<br>在例句2）中，定语从句中的关键词unexpected表明定语从句的意思与前面主句的意思是否定、排斥的关系，所以用which比较妥当，表示“这是出乎人们意料的”。<br>1）她又结婚了，正如人们所预料的那样。<br>2）她又结婚了，这真出乎人们预料。</p>
<p>She is very careful, as her work shows.<br>在该句中，定语从句的意思与前面主句的意思是顺接关系，所以用as比较妥当，表示“正如她的工作所显示的”。<br>她很细心，这从她的工作中就可看得出来。</p>
<p>The young man cheated his friend of much money, which was disgraceful.<br>在该句中，定语从句中的关键词disgraceful表明定语从句的意思与前面主句的意思是否定、排斥的关系，所以用which比较妥当，表示“这真可耻”。<br>这个年轻人骗了他朋友很多钱，这真可耻。</p>
<h3 id="as引导限定性定语从句"><a href="#as引导限定性定语从句" class="headerlink" title="as引导限定性定语从句"></a>as引导限定性定语从句</h3><p>as引导限定性定语从句只能用在一些固定结构中，即只能用在由such, the same, as修饰的先行词的后面。as在定语从句中可以作主语、宾语或表语。as的先行词可以是人，也可以是物。</p>
<h4 id="as在定语从句中作主语"><a href="#as在定语从句中作主语" class="headerlink" title="as在定语从句中作主语"></a>as在定语从句中作主语</h4><p>He’ll repeat such points as are discussed in the book.<br>这里such…as构成结构上的呼应关系。如果没有such，则不用as引导定语从句，比如可以说成“He’ll repeat the point that are discussed in the book.”。<br>他将会重复书上讨论过的要点内容。</p>
<p>He is not such a man as would leave his work half done.<br>也可以说成“He is not a man who would leave his work half done.”。<br>他不是那种会将工作半途而废的人。</p>
<p>The new map of the ocean floor shows the locations of twice as any undersea volcanoes as were previously thought to exist.<br>这里as…as构成结构上的呼应关系。如果没有as，则不用as引导定语从句。as的先行词是undersea volcanoes。<br>新的洋底地图显示出海底火山的位置，火山数量是人们以前知道的两倍。</p>
<h4 id="as在定语从句中作宾语"><a href="#as在定语从句中作宾语" class="headerlink" title="as在定语从句中作宾语"></a>as在定语从句中作宾语</h4><p>He tried to make as few mistakes as he could avoid.<br>如果没有前面的as，则不用后面的as引导定语从句。as指代先行词mistakes，并且在从句中作avoid的宾语。<br>他尽量避免犯错误。</p>
<p>He is not the same playboy as we knew.<br>这里the same…as构成结构上的呼应关系。<br>他不再是我们所知道的那个花花公子了。</p>
<h4 id="as在定语从句中作表语"><a href="#as在定语从句中作表语" class="headerlink" title="as在定语从句中作表语"></a>as在定语从句中作表语</h4><p>He is not such a fool as we would assume him to be.<br>as指代先行词fool，并且在从句中作be的表语。<br>他并不像我们想象的那样傻。</p>
<h2 id="关系代词than"><a href="#关系代词than" class="headerlink" title="关系代词than"></a>关系代词than</h2><ul>
<li>than可作关系代词引导定语从句，在从句中一般作主语（也可作宾语）；</li>
<li>than前面的主句需有形容词的比较级形式；</li>
<li>比较级所修饰的名词即为先行词。</li>
</ul>
<h3 id="than作主语"><a href="#than作主语" class="headerlink" title="than作主语"></a>than作主语</h3><p>Don’t drink more wine than is good for health.<br>不要过量饮酒。适量饮酒有益于健康。<br>Don’t give him more money than is needed, since money will burn a hole in his pocket.<br>不要多给他钱，他需要多少就给多少，因为他有钱就花光。</p>
<h3 id="than作宾语"><a href="#than作宾语" class="headerlink" title="than作宾语"></a>than作宾语</h3><p>He soon found it easy to make more money by thieving than his father had done by a lifetime of honest work.<br>这里的more所修饰的名词money即为先行词，than指代money的同时，在从句中作谓语动词had done（即had made）的宾语。<br>很快他就发现，通过盗窃所得的钱比他老爸一辈子辛勤劳动挣来的钱要多得多。</p>
<h2 id="关系代词but"><a href="#关系代词but" class="headerlink" title="关系代词but"></a>关系代词but</h2><p>对于but用作关系代词的用法特点：</p>
<ul>
<li>具有否定意义，相当于that…not。因此but后面接的定语从句在形式上是肯定的，但在意义上是否定的。</li>
<li>but所修饰的先行词往往会被一个否定词修饰，换句话说，but常与具有否定意义的主句连用。主句中的否定和but本身的否定意义结合起来即构成双重否定，表达肯定意思。</li>
<li>but可指人也可指物，在句中作主语或宾语。</li>
<li>but通常只引导限定性定语从句。</li>
</ul>
<p>There is no man but errs.<br>该句相当于说“There is no man who doesn’t err.”。表示“不犯错误的人是没有的”。关系代词but指代人，在定语从句中作主语。与此句相关的还有一句是“To err is human; to forgive, divine.”。表示“犯错人皆难免，宽恕则属超凡”。这两句话可以连在一起使用。<br>人必犯错。<br>There are very few but admire his talents.<br>该句相当于说“There are very few who don’t admire his talents.”。表示“不赞赏他的才能的人几乎没有”。关系代词but指代先行词few，在定语从句中作主语。<br>很少有人不赞赏他的才干的。</p>
<h2 id="缩合关系代词what"><a href="#缩合关系代词what" class="headerlink" title="缩合关系代词what"></a>缩合关系代词what</h2><p><em><strong>what的用法与其他关系代词在结构上有一个重大的区别，那就是what不能指代先行词，即what前面不能有名词，换句话说，what引导的从句并不能修饰主句中的任何先行词。</strong></em><br>All ______ is a continuous supply of the basic necessities of life.<br>A. what is needed<br>B. the things needed<br>C. for our needs<br>D. that is needed<br>正确答案D，题干给出的是一个主句结构，其中all要被一个定语从句修饰，即all是先行词，所以不能选择A，因为不能用what来指代主句中的任何词。<br>关系代词that指代all，在从句中作主语。此外，若选B，则主语是复数things，与后面的谓语is不搭配。也不能选C，因为没有all for our needs is…这样的句子结构。<br>所需要的就是日常生活必需品能够持续供应。</p>
<p><em><strong>what在从句中大多数情况下是没有疑问意义的，即不翻译成“什么”，而是理解为the things that, all that或something that。</strong></em><br><em><strong>可以把what看作是一个特殊的关系代词，它是先行词和关系代词的结合体，这就是为什么what被称为“缩合关系代词”。或者说what本身的含义里已经含有一个“隐性”的先行词了，这也就解释了为什么what前面不能再有“显性”的先行词。</strong></em></p>
<h3 id="使用关系词what的前提：what的前面不能有先行词"><a href="#使用关系词what的前提：what的前面不能有先行词" class="headerlink" title="使用关系词what的前提：what的前面不能有先行词"></a>使用关系词what的前提：what的前面不能有先行词</h3><p>下面这个句子语法是错误的：<br>You can have everything what you like. *<br>比较下面两个例句：<br>1） Dolphins might be trained to cooperate with fishermen and help them by finding, tracking, herding, or even catching fish—in all of which activities dolphins are expert.<br>2） Dolphins might be trained to cooperate with fishermen and help them by finding, tracking, herding, or even catching fish—in all of what activities dolphins are expert. *<br>在例句1）中，关系词which后面接了一个名词activities，整个短语which activities显然指的是前面提到的finding, tracking, herding, or even catching fish这一系列“活动”，这个动名词短语就是被关系词which所指代的先行词。因为在主句中有了这个先行词，所以就不能用what引导从句了。</p>
<p>1） Most of the food ______ elephants eat is brought to their mouths by their trunks.<br>2） Most of ______ food elephants eat is brought to their mouths by their trunks.<br>A. what B. which C. who D. as<br>在例句1）中，空格前面有一个名词food，即需要被定语从句修饰的先行词。而有了先行词就不能填入what，所以A不正确。因为food是指物不是指人，所以不能用who。又因为as要与the same, such或as搭配使用，所以也不能填as。故B正确。在例句2）中，空格前面没有任何名词，即没有先行词，所以要填入what。故A正确。<br>大象吃的所有食物中的大部分是通过象鼻送到嘴里的。</p>
<p>Beethoven, the great musician, wrote【A】 nine symphonies in his life, most of what【B】 were written after he had lost【C】 his hearing【D】.<br>B。应改为：most of which。<br>从表面上看来，这里的most of what中的what前面没有名词，但其实这是一个非限定性定语从句，这个定语从句是补充说明先 行词nine symphonies的。因为有先行词，所以不能用what引导从句，而应改成most of which，也就相当于most of the nine symphonies。<br>贝多芬这位伟大的音乐家一生中创作了九部交响曲，其中大部分是在他耳朵失聪后完成的。</p>
<h3 id="what单独使用，即其后面可以不接名词"><a href="#what单独使用，即其后面可以不接名词" class="headerlink" title="what单独使用，即其后面可以不接名词"></a>what单独使用，即其后面可以不接名词</h3><p>what可表示物，也可表示人。所以，what在意义上相当于说the thing that 或the person that，此时的what一般不具有“什么”这样的疑问意义。<br>She is not what she used to be.<br>这里的what后面没有接名词，what用来指人，原句可以改成一个含有定语从句的句子：“She is not the girl that she used to be.”。<br>这里的what没有疑问意义，它相当于一个先行词和关系代词的结合体，<em><strong>从这个意义上来说，what引导的是一个定语从句。但从结构上来说，这里what引导的从句是充当is的表语，即名词从句中的表语从句。可以称之为”What从句”。</strong></em><br>她不再是以前的她了。</p>
<p>Show me what you have written.<br>可以改成一个含有定语从句的句子：“Show me the things that you have written.”。<br><em><strong>从这个意义上来说，what引导的是一个定语从句。但从结构上来说，这里的what从句是充当show的直接宾语，即名词从句中的宾语从句。</strong></em></p>
<p>Today’s vessels can find their prey using satellites and sonar, which were not available 50 years ago. That means a higher proportion of what is in the sea is being caught.<br>原句可以改成一个含有定语从句的句子：“That means a higher proportion of the fish that is in the sea is being caught.”。<br>还要注意断句，不能理解成a higher proportion of what是主语，谓语是is in the sea，而应该理解成是a higher proportion of这个短语后面接了一个从 句what is in the sea，即充当介词of的宾语的不是what这个词，而是what从句what is in the sea。所以，这个短语不是表示“更大比例的鱼类在海洋里”，而是要理解成“海洋里更大比例的鱼类”。<br>今天的船只可以利用50年前还没有的卫星和声呐发现猎物，这意味着海洋里更大比例的鱼类正在被捕捉。</p>
<h3 id="what的后面可以接名词"><a href="#what的后面可以接名词" class="headerlink" title="what的后面可以接名词"></a>what的后面可以接名词</h3><p>尽管what的前面不能有名词，但它后面可以接名词。当what后面接名词时，what作关系形容词，其结构是“what+名词”，相当于“all the+名 词+that”，意思为“所有的……，尽可能多的……”。所以，此时的what同样没有疑问含义。这里的what一般表示物，而不表示人。<br>Most of what food elephants eat is brought to their mouths by their trunks.<br>这里what后面接名词food，what food相当于all the food that，表示“所有食物”，并不表示疑问意义的“什么食物”。于是，most of what food elephants eat相当于most of all the food that elephants eat，表示“大象吃的所有食物中的大部分”，并不表示疑问意义的“大象吃的大部分是什么食物”或“大象大部分吃的是什么食物”。<br>大象吃的所有食物中的大部分是通过象鼻送到嘴里的。</p>
<p>What money I have has been given to you.<br>what money相当于all the money that，表示“所有的钱”，并不表示疑问意义的“什么钱”。于是，what money I have相当于all the money that I have，表示“我身上所有的钱”，并不表示疑问意义的“我身上有什么钱”。<br>我身上所有的钱都给你了。</p>
<p><em><strong>在“what+名词”这个结构中，在名词前面还可以添加其他限定词修饰名词，比如little，即“what little+名词”结构，相当于“all the little+名词+that”，表示“仅有的这点东西”。</strong></em><br>The accident completely wiped out what little sight he had left.<br>名词短语little sight相当于说all the little sight that，表示“仅有的这点视力”。what little sight he had left相当于all the little sight that he had left，表示“他所剩下的仅有的这点视力”。<br>这次事故使他原本仅有的一点视力也完全丧失了。</p>
<h3 id="what用在一些固定结构中"><a href="#what用在一些固定结构中" class="headerlink" title="what用在一些固定结构中"></a>what用在一些固定结构中</h3><p>what从句常用在一些结构中，比如表示“所谓的”：what is called, what can be called, what we call, what used to call。<br>此外还有其他结构，比如：what they described as, what they regarded as, what you may see as等等。这些结构可以作插入语，一般放在动词或介词后面作宾语。<br>For Williams, those activities became what he calls “electronic heroin”.<br>对威廉斯来说，这些活动成了他所称的“电子海洛因”。<br>One difficulty is that almost all of what is called behavioral science continues to trace behavior to states of mind, feelings, traits of character, human nature, and so on.<br>难题之一在于，所谓的行为科学几乎全部依然从心态、感情、性格特征、人性等方面去寻求行为的根源。<br>In America, the move away from juggling to a simpler, less materialistic lifestyle is a well-established trend. Downshifting—also known in America as “voluntary simplicity”—has, ironically, even bred a new area of what might be termed anticonsumerism.<br>在美国，从紧张忙碌的生活隐退到一种较为简单、不太注重物质的生活，这是一个明确的趋势。让人哭笑不得的是，放慢生活节奏——在美国也叫作“自愿返璞归真”——甚至已形成一个可称为“反消费主义”的新领域。</p>
<h2 id="关系副词的用法"><a href="#关系副词的用法" class="headerlink" title="关系副词的用法"></a>关系副词的用法</h2><h3 id="when的用法"><a href="#when的用法" class="headerlink" title="when的用法"></a>when的用法</h3><h4 id="先行词指时间"><a href="#先行词指时间" class="headerlink" title="先行词指时间"></a>先行词指时间</h4><p>when可以引导限制性和非限制性定语从句，其先行词必须是表示时间的名词，如day，year或time等。<br>I’ll never forget the day when I met you.<br>这里的先行词是表示时间的名词day，所以用when引导定语从句。when作从句的时间状语，修饰谓语动词met。<br>我永远不会忘记我们见面的那一天。</p>
<p>My favorite season is spring, when the earth seems born again.<br>这里是when引导的非限制性定语从句，先行词是表示时间的名词spring。<br>到了春天，万物复苏，所以春天是我最喜欢的季节。</p>
<p>We will put off the outing until next week, when we won’t be so busy.<br>这里是when引导的非限制性定语从句，先行词是表示时间的短语next week。<br>我们要把出游推迟到下周，到时我们就不会这么忙了。</p>
<p>The day may soon come when we don’t bother to go to office but just work at home.<br>也许在不久的将来，我们就不必去办公室上班了，而就在家里工作。</p>
<h4 id="关系副词when在从句中作时间状语（先行词表示时间时，不一定都用when引导定语从句）"><a href="#关系副词when在从句中作时间状语（先行词表示时间时，不一定都用when引导定语从句）" class="headerlink" title="关系副词when在从句中作时间状语（先行词表示时间时，不一定都用when引导定语从句）"></a>关系副词when在从句中作时间状语（先行词表示时间时，不一定都用when引导定语从句）</h4><p>when是在定语从句中作时间状语。换句话说，若定语从句不是缺少状语，而是缺少主语或宾语，那么即使先行词是表示时间的名词，也不能用when而要用which或that来引导定语从句。因为用when来引导定语从句的前提条件是：when必须在其引导的定语从句中作时间状语。<br>1） I’ll never forget the time which I spent on campus.<br>2） I’ll never forget the day when we first met in the park.<br>在例句1）中，由于定语从句中的谓语spent缺宾语，因此关系词要充当这一宾语，故要用which。<br>在例句2）中，定语从句不缺主语或宾语，而是缺少时间状语，故关系词用when，这里when作时间状语，修饰met。<br>1）我永远不会忘记在大学校园里度过的时光。<br>2）我永远不会忘记我们第一次在公园里相遇的那一天。</p>
<p>The day, which began brightly, ended with a violent storm.<br>这里的先行词是day，表示时间。由于定语从句缺少主语，所以用关系代词which引导定语从句，which作从句的主语，而不用关系副词when，因为关系副词无法作主语，只能作状语。<br>那天，开始的时候还是阳光明媚，后来就下起了暴风雨。</p>
<h4 id="如何区分when引导的定语从句与when引导的时间状语从句"><a href="#如何区分when引导的定语从句与when引导的时间状语从句" class="headerlink" title="如何区分when引导的定语从句与when引导的时间状语从句"></a>如何区分when引导的定语从句与when引导的时间状语从句</h4><p>很多时候，若不区分开when引导的这两类从句，就会导致误解。<br>This trend began during the Second World War, when several governments came to the conclusion that the specific demands that a government wants to make of its scientific establishment cannot generally be foreseen in detail.<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/fAfJaW.png"><br>这里when的前面有表示时间的名词短语the Second World War，这里的when不是表示“当……时”，而要译成“当时”，这个从句可以译成“当时一些国家的政府得出结论”，而不能译成“当一些国家的政府得出结论的时候”。<br>同位语从句的主语部分是the specific demands that a government wants to make of its scientific establishment，谓语部分是cannot generally be foreseen in detail。这个主语部分比较难，因为主语中心词demands后面又带了一个that引导的定语从句that a government wants to make of its scientific establishment。<br>这里的that指代先行词demands，在定语从句中作谓语make的宾语，从而构成一个make demands of的搭配，表示“对……提出要求”。<br>这种趋势始于第二次世界大战期间，当时一些国家的政府得出结论：政府要向科研机构提出的具体要求通常是无法详尽预见的。<br>While even the modestly educated sought an elevated tone when they put pen to paper before the 1960s, even the most well regarded writing since then has sought to capture spoken English on the page.<br>这里when引导的是一个时间状语从句，因为其前面没有时间名词作先行词，可以译成“当……时”，所以整个when引导的从句可以译成“当人们伏案写作时”。<br>在20世纪60年代之前，当人们伏案写作时，即使受教育不多的人也追求一种高雅的风格，而从那以后，即使是令人景仰的文章作品也在追求一种口语风格。<br>While even the modestly educated sought an elevated tone when they put pen to paper before the 1960s, even the most well regarded writing since then has sought to capture spoken English on the page.<br>这里when引导的是一个时间状语从句，因为其前面没有时间名词作先行词，可以译成“当……时”，所以整个when引导的从句可以译成“当人们伏案写作时”。<br>在20世纪60年代之前，当人们伏案写作时，即使受教育不多的人也追求一种高雅的风格，而从那以后，即使是令人景仰的文章作品也在追求一种口语风格。</p>
<p>总的来说有三个不同点：</p>
<h5 id="结构上不同"><a href="#结构上不同" class="headerlink" title="结构上不同"></a>结构上不同</h5><ul>
<li>若when引导定语从句，则when的前面必然有表示时间的名词；</li>
<li>若when引导时间状语从句，则其前面往往没有表示时间的名词。</li>
</ul>
<h5 id="作用不同"><a href="#作用不同" class="headerlink" title="作用不同"></a>作用不同</h5><ul>
<li>当when引导定语从句时，此时when是指代表示时间的先行词，在定语从句中作时间状语，修饰从句的谓语。</li>
<li>当when引导时间状语从句时，此时when不在从句中作任何成分，只起连接主句和从句的作用（when引导的时间从句修饰主句的谓语，作主句谓语的时间状语）。</li>
</ul>
<h5 id="when的译法不同"><a href="#when的译法不同" class="headerlink" title="when的译法不同"></a>when的译法不同</h5><p>when引导定语从句：</p>
<ul>
<li>如果从句谓语是过去时，则when表示从句谓语动作发生的过去时间，因而一般译成“当时”、“那时”；</li>
<li>如果从句谓语是表示将来的动作，则when表示从句谓语动作发生的将来时间，因而常译成“到时”、“届时”。</li>
</ul>
<p>而引导时间状语从句的 when，通常都是译成“当……时候”。</p>
<h5 id="when也可以是一个”缩合关系词”"><a href="#when也可以是一个”缩合关系词”" class="headerlink" title="when也可以是一个”缩合关系词”"></a>when也可以是一个”缩合关系词”</h5><p>To her, the arguments about little things and other obstacles she and her husband face are forgettable when she thinks back to when she first met her husband.<br>第一个when引导的从句不难理解，应是一个时间状语从句，所以when可译成“当……时”。而第二个when引导的从句较为特殊，从结构上看，这个从句是作介词to的宾语，所以应该是一个宾语从句。但从when的意义上来看，这个when相当于说the day when，是一个“缩合关系词”，也就是说when本身含有一个“隐性”先行词the day。所以从句when she first met her husband可以改写成一个定语从句the day when she first met her husband，表示“当初第一次认识她丈夫时的那天”。<br>对于她来说，当她回忆起初遇丈夫时的情景，就把他们之间的关于生活琐事的争议抛到九霄云外了。</p>
<h3 id="where的用法"><a href="#where的用法" class="headerlink" title="where的用法"></a>where的用法</h3><h4 id="where的先行词指地点"><a href="#where的先行词指地点" class="headerlink" title="where的先行词指地点"></a>where的先行词指地点</h4><p>where引导定语从句，在定语从句中作地点状语，修饰从句谓语动词，其先行词一般是表示地点的名词，如place和house等。<br>A: Since you work in the theater, can’t you get me a free ticket now and then?<br>B: Certainly if you bring me a few notes now and then from the bank where you work!<br>这里的先行词bank表示地点，where在从句中充当地点状语（定语从句中不缺主语或宾语），修饰work。<br>A：既然你在剧院工作，那你就不能时常给我弄些免费的票吗？<br>B：当然可以，只要你能够从你工作的那家银行里时常给我弄些票子出来。</p>
<p>Literature is the place where the past meets the present to contemplate the future.<br>where在从句中充当地点状语（定语从句中不缺少主语或宾语），修饰从句谓语meets。<br>在文学作品里，过去与现实交汇，以思考未来。</p>
<p>This is the town where I spent my childhood.<br>这就是我度过童年的小镇。</p>
<h4 id="关系副词where在从句中作地点状语"><a href="#关系副词where在从句中作地点状语" class="headerlink" title="关系副词where在从句中作地点状语"></a>关系副词where在从句中作地点状语</h4><p>与when类似，并不是先行词是表示地点的名词时，都得由where来引导定语从句，这得看关系词在从句中充当的成分。若定语从句不是缺少状语，而是缺少主语或宾语，则要用which或that引导定语从句。<br>1） This is the town where I spent my childhood.<br>2） This is the town which I told you about before.<br>在例句1）中，定语从句不缺少主语或宾语，而是缺少地点状语，故关系词用where。where作地点状语，修饰spent。<br>在例句2）里，由于定语从句中的谓语部分told you about缺少宾语，因此关系词要充当这一宾语，故要用which。<br>1）这就是我度过童年的小城。<br>2）这就是我以前告诉过你的小城。</p>
<p>I’ve never been to Beijing, but it’s the place ______.<br>A. where I’d like to visit<br>B. in which I’d like to visit<br>C. I most want to visit<br>D. that I want to visit it most<br>本题考查定语从句关系词的选择。这句话中尽管先行词是表示地点的名词place，但由于从句中的谓语visit缺少宾语，所以不能选A，而C才是正确答案。这里相当于省去了关系词that或which，因此原句应该是that &#x2F; which I most want to visit。<br>我从未到过北京，但北京却是我最想游览的地方。</p>
<p>In fact, there are now so many deer that some are being sent to places which would like to return this kind of deer to the wild.<br>尽管这句的先行词是表示地点的名词places，但由于从句缺少主语，所以我们用关系代词which。<br>事实上，现在鹿群数量过多，因此有些鹿被送到那些能将它们送回野外的地方。</p>
<h4 id="where引导定语从句，先行词可以是含有地点意义的其他各种名词"><a href="#where引导定语从句，先行词可以是含有地点意义的其他各种名词" class="headerlink" title="where引导定语从句，先行词可以是含有地点意义的其他各种名词"></a>where引导定语从句，先行词可以是含有地点意义的其他各种名词</h4><p>where引导定语从句，其先行词可以不是表示地点的名词。我们可以把这种不表示地点的名词解释成一种“含有地点意义的名词”，这些名词往往是一些抽象名词，比如dream, case, situation, point等等。<br>Cheating is most likely in situations where the vital interests are high and the chances of getting caught are low.<br>这里的先行词situations表示“情形，情况”，并非我们习惯意义上表示地点的名词，但这里依然用了where引导定语从句。where在从句中充当地点状语，定语从句中不缺少主语或宾语。<br>如果利益重大而且被人发现的可能性又很小，在这种情况下，欺诈行为最有可能发生。</p>
<p>He has reached the point where a change is needed.<br>这里的先行词point表示“地步，某一程度”，并非我们习惯意义上的表示地点的名词。<br>他已到了需要改弦易辙的地步。</p>
<h4 id="再次强调一下where引导的定语从句的两个特点"><a href="#再次强调一下where引导的定语从句的两个特点" class="headerlink" title="再次强调一下where引导的定语从句的两个特点"></a>再次强调一下where引导的定语从句的两个特点</h4><ul>
<li>先行词可以是除了表示时间的名词（在这种情况下会用when）和表示原因的名词（在这种情况下会用why）以外的任何其他名词；</li>
<li>where在从句中作状语，即从句不能缺少主语或宾语，否则不可能用where，而是用which或that。</li>
</ul>
<h4 id="如何区分where引导的地点状语从句和定语从句"><a href="#如何区分where引导的地点状语从句和定语从句" class="headerlink" title="如何区分where引导的地点状语从句和定语从句"></a>如何区分where引导的地点状语从句和定语从句</h4><p>1） 45 percent of the world’s population live where mosquitoes transmit malaria.<br>2） Approximately 45 percent of the world’s population live in the climate zone where mosquitoes transmit malaria.<br>疟疾是由蚊子传播的，全球有大约45％的人口生活在疟疾肆虐的区域。</p>
<p>where引导的这两种从句有如下两点不同：</p>
<ul>
<li>结构上的不同:<ul>
<li>若where引导定语从句，则where的前面必然有表示地点的名词；</li>
<li>若where引导地点状语从句，则其前面往往没有表示地点的名词。</li>
</ul>
</li>
<li>作用不同：<ul>
<li>当where引导定语从句时，指代表示地点的先行词在定语从句中作地点状语，修饰从句的谓语。</li>
<li>当where引导地点状语从句时，不在从句中充当任何成分，只起连接主句和从句的作用。</li>
</ul>
</li>
</ul>
<blockquote>
<p>定语从句中的where才能转换成“介词+which”的结构，而地点状语从句的where不能。</p>
</blockquote>
<p>1） Would you please put the book where it belongs?<br>2） Would you please put the book to which it belongs? *<br>请把书放回原处。</p>
<h4 id="where作为“缩合关系词”"><a href="#where作为“缩合关系词”" class="headerlink" title="where作为“缩合关系词”"></a>where作为“缩合关系词”</h4><p>We stopped for a minute to walk out to where we had seen George Mills work in the mud the night before.<br>从结构上看，这里的where引导的从句是作介词to的宾语，所以应该是一个宾语从句。但从where的意义上来看，这里的where相当于说the place where，是一个“缩合关系词”，也就是说where本身含有一个“隐性”的先行词the place。<br>所以从句where we had seen George Mills work in the mud the night before可以改写成一个定语从句the place where we had seen George Mills work in the mud the night before。<br>我们停留了片刻，出来走到我们曾经看到乔治·米尔斯前一天晚上在泥里工作的地方。</p>
<h3 id="why的用法"><a href="#why的用法" class="headerlink" title="why的用法"></a>why的用法</h3><p>why在定语从句中作原因状语，修饰从句的谓语动词，用来表示原因，只引导限制性定语从句，先行词是reason等表示原因的名词。<br>This is the reason why I didn’t come here.<br>此处的why相当于for which。<br>这就是我没来的原因。</p>
<h3 id="关系副词有how吗？"><a href="#关系副词有how吗？" class="headerlink" title="关系副词有how吗？"></a>关系副词有how吗？</h3><p>how不可以作为表示方式的关系副词。表示方式的四种句型：</p>
<ul>
<li>the way+从句 </li>
<li>the way that+从句</li>
<li>the way in which+从句</li>
<li>the manner that+从句</li>
</ul>
<p>You know the old golden rule, “Care for others the way you would like them to care for you.”<br>这里the way后面的关系词省去了。<br>要记住这样一个真理——以希望别人对待你的方式来对待别人（己所不欲，勿施于人）。</p>
<blockquote>
<p>在英语中没有“the way how+从句”这样的表达。</p>
</blockquote>
<h2 id="限制性与非限制性定语从句"><a href="#限制性与非限制性定语从句" class="headerlink" title="限制性与非限制性定语从句"></a>限制性与非限制性定语从句</h2><p>在限制性定语从句中，先行词和关系词之间不用逗号隔开，而非限制性定语从句则需要逗号隔开。</p>
<h3 id="限制性定语从句——不用逗号隔开"><a href="#限制性定语从句——不用逗号隔开" class="headerlink" title="限制性定语从句——不用逗号隔开"></a>限制性定语从句——不用逗号隔开</h3><p>限制性定语从句是用来对一个名词提供必要的信息（a defining relative clause defines or gives essential information about a noun），以说明定语从句所修饰的先行词的身份或性质，或用来限制先行词所指的范围。若去掉限制性定语从句，则主句部分的含义不明确，或意义不完整，所以不能用逗号来分隔先行词和定语从句。<br>比如“I don’t like people.”，这句话的意思不明确，句意不完整，因此其后面必须加一个限制性定语从句，才能使句意完整。比如：<br>I don’t like people who are never on time. 我不喜欢不守时的人。<br>I don’t like people who never keep their word. 我不喜欢不守信用的人。<br>以上句子黑体部分的定语从句都用来说明people的性质，是必不可少的信息，因此不能加逗号将其变为非限制性定语从句。</p>
<p>There are two factors which determine an individual’s intelligence.<br>这里若只是说“There are two factors.”，则句意不够完整，现在有了限制性定语从句which determine an individual’s intelligence来限制、修饰名词factors，就使得句意更明确。<br>决定人的智力的因素有两个。</p>
<p>He is a man who is of value to the people.<br>这里若只是说“He is a man.”，则句意不完整，现在有了限制性定语从句who is of value to the people来限制修饰名词man，就使得句意完整而明确。<br>他是一个有利于人民的人。</p>
<h3 id="非限制性定语从句——用逗号隔开"><a href="#非限制性定语从句——用逗号隔开" class="headerlink" title="非限制性定语从句——用逗号隔开"></a>非限制性定语从句——用逗号隔开</h3><p>非限制性定语从句用来提供附加的而非必要的信息，只是对先行词做进一步的解释、补充或说明（a non-defining relative clause gives optional information about a noun）。若去掉此定语从句，整个主句的意义一样很明确，不会引起误解和歧义。</p>
<h4 id="专有名词"><a href="#专有名词" class="headerlink" title="专有名词"></a>专有名词</h4><p>如果定语从句修饰一个专有名词，一般要用逗号分隔先行词与定语从句，也就是说要使用非限制性定语从句。这是因为专有名词本身的意思已经很完整，不需要限制，用定语从句只是对它进行补充说明。<br>My mother, who is 50 this year , lives with me now.<br>这里的先行词my mother就是一个专有名词，其后的定语从句who is 50 this year只能是作为非限制性的定语从句来提供附加信息，不能使用限制性定语从句。若说“My mother who is 50 this year lives with me now.”，则言外之意为“我有好几个母亲，目前和我住在一起的是今年50岁的那位母亲”。<br>我母亲今年50岁了，现在和我生活在一起。</p>
<p>I asked my mother, who is 80 , whether she’d ever seen snow in Iraq before, and her answer was no.<br>我问我已经80岁的妈妈，她以前在伊拉克是否见过雪，她回答说没见过。</p>
<p>Einstein, who was a great Jewish scientist, created the theory of relativity.<br>爱因斯坦这位伟大的犹太科学家创立了相对论。</p>
<p>Hawaii, which consists of eight principal islands, is a favorite vacation spot.<br>夏威夷包含八个主要岛屿，是一个度假胜地。</p>
<h4 id="类指名词"><a href="#类指名词" class="headerlink" title="类指名词"></a>类指名词</h4><p>普通名词若是用来表示类指，即表示的是一类事物，而非具体的某一个事物，此时，其后也宜用非限制性定语从句。<br>1） An elephant, which is the earth’s largest land mammal , has few natural enemies other than human beings.<br>2） One of the elephants which we saw at the zoo had only one tusk.<br>例句1）中的an elephant是类指或泛指，即表示“大象”这类动物，而不是指称具体的某一头大象。<br>例句2）中的one of the elephants则不是类指概念，而是具体指代某一头大象，即“我们在动物园看到的那头大象”。<br>1）大象作为陆地上体形最大的哺乳类动物，很少有天敌，除了人类之外。<br>2）我们在动物园看到有一头大象只有一颗象牙。</p>
<h3 id="用或不用逗号，句意有差别"><a href="#用或不用逗号，句意有差别" class="headerlink" title="用或不用逗号，句意有差别"></a>用或不用逗号，句意有差别</h3><p>还有一类句子，用限制性或非限制性定语从句都可以，但强调的意义不一样，即句意不同。<br>1） He has a daughter who works in a hospital.<br>2） He has a daughter, who works in a hospital.</p>
<p>1） The cab drivers who knew about the traffic jam took another road.<br>2） The cab drivers, who knew about the traffic jam, took another road.<br>例句1）的言外之意是“不知道的司机则没有换路线，只有部分司机换行驶路线了”。<br>例句2）的言外之意是“全部司机都知道，都换了行驶路线”。<br>1）知道那里堵车的出租车司机换了另一条路。<br>2）出租车司机知道那里堵车了，他们都换了另一条路。</p>
<h3 id="非限制性定语从句的翻译"><a href="#非限制性定语从句的翻译" class="headerlink" title="非限制性定语从句的翻译"></a>非限制性定语从句的翻译</h3><p>限制性定语从句一般翻译成定语的形式“……的”，而非限制性定语从句往往会译成各种状语形式。<br>The food, which wasn’t in the fridge , all went off.<br>食物都坏了，因为没有放在冰箱里。（译成原因状语从句）</p>
<p>The Ambassador gave a dinner to the scientists, with whom he especially wished to talk.<br>大使宴请了那些科学家，因为他特别想与他们交谈一下。（译成原因状语从句）</p>
<p>The people were desperate for work, any work, which could support their family.<br>人们急于找到工作，什么工作都行，只要能养家糊口。（译成条件状语从句）</p>
<p>The millionaire had another house built, which he didn’t need at all.<br>那位百万富翁又建了一幢房子，尽管他并不需要。（译成让步状语从句）</p>
<p>They tried to stamp out the revolt, which spread all the more furiously throughout the country.<br>起义依然声势浩大地遍布全国，尽管他们试图镇压。（译成让步状语从句）</p>
<h2 id="定语从句与同位语从句的区分"><a href="#定语从句与同位语从句的区分" class="headerlink" title="定语从句与同位语从句的区分"></a>定语从句与同位语从句的区分</h2><p>二者在结构上有相似性，都是“名词that从句”，这里的名词都称作先行词。</p>
<h3 id="从结构上区分：that是否作成分"><a href="#从结构上区分：that是否作成分" class="headerlink" title="从结构上区分：that是否作成分"></a>从结构上区分：that是否作成分</h3><p>that在定语从句中要充当成分，比如作从句的主语或宾语；而that在同位语从句中不充当任何成分，仅起连词的作用。<br>换句话说，定语从句的结构是“名词+that+不完整的句子”，而同位语从句的结构是“名词that+完整的陈述句”。<br>1） The rumor that he spread everywhere turned out to be untrue.<br>2） The rumor that Tom was a thief turned out to be untrue.<br>例句 1）中的that在从句中充当spread的宾语，故此处为定语从句。<br>例句2）中 的that在从句中不充当任何成分，因为从句“Tom was a thief”是一个完整的句子，不缺少任何成分。故其为同位语从句，作the rumor的同位语，补充说明the rumor的具体内容。<br>1）他到处散布的那个谣言，结果证明是假的。<br>2）有谣传说汤姆是小偷，结果证明是假的。</p>
<p>1） The fact that we talked about is very important.<br>2） The fact that he succeeded in the experiment pleased everybody.<br>例句1）中的that作talked about的宾语，故此处为定语从句。<br>例句2）中的that不充当成分，因为“he succeeded in the experiment”是一个完整的陈述句，故其为同位语从句。<br>1）我们讨论的这些情况很重要。<br>2）他的实验取得了成功，这让大家很高兴。</p>
<h3 id="从意义上区分：that引导的从句的意义不同"><a href="#从意义上区分：that引导的从句的意义不同" class="headerlink" title="从意义上区分：that引导的从句的意义不同"></a>从意义上区分：that引导的从句的意义不同</h3><p>定语从句相当于形容词, 对先行词起修饰、描述和限制的作用；同位语从句相当于一个名词，是对其前面名词内容的具体表述，二者是同位关系。<br>1） The news that you heard is not true.<br>2） The news that Lincoln was murdered at a theater is true.<br>例句1）中的定语从句that you heard并不是表示news的内容，只是在限制news所指的范围，即“你听到的那个消息”。<br>例句2）中的同位语从句that Lincoln was murdered at a theater是表示news的具体 内容，在意义上与news构成同位关系。<br>1）你听到的那个消息并不是真实的。<br>2）有消息说林肯是在一个剧院被刺杀的，这是真的。</p>
<p>1） The fact that you pointed out made me interested.<br>2） The fact that there are no lives on the moon is known to us all.<br>例句1）中的定语从句that you pointed out并不是表示fact的内容，只是在限制fact的所指范围，即“你指出的这个事实”。<br>例句2）中的同位语从句that there are no lives on the moon是表示fact的具体内容，在意义上与fact构成同位关系。<br>1）你指出的这一点，我很感兴趣。<br>2）众所周知，月球上并没有生命存在。</p>
<h2 id="带有插入语的定语从句"><a href="#带有插入语的定语从句" class="headerlink" title="带有插入语的定语从句"></a>带有插入语的定语从句</h2><h3 id="定语从句的关系词后面插入一个主谓结构"><a href="#定语从句的关系词后面插入一个主谓结构" class="headerlink" title="定语从句的关系词后面插入一个主谓结构"></a>定语从句的关系词后面插入一个主谓结构</h3><p>定语从句的关系词后面插入的往往是一些表达个人主观观点的主谓结构，如they think, he said, they believe, he claimed, they assume等等。这些主谓结构紧跟在关系代词后面。</p>
<h4 id="作主语的关系词-插入语-定语从句的谓语部分"><a href="#作主语的关系词-插入语-定语从句的谓语部分" class="headerlink" title="作主语的关系词+插入语+定语从句的谓语部分"></a>作主语的关系词+插入语+定语从句的谓语部分</h4><p>Many students face problems when they have to study a subject that they think is difficult.<br>这里的定语从句本身的结构是that…is difficult，但现在关系代词that后面紧跟了一个插入语they think，定语从句的主语that和谓语部分is difficult被they think这个插入语分隔。<br>很多学生如果必须学一门他们认为很难的课程时，就会遇到很多问题。</p>
<p>Sometimes the very things that we think are holding us down are the things that are helping us fly. That is what discipline is all about.<br>定语从句的主语that和谓语部分are holding us down被 we think这个插入语分隔。<br>有时候我们认为正在拖我们后腿的东西其实正是帮助我们飞翔的东西，那就是纪律的含义所在。</p>
<h4 id="作宾语的关系词-插入语-定语从句的主谓部分"><a href="#作宾语的关系词-插入语-定语从句的主谓部分" class="headerlink" title="作宾语的关系词+插入语+定语从句的主谓部分"></a>作宾语的关系词+插入语+定语从句的主谓部分</h4><p>The millionaire had a very ugly girl who I could not have dreamed many boys fell in love with.<br>定语从句的宾语who和定语从句的主谓语many boys fell in love with被I could not have dreamed这个插入语分隔。<br>这个百万富翁有一个十分丑陋的女儿，可是让我难以想象的是，竟然有很多男孩子在追求她。</p>
<p>What is harder to establish is whether the productivity revolution that businessmen assume they are presiding over is for real.<br>定语从句的宾语that和定语从句的主谓语they are presiding over被businessmen assume这个插入语分隔。<br>商界人士自以为他们正在进行一场生产力革命，但这是否是真正意义上的生产力革命，对此更加难以证实。</p>
<blockquote>
<p>插入语是不影响定语从句本身的结构的，所以不能在这种特殊的定语从句中随便添加连词，比如上面定语从句不能改成that businessmen assume that they are presiding over is for real*。<br>这里over是缺少宾语的，从句不是一个完整的结构，无法构成名词从句。</p>
</blockquote>
<p>They pointed out【A】 the damage which【B】 they supposed that【C】 had been done by last night’s【D】 storm.<br>这里的定语从句本身的结构应该是which…had been done by last night’s storm，修饰前面的名词damage。但现在关系代词which后面紧跟了一个插入语they supposed<br>他们指出了这些损坏，认为这是由昨晚的暴风雪造成的。</p>
<h4 id="what引导的从句中带一个主谓结构的插入语"><a href="#what引导的从句中带一个主谓结构的插入语" class="headerlink" title="what引导的从句中带一个主谓结构的插入语"></a>what引导的从句中带一个主谓结构的插入语</h4><p>There was a very interesting remark in a book by an Englishman that I read recently giving what he thought was a reason for this American characteristic.<br>我最近看过一本书，它是由一个英国人写的，我还记得书里有一句十分有趣的话，作者认为这句话说明了美国人为什么是这种性格。<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/3cBypA.png"><br>分词短语的结构图示：<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/tzs6BO.png"><br>我最近看过一本书，它是由一个英国人写的，我还记得书里有一句十分有趣的话，作者认为这句话说明了美国人为什么是这种性格。</p>
<h4 id="定语从句的关系词后面插入一个其他成分"><a href="#定语从句的关系词后面插入一个其他成分" class="headerlink" title="定语从句的关系词后面插入一个其他成分"></a>定语从句的关系词后面插入一个其他成分</h4><p>Real friends are those who, when you’ve made a fool of yourself, don’t feel that you’ve done a permanent job.<br><img src="https://gitee.com/fengorz/oss/raw/master/uPic/OVN2TR.png"><br>真正的朋友就是，即使你出了洋相，他们也不会认为你以后还会这样。</p>
<p>Our limited thinking prevents us from progress. There was a fisherman who, every time he caught a big fish, would throw it back into the river, keeping only the smaller ones. A man watching this unusual behavior asked the fisherman why he was doing this. The fisherman replied: “Because I have a small frying pan.”Most people never make it in life because they are carrying a small frying pan. That is limited thinking.<br>我们局限性的思维会阻碍我们进步。比如，有个渔夫，每次捕到大鱼时都会把它丢回河里，而只把个头比较小的鱼留下。有个人看到了渔夫这种不寻常的行为，就问他为什么这样做。渔夫回答说：“因为我家只有一只很小的平底锅。”大部分人在生活中不能成功就是因为他们只带着一只小平底锅。这就是局限性的思维。</p>
<h2 id="并列定语从句"><a href="#并列定语从句" class="headerlink" title="并列定语从句"></a>并列定语从句</h2><p>所谓并列定语从句，是指两个或两个以上的定语从句，通过and, but, or等并列连词连接共同修饰一个先行词。<br>The errors occurring in the exam often result from the things that you don’t know or that you think you know.<br>两个定语从句that you don’t know 和that you think you know由连词or连接，修饰同一个先行词the things。<br>考试中所犯的错误，往往是因为某些知识点你不知道或者你认为自己知道（但实际上你不知道）。</p>
<p>这样的定语从句不是并列定语从句：<br>He found a dollar bill that he had forgotten in a suit that he was sending to the cleaner.<br>两个定语从句that he had forgotten in a suit和that he was sending to the cleaner的先行词各不相同，前者的先行词是a dollar bill，后者的先行词是a suit。<br>他在那件正要送到洗衣店去的西服里找到了他忘记的一美元。</p>
<h2 id="双层定语从句"><a href="#双层定语从句" class="headerlink" title="双层定语从句"></a>双层定语从句</h2><p>He is the only person that we know who speaks so many foreign languages.<br>第一层定语从句that we know的先行词为the only person；第二层定语从句who speaks so many foreign languages的先行词为the only person that we know。<br>他是我们所认识的人当中唯一一位会说这么多外语的人。</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之状语从句</title>
    <url>/2020/10/17/English%E7%B3%BB%E5%88%97%E4%B9%8B%E7%8A%B6%E8%AF%AD%E4%BB%8E%E5%8F%A5/</url>
    <content><![CDATA[<blockquote>
<p>这篇笔记摘选自张满胜老师的《英语语法新思维中级教程第2版》，以及其他网上知识点收集，只是我自己的个人复习笔记，禁止转载，如有侵权，请联系我删除。</p>
</blockquote>
<h2 id="时间状语从句"><a href="#时间状语从句" class="headerlink" title="时间状语从句"></a>时间状语从句</h2><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/eu3tlA.png"></p>
<h3 id="时间连词when的用法特点"><a href="#时间连词when的用法特点" class="headerlink" title="时间连词when的用法特点"></a>时间连词when的用法特点</h3><p>when的意思相当于at that time（在……时刻），从句的谓语动词通常是短暂动词，表示某一时刻的动作（从句也可接延续动词，这时从句往往用过去进行时态）。</p>
<h4 id="主句一般过去时-从句一般过去时"><a href="#主句一般过去时-从句一般过去时" class="headerlink" title="主句一般过去时+从句一般过去时"></a>主句一般过去时+从句一般过去时</h4><p>I started my dinner when he left. 他走了之后，我才开始吃晚饭。<br>He left when I got there. 我到了以后，他才离开。<br>若主从句都用一般过去时，则表示从句动作先发生。要强调从句动作先发生，从句还可以用过去完成时。</p>
<h4 id="主句一般过去时-从句过去完成时"><a href="#主句一般过去时-从句过去完成时" class="headerlink" title="主句一般过去时+从句过去完成时"></a>主句一般过去时+从句过去完成时</h4><p>I started my dinner when he had left.<br>He left when I had got there.</p>
<blockquote>
<p>短暂动作用一般过去时，延续动作用过去进行时。</p>
</blockquote>
<h4 id="主句一般过去时-从句过去进行时"><a href="#主句一般过去时-从句过去进行时" class="headerlink" title="主句一般过去时+从句过去进行时"></a>主句一般过去时+从句过去进行时</h4><p>The doorbell rang when I was telephoning.<br>这里的短暂动作rang用一般过去时，延续动作telephone用过去进行时。<br>门铃响的时候，我正在打电话。</p>
<h4 id="主句过去完成时-从句一般过去时"><a href="#主句过去完成时-从句一般过去时" class="headerlink" title="主句过去完成时+从句一般过去时"></a>主句过去完成时+从句一般过去时</h4><p>I had started my dinner when he left.<br>他走的时候，我已经开始吃晚饭了。<br>He had already left when I got there.<br>我到的时候，他已经离开了。</p>
<h4 id="主句过去进行时-从句一般过去时"><a href="#主句过去进行时-从句一般过去时" class="headerlink" title="主句过去进行时+从句一般过去时"></a>主句过去进行时+从句一般过去时</h4><p>I was telephoning when the doorbell rang. 我当时正在打电话，突然门铃响了。<br><em><strong>短动作才能接类似suddenly的词：</strong></em><br>1）The doorbell rang when suddenly I was telephoning. *<br>2）I was telephoning when suddenly the doorbell rang.</p>
<h4 id="主句一般将来时-从句一般现在时"><a href="#主句一般将来时-从句一般现在时" class="headerlink" title="主句一般将来时+从句一般现在时"></a>主句一般将来时+从句一般现在时</h4><p>在表示将来的动作时，主句显然要用一般将来时（simple future），而时间状语从句要用一般现在时（simple present）表示将来，不能使用将来时态。<br>I’ll speak to him when he arrives. 等他到了我要和他说话。<br>I’ll tell him about it when he comes back. 等他回来我要告诉他这件事。</p>
<h4 id="主句一般将来时-从句现在完成时"><a href="#主句一般将来时-从句现在完成时" class="headerlink" title="主句一般将来时+从句现在完成时"></a>主句一般将来时+从句现在完成时</h4><p>在when引导的从句中，除了用一般现在时表示将来之外，还可用现在完成时表示一个将要发生的动作，主句依然用一般将来时。<br>从句中用完成时态是为了强调：在从句动作结束了之后，主句动作才开始发生。此时从句的动作一般都是需要持续一段时间的。<br>I’ll go when I have had my dinner.<br>如果说“I’ll go when I have my dinner.”，则表示“我吃着饭的同时就出去了。”<br>我吃完饭就去。</p>
<p>I’ll give you a call when I have finished the work.<br>工作做完后，我就给你打电话。</p>
<h4 id="主句将来完成时-从句一般现在时"><a href="#主句将来完成时-从句一般现在时" class="headerlink" title="主句将来完成时+从句一般现在时"></a>主句将来完成时+从句一般现在时</h4><p>The performer will already have played the music when we get here.<br>一会我们到的时候，那位演奏家一定已经弹完那首曲子了。</p>
<h4 id="主句将来进行时-从句一般现在时"><a href="#主句将来进行时-从句一般现在时" class="headerlink" title="主句将来进行时+从句一般现在时"></a>主句将来进行时+从句一般现在时</h4><p>The performer will be playing the music when we get there.<br>一会我们到的时候，那位演奏家一定正在弹那首曲子。</p>
<h4 id="主从句都用一般现在时"><a href="#主从句都用一般现在时" class="headerlink" title="主从句都用一般现在时"></a>主从句都用一般现在时</h4><p>表示一般动作的when引导的从句往往是说明一般情况，阐明一个道理，因而常出现在名言警句、谚语或格言中。<br>If there are no dogs in Heaven, then when I die I want to go where they went.<br>如果天堂里没有狗，那么我愿意死后不去天堂，而去有狗的地方。<br>When my attitudes are right, there is no barrier too high, no valley too deep, no dream too extreme, no challenge too great for me.</p>
<h4 id="whenever引导时间状语从句"><a href="#whenever引导时间状语从句" class="headerlink" title="whenever引导时间状语从句"></a>whenever引导时间状语从句</h4><p>我们可以用whenever引导时间状语从句，表示“无论何时”，它相当于when的强调形式。<br>Whenever you say “I love you”, mean it. Whenever you say “I’m sorry”, look the person right in the eyes.<br>无论何时说“我爱你”，请真心诚意。无论何时说“对不起”，请看着对方的眼睛。</p>
<p>Smile whenever you pick up the phone, for the caller will be able to notice it.<br>面带微笑地接听电话，因为对方会感觉得到。</p>
<h3 id="时间连词while的用法特点"><a href="#时间连词while的用法特点" class="headerlink" title="时间连词while的用法特点"></a>时间连词while的用法特点</h3><p>当while用作时间连词时，意思相当于during that time（在……期间），表示某一时间段内发生的动作。因此，从句的谓语动词通常是延续动词。<br>The phone rang while I was taking my bath.</p>
<p>A detective （侦探） arrested a criminal and was about to handcuff（给……戴手铐） him when a huge gust （一阵狂风） of wind blew the detective’s hat off.<br>“Shall I go and fetch it?”the criminal asked.“Do you take me for a fool?”asked the detective.“You wait here while I go and get it!”<br>此句中的go和get尽管是短暂动词，但两个动词连用表示的是在一段期间内的活动，所以用连词while。<br>一个侦探逮捕了一名罪犯。他正准备给罪犯戴上手铐，这时刮起了一阵狂风，把侦探的帽子吹落了。罪犯立即说：“需要我去帮你把帽子捡起来吗？”侦探答道：“你把我当傻瓜啊？你在这里等着，我自己去捡！”</p>
<h3 id="时间连词as的用法特点"><a href="#时间连词as的用法特点" class="headerlink" title="时间连词as的用法特点"></a>时间连词as的用法特点</h3><p>当as引导时间从句时，它相当于while，即后面要接延续动词，一般译成“正当……”，“随着……”或“一边……一边……”。与as引导的从句搭配的主句的谓语可以是延续动词，也可以是短暂动词。<br>The arrow fell into the river as the boat was drifting on the water. The soldier tried to retrieve it.<br>船在水面上行使时，箭突然掉进了河里。这名士兵想找回这支箭。</p>
<p>Urban Japanese have long endured lengthy commutes （travels to and from work） and crowded living conditions, but as the old group and family values weaken, the discomfort is beginning to tell.<br>从句的谓语weaken是延续动词，主句的谓语is beginning表示一个持续的过程。as在这里可以译成“随着……”。<br>日本的城市居民长期以来忍受着漫长的上下班往返时间以及拥挤的住房条件，但是，随着老龄人群和家庭的价值削弱，人们慢慢开始感受到不舒服了。</p>
<h3 id="时间连词before的用法特点"><a href="#时间连词before的用法特点" class="headerlink" title="时间连词before的用法特点"></a>时间连词before的用法特点</h3><p>before主从句时态搭配中，比较常见的一种是“主句用过去完成时，从句用一般过去时”，before一般译成“在……之前”，但有时候可以有不同的译法。<br>During several years of gambling in that casino, Williams, a state auditor earning $35,000 a year, lost approximately $175,000. He had never gambled before the casino sent him a coupon for $20 worth of gambling.<br>威廉斯先生是一位审计员，年收入为35,000美元，他这几年在这个赌场里输掉了175,000美元。而在该赌场送给他一张价值20美元的赌票之前，他从未赌博过。</p>
<h4 id="前后两个部分有一种转折的意味"><a href="#前后两个部分有一种转折的意味" class="headerlink" title="前后两个部分有一种转折的意味"></a>前后两个部分有一种转折的意味</h4><p>Our magazines feature beaming celebrities and happy families in perfect homes. And since these messages have an agenda—to lure us to open our wallets—they make the very idea of happiness seem unreliable. “Celebrate!”commanded the ads for the arthritis drug Celebrex, before we found out it could increase the risk of heart attacks.<br>这里before引导的从句虽然是表示时间，但其实是引导了一个前后对比关系：before之前的部分说，治疗关节炎的药物Celebrex的广告鼓动人们去“欢乐”，before后面的部分说，我们发现这种药物会加大罹患心脏病的危险。所以，前后两个部分有一种转折的意味。<br>我们杂志的报道往往都是专注于那些面带愉快微笑的名人以及其他完美之家中的快乐成员。由于这些信息只有一个目的——诱惑我们打开钱包，所以这些信息使“快乐”这个概念似乎不可靠。比如，治疗关节炎的药物西乐葆这个广告鼓动人们去“欢乐”，结果我们发现这种药品会加大罹患心脏病的危险。</p>
<h4 id="译成“只有……才……”"><a href="#译成“只有……才……”" class="headerlink" title="译成“只有……才……”"></a>译成“只有……才……”</h4><p>The mineral elements from the soil that are usable by the plant must be dissolved in the soil solution before they can be taken into the root.<br>这里before引导的从句虽然是表示时间，但就上下文的逻辑关系来看，我们可以把它转译成一个条件从句，译成“只有……才……”。<br>土壤里的矿物质是无法被植物直接利用的，它们只有在溶于土壤的溶液里之后，才能为植物的根系所吸收。</p>
<h4 id="译成“在多长时间之后才……”"><a href="#译成“在多长时间之后才……”" class="headerlink" title="译成“在多长时间之后才……”"></a>译成“在多长时间之后才……”</h4><p>在before引导的从句之前若有一段时间，这时候before引导的从句一般可以翻译成“在多长时间之后才……”。<br>It took a few months of investigation before it became clear.<br>这里before的前面有一个时间段a few months，如果按照原文的语序译成“在情况变得明朗之前，花了几个月时间的调查”，就有股“英语腔”，不符合汉语的表达习惯。<br>经过了几个月的调查之后，情况才开始变得明朗。</p>
<p>In this factory, suggestions often have to wait for months before they are fully considered.<br>在这家工厂里，建议往往要等上数月之后才能被考虑。</p>
<h3 id="时间连词after的用法特点"><a href="#时间连词after的用法特点" class="headerlink" title="时间连词after的用法特点"></a>时间连词after的用法特点</h3><p>常见的搭配是“主句用一般过去时，从句用过去完成时”。<br>I moved to America after I had learned English for ten years.<br>我学了十年英语后搬到了美国。</p>
<h3 id="时间连词since的用法特点"><a href="#时间连词since的用法特点" class="headerlink" title="时间连词since的用法特点"></a>时间连词since的用法特点</h3><h4 id="现在完成时态-since-短暂动词的一般过去时"><a href="#现在完成时态-since-短暂动词的一般过去时" class="headerlink" title="现在完成时态+since+短暂动词的一般过去时"></a>现在完成时态+since+短暂动词的一般过去时</h4><p>I have worked in this company since I graduated.<br>自从我毕业，就一直在这家公司上班。</p>
<h4 id="现在完成时态-since-延续动词的一般过去时"><a href="#现在完成时态-since-延续动词的一般过去时" class="headerlink" title="现在完成时态+since+延续动词的一般过去时"></a>现在完成时态+since+延续动词的一般过去时</h4><p>若since后面的延续动词用一般过去时态，则表示从句动作“结束”以来，主句活动还在持续。<br>He hasn’t contacted me since I worked in that company.<br>主句时间则是从work这个活动已经“结束”后开始算起的，即该句表示“我”不在这家公司工作了。<br>自从我离开那家公司后，他就再没有和我联系过。</p>
<h4 id="现在完成时态-since-延续动词的现在完成时"><a href="#现在完成时态-since-延续动词的现在完成时" class="headerlink" title="现在完成时态+since+延续动词的现在完成时"></a>现在完成时态+since+延续动词的现在完成时</h4><p>若since后面的延续动词用现在完成时态，则表示从句动作“开始”以来，主句活动在持续。<br>He hasn’t contacted me since I have worked in that company.<br>自从我开始在那家公司工作后，他就再没有和我联系过。</p>
<h3 id="时间连词until的用法特点"><a href="#时间连词until的用法特点" class="headerlink" title="时间连词until的用法特点"></a>时间连词until的用法特点</h3><h4 id="延续动词-until-短暂动词或时间点"><a href="#延续动词-until-短暂动词或时间点" class="headerlink" title="延续动词+until+短暂动词或时间点"></a>延续动词+until+短暂动词或时间点</h4><p>当主句或句子的谓语动词是延续动词时，通常用肯定形式。until的后面若接从句，则从句的谓语必定是短暂动词，或者接表示时间点（point of time）的名词短语。<br>Wait until he comes back.<br>I will be away from my office until next Tuesday.<br>我将要离开办公室，要到下周二才能回来。</p>
<h4 id="短暂动词-until-短暂动词或时间点"><a href="#短暂动词-until-短暂动词或时间点" class="headerlink" title="短暂动词+until+短暂动词或时间点"></a>短暂动词+until+短暂动词或时间点</h4><p>若主句的谓语动词是短暂动词，则要用否定形式。因为否定之后表示的是一个状态，而状态则是延续的。</p>
<blockquote>
<p>not…until（直到……才）</p>
</blockquote>
<p>He didn’t leave the office until his boss came back.<br>直到老板回来后，他才离开办公室。</p>
<p>I didn’t go to bed until 12 o’clock last night.<br>我昨晚12点才上床睡觉。</p>
<h3 id="表示“一……就”的结构"><a href="#表示“一……就”的结构" class="headerlink" title="表示“一……就”的结构"></a>表示“一……就”的结构</h3><h4 id="从句动作先于主句动作"><a href="#从句动作先于主句动作" class="headerlink" title="从句动作先于主句动作"></a>从句动作先于主句动作</h4><p>表示这一时间关系的连词有：as soon as，once，the minute，the moment，the instant，immediately，directly和instantly等等。<br>这些连词的用法和句式结构是一样的，主从句时态一般一致。若表示将来的动 作，则主句用一般将来时（simple future），从句用一般现在时（simple present）表示将来。<br>We will leave as soon as it stops raining.<br>这里主句谓语的时态是一般将来时will leave，从句谓语的时态是一般现在时stops，但表示将来的动作。最后，这里从句的动作stops先发生，紧接着主句动作leave发生，即“雨先停，再离开”。<br>雨一停，我们就动身。</p>
<p>The doorbell rang as soon as we began having dinner.<br>我们刚开始吃晚饭，这时候门铃就响了。</p>
<p>可以把连词as soon as换成其他连词，比如 immediately，instantly或directly。<br>It began to rain immediately I arrived home.<br>The doorbell rang immediately we began having dinner.<br>或者换成带有定冠词the的连词，比如the moment，the minute或the instant。</p>
<p>A fair-weather friend is like a banker who lends you his umbrella when the sun is shining and takes it back the minute it rains.<br>酒肉朋友就像一个银行家，正值阳光灿烂时他会把伞借给你，而一旦天下雨他就立即将伞收回。<br>Don’t trust those who leave their friends the moment they get into difficulty!<br>一旦朋友陷入困境就会转身脱逃的人，我们不能信任！</p>
<p>You see the lightning <em><strong>the instant</strong></em> it happens, but you hear the thunder later.<br>这里主句的谓语动词see和从句的谓语动词happens都是短暂动词，即表示“一……就”。<br>闪电一发生你就能看见，但你要过一会才能听见雷声。</p>
<h4 id="主句动作先于从句动作"><a href="#主句动作先于从句动作" class="headerlink" title="主句动作先于从句动作"></a>主句动作先于从句动作</h4><p>如果要表达在主句动作发生之后，紧接着从句动作就发生了。<br>表示这一时间关系的连词有：hardly…when，scarcely…when和no sooner…than。这些连词的用法和句式结构是不一样的，主从句时态一般也不一致。<br>1） No sooner had I arrived home than it began to rain.<br>2） It began to rain as soon as I arrived home.<br>在例句1）中，连词than后面的it began to rain是从句，had I arrived home是主句；主句had I arrived home用了过去完成时且是倒装结构，从句it began to rain用一般过去时。<br>在例句2）中，it began to rain是主句，I arrived home是从句；主句it began to rain和从句I arrived home都用一般过去时。</p>
<p>No sooner had I started to type my paper than the telephone rang.<br>我刚开始打我的论文，这时电话铃响了。</p>
<p>还可以用<code>hardly/scarcely…when</code>这一结构来表达同样的意思。<br>Hardly had I arrived home when it began to rain.<br>Scarcely had I started to type my paper when the telephone rang.</p>
<h2 id="地点状语从句"><a href="#地点状语从句" class="headerlink" title="地点状语从句"></a>地点状语从句</h2><p>地点状语从句通常由where引导，用来表达主句的动作发生的场所。其结构通常就是“where+陈述句”，从句可以放在句首或句末。<br>Stay where you are. 呆在原处别动。<br>Generally, air will be heavily polluted where there are factories. 一般在有工厂的地方，空气污染都会很严重。</p>
<p>地点状语从句若放在句首，在翻译时往往失去地点的含义，要灵活 处理。<br>Where there is a will, there is a way. 有志者，事竟成。<br>Where there is Love, there is also Wealth and Success! 只要有爱，就会有成功和财富！</p>
<h2 id="原因状语从句"><a href="#原因状语从句" class="headerlink" title="原因状语从句"></a>原因状语从句</h2><h3 id="常见连词的用法"><a href="#常见连词的用法" class="headerlink" title="常见连词的用法"></a>常见连词的用法</h3><p>我们常用because，for，as和since这四个连词来引导原因状语从句。<br>because的语气最强，只有它才能用来回答why的问句，所引出的原因往往是听话人所不知道的或最感兴趣的；也只有because才能被强调词如only，just和perhaps等来修饰。<br>My friends dislike me because I’m handsome and successful.<br>我的朋友都不喜欢我，是因为我长相英俊又事业有成。<br>Perhaps because most of today’s cross-cultural marriages occur because of“true love”, these couples work hard to overcome their differences.<br>一般就不会说perhaps for<em>，perhaps as</em>或perhaps since*。<br>可能因为现在大多数跨国婚姻都是基于真爱，所以夫妇俩都很努力地克服双方的差异。</p>
<p>连词since表示人们已知的事实，是不需强调的原因，所以常译成“既然”，通常放在句首。<br>Since we don’t have class tomorrow, why not go out for a picnic?<br>既然我们明天没有课，那么为什么不出去野餐呢？</p>
<p>连词as与since的用法差不多，所引出的理由在说话人看来已经很明显，或已为听话人所熟悉而不需用because加以强调。<br>As Monday is a national holiday, all government offices will be closed.<br>由于周一是法定假日，所有的政府机关都将休息。</p>
<p>连词for表示推断的理由，是对前面分句的内容加以解释或说明。<br>It rained last night, for the ground is wet this morning.<br>昨晚下雨了，因为今天早上地是湿的。</p>
<p>相比较而言：</p>
<ul>
<li>as和for引导的主、从句，二者处于平等位置；</li>
<li>because引导的从句显得比主句重要，强调原因；</li>
<li>since引导的从句显得次要，而主句重要，以说明将要做什么事。</li>
</ul>
<h3 id="用介词表示因果关系"><a href="#用介词表示因果关系" class="headerlink" title="用介词表示因果关系"></a>用介词表示因果关系</h3><p>常用的介词有：because of，due to和owing to。因为是介词，所以其后面不能接从句。<br>We had an accident because he was careless.<br>We had an accident due to his carelessness.<br>Owing to his carelessness we had an accident.</p>
<ul>
<li>在例句1中，因为是从句，所以用连词because引导。</li>
<li>在例句2中，因为是名词短语his carelessness，所以用介词连接。此处不能说due to he was careless*。</li>
<li>在例句3中，同样是名词短语his carelessness，所以要用介词。一般来说，owing to常置于句首，而due to通常不这么用。</li>
</ul>
<p>由于他的粗心大意，我们出了车祸。</p>
<h2 id="目的状语从句"><a href="#目的状语从句" class="headerlink" title="目的状语从句"></a>目的状语从句</h2><p>常用的引导目的状语从句的连词有：so that，in order that和that。另外，在目的状语从句中常含有情态动词，比如may&#x2F;might或can&#x2F;could等。<br>I turned off the TV in order that my roommate could study in peace and quiet.<br>这里的从句由in order that引导，表示目的，意为“以便”。从句含有情态动词could。<br>我关掉了电视，好让我的室友安静地学习。</p>
<p>When I was a child, I would take a flashlight to bed with me so that I could read comic books without my parents’ knowing about it.<br>这里的从句由so that引导，表示目的，意为“以便”。从句含有情态动词could。<br>小的时候，我睡觉时常常带着手电筒上床，这样我就可以偷看连环画册而不被父母发觉。</p>
<p>We climbed high (so) that we might get a better view. 我们爬到高处，以便能看得更清楚。</p>
<p>目的状语从句一般位于主句之后。但若要强调目的状语从句，可将so that或in order that引导的目的状语从句置于句首：<br>In order that my roommate could study in peace and quiet, I turned off the TV.</p>
<h2 id="结果状语从句"><a href="#结果状语从句" class="headerlink" title="结果状语从句"></a>结果状语从句</h2><p>结果状语从句都要放在主句之后，而不能提到句首。</p>
<h3 id="连词so…that的用法"><a href="#连词so…that的用法" class="headerlink" title="连词so…that的用法"></a>连词so…that的用法</h3><p>so后面接形容词或副词。</p>
<h4 id="接形容词"><a href="#接形容词" class="headerlink" title="接形容词"></a>接形容词</h4><p>The food in our school canteen is so bad that flies go there to lose weight.<br>我们学校食堂的饭菜质量真差，连苍蝇都飞到那里去减肥。</p>
<h4 id="接副词"><a href="#接副词" class="headerlink" title="接副词"></a>接副词</h4><p>He has put forward unquestioned claims so consistently that he not only believes them himself, but has convinced industrial and business management that they are true.<br>他一直不断地提出确定不疑的主张，以至于不仅他自己对他们深信不疑，而且还使得工商管理界相信他们都是真的。</p>
<h3 id="连词such…that的用法"><a href="#连词such…that的用法" class="headerlink" title="连词such…that的用法"></a>连词such…that的用法</h3><p>such后面要接名词（短语）。<br>Diplomats and crabs are creatures who move in such a way that it is impossible to tell whether they are coming or going.<br>外交官和螃蟹是行为方式相同的动物，我们无法判断他们是要向前走还是想往后退。</p>
<p>1） He is such a good teacher that everyone likes him.<br>2） He is so good a teacher that everyone likes him.<br>注意这里冠词a的位置：a要紧跟在such的后面。<br>他是一个好老师，所有人都喜欢他。</p>
<h3 id="结果状语从句的倒装"><a href="#结果状语从句的倒装" class="headerlink" title="结果状语从句的倒装"></a>结果状语从句的倒装</h3><p>such&#x2F;so…that引导结果状语从句，为了强调，还可以将主句中的so或such引导的部分置于句首从而构成倒装结构。</p>
<p>So fast does light travel that it is difficult for us to imagine its speed.<br>这句话的正常语序为“Light travels so fast that it is difficult for us to imagine its speed.”。<br>光的传播速度是如此之快，以至于我们无法想象它的速度。</p>
<p>Such a fool was he that he believed her.<br>这句话的正常语序为“He was such a fool that he believed her.”。<br>他真是愚蠢，连她都相信。</p>
<h2 id="条件状语从句"><a href="#条件状语从句" class="headerlink" title="条件状语从句"></a>条件状语从句</h2><p>最常见的条件状语从句的引导词是if和unless。连词if表示“如果”，unless表示“如果不”或“除非”。<br>If winter comes, can spring be far behind? 冬天来了，春天还会远吗？</p>
<p>其他引导条件状语从句的连词有：suppose (that)，supposing (that)，providing&#x2F;provided (that)，so long as，as long as和on condition that等。<br>So long as you work hard enough, an iron rod can be ground into a needle. 只要功夫深，铁杵磨成针。<br>A man is not old as long as he is seeking something. A man is not old until regrets take the place of dreams.<br>一个人只要还有追求，他就不算老。只有当心中不再有梦想，而只是满怀遗憾，这时他才真正老了。<br>Knowledge helps you to reach the destination provided you know what the destination is.<br>如果你知道自己的目标是什么，知识就能帮助你达到这个目标。</p>
<h2 id="让步状语从句"><a href="#让步状语从句" class="headerlink" title="让步状语从句"></a>让步状语从句</h2><p>常见的引导让步状语从句的词有though，although，even though和 even if。此时，主句前不可用but，但可用yet或still。<br>Although he tried hard, (yet&#x2F;still) he failed. 尽管他努力了，但他还是失败了。<br>The family is the essential presence–the thing that never leaves you, even if you find you have to leave it.<br>对于每个人来说，家是不可或缺的，它永远为你守候，即使有一天你发现你不得不离开它。</p>
<p>Although Professor Green’s lectures usually ran over【A】 the fifty- minute period, but 【B】none【C】 of his students even objected【D】 as they found his lectures both informative and interesting.<br>B，应该把but去掉。<br>尽管格林教授上课时间常超过50分钟，但是他的学生中没有一个人反对，因为他们觉得他的课既有趣又有收获。</p>
<h3 id="表示让步转折关系的介词"><a href="#表示让步转折关系的介词" class="headerlink" title="表示让步转折关系的介词"></a>表示让步转折关系的介词</h3><p>这些介词主要有despite，in spite of和for all。需要注意的是，although和though是连词，因此后面只接从句（有时是省略形式的从句），而这里的介词只接名词（短语），不能接从句。<br>1） Though he was inexperienced, he did a very good job.<br>2） In spite of his inexperience, he did a very good job.<br>3） In spite of his being inexperienced, he did a very good job.<br>在例句3）中，his being inexperienced是动名词短语的形式，也属于名词短语，所以这里也需要用介词。<br>尽管他没有经验，但是他表现得很不错。</p>
<p>其他类似的例子还有：<br>1） Although it was dangerous,…<br>2） Despite the danger,…</p>
<p>1） Though the weather was bad,…<br>2） In spite of the bad weather,…</p>
<blockquote>
<p>介词后面除了接名词短语外，还可以接what引导的名词从句。</p>
</blockquote>
<p>______ tired, he wouldn’t stop working.<br>A. Despite<br>B. For all<br>C. Though<br>D. Whereas<br>这是一个省略的状语从句，原句相当于“Though he was tired, he wouldn’t stop working.”。所以要用连词，而不是介词。</p>
<blockquote>
<p>介词后面可以接名词、名词短语、动名词或what引导的从句；<br>连词后面可以接完整的陈述句、形容词（相当于省略句）、分词（相当于省略句）等。</p>
</blockquote>
<h3 id="置于句首的while一般表示“尽管”"><a href="#置于句首的while一般表示“尽管”" class="headerlink" title="置于句首的while一般表示“尽管”"></a>置于句首的while一般表示“尽管”</h3><p>While the government pushed for a total breakup of the software maker, Microsoft fought fiercely against any positions that would affect its ability to compete in the marketplace.<br>尽管美国政府积极要求彻底拆分微软这个软件巨人，但是微软公司极力反对任何影响其市场竞争力的动议。</p>
<h3 id="as引导的倒装句表示让步"><a href="#as引导的倒装句表示让步" class="headerlink" title="as引导的倒装句表示让步"></a>as引导的倒装句表示让步</h3><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/e35fTf.png"></p>
<h4 id="形容词提至句首"><a href="#形容词提至句首" class="headerlink" title="形容词提至句首"></a>形容词提至句首</h4><p>Young as he is, he is knowledgeable. 他虽然年轻，但知识渊博。<br>Oldest in our workshop as he is, he works hardest.<br>尽管他是我们车间最年长的一位，他工作起来最努力。</p>
<h4 id="副词提至句首"><a href="#副词提至句首" class="headerlink" title="副词提至句首"></a>副词提至句首</h4><p>Much as I respect him, I can not agree with him. 虽然我非常尊重他，但是我仍旧不同意他的意见。<br>Again as he failed in doing this experiment, he didn’t lose his heart. 尽管他的试验再次失败了，但是他并不灰心。</p>
<h4 id="分词提至句首"><a href="#分词提至句首" class="headerlink" title="分词提至句首"></a>分词提至句首</h4><p>Praised as he was, he remained modest. 尽管他受到了表扬，却仍旧很谦虚。</p>
<h4 id="名词提至句首"><a href="#名词提至句首" class="headerlink" title="名词提至句首"></a>名词提至句首</h4><p>Child as he is, he is knowledgeable.<br>他虽然还是个孩子，却知识渊博。<br>Lazy a boy as he is, he is kind to help others.<br>他虽然很懒惰，却乐于助人。</p>
<h2 id="比较状语从句"><a href="#比较状语从句" class="headerlink" title="比较状语从句"></a>比较状语从句</h2><h3 id="连词as的基本用法"><a href="#连词as的基本用法" class="headerlink" title="连词as的基本用法"></a>连词as的基本用法</h3><p>as引导比较状语从句，其基本结构是as…as，其中前一个as是副词，后一个as是比较状语从句的连词。</p>
<h4 id="结构1：as-形容词或副词-as"><a href="#结构1：as-形容词或副词-as" class="headerlink" title="结构1：as+形容词或副词+as"></a>结构1：as+形容词或副词+as</h4><p>The work is not as difficult as you think. 这项工作不像你想象的那么难。</p>
<h4 id="结构2：as-形容词-a-n-可数名词单数-as"><a href="#结构2：as-形容词-a-n-可数名词单数-as" class="headerlink" title="结构2：as+形容词+a(n)+可数名词单数+as"></a>结构2：as+形容词+a(n)+可数名词单数+as</h4><p>这里前一个as作为副词来修饰一个形容词，而这个形容词同时又修饰一个名词。使用时要特别注意这里形容词置于不定冠词之前这一特点。<br>Rarely has a technological development had as great an impact on so many aspects of social, economic, and cultural development as the growth of electronics.<br>若没有as修饰great，这句话原本的结构是a great impact，但现在将其放置在as…as结构中，则冠词和形容词的语序要互换，因此成了as great an impact as。另外要注意的是，整个句子是一个倒装句，正常语序为“A technological development has rarely had as great an impact on…as the growth of electronics.”。<br>很少有哪项科技的发展能像电子技术的发展这样，对我们的社会、经济以及文化等诸多方面产生如此重要的影响。</p>
<p>Americans tend to think from small to large. Let us take as simple an example as the addressing of envelopes.<br>若没有as修饰simple，这句话原本的结构是a simple example，但现在将其放置在as…as结构中，则冠词和形容词的语序要互换，因此成了as simple an example as，译成“像这样的一个简单例子”。虽然这里as…as结构并不是引导一个比较状语从句，举这个例子主要是为了说明“as+形容词+a(n)+可数名词单数+as”这一结构。<br>美国人的思维习惯是由小到大。我们举一个写信封地址的简单例子吧。</p>
<h4 id="在否定句中第一个as可用so代替"><a href="#在否定句中第一个as可用so代替" class="headerlink" title="在否定句中第一个as可用so代替"></a>在否定句中第一个as可用so代替</h4><p>This room is not so large as the one we saw yesterday.<br>这个房间没有我们昨天看到的那个大。<br>No other modern nation devotes so small a portion of its wealth to public health as the United States does.<br>没有一个现代国家像美国这样，只把很少一部分财富投入到公共卫生事业中去。</p>
<h4 id="为了保持句子平衡，从句还可以用倒装结构"><a href="#为了保持句子平衡，从句还可以用倒装结构" class="headerlink" title="为了保持句子平衡，从句还可以用倒装结构"></a>为了保持句子平衡，从句还可以用倒装结构</h4><p>此时的结构是“as…as+助动词+主语”。<br>Small as it is, the ant is as much a creature as are all other animals on the earth.<br>这里的as are all other animals on the earth是一个倒装结构，主语是all other animals on the earth。另外，这里的as much…as表示的是“在同等程度上”，翻译时可以处理成“和……一样”。<br>尽管蚂蚁很小，但是它同地球上的任何其他动物一样，也是一种动物。</p>
<p>The computer revolution may well change society as fundamentally as did the Industrial Revolution.<br>这里的as did the Industrial Revolution是一个倒装结构。<br>计算机革命对于我们人类社会的改变之深刻，就如同当年的工业革命。</p>
<h3 id="连词than的基本用法"><a href="#连词than的基本用法" class="headerlink" title="连词than的基本用法"></a>连词than的基本用法</h3><h4 id="可比性问题"><a href="#可比性问题" class="headerlink" title="可比性问题"></a>可比性问题</h4><p>可比性问题，指两个同类事物才能比较，如he和I。不是同类事物是无法比较的。<br>He is taller than I (am). 他比我高。<br>The weather of the South is wetter than the North. *<br>因为the weather of the South和 the North是两个截然不同的事物，无法进行比较，应改为“The weather of the South is wetter than that of the North.”。</p>
<h4 id="比较形式问题"><a href="#比较形式问题" class="headerlink" title="比较形式问题"></a>比较形式问题</h4><p>在有than的比较句子里，主句中必须有比较级形式出现。<br>There are few electronic applications more likely to raise fears regarding future employment opportunities than robots.<br>很少有任何一项电子技术的应用能够像机器人这样，引起人们对未来就业机会的恐慌。</p>
<p>On the whole【A】, ambitious students are much likely 【B】to succeed in their studies than are those 【C】with little 【D】ambition.<br>B，应改为：more likely。<br>总的来说，有远大抱负的学生比那些胸无大志的学生更可能取得学业上的成功。</p>
<h4 id="为了保持句子平衡，从句还可以用全部或部分倒装"><a href="#为了保持句子平衡，从句还可以用全部或部分倒装" class="headerlink" title="为了保持句子平衡，从句还可以用全部或部分倒装"></a>为了保持句子平衡，从句还可以用全部或部分倒装</h4><p>此时的结构是：than助动词+主语。<br>On the whole, ambitious students are more likely to succeed in their studies than are those with little ambition.<br>这里的than are those with little ambition是一个倒装结构，主语是those with little ambition。</p>
<p>The surface conditions on the planet Mars are more like the Earth’s than are those of any other planet in the solar system.<br>与太阳系中的其他行星相比，火星表面的情况同地球表面的情况最为相似。</p>
<h4 id="表示倍数比较的三种句型"><a href="#表示倍数比较的三种句型" class="headerlink" title="表示倍数比较的三种句型"></a>表示倍数比较的三种句型</h4><p>除了用than和as来对两个事物进行比较外，还可以用times和twice等词来说明两事物之间的倍数关系：</p>
<ul>
<li>“倍数+比较级”结构：A is three times bigger （或其他形容词的比较级） than B</li>
<li>“倍数+as…as”结构：A is three times as big （或其他形容词的原级） as B</li>
<li>“倍数+名词”结构：A is three times the size （或其他形容词对应的名词形式） of B</li>
</ul>
<p>When the United States entered just such a glowing period after the end of the Second World War, it had a market eight times larger than any competitor, giving its industries unparalleled economies of scale.<br>这里是“倍数+比较级”结构。<br>美国在二战后进入这样辉煌的历史时期时，其市场规模是任何竞争对手的八倍，这使其工业经济规模无可匹敌。</p>
<p>There are about 105 males born for every 100 females, but this ratio drops to near balance at the age of maturity, and among 70-year-olds there are twice as many women as men.<br>这里是“倍数+as…as”结构。<br>每出生100名女婴，就会有105名男婴出生，但这个比例在他们成年时下降为基本平衡，在70岁的老人中女性是男性的两倍。</p>
<p>According to the Canadian Institute for Health Information, prescription drug costs have risen since 1997 at twice the rate of overall health-care spending.<br>这里是“倍数+名词”结构。<br>加拿大医疗信息协会的资料表明，自1997年以来，处方药费用的增长速度是整个医疗费用增长速度的两倍。</p>
<h4 id="the-more…-the-more句型"><a href="#the-more…-the-more句型" class="headerlink" title="the more…, the more句型"></a>the more…, the more句型</h4><p>“the more…, the more”结构的基本意思是“越……，越……”。<br><em><strong>比较级部分都必须在各自的分句中充当一定的成分，换句话说，相当于是将分句中的某个成分变为比较级之后提到了句首。</strong></em></p>
<p>你用词越准确，人们就能越容易理解你的意思。</p>
<ul>
<li><p>1） The more exact you use your words, the easier people will understand you.*</p>
</li>
<li><p>2） The more exactly you use your words, the more easily people will understand you.</p>
</li>
<li><p>3） The more exact your words are, the easier it is for people to understand you.</p>
</li>
<li><p>4） The more exact words you use, the more easily people will understand you.</p>
</li>
<li><p>在句1）中，其各自引导的分句分别是you use your words和people will understand you，这里使用的形容词比较级the more exact和the easier不能修饰句子的谓语use和understand（<em><strong>因为形容词不能修饰动词</strong></em>），即比较级部分无法充当后面分句的任何成分。</p>
</li>
<li><p>在句2）中，把比较级部分都改为副词的比较级the more exactly和the more easily，此时就能修饰句子的谓语use和understand（因为副词修饰动词），即比较级部分充当了后面分句的方式状语。</p>
</li>
<li><p>在句3）中，形容词的比较级the more exact就在其后的分句your words are中作表语，相当于your words are more exact；形容词的比较级the easier就在分句it is for people to understand you中作表语，相当于it is easier for people to understand you。</p>
</li>
<li><p>在句4）中，比较级部分the more exact words作后面分句的谓语use的宾语，相当于you use more exact words；比较级部分the more easily作后面分句谓语understand的方式状语，相当于people will more easily understand you。</p>
</li>
</ul>
<p>这个句型的三个用法要点：</p>
<ul>
<li>比较级部分都必须在各自引导的分句中充当一定的成分。</li>
<li>“the+比较级（从句），the+比较级（主句）”，这就是为什么前半句常用一般现在时态，而后半句常用一般将来时态，类似于其他状语从句的“主句用将来时，从句用一般现在时”的规则。</li>
</ul>
<p>Friends are lights in winter: the older the friend, the brighter the light.<br>这个句子的比较部分是省略结构，完整的表达应该是the older the friend is, the brighter the light is，即这里省去了系动词is。所以，比较级都是在各自引导的分句中作表语。注意，<em><strong>在这个句型中，系动词常常会被省略。</strong></em></p>
<h2 id="方式状语从句"><a href="#方式状语从句" class="headerlink" title="方式状语从句"></a>方式状语从句</h2><p>方式状语从句表示动作的方式，引导词有：as，like，as if，as though和the way等。<br>When in Rome, do as the Romans do.<br>意思是“When traveling, follow the customs of the local people.”，相当于汉语中的“入乡随俗”。</p>
<p>Do it the way you were taught. 按照教给你的那样做。<br>He looks as though&#x2F;as if he is an actor. 他看上去像个演员。</p>
<p>Work like you don’t need the money.<br>Love like you’ve never been hurt.<br>Dance like nobody’s watching.<br>Sing like nobody’s listening.<br>Live like it’s heaven on earth.<br>去工作吧，犹如你不需要金钱。<br>去爱吧，犹如你从未曾被伤害过。<br>去舞蹈吧，犹如无人在一旁观看。<br>去歌唱吧，犹如无人在一旁聆听。<br>热爱生活吧，犹如这里是人间乐土。</p>
<h2 id="状语从句的省略"><a href="#状语从句的省略" class="headerlink" title="状语从句的省略"></a>状语从句的省略</h2><ul>
<li>主句的主语和从句的主语一致，或从句主语是it；</li>
<li>从句谓语中含有be动词的情况下，我们可将从句的主语和be动词省去。这种省略常见于时间、地点、条件及让步状语从句中。</li>
</ul>
<h3 id="时间状语从句的省略"><a href="#时间状语从句的省略" class="headerlink" title="时间状语从句的省略"></a>时间状语从句的省略</h3><p>A zero can have its meaning only when used with real numbers; thoughts can give off brilliant light only when put into actions.<br>这是when引导的时间状语从句的省略，还原后完整的句子结构应该是“A zero can have its meaning only when it is used with real numbers; thoughts can give off brilliant light only when they are put into actions.”。所以这里的两个when引导的从句分别省去了it is和they are。 这里的it指主句的主语zero，they指主句的主语thoughts。<br>零，只有和实数在一起使用才有意义；思想，只有付诸行动才能散发光芒。</p>
<p>Metals expand when heated and contract when cooled.<br>还原后的完整的句子结构应该是“Metals expand when they are heated and contract when they are cooled.”。所以两个when引导的从句都是省略了they are。<br>金属具有热胀冷缩的特性。</p>
<p><em><strong>若不能同时满足主句与从句主语一致（或从句主语是it）、从句谓语中含有be动词这两个条件，则从句不能省略主语和be动词。</strong></em><br>1） When I was ten years old, my family moved to the city.<br>2） When ten years old, my family moved to the city.*<br>尽管句 2）很符合我们汉语的表达习惯：“在10岁的时候，我们家搬到城市里来了。”</p>
<h3 id="地点状语从句的省略"><a href="#地点状语从句的省略" class="headerlink" title="地点状语从句的省略"></a>地点状语从句的省略</h3><p>The kind of tree grows favorably where wet.<br>还原后的完整的句子结构应该是“The kind of tree grows favorably where it is wet.”。<br>这里的it并不是指代主句的主语tree，而是泛指任何地方。所以我们看到，从句的主语若是it，则是可以省去的。</p>
<h3 id="条件状语从句的省略"><a href="#条件状语从句的省略" class="headerlink" title="条件状语从句的省略"></a>条件状语从句的省略</h3><p>A tiger can’t be tamed unless caught very young.<br>还原后的完整的句子结构应该是“A tiger can’t be tamed unless it is caught very young.”。<br>老虎只有在年幼时捉来才能被驯服。</p>
<h3 id="让步状语从句的省略"><a href="#让步状语从句的省略" class="headerlink" title="让步状语从句的省略"></a>让步状语从句的省略</h3><p>Although not an economist himself, Dr. Smith has long been a severe critic of the government’s economic policies.<br>还原后的完整的句子结构应该是“Although he is not an economist himself, Dr. Smith has long been a severe critic of the government’s economic policies.”。<br>尽管史密斯博士本人不是经济学家，但他一直以来对政府的经济政策提出尖锐的批评。</p>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>Kafka汇总</title>
    <url>/2020/12/10/Kafka%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h2 id="Kafka底层原理"><a href="#Kafka底层原理" class="headerlink" title="Kafka底层原理"></a>Kafka底层原理</h2><h3 id="与系统调用的关系分析图"><a href="#与系统调用的关系分析图" class="headerlink" title="与系统调用的关系分析图"></a>与系统调用的关系分析图</h3><p><img src="https://gitee.com/fengorz/oss/raw/master/uPic/BiCftf.png"></p>
]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
      <tags>
        <tag>Kafka</tag>
      </tags>
  </entry>
  <entry>
    <title>English系列之IT专用</title>
    <url>/2020/12/17/English%E7%B3%BB%E5%88%97%E4%B9%8BIT%E4%B8%93%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>专用词汇至少要耳熟能详、”章口就来”。</p>
</blockquote>
<h1 id="Chrome-Extensions"><a href="#Chrome-Extensions" class="headerlink" title="Chrome Extensions"></a>Chrome Extensions</h1><p><a href="https://chrome.google.com/webstore/detail/select-and-speak-text-to/gfjopfpjmkcfgjpogepmdjmcnihfpokn/related?utm_source=chrome-ntp-icon">Select and Speak - Text to Speech</a><br>可以智能播放英文网页</p>
<h1 id="Programming"><a href="#Programming" class="headerlink" title="Programming"></a>Programming</h1><ul>
<li>Decoupling</li>
<li>Componentization</li>
<li>Autonomy</li>
<li>Continuous Delivery </li>
<li>Agility</li>
<li>Decentralized Governance</li>
<li>Footprint</li>
<li>Cycle</li>
<li>Serializable</li>
<li>Repeatable</li>
<li>Wildcard</li>
<li>Landing page（着陆页）：拿书来比喻，首页是书的目录，着陆页是随手翻开的那一页。</li>
</ul>
<h2 id="Abbreviation（abbr-）"><a href="#Abbreviation（abbr-）" class="headerlink" title="Abbreviation（abbr.）"></a>Abbreviation（abbr.）</h2><ul>
<li>CLI: 命令行界面（Command Line Interface for batch scripting）</li>
<li>UAT: 用户验收测试（User Acceptance Test）</li>
<li>SIT: 系统集成测试（System Integration Test）</li>
<li>FQDN：全限定域名：同时带有主机名和域名的名称（Fully Qualified Domain Name）</li>
<li>N&#x2F;A：”不适用”(Not applicable)</li>
<li>SVS：Schedule Visibility System 进度【程序】表可见性系统【装置】</li>
<li>UML：Unified Modeling Language</li>
<li>CI&#x2F;CD：Continuous Integration&#x2F;Continuous Delivery，持续集成&#x2F;持续交付</li>
<li>I&#x2F;O: Input&#x2F;Output</li>
</ul>
<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Basic"><a href="#Basic" class="headerlink" title="Basic"></a>Basic</h2><ul>
<li>POJO（Plain Ordinary Java Object） </li>
<li>Cloneable</li>
<li>Executor</li>
<li>Finalize</li>
<li>Shallow</li>
</ul>
<h3 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h3><ul>
<li>Semaphore</li>
<li>Acquire</li>
<li>Synchronized</li>
<li>Transient</li>
<li>Barrier</li>
<li>Yield</li>
<li>Consistency</li>
<li>Availability</li>
<li>Partition</li>
<li>Tolerance</li>
</ul>
<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><ul>
<li>AOP（Aspect-Oriented Programming）</li>
<li>IOC（Inversion Of Control） </li>
<li>DI（Dependency Injection）</li>
<li>Transactional</li>
<li>Autowired</li>
<li>Qualifier</li>
<li>Required</li>
<li>Security</li>
</ul>
<h2 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h2><ul>
<li>Netﬂix</li>
<li>Feign</li>
<li>Hystrix</li>
<li>Nacos</li>
<li>Eureka</li>
<li>Ribbon</li>
<li>Feign</li>
<li>Turbine</li>
<li>SkyWalking</li>
<li>Sleuth </li>
<li>Zipkin</li>
</ul>
<h2 id="Spring-Data"><a href="#Spring-Data" class="headerlink" title="Spring Data"></a>Spring Data</h2><h3 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h3><ul>
<li>Cacheable</li>
<li>Evict</li>
<li>Generator</li>
</ul>
<h2 id="JVM-amp-amp-GC"><a href="#JVM-amp-amp-GC" class="headerlink" title="JVM &amp;&amp; GC"></a>JVM &amp;&amp; GC</h2><ul>
<li>Arthas</li>
<li>Serial</li>
<li>Serial Old</li>
<li>Parallel Old</li>
<li>Parallel Scavenge</li>
<li>Garbage First(G1)</li>
<li>CMS</li>
<li>Young Generation</li>
<li>Old Generation</li>
<li>Minor GC</li>
<li>Major GC</li>
<li>Appel GC</li>
<li>Eden Space</li>
<li>Survivor From</li>
<li>Survivor To</li>
<li>Humongous</li>
<li>Throughput</li>
<li>Latency</li>
<li>Shenandoah</li>
<li>ZGC</li>
<li>Epsilon</li>
</ul>
<h2 id="IntelliJ-Idea"><a href="#IntelliJ-Idea" class="headerlink" title="IntelliJ Idea"></a>IntelliJ Idea</h2><ul>
<li>JRebel</li>
</ul>
<h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><ul>
<li>MyISAM（Index Sequential Access Mode）</li>
<li>InnoDb</li>
<li>varchar</li>
<li>Atomicity</li>
<li>Consistency</li>
<li>Isolation</li>
</ul>
<h1 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h1><ul>
<li>Lucene</li>
<li>wildcard</li>
</ul>
<h1 id="Job"><a href="#Job" class="headerlink" title="Job"></a>Job</h1><ul>
<li>JD（Job Description）</li>
</ul>
<h1 id="Frontend"><a href="#Frontend" class="headerlink" title="Frontend"></a>Frontend</h1><ul>
<li>Electron</li>
</ul>
<h1 id="Other"><a href="#Other" class="headerlink" title="Other"></a>Other</h1><p>有时候会看到一些由两个单词中间加横杆的组合词，代表两个词义的意义之一</p>
<ul>
<li>RMP：风险管理计划（Risk Management Plan）</li>
</ul>
]]></content>
      <categories>
        <category>English</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac与Win兼容使用</title>
    <url>/2021/01/08/Mac%E4%B8%8EWin%E5%85%BC%E5%AE%B9%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="必备软件"><a href="#必备软件" class="headerlink" title="必备软件"></a>必备软件</h1><h2 id="快贴"><a href="#快贴" class="headerlink" title="快贴"></a>快贴</h2><ul>
<li>端到端加密PIN</li>
<li>开机自启</li>
<li>自动设置剪贴板</li>
</ul>
<h3 id="Problem"><a href="#Problem" class="headerlink" title="Problem"></a>Problem</h3><p>每次要手动同步剪贴板？ </p>
<h2 id="Wox"><a href="#Wox" class="headerlink" title="Wox"></a>Wox</h2><blockquote>
<p>对标Alfred</p>
</blockquote>
<h3 id="快捷键配置修改"><a href="#快捷键配置修改" class="headerlink" title="快捷键配置修改"></a>快捷键配置修改</h3><ul>
<li>Web Search改成在New Tab打开</li>
<li>Clipboard History，修改热键为cp，安装命令</li>
</ul>
<h3 id="Problem-1"><a href="#Problem-1" class="headerlink" title="Problem"></a>Problem</h3><h4 id="Everything-Client-is-not-running"><a href="#Everything-Client-is-not-running" class="headerlink" title="Everything Client is not running"></a>Everything Client is not running</h4><p>Everything没办法和Wox整合</p>
<h4 id="把唤起的快捷键改成win-space"><a href="#把唤起的快捷键改成win-space" class="headerlink" title="把唤起的快捷键改成win+space"></a>把唤起的快捷键改成win+space</h4><h3 id="前缀"><a href="#前缀" class="headerlink" title="前缀"></a>前缀</h3><ul>
<li>bd（百度）</li>
</ul>
<h3 id="alfred的Web-Search同步到wox"><a href="#alfred的Web-Search同步到wox" class="headerlink" title="alfred的Web Search同步到wox"></a>alfred的Web Search同步到wox</h3><ul>
<li>zh</li>
</ul>
<h3 id="Plugins"><a href="#Plugins" class="headerlink" title="Plugins"></a>Plugins</h3><ul>
<li>Wox.Plugin.ProcessKiller（修改关键字kill为quit，和Mac同步）</li>
</ul>
<h2 id="WSL"><a href="#WSL" class="headerlink" title="WSL"></a>WSL</h2><ul>
<li>先在程序与功能开启<code>适用于Linux的Windows子系统</code></li>
<li>在Microsoft Store安装Ubuntu和Windows Terminal</li>
</ul>
<h2 id="工作软件"><a href="#工作软件" class="headerlink" title="工作软件"></a>工作软件</h2><h3 id="Idea"><a href="#Idea" class="headerlink" title="Idea"></a>Idea</h3><h4 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h4><h5 id="IdeaVim"><a href="#IdeaVim" class="headerlink" title="IdeaVim"></a>IdeaVim</h5><p>注意各种快捷键一般都是要调整成默认的IDE，点击右下角的V图标Settings里面修改</p>
<h5 id="emacsIDEAs"><a href="#emacsIDEAs" class="headerlink" title="emacsIDEAs"></a>emacsIDEAs</h5><p>文本编辑神器</p>
<h5 id="Eclipse-Code-Formatter"><a href="#Eclipse-Code-Formatter" class="headerlink" title="Eclipse Code Formatter"></a>Eclipse Code Formatter</h5><p>Eclipse代码格式复用</p>
<h4 id="修改Maven的仓库至国内的"><a href="#修改Maven的仓库至国内的" class="headerlink" title="修改Maven的仓库至国内的"></a>修改Maven的仓库至国内的</h4><ul>
<li>修改settings.xml</li>
<li>修改仓库路径到D盘</li>
</ul>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><h2 id="其他软件"><a href="#其他软件" class="headerlink" title="其他软件"></a>其他软件</h2><blockquote>
<p>注意不要安装在C盘</p>
</blockquote>
<ul>
<li>Chrome</li>
<li>Everything</li>
<li>QQ音乐</li>
<li>网易云音乐</li>
<li>微信</li>
<li>Xmind</li>
<li>有道词典</li>
<li>有道网易云笔记</li>
<li>360压缩</li>
</ul>
<h2 id="翻墙"><a href="#翻墙" class="headerlink" title="翻墙"></a>翻墙</h2><blockquote>
<p><a href="%22%22">参考</a></p>
</blockquote>
<h3 id="Qv2ray"><a href="#Qv2ray" class="headerlink" title="Qv2ray"></a>Qv2ray</h3><p><a href="https://github.com/Qv2ray/Qv2ray/releases/tag/v2.6.3">github的下载链接</a></p>
<h3 id="下载v2ray-core"><a href="#下载v2ray-core" class="headerlink" title="下载v2ray-core"></a>下载v2ray-core</h3><p><a href="https://github.com/v2fly/v2ray-core/releases/tag/v4.34.0">下载链接</a></p>
<h3 id="Qv2ray内核设置"><a href="#Qv2ray内核设置" class="headerlink" title="Qv2ray内核设置"></a>Qv2ray内核设置</h3><ul>
<li>核心可执行文件</li>
<li>资源目录（注意路径应该选择核心可执行文件的父目录）</li>
</ul>
<h2 id="AutoHotKey"><a href="#AutoHotKey" class="headerlink" title="AutoHotKey"></a>AutoHotKey</h2><h1 id="win快捷键"><a href="#win快捷键" class="headerlink" title="win快捷键"></a>win快捷键</h1><h2 id="常用快捷键"><a href="#常用快捷键" class="headerlink" title="常用快捷键"></a>常用快捷键</h2><blockquote>
<p>[效率提升！这15组微软Win 10快捷键了解一下](<a href="https://www.ithome.com/0/482/353.htm">https://www.ithome.com/0/482/353.htm</a> “””)<br>[Windows快捷键，超全！](<a href="https://zhuanlan.zhihu.com/p/29518391">https://zhuanlan.zhihu.com/p/29518391</a> “””)</p>
</blockquote>
<ul>
<li>win+Q：开启快捷搜索</li>
<li>win+E：打开资源管理器</li>
<li>win+D：显示桌面</li>
<li>win+V：显示剪切板</li>
</ul>
<h2 id="变更默认快捷键"><a href="#变更默认快捷键" class="headerlink" title="变更默认快捷键"></a>变更默认快捷键</h2><h3 id="输入法切换"><a href="#输入法切换" class="headerlink" title="输入法切换"></a>输入法切换</h3><ul>
<li>^+space改为win+space</li>
</ul>
<h3 id="win10自带输入法快捷键"><a href="#win10自带输入法快捷键" class="headerlink" title="win10自带输入法快捷键"></a>win10自带输入法快捷键</h3><ul>
<li>^+Shift+F：简繁体切换</li>
</ul>
<h3 id="关闭win10系统默认的微软拼音输入法"><a href="#关闭win10系统默认的微软拼音输入法" class="headerlink" title="关闭win10系统默认的微软拼音输入法"></a>关闭win10系统默认的微软拼音输入法</h3><p><a href="https://jingyan.baidu.com/article/ed2a5d1f99277909f7be1753.html">关闭win10系统默认的微软拼音输入法</a></p>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><p>设置&gt;语言&gt;拼写、键入和键盘设置&gt;高级热键设置<br>将切换输入法的其他热键绑定去掉，只剩下<code>^+space</code>用来切换到win10默认输入法</p>
<h3 id="最上面一排按键默认采用F1-F12"><a href="#最上面一排按键默认采用F1-F12" class="headerlink" title="最上面一排按键默认采用F1~F12"></a>最上面一排按键默认采用F1~F12</h3><p>联想小新下载Lenovo Vantage可以设置</p>
<h3 id="底部任务栏图标大小调小"><a href="#底部任务栏图标大小调小" class="headerlink" title="底部任务栏图标大小调小"></a>底部任务栏图标大小调小</h3><h3 id="关闭小娜Cortana默认快捷键"><a href="#关闭小娜Cortana默认快捷键" class="headerlink" title="关闭小娜Cortana默认快捷键"></a>关闭小娜Cortana默认快捷键</h3><p>Cortana-&gt;Settings-&gt;Keyboard shortcut</p>
<h3 id="修改锁屏快捷键"><a href="#修改锁屏快捷键" class="headerlink" title="修改锁屏快捷键"></a>修改锁屏快捷键</h3><h3 id="Win10关闭AerPeek-窥探桌面-x2F-win"><a href="#Win10关闭AerPeek-窥探桌面-x2F-win" class="headerlink" title="Win10关闭AerPeek(窥探桌面&#x2F;win+,)"></a>Win10关闭AerPeek(窥探桌面&#x2F;win+,)</h3>]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>Windows</tag>
      </tags>
  </entry>
</search>
